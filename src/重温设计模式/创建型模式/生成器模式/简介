生成器模式是一种创建型模式，是你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。

生成器模式建议将对象构造代码从产品中抽取出来，并将其放在一个名为生成器的独立对象中。它让你能够分步骤创建复杂对象，不允许其他对象访问正在创建中的产品。
该模式会将对象构造过程分为一组步骤，每次创建对象时，你都需要通过生成器对象执行一系列步骤。重点在于你无需调用所有步骤，而只需调用创建特定对象配置
所需的那些步骤即可。
当你需要创建不同形式的产品时，其中的一些构造步骤可能需要不同的实现。在这种情况下，你可以创建多个不同的生成器，用不同方式实现一组相同的创建步骤。然后你就
可以在创建过程中使用这些生成器(例如顺序调用多个构造步骤)来生成不同类型的对象。

=====================
主管：
你可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。主管类可定义创建步骤的执行顺序，而生成器则提供这些步骤的实现。严格来说，你的程序中
并不一定需要主管类。客户端代码可直接以特定顺序调用创建步骤。不过主管类中非常适合放入各种例行构造流程，以便在程序中反复使用。
此外对于客户端代码来说，主管类完全隐藏了产品构造细节。客户端只需将一个生成器与主管类关联，然后使用主管类来构造产品，就能从生成器处获得构造结果了。

================
结构：
1、生成器接口声明在所有类型生成器中通用的产品构造步骤。
2、具体生成器提供构造过程的不同实现。具体生成器也可以构造不遵循通用接口的产品，
3、产品时最终生成的对象。由不同生成器构造的产品无需属于同一类层次或接口。
4、主管类定义调用构造步骤的顺序，这样你就可以创建和复用特定的产品配置。
5、客户端必须将某个生成器对象与主管类关联。一般情况下，你只需通过主管类构造函数的参数进行一次性关联即可。此后主管类就能使用
生成器对象完成后续所有的构造任务。但在客户端将生成器对象传递给主管类制造方法时还有一种方式。在这种情况下，你在使用主管类生产产品时每次都可以使用不同的生成器。
=====================================
适合应用场景：
1、使用生成器模式可以避免“重叠构造函数(telescopic constructor)”的出现。
假设你的构造函数中有十个可选参数， 那么调用该函数会非常不方便； 因此， 你需要重载这个构造函数， 新建几个只有较少参数的简化版。 但这些构造函数仍需调用主构造函数，
传递一些默认数值来替代省略掉的参数。
class Pizza {
    Pizza(int size) { ... }
    Pizza(int size, boolean cheese) { ... }
    Pizza(int size, boolean cheese, boolean pepperoni) { ... }
    // ...
只有在 C# 或 Java 等支持方法重载的编程语言中才能写出如此复杂的构造函数。
生成器模式让你可以分步骤生成对象， 而且允许你仅使用必须的步骤。 应用该模式后， 你再也不需要将几十个参数塞进构造函数里了。
2、当你希望使用代码创建不同形式的产品时，可以使用生成器模式。
如果你需要创建的各种形式的产品，他们的制作过程相似且仅有细节上的差异，此时可以使用生成器模式。
基本生成器窗口中定义了所有可能的制作步骤，具体生成器将实现这些步骤来制造特定形式的产品。同时，主管类将负责管理制造步骤的顺序。
3、使用生成器构造组合树或其他复杂对象。
生成器模式让你能分步构造产品。你可以延迟执行某些步骤而不会影响最终产品。你甚至可以递归调用这些步骤，这在创建对象树时非常方便。
生成器在执行制作步骤时，不能对外发布未完成的产品。这可以避免客户端代码获取到不完整结果对象的情况。
==================================
实现方法：
1、清晰定义通用步骤，确保他们可以制作各种形式的产品。否则你将无法进一步实施该模式。
2、在基本生成器接口中声明这些步骤。
3、为每个形式的产品创建具体的生成器，并实现其构造步骤。
不要忘记实现获取构造结果对象的方法。你不能在生成器接口中声明该方法，因为不同的生成器构造的产品可能没有公共接口，因此你就不知道该对象返回的对象类型。但是，如果所有产品
都位于但一类层中，你就可以安全的在基本接口中添加获取生成对象的方法。
4、考虑创建主管类。它可以使用同一生成器对象来封装多种构造产品的方式。
5、客户端代码会同时创建生成器和主管对象。构造开始前，客户端必须将生成器对象传递给主管对象。通常情况下，客户端只管调用主管类构造函数一次即可。主管类使用生成器对象完成
后续所有制作任务。还有另一种方式，那就是客户端可以将生成器对象直接传递给主管类的制造方法。
6、只有在所有产品都遵循相同接口的情况下，构造结果可以直接通过主管类获取。否则客户端应通过生成器获取构造结果。
===================================
优点：
 你可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。
 生成不同形式的产品时， 你可以复用相同的制造代码。
 单一职责原则。 你可以将复杂构造代码从产品的业务逻辑中分离出来。

缺点：
 由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加
 ==============================================
 与其他创建型模式不同，生成器不要求产品拥有通用接口。这使得相同创建过程生成不同的产品成为可能。

 在 Java 中使用模式
 使用示例： 生成器模式是 Java 世界中的一个著名模式。 当你需要创建一个可能有许多配置选项的对象时， 该模式会特别有用。

 生成器在 Java 核心程序库中得到了广泛的应用：

 java.lang.StringBuilder#append() （ 非同步 ）
 java.lang.StringBuffer#append() （ 同步 ）
 java.nio.ByteBuffer#put() （还有 Char­Buffer、 Short­Buffer、 Int­Buffer、 Long­Buffer、 Float­Buffer 和 Double­Buffer）
 javax.swing.GroupLayout.Group#addComponent()
 java.lang.Appendable的所有实现
 识别方法： 生成器模式可以通过类来识别， 它拥有一个构建方法和多个配置结果对象的方法。 生成器方法通常支持方法链
 （例如 someBuilder->setValueA(1)->setValueB(2)->create() ）。



