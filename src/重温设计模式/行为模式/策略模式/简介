策略模式能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够互相替换.
他将一组行为转换为对象，并使其在原始上下文对象内部能够相互替换。原始对象被称为上下文，包含指向策略对象的引用并将
执行行为的任务分派给策略对象。为了改变上下文完成其工作的方式，其他对象可以使用另一个对象来替换当前链接的策略对象。
=============================================================================
策略模式建议找出负责用许多种不同方式完成特定任务的类，然后将其中的算法抽取到一组被称为策略的独立类中。
名为上下文的原始类必须包含一个成员变量来存储对于每种策略的引用。上下文并不执行任务，而是将工作委派给已连接的策略对象。
上下文不负责选择符合任务需要的算法--客户端会将所需策略传递给上下文。实际上，上下文并不十分了解策略，他会通过同样的通用接口与所有策略
进行交互，而该接口只需要暴露一个方法来触发所选策略中封装的算法即可。
因此上下文可独立于具体策略。这样你就可在不修改上下文代码或其他策略的情况下添加新算法或修改已经算法。
==============================================================================
适合使用的场景：
1、当你想使用对象中各个不同的算法变体，并希望能在运行时切换算法时，可以使用策略模式。
策略模式让你能够将对象关联至可以不同方式执行特定子类任务的不同子对象中，从而以间接方式在运行时更改对象行为。

2、当你有许多仅在执行某些行为时略有不同的相似类时，可以使用策略模式。
策略模式让你将不同行为抽取到一个独立类层次结构中，并将原始类组合成同一个，从而减少重复代码。
3、如果算法在上下文的逻辑中不是特别重要，使用该模式能将类的业务逻辑与其算法实现细节隔离开来。
 策略模式让你能将各种算法的代码、内部数据和依赖关系与其他代码隔离开来。不同客户端可通过一个简单接口执行算法，并能在运行时进行切换。
4、当类中使用了复杂条件运算符以在同一算法的不同变体中切换时，可使用该模式。
 策略模式将所有继承自同样接口的算法抽取到独立类中，因此不再需要条件语句。原始对象并不实现所有算法的变体，而是将执行工作委派给其中的一个独立算法对象。

===============================================================================
实现方法：
1、上下文类中找出修改频率较高的算法(也可以是用于在运行时选择某个算法变体的复杂条件运算符)。
2、声明该算法所有变体的通用策略接口。
3、将算法逐一抽取到各自的类中，他们都必须实现策略接口。
4、在上下文类中添加一个成员变量用于保存对于策略对象的引用。然后提供设置器以修改该成员变量。上下文仅可通过策略接口同策略对象进行交互，
如有需求还可以定义一个接口来让策略访问其数据。
5、客户端必须将上下文类与相应策略进行关联，使上下文可以预期的方式完成其主要工作。
=================================================================================
优点：
 你可以在运行时切换对象内的算法。
 你可以将算法的实现和使用算法的代码隔离开来。
 你可以使用组合来代替继承。
 开闭原则。 你无需对上下文进行修改就能够引入新的策略。
缺点：
  如果你的算法极少发生改变， 那么没有任何理由引入新的类和接口。 使用该模式只会让程序过于复杂。
  客户端必须知晓策略间的不同——它需要选择合适的策略。
  许多现代编程语言支持函数类型功能， 允许你在一组匿名函数中实现不同版本的算法。 这样，你使用这些函数的方式就和使用策略对象时完全相同， 无需借助额外的类和接口来保持代码简洁。
 ================================================
 在 Java 中使用模式

 使用示例： 策略模式在 Java 代码中很常见。 它经常在各种框架中使用， 能在不扩展类的情况下向用户提供改变其行为的方式。

 Java 8 开始支持 lambda 方法， 它可作为一种替代策略模式的简单方式。

 这里有一些核心 Java 程序库中策略模式的示例：

 对 java.util.Comparator#compare() 的调用来自 Collections#sort().

 javax.servlet.http.HttpServlet： ​ service­()方法， 还有所有接受 Http­Servlet­Request和 Http­Servlet­Response对象作为参数的 do­XXX()方法。

 javax.servlet.Filter#doFilter()

 识别方法： 策略模式可以通过允许嵌套对象完成实际工作的方法以及允许将该对象替换为不同对象的设置器来识别。
 ====================================================================
 策略模式结构：
 1.上下文(context)：维护指向具体策略的引用，仅通过策略接口与该对象进行交流。
 2.策略(strategy)接口是所有具体策略的通用接口，他声明了一个上下文用于执行策略的方法。
 3.具体策略实现了上下文所有算法的各种不同实体。
 4.当上下文需要运行算法时，他会在其已连接的策略对象上调用执行方法，。上下文不清楚其所涉及的策略类型与算法的执行方式。
 5.客户端会创建一个特定的策略对象并将其传递给上下文。上下文则会提供一个设置器以便客户端在运行时替换相关联的策略。
 ============================================================
 不同模式对比：
 模版方法模式基于继承机制：他允许你通过扩展子类中的部分内容来改变部分算法。策略模式基于组合机制:你可以通过对相应行为提供不同的策略来改变对象的部分行为。
 模版方法在类层次上运作，因此它是静态的。策略在对象层次上运作，因此允许在运行时切换行为。