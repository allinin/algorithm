模版方法模式他在超类中定义了一个算法框架，允许子类在不修改结构的情况下重写算法的特定步骤。
模版方法模式建议将算法分解成一些列步骤，然后将这些步骤改写成方法，最后在“模板方法”中依次调用这些方法。步骤可以是抽象的，也可以是
有一些默认的实现。为了能够使用算法，客户端需要自行提供子类并实现所有的抽象步骤。如有必要还需要重写一些步骤(不包括模板方法自身)。

首先我们将所有步骤声明为抽象类型，强制要求子类自行实现这些方法。
我们有两种类型的步骤：
1、抽象步骤必须由各个子类来实现。
2、可选步骤已有一些默认实现，但仍可在需要的时候重写。

还有一种名为钩子的步骤。钩子是内容为空的可选步骤。即使不重写钩子，模板方法也能工作。钩子通常放置在算法重要步骤的前后，为子类提供额外大的算法扩展点。
==========================
基本结构：
1、抽象类会声明作为算法步骤的方法，以及依次调用他们的实际模板方法。算法步骤可以被声明为抽象类型，也可以提供一些默认实现。
2、具体类可以重写所有步骤，但不能重写模板方法本省。
================================================
适用场景：
1.当你只希望客户端扩展某个特定算法步骤，而不是整个算法或其结构时，可以使用模板方法模式。
模板方法将整个算法转换为一系列独立的步骤，以便子类能对其进行扩展，同时还可以让超类中定义的结构保持不变。
2、当多个类的算法除了一些细微不同之处外几乎完全一样时，可以使用该模式。但其后果是，只要算法发生改变，你就可能需要修改所有的类。
在将算法转换为模板方法时，你可将相似的实现步骤提取到一个超类中以去除重复代码。子类间各不同的代码可继续保留在子类中。

=================================
实现方式：
1.分析目标方法，确定能否将其分解成多个步骤。从所有子类的角度出发，考虑哪些步骤能够通用，哪些步骤各不相同。
2.创建抽象基类并声明一个模板方法和代表算法步骤的一些列抽象方法。在模板方法中根据算法结构依次调用相应步骤。可以final最终修饰模板方法以防止子类对其进行重写。
3.虽然可将算法步骤全都设为抽象类型，但默认实现可能会给部分步骤带来好处，因为子类无需实现那些方法。
4.可考虑在算法的关键步骤之间添加钩子。
5.为每个算法变体新建一个具体子类，他必须实现所有的抽象步骤，也可以重写部分可选步骤。
=======================
优点：
 你可仅允许客户端重写一个大型算法中的特定部分， 使得算法其他部分修改对其所造成的影响减小。
 你可将重复代码提取到一个超类中。
缺点：
 部分客户端可能会受到算法框架的限制。
 通过子类抑制默认步骤实现可能会导致违反_里氏替换原则_。
 模板方法中的步骤越多， 其维护工作就可能会越困难。
 =========================
 工厂方法模式可以看作是模板方法模式的一种特殊形式。同时，工厂方法可以作为一个大型模板方法中的一个步骤。
 ================================================
 在 Java 中使用模式


 使用示例： 模版方法模式在 Java 框架中很常见。 开发者通常使用它来向框架用户提供通过继承实现的、 对标准功能进行扩展的简单方式。

 这里是一些核心 Java 程序库中模版方法的示例：

 java.io.InputStream、 java.io.OutputStream、 java.io.Reader 和 java.io.Writer 的所有非抽象方法。

 java.util.AbstractList、 java.util.AbstractSet 和 java.util.AbstractMap 的所有非抽象方法。

 javax.servlet.http.HttpServlet， 所有默认发送 HTTP 405 “方法不允许” 错误响应的 do­XXX()方法。 你可随时对其进行重写。

 识别方法：模板方法可以通过行为方法来识别，该方法已有一个在基类中定义的“默认”行为。