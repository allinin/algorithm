亦称时间订阅者，监听者，Event-Subscriber,Listener,Observer
观察者模式是一种行为设计模式，允许你定义一种订阅机制，可以在对象事件发生时通知多个“观察”该对象的其他对象。

拥有一些值得关注的状态的对象通常被称为目标，由于他要将自身的状态改变通知给其他对象，我们也将其称为发布者(publish).
所有希望关注发布者状态变化的其他对象被称为订阅者。
观察者模式建议你为发布者类添加订阅机制，让每个对象都能订阅或取消订阅发布者事件流。该机制包括：
1）一个用于存储订阅者对象引用的列表成员变量；
2）几个用于添加或删除该列表中订阅者的方法。
无论何时发生了重要的发布者事件，他都要遍历订阅者并调用其对象的特定通知方法。

所有订阅者都必须实现同样的接口，发布者仅通过该接口与订阅者交互。接口中必须声明通知方法及其参数，这样发布者在发出通知时还能传递一些上下文数据。

如果你的应用中有多个不同类型的发布者，且希望订阅者可兼容所有发布者，那么你甚至可以进一步让所有订阅者都遵循同样的接口。
该接口仅需描述几个订阅方法即可。 这样订阅者就能不与具体发布者类耦合的情况下通过接口观察发布者的状态。


++++++++++++++++++++++++++
应用场景：
1、当一个对象状态的改变需要改变其他对象，或实际对象是事先未知的或动态变化时，可使用观察者模式。
 当你用图形用户界面类时通常会遇到一个问题。比如，你创建了自定义按钮类并允许客户端在按钮中注入自定义代码，这样当用户按下按钮时就会触发这些代码。
 观察者模式允许任何实现了订阅者接口的对象订阅发布者对象的事件通知。你可在按钮中添加订阅机制，允许客户端通过自定义订阅类注入自定义代码。
2、当应用中的一些对象必须观察其他对象时，可以使用该模式。但仅能在有限时间内或特定情况下使用。
订阅者列表是动态的，因此订阅者可随时加入或离开列表。
+++++++++++++++++++++++++++======================================
实现方式：
1、仔细观察你的业务逻辑，试着将其拆分成为两部分：独立于其他代码的核心功能将作为发布者；其他代码则将转化为一组订阅者。
2、声明订阅者接口。该接口中至少应声明一个update方法。
3、声明发布者接口并定义一些接口来在列表中添加和删除订阅对象。记住发布者必须仅通过订阅者接口与他们进行交互。
4、确定存放实际订阅列表的位置并实现订阅方法。通常所有类型的发布者代码看上去都一样，因此将列表放置在直接扩展自发布者接口的抽象类
中是显而易见的。具体发布者会扩展该类从而继承所有订阅行为。
  但是，如果你需要在现有的类层次结构中应用该模式，则可以考虑使用组合的方式：将订阅逻辑放入一个独立的对象，然后让所有实际订阅者使用该对象。
5、创建具体发布者类。每次发布者发生了重要事件时都必须通知所有的订阅者。
6、在具体订阅者类中实现通知更新方法。绝大部分订阅者需要一些与事件相关的上下文数据。这些数据可作为通知方法大的参数来传递。
   还有另一种选择。订阅者接收到通知后直接从通知中获取所有数据。在这种情况下，发布者必须通过更新方法将自身传递出去。另一种不太灵活的方式是通过
   构造函数将发布者与订阅者永久性地连接起来。
7、客户端必须生成所需的全部订阅者，并在相应的发布者处完成注册工作。

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
优缺点：
 开闭原则。 你无需修改发布者代码就能引入新的订阅者类 （如果是发布者接口则可轻松引入发布者类）。
 你可以在运行时建立对象之间的联系。
 订阅者的通知顺序是随机的

=======================================
在 Java 中使用模式
复杂度：

流行度：

使用示例： 观察者模式在 Java 代码中很常见， 特别是在 GUI 组件中。 它提供了在不与其他对象所属类耦合的情况下对其事件做出反应的方式。

这里是核心 Java 程序库中该模式的一些示例：

java.util.Observer/ java.util.Observable （极少在真实世界中使用）
java.util.EventListener的所有实现 （几乎广泛存在于 Swing 组件中）
javax.servlet.http.HttpSessionBindingListener
javax.servlet.http.HttpSessionAttributeListener
javax.faces.event.PhaseListener
识别方法： 该模式可以通过将对象存储在列表中的订阅方法， 和对于面向该列表中对象的更新方法的调用来识别。
============================================
 与其他模式的关系
责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：

责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。
命令在发送者和请求者之间建立单向连接。
中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。
观察者允许接收者动态地订阅或取消接收请求。
中介者和观察者之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。

中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。

有一种流行的中介者模式实现方式依赖于观察者。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当中介者以这种方式实现时， 它可能看上去与观察者非常相似。

当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和观察者并不相同， 但这仍是一种中介者模式。

假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。