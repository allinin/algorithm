适配器是一个特殊的对象，能够转化对象接口，使其能够与其他对象进行交互。
运作方式：
1、适配器实现与其中一个现有对象兼容的接口。
2、现有对象可以使用该接口安全地调用适配器方法。
3、适配器方法被调用后以另一个对象兼容的格式和顺序将请求传递给该对象

对象适配器：
实现时使用了构成原则：适配器实现了其中一个对象接口，并对另一个对象进行封装。所有流行的编程语言都可以实现适配器

类适配器：
这一实现使用了继承机制：适配器同时继两个对象的接口。仅能用在支持多继承的语言。

实现方式：
1、确保至少有两个类的接口不兼容。
 一个无法修改(通常是第三方、遗留系统或者众多已有依赖的类）的功能性服务类。
 一个或多个将受益于使用服务类的客户端类
2、声明客户端接口，描述客户端如何与服务交互
3、创建遵循客户端接口的适配器类。所有方式暂时为空。
4、在适配器类中添加一个成员变量用于保存对于服务类的引用。通常情况下会通过构造函数对该成员变量进行初始化，
但有时在调用其方法时会将该变量传递给适配器更会方便。
5、依次实现适配器类客户端接口的所有方法。适配器会将实际工作委派给服务对象，自身只负责接口或数据格式的转换
6、客户端必须通过客户端接口使用适配器。这样一来就可以在不影响客户端代码的情况下修改或扩展适配器。


适配器模式优缺点
 _单一职责原则_你可以将接口或数据转换代码从程序主要业务逻辑中分离。
 开闭原则。 只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。
 代码整体复杂度增加， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。


使用示例： 适配器模式在 Java 代码中很常见。 基于一些遗留代码的系统常常会使用该模式。 在这种情况下， 适配器让遗留代码与现代的类得以相互合作。
Java 核心程序库中有一些标准的适配器：

java.util.Arrays#asList()
java.util.Collections#list()
java.util.Collections#enumeration()
java.io.InputStreamReader(InputStream) （返回 Reader对象）
java.io.OutputStreamWriter(OutputStream) （返回 Writer对象）
javax.xml.bind.annotation.adapters.XmlAdapter#marshal() 和 #unmarshal()

识别方法：
适配器可以通过不同抽象或者接口类型实例为参数的构造方法来识别。当适配器的任何方法被调用时，他会将参数转换为合适的格式，
然后将调用定向到其封装对象中的一个或多个方法。