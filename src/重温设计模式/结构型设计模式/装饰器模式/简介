装饰器模式是一种结构型模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。
装饰器模式中最外层的装饰器类与内部封装的对象实现了相同的接口。

当你需要更改一个对象的行为时，第一个跳入脑海的想法就是扩展他所属的类。但是你不能忽视继承可能引发的几个严重问题。
1.继承时静态的。你无法在运行时更改已有对象的行为，只能使用由不同子类创建的对象来替代当前的整个对象。
2.子类只能有一个父类。大部分编程语言不允许一个类同时继承多个类的行为。
其中一种方法是用组合或聚合，而不是继承。两者的工作方式几乎一摸一样：一个对象包含指向另一个对象的引用，并将部分
工作委派给引用对象；继承中的对象则继承了父类的行为，他们自己能够完成这些工作。

组合与聚合是许多设计模式背后的关键原则(包括装饰器模式)。

封装器是装饰模式的别称，这个称谓明确地表达了该模式的主要思想。“封装器”是一个能与其他“目标”对象连接的对象。封装器包含与
目标对象相同的一系列方法，他会将所有接收到的请求委派给目标对象。但是，封装器可以在将请求委派给目标前后对其进行处理，所以可能会
改变最终的结果。

什么时候一个简单的封装器可以被称为是真正的装饰呢？封装器实现了与其封装对象相同的接口。从客户端角度考虑，这些对象是完全一样的。
封装器中的引用成员变量可以是与其遵循相同接口的任意对象。这使得你可以将一个对象放入多个封装器中，并在对象中添加所有这些封装器的组合行为。

客户端代码必须将基础通知器放入一系列自己所需的装饰中。因此最后的对象将形成一个栈结构。实际与客户端进行交互的对象是最后一个进入栈中大的装饰对象。
由于所有的装饰都实现了与通知基类相同的接口，客户端的其他代码并不在意自己到底是与“纯粹”的通知器对象还是与装饰后的通知器对象进行交互。

========================================
结构：
1.部件声明封装其器和被封装对象的公用接口。
2.具体部件类是被封装对象所属的类。它定义了基础行为，但装饰类可以改变这些行为。
3.基础装饰类拥有一个指向被封装对象的引用成员变量。该变量的类型被声明为通用部件接口，这样他就可以引用具体的部件和装饰。装饰基类会将所有操作委派给
被封装的对象。
4.具体装饰类定义了可以动态添加到部件的额外行为。具体装饰类会重写装饰基类方法，并在调用父类方法之前或之后进行额外的行为。
5.客户端可以使用多层装饰来封装部件，只要他能使用通用接口与所有的对象互动即可。
==========================================
适用场景：
1.如果你希望在无需修改代码的情况下即可使用对象，且希望在运行时为对象新增额外的行为，可以使用装饰模式。
装饰能将业务逻辑组织为层次结构，你可为各层创建一个装饰，在运行时将各种不同逻辑组合成对象。由于这些对象都遵循通用接口，客户端代码
能以相同的方式使用这些对象。
2.如果用继承来扩展对象行为的方案难以实现或者根本不可行，你可以使用这种模式。
许多编程语言使用final最终关键字来限制对某个类的进一步扩展。复用最终类已有行为的唯一方法是使用装饰模式：用封装器对其进行封装。
===================================
实现方式：
1.确保业务逻辑可以用一个基层组件及多个可选层次表示。
2.找出基本组件和可选层次的通用方法。创建一个组件接口并在其中声明这些方法。
3.创建一个具体组件类，并定义基础行为。
4.创建装饰基类，使用一个成员变量存储指向被封装对象的引用。该成员变量必须被声明为组件接口类型，从而能在运行时连接具体组件和装饰。装饰基类
必须将所有工作委派给被装饰大的对象。
5.确保所有类实现组件接口
6.将装饰基类扩展为具体装饰。具体装饰必须在调用父类方法(总是委派给被封装对象)之前或之后执行自身的行为。
7.客户端代码负责创建装饰并将其组合成客户端所需的行为。
===============
优点：
 你无需创建新子类即可扩展对象的行为。
 你可以在运行时添加或删除对象的功能。
 你可以用多个装饰封装对象来组合几种行为。
 单一职责原则。 你可以将实现了许多不同行为的一个大类拆分为多个较小的类。

缺点：
 在封装器栈中删除特定封装器比较困难。
 实现行为不受装饰栈顺序影响的装饰比较困难。
 各层的初始化配置代码看上去可能会很糟糕。
=====================
适配器模式可以对已有对象的接口进行修改， 装饰模式则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。

适配器能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰则能为对象提供加强的接口。

责任链模式和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。

责任链的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。

组合模式和装饰的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。

装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。

但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。

大量使用组合和装饰的设计通常可从对于原型模式的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。

装饰可让你更改对象的外表， 策略模式则让你能够改变其本质。

装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。
两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。
=========================
装饰是一种结构设计模式，允许你将对象放入特殊封装对象中来为原来对象增加新的行为。由于目标对象和封装器遵循相同的接口，因此你可用装饰来对对象进行无限次的封装。
结果对象将获得封装器叠加而来的行为。
===================================
在 Java 中使用模式

使用示例： 装饰在 Java 代码中可谓是标准配置， 尤其是在与流式加载相关的代码中。

Java 核心程序库中有一些关于装饰的示例：

java.io.InputStream、 Output­Stream、 Reader 和 Writer 的所有代码都有以自身类型的对象作为参数的构造函数。

java.util.Collections； checked­XXX()、 synchronized­XXX() 和 unmodifiable­XXX() 方法。

javax.servlet.http.HttpServletRequestWrapper 和 Http­Servlet­Response­Wrapper

识别方法： 装饰可通过以当前类或对象为参数的创建方法或构造函数来识别。

