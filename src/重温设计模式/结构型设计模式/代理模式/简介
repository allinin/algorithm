代理模式让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在请求提交给对象的前后做一些处理。

代理模式建议新建一个与原服务对象接口相同的代理类，然后更新应用以将代理对象传递给所有原始对象客户端。代理类接受到客
户端请求后会创建市实际的服务对象，并将所有工作委派给他。创建代理之后，如果需要在类的主业务逻辑前后执行一些工作，你
无需改变就能完成这项工作。

++++++++++++++++++++++++++++++++++++++
代理(proxy)类包含了一个指向服务对象的引用成员变量，代理完成器任务(如延迟初始化，记录日志，访问控制和缓存等)后会将
请求传递给服务对象，通常情况下，代理会对其服务对象的整个生命周期进行管理。
++++++++++++++++++++++++++++++++++++++++

适用场景：
1.延迟初始化(虚拟代理)。如果你有一个偶尔使用的重量级服务对象，一直保持该对象运行会消耗系统资源时，可以使用代理模式。
无需在程序启动的时候就创建该对象，可将对象的初始化延迟到真正又需要的时候。
2.访问控制(保护代理)。如果你只希望特定客户端使用服务对象，这里的对象可以是操作系统中非常重要的部分，而客户端则是各种已经
启动的程序(包括恶意程序)，此时可以使用代理模式。代理可仅在客户端凭据满足要求时候将请求传递给服务对象。
3.本地执行远程服务(远程代理)。适用于服务对象位于远程服务器上的情形。 在这种情况下，代理通过网络传递客户端请求，复杂处理
所有与网络相关的复杂细节。
4.记录日志请求(日志记录代理)。适用于需要缓存客户请求结果并对缓存生命周期进行管理时，特别是当返回结果的体积非常大时。
代理可对重复请求所需的相同结果进行缓存，还可使用请求参数作为缓存索引的键值
5.智能引用。可在没有客户端使用某个重量级对象时立即销毁该对象。
代理会将所有获取了指向服务对象或其结果的客户端记录在案。代理会时不时地遍历各个客户端，检查他们是否仍在运行。如果相应的客户端列表为空，代理
就会销毁该服务对象，释放底层系统资源。代理还可以记录客户端是否修改了服务对象。其他客户端还可以服用未修改的对象。

++++++++++++++++++++++++++++++++++++++++++++++++++============================
实现方式：
1.如果没有现成的服务接口，你就需要创建一个接口来实现代理和代理对象的可交换性。从服务类中抽取接口并非总是可行的，因为你
需要对服务的所有客户端进行修改，让他们使用接口。被选计划是将代理作为服务类的子类，这样代理就能继承服务的所有接口了。

2.创建代理类，其中必须包含一个存储指向服务的引用的成员变量。通常情况下，代理负责创建服务并对其整个生命周期进行管理。在一些特殊
的情况下，客户端会通过构造函数将服务传递给代理。

3.根据需求实现代理方法。在大多数情况下，代理在完成一些任务后应将工作委派给服务对象。

4.可以考虑新建一个构造方法来判断客户端可以获取的是代理还是实际服务。你可以在代理类中新建一个简单的静态方法，也可以创建一个完整的工厂方法。

5.可以考虑为服务对象实现延迟初始化。

+++++++++++============================================================
代理模式优缺点：
 你可以在客户端毫无察觉的情况下控制服务对象。
 如果客户端对服务对象的生命周期没有特殊要求， 你可以对生命周期进行管理。
 即使服务对象还未准备好或不存在， 代理也可以正常工作。
 开闭原则。 你可以在不对服务或客户端做出修改的情况下创建新代理。
 代码可能会变得复杂， 因为需要新建许多类。
 服务响应可能会延迟。