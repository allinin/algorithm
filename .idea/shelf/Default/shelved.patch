Index: src/Gof/Factory/factorymethod/abstractFactoryOrder/AbsFactory.java
===================================================================
diff --git a/src/Gof/Factory/factorymethod/abstractFactoryOrder/AbsFactory.java b/src/Gof/Factory/factorymethod/abstractFactoryOrder/AbsFactory.java
deleted file mode 100644
--- a/src/Gof/Factory/factorymethod/abstractFactoryOrder/AbsFactory.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,7 +0,0 @@
-package Gof.Factory.factorymethod.abstractFactoryOrder;
-
-import Gof.Factory.factorymethod.pizza.Pizza;
-
-public interface AbsFactory {
-    public Pizza createPizze(String orderType);
-}
Index: src/org/sd/composite/AbstractFile.java
===================================================================
diff --git a/src/org/sd/composite/AbstractFile.java b/src/org/sd/composite/AbstractFile.java
deleted file mode 100644
--- a/src/org/sd/composite/AbstractFile.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,79 +0,0 @@
-package org.sd.composite;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public interface AbstractFile {
-    void killVirus();
-}
-class ImageFile implements AbstractFile {
-    private String name;
-
-    public ImageFile(String name) {
-        super();
-        this.name = name;
-    }
-
-    @Override
-    public void killVirus() {
-        System.out.println("---图像文件："+name+",进行查杀！");
-    }
-
-}
-class TextFile implements AbstractFile {
-    private String name;
-
-    public TextFile(String name) {
-        super();
-        this.name = name;
-    }
-
-    @Override
-    public void killVirus() {
-        System.out.println("---文本文件："+name+",进行查杀！");
-    }
-}
-class VideoFile implements AbstractFile {
-    private String name;
-
-    public VideoFile(String name) {
-        super();
-        this.name = name;
-    }
-
-    @Override
-    public void killVirus() {
-        System.out.println("---视频文件："+name+",进行查杀！");
-    }
-}
-class Folder implements AbstractFile{
-    private String name;
-    private List<AbstractFile>list=new ArrayList<>();
-    public Folder(String name) {
-        this.name = name;
-    }
-
-    @Override
-    public void killVirus() {
-        System.out.println("-----文件夹"+name+"进行杀毒");
-        for(AbstractFile file:list)
-        {
-            file.killVirus();
-        }
-
-
-    }
-    public void add(AbstractFile file)
-    {
-        list.add(file);
-    }
-    public void remove(AbstractFile file)
-    {
-        list.remove(file);
-    }
-    public AbstractFile getChild(int index)
-    {
-        return list.get(index);
-    }
-}
-
Index: src/Gof/visitor/Action.java
===================================================================
diff --git a/src/Gof/visitor/Action.java b/src/Gof/visitor/Action.java
deleted file mode 100644
--- a/src/Gof/visitor/Action.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,7 +0,0 @@
-package Gof.visitor;
-
-public abstract class Action {
-
-    public abstract void getManResult(Man man);
-    public abstract void getWomanResult(Woman woman);
-}
Index: src/org/sd/Adapter/Adaptee.java
===================================================================
diff --git a/src/org/sd/Adapter/Adaptee.java b/src/org/sd/Adapter/Adaptee.java
deleted file mode 100644
--- a/src/org/sd/Adapter/Adaptee.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,9 +0,0 @@
-package org.sd.Adapter;
-
-public class Adaptee {
-
-    public void request()
-    {
-        System.out.println("可以完成客户请求的需要功能");
-    }
-}
Index: src/org/sd/Adapter/Adapter.java
===================================================================
diff --git a/src/org/sd/Adapter/Adapter.java b/src/org/sd/Adapter/Adapter.java
deleted file mode 100644
--- a/src/org/sd/Adapter/Adapter.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,15 +0,0 @@
-package org.sd.Adapter;
-
-public class Adapter  implements Target{
-
-    private Adaptee adaptee;
-
-
-   public Adapter(Adaptee adaptee)
-   {
-       this.adaptee=adaptee;
-   }
-    public void handleReq() {
-        this.adaptee.request();
-    }
-}
Index: src/JUC/demo1/AirConditionDemo.java
===================================================================
diff --git a/src/JUC/demo1/AirConditionDemo.java b/src/JUC/demo1/AirConditionDemo.java
deleted file mode 100644
--- a/src/JUC/demo1/AirConditionDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,134 +0,0 @@
-package JUC.demo1;
-
-
-import java.util.concurrent.locks.Condition;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-
-class AirCondition{
-    private int number=0;
-//    public synchronized void increment() throws InterruptedException {
-//
-//        //判断
-//        while(number!=0)
-//        {
-//            this.wait();
-//        }
-//
-//        //干活
-//
-//        number++;
-//        System.out.println(Thread.currentThread().getName()+"\t"+number);
-//
-//        //通知
-//        this.notifyAll();
-//    }
-//
-//    public synchronized void decrement() throws InterruptedException {
-//        while(number==0)
-//        {
-//            this.wait();
-//        }
-//
-//        number--;
-//        System.out.println(Thread.currentThread().getName()+"\t"+number);
-//
-//        this.notifyAll();
-//    }
-
-    //用lock
-    Lock lock=new ReentrantLock();
-    Condition condition=lock.newCondition();
-
-      public void increment()
-    {
-        lock.lock();
-        try{
-
-            while(number!=0)
-            {
-                condition.await();
-            }
-
-            number++;
-            System.out.println(Thread.currentThread().getName()+"\t"+number);
-
-            condition.signalAll();
-
-        }catch (Exception e)
-        {
-            e.printStackTrace();
-        }finally {
-            lock.unlock();
-        }
-    }
-    public void decrement()
-    {
-        lock.lock();
-        try{
-
-            while(number==0)
-            {
-                condition.await();
-            }
-
-            number--;
-            System.out.println(Thread.currentThread().getName()+"\t"+number);
-
-            condition.signalAll();
-
-        }catch (Exception e)
-        {
-            e.printStackTrace();
-        }finally {
-            lock.unlock();
-        }
-    }
-
-
-}
-
-public class AirConditionDemo {
-
-    public static void main(String[] args) {
-
-        AirCondition airCondition=new AirCondition();
-
-        new Thread(()->{
-            try {
-                for(int i=0;i<10;i++)
-                airCondition.increment();
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
-        },"AA").start();
-
-        new Thread(()->{
-            try {
-                for(int i=0;i<10;i++)
-                    airCondition.increment();
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
-        },"BB").start();
-
-        new Thread(()->{
-            try {
-                for(int i=0;i<10;i++)
-                    airCondition.decrement();
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
-        },"CC").start();
-
-        new Thread(()->{
-            try {
-                for(int i=0;i<10;i++)
-                    airCondition.decrement();
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
-        },"DD").start();
-
-    }
-}
Index: src/Gof/mediator/Alarm.java
===================================================================
diff --git a/src/Gof/mediator/Alarm.java b/src/Gof/mediator/Alarm.java
deleted file mode 100644
--- a/src/Gof/mediator/Alarm.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,24 +0,0 @@
-package Gof.mediator;
-
-
-
-public class Alarm extends Colleague {
-
-    private Mediator mediator;
-    private String name;
-
-    public Alarm(Mediator mediator, String name) {
-        super(mediator,name);
-        mediator.register(name,this);
-    }
-
-    public void sendAlarm(int stageChange)
-    {
-        sendMessage(stageChange);
-    }
-
-    @Override
-    public void sendMessage(int stageChange) {
-          this.getMediator().getMessage(this.name,stageChange);
-    }
-}
Index: src/左神算法/进阶班一/滑动窗口/AllLessNumSubArray.java
===================================================================
diff --git a/src/左神算法/进阶班一/滑动窗口/AllLessNumSubArray.java b/src/左神算法/进阶班一/滑动窗口/AllLessNumSubArray.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/滑动窗口/AllLessNumSubArray.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,111 +0,0 @@
-package 左神算法.进阶班一.滑动窗口;
-
-import java.util.LinkedList;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 求一个数组中最大值减去最小值小于等于num的子数组的数量。
- * @date 2019/12/30 13:26
- */
-public class AllLessNumSubArray {
-
-    //暴力解O(N^3)
-    public static int getNum1(int[] arr,int num){
-        int res=0;
-        for(int start=0;start<arr.length;start++){
-            for(int end=start;end<arr.length;end++)
-                if(isValid(arr,start,end,num))
-                    res++;
-        }
-        return res;
-    }
-
-    private static boolean isValid(int[] arr, int start, int end, int num) {
-
-        int min=Integer.MAX_VALUE;
-        int max=Integer.MIN_VALUE;
-        for(int i=start;i<=end;i++){
-            min=Math.min(arr[i],min);
-            max=Math.max(arr[i],max);
-        }
-        return max-min<=num;
-    }
-
-    //O(N)
-    public static int getNum(int[] arr,int num){
-        if(arr==null || arr.length==0)
-            return 0;
-        LinkedList<Integer>qmin=new LinkedList<>();//存放最小值的双端队列，最小值在队列头，后面依次是出现的比他大额元素
-        LinkedList<Integer>qmax=new LinkedList<>();//存放最大值的双端队列，最大值在队列头部，后面依次出现的比他小的元元素
-        int start=0;
-        int end=0;
-        int res=0;
-        while(start<arr.length){
-            while(end<arr.length){
-                //最大值结构更新
-                while(!qmax.isEmpty() && arr[qmax.peekLast()]<=arr[end])
-                {
-                    qmax.pollLast();
-                }
-                qmax.addLast(end);
-                //最小值结构更新
-                while(!qmin.isEmpty() && arr[qmin.peekLast()]>=arr[end])
-                {
-                    qmin.pollLast();
-                }
-                qmin.addLast(end);
-                if(arr[qmax.getFirst()]-arr[qmin.getFirst()]>num)//不满足条件，则往外扩会继续不达标，所以没有必要继续往外扩了，结算一番
-                {
-                    break;
-                }
-                end++;
-            }
-            //start左移，判断是否过期。start左移后end有可能还可以继续后移
-            if(qmin.peekFirst()==start)
-            {
-                qmin.pollFirst();
-            }
-            if(qmax.peekFirst()==start)
-                qmax.pollFirst();
-            res+=end-start;//退出上面的时候，已经end++了。
-            start++;
-        }
-
-
-        return res;
-    }
-
-// for test
-    public static int[] getRandomArray(int len) {
-        if (len < 0) {
-            return null;
-        }
-        int[] arr = new int[len];
-        for (int i = 0; i < len; i++) {
-            arr[i] = (int) (Math.random() * 10);
-        }
-        return arr;
-    }
-
-    // for test
-    public static void printArray(int[] arr) {
-        if (arr != null) {
-            for (int i = 0; i < arr.length; i++) {
-                System.out.print(arr[i] + " ");
-            }
-            System.out.println();
-        }
-    }
-
-    public static void main(String[] args) {
-        int[] arr = getRandomArray(30);
-        int num = 5;
-        printArray(arr);
-        System.out.println(getNum(arr, num));
-        System.out.println(getNum1(arr, num));
-
-
-    }
-
-}
Index: src/左神算法/高频面试题/七_头条题/AllTimesMinToMax.java
===================================================================
diff --git a/src/左神算法/高频面试题/七_头条题/AllTimesMinToMax.java b/src/左神算法/高频面试题/七_头条题/AllTimesMinToMax.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/七_头条题/AllTimesMinToMax.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,79 +0,0 @@
-package 左神算法.高频面试题.七_头条题;
-
-import java.util.Stack;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 给定一个数组序列，需要求选出一个区间，使得该区间是所有区间中经过如下计算的值最大的一个：区间中的最小数*区间中所有数的和，最后程序输出经过计算后的最大值即可，
- * 不需要输出具体的区间
- *
- * @date 2020/1/12 15:14
- */
-public class AllTimesMinToMax {
-
-    //时间复杂度O（n)
-    public static int max1(int[] arr){
-        int size=arr.length;
-        //size[i]存放arr中0-i位置值的和,这样可以做到时间复杂度为O(n)
-        int[] sums=new int[size];
-        sums[0]=arr[0];
-        for(int i=1;i<size;i++){
-            sums[i]=sums[i-1]+arr[i];
-        }
-        Stack<Integer>stack=new Stack<>();
-        int temp=0;
-        int res=Integer.MIN_VALUE;
-        for(int i=0;i<size;i++){
-            while(!stack.isEmpty() && arr[stack.peek()]>=arr[i]){
-               temp=stack.pop();
-               res=Math.max(res,arr[temp]*(stack.isEmpty() ? sums[i-1] : (sums[i-1]-sums[stack.peek()])));
-            }
-            stack.push(i);
-        }
-        while(!stack.isEmpty()){
-            temp=stack.pop();
-            res=Math.max(res,arr[temp]*(stack.isEmpty() ? sums[size-1] : (sums[size-1]-sums[stack.peek()])));
-        }
-        return res;
-    }
-
-
-    //暴力解
-    public static int max2(int [] arr){
-        int res=Integer.MIN_VALUE;
-        for(int i=0;i<arr.length;i++){
-            for(int j=i;j<arr.length;j++){
-                int minNum=Integer.MAX_VALUE;
-                int sum=0;
-                for(int k=i;k<=j;k++){
-                    sum+=arr[k];
-                    minNum=Math.min(minNum,arr[k]);
-                }
-                res=Math.max(minNum*sum,res);
-            }
-        }
-        return res;
-
-    }
-
-    public static int[] gerenareRondomArray() {
-        int[] arr = new int[(int) (Math.random() * 20) + 10];
-        for (int i = 0; i < arr.length; i++) {
-            arr[i] = (int) (Math.random() * 101);
-        }
-        return arr;
-    }
-
-    public static void main(String[] args) {
-        int testTimes = 2000000;
-        for (int i = 0; i < testTimes; i++) {
-            int[] arr = gerenareRondomArray();
-            if (max1(arr) != max2(arr)) {
-                System.out.println("FUCK!");
-                break;
-            }
-        }
-
-    }
-}
Index: src/Gof/bridge/Apple.java
===================================================================
diff --git a/src/Gof/bridge/Apple.java b/src/Gof/bridge/Apple.java
deleted file mode 100644
--- a/src/Gof/bridge/Apple.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,22 +0,0 @@
-package Gof.bridge;
-
-public class Apple implements Brand{
-
-    @Override
-    public void open() {
-        System.out.println("苹果手机开机");
-
-    }
-
-    @Override
-    public void call() {
-        System.out.println("苹果手机开机");
-
-    }
-
-    @Override
-    public void close() {
-        System.out.println("苹果手机开机");
-
-    }
-}
Index: src/Gof/responsibilityChain/Approver.java
===================================================================
diff --git a/src/Gof/responsibilityChain/Approver.java b/src/Gof/responsibilityChain/Approver.java
deleted file mode 100644
--- a/src/Gof/responsibilityChain/Approver.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,18 +0,0 @@
-package Gof.responsibilityChain;
-
-public abstract class Approver {
-
-    String name;
-    Approver approver;
-
-    public Approver(String name) {
-        this.name = name;
-    }
-
-    public void setApprover(Approver approver)
-    {
-        this.approver=approver;
-    }
-
-    public abstract void processRequest(PurchaseRequest purchaseRequest);
-}
Index: src/左神算法/基础班/第三课/Array_to_Stack_Queue.java
===================================================================
diff --git a/src/左神算法/基础班/第三课/Array_to_Stack_Queue.java b/src/左神算法/基础班/第三课/Array_to_Stack_Queue.java
deleted file mode 100644
--- a/src/左神算法/基础班/第三课/Array_to_Stack_Queue.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,82 +0,0 @@
-package 左神算法.基础班.第三课;
-
-public class Array_to_Stack_Queue {
-
-    public static class ArrayStack{
-        private Integer[] arr;
-        private Integer size; //记录了数组中将要添加的元素的位置
-
-        public ArrayStack(int initSize)
-        {
-            if(initSize<0)
-                throw new IllegalArgumentException("This init size is less than 0");
-            arr= new Integer[initSize];
-            size=0;
-        }
-
-        public Integer peek()
-        {
-            if(size==0)
-                return null;
-            return arr[size-1];
-        }
-
-        public void push(int obj)
-        {
-            if(size==arr.length)
-                throw new ArrayIndexOutOfBoundsException("The stack is full");
-            arr[size]=obj;
-            size++;
-        }
-        public Integer pop()
-        {
-            if(size==0)
-                throw new ArrayIndexOutOfBoundsException("The stack is empty");
-            return arr[size--];
-        }
-
-    }
-
-    //用数组构建循环队列
-    public static class ArrayQueue{
-
-        private Integer[] arr;
-        private int size; //队列中实际元素的个数，利用size来解耦了。
-        private int first;//指向对列头部，第一个元素的位置
-        private int last;//指向对列尾部,新插入元素的位置
-
-        public ArrayQueue(int init)
-        {
-            if(init<0)
-                throw new IllegalArgumentException("The init size is less than 0");
-            arr=new Integer[init];
-            size=0;
-            first=0;
-            last=0;
-        }
-
-        public Integer peek()
-        {
-            if(size==0)
-                return null;
-            return arr[first];
-        }
-        public void push(int obj)
-        {
-            if(size==arr.length)
-                throw new ArrayIndexOutOfBoundsException("The queue is full");
-            size++;
-            arr[last]=obj;
-            last=last==arr.length-1?0:last+1;
-        }
-
-        public Integer pop(){
-            if(size==0)
-                throw  new ArrayIndexOutOfBoundsException("The queue is empty");
-            size--;
-            int temp=first;
-            first=first==arr.length-1?0:first+1;
-            return arr[temp];
-        }
-    }
-}
Index: src/JUC/Demo5/ArrayListDemo.java
===================================================================
diff --git a/src/JUC/Demo5/ArrayListDemo.java b/src/JUC/Demo5/ArrayListDemo.java
deleted file mode 100644
--- a/src/JUC/Demo5/ArrayListDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,21 +0,0 @@
-package JUC.Demo5;
-
-import java.util.*;
-import java.util.concurrent.CopyOnWriteArrayList;
-
-public class ArrayListDemo {
-
-    public static void main(String[] args) {
-        ////Vector<String> vector=new Vector<>();
-       //List<String> vector = Collections.synchronizedList(new ArrayList<String>());
-        CopyOnWriteArrayList<String>vector=new CopyOnWriteArrayList<>();
-        for(int i=0;i<30;i++)
-        {
-            new Thread(()->{vector.add(UUID.randomUUID().toString().substring(0,8));
-                System.out.println(vector);},"AA").start();
-        }
-
-
-
-    }
-}
Index: src/韩顺平算法与数据结构/datastructure/stack/ArrayStackDemo.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/stack/ArrayStackDemo.java b/src/韩顺平算法与数据结构/datastructure/stack/ArrayStackDemo.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/stack/ArrayStackDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,65 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.stack;
-
-import javax.sound.midi.SoundbankResource;
-
-public class ArrayStackDemo {
-}
-class ArrayStack{
-    private int maxSize;
-    private int[] stack;
-    private int top=-1;
-
-    public ArrayStack(int maxSize)
-    {
-        this.maxSize=maxSize;
-        stack=new int[maxSize];
-    }
-    //栈满
-    public boolean isFull()
-    {
-        return top==maxSize-1;
-    }
-    //栈空
-    public boolean isEmpty()
-    {
-        return top==-1;
-    }
-    //入栈
-    public void push(int value)
-    {
-        if(isFull())
-        {
-            System.out.println("栈满");
-            return;
-        }else{
-            top++;
-            stack[top]=value;
-        }
-    }
-    //出栈
-    public int pop()
-    {
-        if(isEmpty())
-        {
-          throw new  RuntimeException("栈空，没有数据");
-        }
-        int value=stack[top];
-        top--;
-        return value;
-    }
-
-    //遍历显示栈
-    public void list()
-    {
-        if(isEmpty())
-        {
-            System.out.println("栈空");
-            return;
-        }
-        //需要从栈顶显示数据
-        for(int i=top;i>=0;i--)
-        {
-            System.out.println(stack[i]);
-        }
-    }
-}
Index: src/韩顺平算法与数据结构/datastructure/tree/ArrBinaryTreeDemo.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/tree/ArrBinaryTreeDemo.java b/src/韩顺平算法与数据结构/datastructure/tree/ArrBinaryTreeDemo.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/tree/ArrBinaryTreeDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,102 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.tree;
-
-import javax.sound.midi.SoundbankResource;
-
-public class ArrBinaryTreeDemo {
-
-    public static void main(String[] args) {
-        int[] arr=new int[]{1,2,3,4,5,6,7};
-        ArrBinaryTree arrBinaryTree=new ArrBinaryTree(arr);
-        //arrBinaryTree.preOrder();
-        arrBinaryTree.postOrder();
-        System.out.println("-================-=-=-=-=-==-=-=-==-");
-        arrBinaryTree.midOrder();
-    }
-
-}
-
-class ArrBinaryTree{
-    //存储数据结点的数组
-    private int[] arr;
-    public ArrBinaryTree(int[] arr)
-    {
-        this.arr=arr;
-    }
-
-
-    //重载preOrder
-    public void preOrder()
-    {
-        this.preOrder(0);
-    }
-     //重载midOrder
-    public void midOrder()
-    {
-        this.midOrder(0);
-    }
-
-     //重载postOrder
-    public void postOrder()
-    {
-        this.postOrder(0);
-    }
-    //实现顺序存储二叉树的前序遍历
-    public void preOrder(int index) {
-
-        if (arr == null || arr.length == 0)
-        {
-            System.out.println("数组为空，不能遍历");
-        }
-        //输出当前元素
-        System.out.print(arr[index]);
-        if(index*2+1<arr.length)
-        {
-            preOrder(2*index+1);
-        }
-
-        if(index*2+2<arr.length)
-        {
-            preOrder(index*2+2);
-        }
-    }
-
-    //顺序存储的中序遍历
-    public void midOrder(int index)
-    {
-        if(arr==null || arr.length==0)
-        {
-            System.out.println("数组为空不能进行遍历");
-        }
-
-        if(index*2+1<arr.length)
-        {
-            midOrder(index*2+1);
-        }
-
-        System.out.println(arr[index]);
-
-        if(index*2+2<arr.length)
-        {
-            midOrder(index*2+2);
-        }
-    }
-
-    //后序
-    public void postOrder(int index)
-    {
-        if(arr==null || arr.length==0)
-        {
-            System.out.println("遍历失败");
-        }
-
-        if(index*2+1<arr.length)
-        {
-            postOrder(index*2+1);
-        }
-        if(index*2+2<arr.length)
-        {
-            postOrder(index*2+2);
-        }
-        System.out.println(arr[index]);
-    }
-}
Index: .idea/libraries/asm_commons.xml
===================================================================
diff --git a/.idea/libraries/asm_commons.xml b/.idea/libraries/asm_commons.xml
deleted file mode 100644
--- a/.idea/libraries/asm_commons.xml	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,14 +0,0 @@
-<component name="libraryTable">
-  <library name="asm-commons">
-    <CLASSES>
-      <root url="jar://$PROJECT_DIR$/src/lib/asm-commons.jar!/" />
-      <root url="jar://$PROJECT_DIR$/src/lib/asm.jar!/" />
-      <root url="jar://$PROJECT_DIR$/src/lib/asm-tree.jar!/" />
-      <root url="jar://$PROJECT_DIR$/src/lib/cglib-2.2.jar!/" />
-    </CLASSES>
-    <JAVADOC />
-    <SOURCES>
-      <root url="jar://$USER_HOME$/.ideaLibSources/cglib-2.2-sources.jar!/" />
-    </SOURCES>
-  </library>
-</component>
\ No newline at end of file
Index: src/JUC/demo4/AtomicReferenceDemo.java
===================================================================
diff --git a/src/JUC/demo4/AtomicReferenceDemo.java b/src/JUC/demo4/AtomicReferenceDemo.java
deleted file mode 100644
--- a/src/JUC/demo4/AtomicReferenceDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,34 +0,0 @@
-package JUC.demo4;
-
-import java.util.concurrent.atomic.AtomicReference;
-
-class User{
-    String name;
-    int age;
-
-    public User(String name) {
-        this.name = name;
-    }
-
-    @Override
-    public String toString() {
-        return "User{" +
-                "name='" + name + '\'' +
-                ", age=" + age +
-                '}';
-    }
-}
-public class AtomicReferenceDemo {
-
-    public static void main(String[] args) {
-//        User user=new User("lisi");
-//        User user1=new User("zhangsan");
-//        AtomicReference<User> atomicReference=new AtomicReference<>();
-//        atomicReference.set(user);
-//        System.out.println(atomicReference.compareAndSet(user,user1)+"\t"+atomicReference.get().toString());
-//        System.out.println(atomicReference.compareAndSet(user,user1)+"\t"+atomicReference.get().toString());
-
-
-
-    }
-}
Index: src/JUC/ABAResolve/AtomicStampedReferenceDemo.java
===================================================================
diff --git a/src/JUC/ABAResolve/AtomicStampedReferenceDemo.java b/src/JUC/ABAResolve/AtomicStampedReferenceDemo.java
deleted file mode 100644
--- a/src/JUC/ABAResolve/AtomicStampedReferenceDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,26 +0,0 @@
-package JUC.ABAResolve;
-
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicStampedReference;
-
-public class AtomicStampedReferenceDemo {
-
-    private static AtomicStampedReference<Integer> atomicStampedReference=new AtomicStampedReference<>(100,1);
-    public static void main(String[] args) {
-
-        new Thread(()->{
-            boolean b1 = atomicStampedReference.compareAndSet(100, 101, 1, 2);
-
-            boolean b2=atomicStampedReference.compareAndSet(101,100,2,3);
-            System.out.println(Thread.currentThread().getName()+"\t"+b2+atomicStampedReference.getReference().toString());
-
-        },"AA").start();
-
-        new Thread(()->{
-            try{
-                TimeUnit.SECONDS.sleep(3);}catch (Exception e){e.printStackTrace();}
-               boolean b3= atomicStampedReference.compareAndSet(100,101,1,2);
-            System.out.println(Thread.currentThread().getName()+"\t"+b3+atomicStampedReference.getReference().toString());
-        },"BB").start();
-    }
-}
Index: src/org/sd/factory/Audi.java
===================================================================
diff --git a/src/org/sd/factory/Audi.java b/src/org/sd/factory/Audi.java
deleted file mode 100644
--- a/src/org/sd/factory/Audi.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package org.sd.factory;
-
-public class Audi implements Car {
-    public void run()
-    {
-        System.out.println("奥迪在跑");
-    }
-}
Index: src/org/sd/factory/AudiFactory.java
===================================================================
diff --git a/src/org/sd/factory/AudiFactory.java b/src/org/sd/factory/AudiFactory.java
deleted file mode 100644
--- a/src/org/sd/factory/AudiFactory.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package org.sd.factory;
-
-public class AudiFactory implements CarFactory {
-    @Override
-    public Car createCar() {
-        return new Audi();
-    }
-}
Index: src/org/sd/Author.java
===================================================================
diff --git a/src/org/sd/Author.java b/src/org/sd/Author.java
deleted file mode 100644
--- a/src/org/sd/Author.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,7 +0,0 @@
-package org.sd;
-
-public @interface  Author {
-    String name();
-    int year();
-
-}
Index: src/韩顺平算法与数据结构/datastructure/tree/AVL/AVLDemo.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/tree/AVL/AVLDemo.java b/src/韩顺平算法与数据结构/datastructure/tree/AVL/AVLDemo.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/tree/AVL/AVLDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,337 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.tree.AVL;
-
-public class AVLDemo {
-    public static void main(String[] args) {
-        int[] arr = { 10, 11, 7, 6, 8, 9 };
-        //创建一个 AVLTree对象
-        AVLTree avlTree = new AVLTree();
-        //添加结点
-        for(int i=0; i < arr.length; i++) {
-            avlTree.add(new Node(arr[i]));
-        }
-
-        //遍历
-        System.out.println("中序遍历");
-        avlTree.infixOrder();
-
-        System.out.println("在平衡处理~~");
-        System.out.println("树的高度=" + avlTree.getRoot().height()); //3
-        System.out.println("树的左子树高度=" + avlTree.getRoot().leftHeight()); // 2
-        System.out.println("树的右子树高度=" + avlTree.getRoot().rightHeight()); // 2
-        System.out.println("当前的根结点=" + avlTree.getRoot());//8
-
-    }
-}
-
-
-// 创建AVLTree
-class AVLTree {
-    private Node root;
-
-    public Node getRoot() {
-        return root;
-    }
-
-    // 查找要删除的结点
-    public Node search(int value) {
-        if (root == null) {
-            return null;
-        } else {
-            return root.search(value);
-        }
-    }
-
-    // 查找父结点
-    public Node searchParent(int value) {
-        if (root == null) {
-            return null;
-        } else {
-            return root.searchParent(value);
-        }
-    }
-
-    // 编写方法:
-    // 1. 返回的 以node 为根结点的二叉排序树的最小结点的值
-    // 2. 删除node 为根结点的二叉排序树的最小结点
-    /**
-     *
-     * @param node
-     *            传入的结点(当做二叉排序树的根结点)
-     * @return 返回的 以node 为根结点的二叉排序树的最小结点的值
-     */
-    public int delRightTreeMin(Node node) {
-        Node target = node;
-        // 循环的查找左子节点，就会找到最小值
-        while (target.left != null) {
-            target = target.left;
-        }
-        // 这时 target就指向了最小结点
-        // 删除最小结点
-        delNode(target.value);
-        return target.value;
-    }
-
-    // 删除结点
-    public void delNode(int value) {
-        if (root == null) {
-            return;
-        } else {
-            // 1.需求先去找到要删除的结点 targetNode
-            Node targetNode = search(value);
-            // 如果没有找到要删除的结点
-            if (targetNode == null) {
-                return;
-            }
-            // 如果我们发现当前这颗二叉排序树只有一个结点
-            if (root.left == null && root.right == null) {
-                root = null;
-                return;
-            }
-
-            // 去找到targetNode的父结点
-            Node parent = searchParent(value);
-            // 如果要删除的结点是叶子结点
-            if (targetNode.left == null && targetNode.right == null) {
-                // 判断targetNode 是父结点的左子结点，还是右子结点
-                if (parent.left != null && parent.left.value == value) { // 是左子结点
-                    parent.left = null;
-                } else if (parent.right != null && parent.right.value == value) {// 是由子结点
-                    parent.right = null;
-                }
-            } else if (targetNode.left != null && targetNode.right != null) { // 删除有两颗子树的节点
-                int minVal = delRightTreeMin(targetNode.right);
-                targetNode.value = minVal;
-
-            } else { // 删除只有一颗子树的结点
-                // 如果要删除的结点有左子结点
-                if (targetNode.left != null) {
-                    if (parent != null) {
-                        // 如果 targetNode 是 parent 的左子结点
-                        if (parent.left.value == value) {
-                            parent.left = targetNode.left;
-                        } else { // targetNode 是 parent 的右子结点
-                            parent.right = targetNode.left;
-                        }
-                    } else {
-                        root = targetNode.left;
-                    }
-                } else { // 如果要删除的结点有右子结点
-                    if (parent != null) {
-                        // 如果 targetNode 是 parent 的左子结点
-                        if (parent.left.value == value) {
-                            parent.left = targetNode.right;
-                        } else { // 如果 targetNode 是 parent 的右子结点
-                            parent.right = targetNode.right;
-                        }
-                    } else {
-                        root = targetNode.right;
-                    }
-                }
-
-            }
-
-        }
-    }
-
-    // 添加结点的方法
-    public void add(Node node) {
-        if (root == null) {
-            root = node;// 如果root为空则直接让root指向node
-        } else {
-            root.add(node);
-        }
-    }
-
-    // 中序遍历
-    public void infixOrder() {
-        if (root != null) {
-            root.infixOrder();
-        } else {
-            System.out.println("二叉排序树为空，不能遍历");
-        }
-    }
-}
-// 创建Node结点
-class Node {
-    int value;
-    Node left;
-    Node right;
-
-    public Node(int value) {
-
-        this.value = value;
-    }
-    //返回该结点饿左子树的高度
-    public int leftHeight()
-    {
-        if(left==null)
-        {
-            return 0;
-        }else
-        {
-            return left.height();
-        }
-    }
-
-    //返回该结点的右子树的高度
-    public int rightHeight()
-    {
-        if(right==null)
-        {
-            return 0;
-        }else
-        {
-            return right.height();
-        }
-    }
-    //返回以该结点为根节点的树的高度
-    public int height()
-    {
-        return Math.max(left==null? 0:left.height(),right==null? 0:right.height())+1;
-    }
-
-    //左旋转
-    public void leftRotate()
-    {
-        //创建一个新的结点
-        Node newNode=new Node(value);
-        //把新节点的左子树设置为当前节点的左子树
-        newNode.left=left;
-        //把新节点的右子树设置为当前结点的右子树的左子树
-        newNode.right=right.left;
-        //当前节点的值替换为右子节点的值
-        value=right.value;
-        //把当前结点饿左子树设置为新节点
-        left=newNode;
-        //把当前节点的右子树设置为当前节点的右子树的右子树
-        right=right.right;
-    }
-
-    //右旋转
-    public void rightRotate()
-    {
-        Node newNode=new Node(value);
-        newNode.right=right;
-        newNode.left=left.right;
-        value=left.value;
-        left=left.left;
-        right=newNode;
-    }
-
-    // 查找要删除的结点
-    /**
-     *
-     * @param value
-     *            希望删除的结点的值
-     * @return 如果找到返回该结点，否则返回null
-     */
-    public Node search(int value) {
-        if (value == this.value) { // 找到就是该结点
-            return this;
-        } else if (value < this.value) {// 如果查找的值小于当前结点，向左子树递归查找
-            // 如果左子结点为空
-            if (this.left == null) {
-                return null;
-            }
-            return this.left.search(value);
-        } else { // 如果查找的值不小于当前结点，向右子树递归查找
-            if (this.right == null) {
-                return null;
-            }
-            return this.right.search(value);
-        }
-
-    }
-
-    // 查找要删除结点的父结点
-    /**
-     *
-     * @param value
-     *            要找到的结点的值
-     * @return 返回的是要删除的结点的父结点，如果没有就返回null
-     */
-    public Node searchParent(int value) {
-        // 如果当前结点就是要删除的结点的父结点，就返回
-        if ((this.left != null && this.left.value == value) || (this.right != null && this.right.value == value)) {
-            return this;
-        } else {
-            // 如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空
-            if (value < this.value && this.left != null) {
-                return this.left.searchParent(value); // 向左子树递归查找
-            } else if (value >= this.value && this.right != null) {
-                return this.right.searchParent(value); // 向右子树递归查找
-            } else {
-                return null; // 没有找到父结点
-            }
-        }
-
-    }
-
-    @Override
-    public String toString() {
-        return "Node [value=" + value + "]";
-    }
-
-    // 添加结点的方法
-    // 递归的形式添加结点，注意需要满足二叉排序树的要求
-    public void add(Node node) {
-        if (node == null) {
-            return;
-        }
-
-        // 判断传入的结点的值，和当前子树的根结点的值关系
-        if (node.value < this.value) {
-            // 如果当前结点左子结点为null
-            if (this.left == null) {
-                this.left = node;
-            } else {
-                // 递归的向左子树添加
-                this.left.add(node);
-            }
-        } else { // 添加的结点的值大于 当前结点的值
-            if (this.right == null) {
-                this.right = node;
-            } else {
-                // 递归的向右子树添加
-                this.right.add(node);
-            }
-
-        }
-        if(rightHeight()-leftHeight()>1) {
-            if (right != null && right.leftHeight() > right.rightHeight()) {
-                //先对右子节点进行右旋转
-                right.rightRotate();
-                //左旋转
-                leftRotate();
-            } else {
-                leftRotate();
-            }
-            return;
-        }
-
-        if(leftHeight()-rightHeight()>1)
-        {
-            if(left!=null & left.rightHeight()>left.leftHeight()){
-                //先对左子树进行左旋转
-                left.leftRotate();
-                //再右旋转
-                rightRotate();
-            }else {
-                rightRotate();
-            }
-
-        }
-    }
-
-    // 中序遍历
-    public void infixOrder() {
-        if (this.left != null) {
-            this.left.infixOrder();
-        }
-        System.out.println(this);
-        if (this.right != null) {
-            this.right.infixOrder();
-        }
-    }
-
-}
\ No newline at end of file
Index: src/Gof/Strategy/BadFlyBehavior.java
===================================================================
diff --git a/src/Gof/Strategy/BadFlyBehavior.java b/src/Gof/Strategy/BadFlyBehavior.java
deleted file mode 100644
--- a/src/Gof/Strategy/BadFlyBehavior.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package Gof.Strategy;
-
-public class BadFlyBehavior implements FlyBehavior {
-    @Override
-    public void fly() {
-        System.out.println("飞行技术垃圾");
-    }
-}
Index: src/Gof/Strategy/BadQuackBehavior.java
===================================================================
diff --git a/src/Gof/Strategy/BadQuackBehavior.java b/src/Gof/Strategy/BadQuackBehavior.java
deleted file mode 100644
--- a/src/Gof/Strategy/BadQuackBehavior.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package Gof.Strategy;
-
-public class BadQuackBehavior implements QuackBehavior{
-    @Override
-    public void quack() {
-        System.out.println("小声的叫");
-    }
-}
Index: src/Gof/observer/Baidu.java
===================================================================
diff --git a/src/Gof/observer/Baidu.java b/src/Gof/observer/Baidu.java
deleted file mode 100644
--- a/src/Gof/observer/Baidu.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,24 +0,0 @@
-package Gof.observer;
-
-public class Baidu implements Observer {
-
-    private float temperature;
-    private float pressure;
-    private float humidity;
-
-    @Override
-    public void update(float temperature, float pressure, float humidity) {
-         this.temperature=temperature;
-         this.pressure=pressure;
-         this.humidity=humidity;
-         display();
-    }
-
-    public void display()
-    {
-        System.out.println("====百度=======");
-        System.out.println("***百度网站 气温 : " + temperature + "***");
-        System.out.println("***百度网站 气压: " + pressure + "***");
-        System.out.println("***百度网站 湿度: " + humidity + "***");
-    }
-}
Index: src/左神算法/基础班/第四课/BestArrange.java
===================================================================
diff --git a/src/左神算法/基础班/第四课/BestArrange.java b/src/左神算法/基础班/第四课/BestArrange.java
deleted file mode 100644
--- a/src/左神算法/基础班/第四课/BestArrange.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,45 +0,0 @@
-package 左神算法.基础班.第四课;
-
-import java.util.Arrays;
-import java.util.Comparator;
-
-public class BestArrange {
-
-    public static class Program{
-        public int start;
-        public int end;
-
-        public Program(int start, int end) {
-            this.start = start;
-            this.end = end;
-        }
-    }
-
-    //比较器，用来排序给定的数组，根据会议的结束时间来实行相应的贪心策略
-    public static class ProgramComparator implements Comparator<Program>{
-
-        @Override
-        public int compare(Program o1, Program o2) {
-            return o1.end-o2.end;
-        }
-    }
-
-    public  static int bestArrange(Program[] programs,int cur){ //cur表示当前时间，刚开始的时候也就是开始时间
-
-        Arrays.sort(programs,new ProgramComparator());
-        int result=0;
-        for(int i=0;i<programs.length;i++)
-        {
-            if(cur<=programs[i].start)
-            {
-                result++;
-                cur+=programs[i].end;
-            }
-        }
-        return result;
-    }
-
-    public static void main(String[] args) {
-
-    }
-}
Index: src/左神算法/进阶班一/BFPRT/BFPRT.java
===================================================================
diff --git a/src/左神算法/进阶班一/BFPRT/BFPRT.java b/src/左神算法/进阶班一/BFPRT/BFPRT.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/BFPRT/BFPRT.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,252 +0,0 @@
-package 左神算法.进阶班一.BFPRT;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: bfprt算法的实现，主要用来求：找出一个数组中前k小，或者前k大的数字，返回的是一个长度为k的数组。
- * @date 2019/12/28 13:50
- */
-public class BFPRT {
-
-    // O(N*logK),找出数组中最小的k个数
-    public static int[] getMinKNumsByHeap(int[] arr, int k) {
-        if (k < 1 || k > arr.length) {
-            return arr;
-        }
-        int[] kHeap = new int[k];
-        for (int i = 0; i != k; i++) {
-            heapInsert(kHeap, arr[i], i);
-        }
-        for (int i = k; i != arr.length; i++) {
-            if (arr[i] < kHeap[0]) {
-                kHeap[0] = arr[i];
-                heapify(kHeap, 0, k);
-            }
-        }
-        return kHeap;
-    }
-
-    public static void heapInsert(int[] arr, int value, int index) {
-        arr[index] = value;
-        while (index != 0) {
-            int parent = (index - 1) / 2;
-            if (arr[parent] < arr[index]) {
-                swap(arr, parent, index);
-                index = parent;
-            } else {
-                break;
-            }
-        }
-    }
-
-    public static void heapify(int[] arr, int index, int heapSize) {
-        int left = index * 2 + 1;
-        int right = index * 2 + 2;
-        int largest = index;
-        while (left < heapSize) {
-            if (arr[left] > arr[index]) {
-                largest = left;
-            }
-            if (right < heapSize && arr[right] > arr[largest]) {
-                largest = right;
-            }
-            if (largest != index) {
-                swap(arr, largest, index);
-            } else {
-                break;
-            }
-            index = largest;
-            left = index * 2 + 1;
-            right = index * 2 + 2;
-        }
-    }
-    //自己实现
-    public static int[] getKNumsByHeap(int[] arr,int k){
-        if(arr==null || arr.length<k)
-            return null;
-        int[] res=new int[k];
-        for(int i=0;i<k;i++)
-        {
-            heapInsert(res,arr[i],i);
-        }
-        for(int i=k;i<arr.length;i++)
-        {
-            if(arr[i]<res[0])
-            {
-                res[0]=arr[i];
-                heapify(res,0,k);
-            }
-        }
-        return res;
-
-    }
-    public static void heapInsert2(int[] arr,int value,int index){
-
-        arr[index]=value;
-        int parent=(index-1)/2;
-        while(arr[parent]<arr[index])
-        {  swap(arr,index,parent);
-           index=parent;
-           parent=(index-1)/2;
-        }
-
-    }
-    public static void heapify2(int[] arr,int index,int heapSize){
-        int left=index*2+1;
-        while(left<heapSize){
-            int largest=(left+1<heapSize) && (arr[left] <arr[left+1])? left+1:left;
-            if(arr[index]<arr[largest])
-            {
-                swap(arr,index,largest);
-                index=largest;
-                left=index*2+1;
-            }else{
-                break;
-            }
-        }
-
-    }
-
-
-    //O(N) BFPRT的方式找出数组中最小的k个数
-    public static int[] getMinKNumsByBFPRT(int[] arr,int k){
-
-        if(k<1 || k>arr.length)
-        {
-            return null;
-        }
-        int minKthByBFPRT = getMinKthByBFPRT(arr, k);
-        int[] res=new int[k];
-        int index=0;
-        for(int i=0;i!=arr.length;i++){
-            if(arr[i]<minKthByBFPRT) //这里不能是<=，因为可能有多个相同的minKthByBFPRT
-            {
-                res[index++]=arr[i];
-            }
-        }
-        //如果有多个相同的minKthByBFPRT，这里来补充
-        for (; index != res.length; index++) {
-            res[index] = minKthByBFPRT;
-        }
-        return res;
-    }
-    public static int getMinKthByBFPRT(int[] arr,int k){
-        int[] copyArr=copyArray(arr);
-        return select(copyArr,0,copyArr.length-1,k-1);
-    }
-    public static int[] copyArray(int[] arr){
-        int[] copyArr=new int[arr.length];
-        for(int i=0;i<arr.length;i++){
-            copyArr[i]=arr[i];
-        }
-        return copyArr;
-    }
-    /**
-    *@param ：i表示第i小的数
-    *@return
-    */
-
-    public static int select(int[] arr, int begin, int end, int i) {
-        if (begin == end) {
-            return arr[begin];
-        }
-        int pivot = medianOfMedians(arr, begin, end);
-        int[] pivotRange = partition(arr, begin, end, pivot);
-        if (i >= pivotRange[0] && i <= pivotRange[1]) {
-            return arr[i];
-        } else if (i < pivotRange[0]) {
-            return select(arr, begin, pivotRange[0] - 1, i);
-        } else {
-            return select(arr, pivotRange[1] + 1, end, i);
-        }
-    }
-
-   public static int[] partition(int[] arr,int begin,int end,int num)
-   {
-      int small=begin-1;
-      int cur=begin;
-      int big=end+1;
-      while(cur!=big)
-      {
-          if(arr[cur]<num)
-          {
-              swap(arr,++small,cur++);
-          }else if(arr[cur]>num)
-          {
-              swap(arr,--big,cur);
-          }else{
-              cur++;
-          }
-      }
-      int[] pivotRange=new int[2];
-      pivotRange[0]=small+1;
-      pivotRange[1]=big-1;
-      return pivotRange;
-   }
-//    public static int medianOfMedians(int[] arr,int begin,int end)
-//    {
-//        int num=end-begin+1;
-//        int offset=num % 5==0 ? 0:1;
-//        int[] mArr=new int[num/5+offset];
-//        for(int i=0;i<mArr.length;i++)
-//        {
-//            int beginI=begin+i*5;
-//            int endI=beginI+4;
-//            mArr[i]=getMedian(arr,beginI,Math.min(end,endI));
-//        }
-//        return select(arr,0,mArr.length-1,mArr.length/2);
-//    }
-public static int medianOfMedians(int[] arr, int begin, int end) {
-    int num = end - begin + 1;
-    int offset = num % 5 == 0 ? 0 : 1;
-    int[] mArr = new int[num / 5 + offset];
-    for (int i = 0; i < mArr.length; i++) {
-        int beginI = begin + i * 5;
-        int endI = beginI + 4;
-        mArr[i] = getMedian(arr, beginI, Math.min(end, endI));
-    }
-    return select(mArr, 0, mArr.length - 1, mArr.length/2);
-}
-
-    //求中位数
-    public static int getMedian(int[] arr,int begin,int end){
-        insertSort(arr,begin,end);
-        int sum=(begin+end);
-        int mid=sum/2+(sum%2);
-        return arr[mid];
-    }
-    public static void insertSort(int[] arr,int begin,int end){
-        for(int i=begin+1;i!=end+1;i++){
-            for(int j=i;j!=begin;j--){
-                if(arr[j-1]>arr[j]){
-                    swap(arr,j-1,j);
-                }else{
-                    break;
-                    }
-            }
-        }
-    }
-
-    public static void swap(int[]arr,int i,int j){
-        int temp=arr[i];
-        arr[i]=arr[j];
-        arr[j]=temp;
-    }
-
-    public static void printArray(int[] arr) {
-        for (int i = 0; i != arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-        int[] arr = { 6, 9, 1, 3, 1, 2, 2, 5, 6, 5, 5, 5, 9, 7, 2, 5, 6, 1, 9 };
-        // sorted : { 1, 1, 1, 1, 2, 2, 2, 3, 3, 5, 5, 5, 6, 6, 6, 7, 9, 9, 9 }
-        printArray(getMinKNumsByHeap(arr, 10));
-        printArray(getMinKNumsByBFPRT(arr, 10));
-        printArray(getKNumsByHeap(arr,10));
-
-    }
-
-}
Index: src/左神算法/基础班/图/BFS.java
===================================================================
diff --git a/src/左神算法/基础班/图/BFS.java b/src/左神算法/基础班/图/BFS.java
deleted file mode 100644
--- a/src/左神算法/基础班/图/BFS.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,31 +0,0 @@
-package 左神算法.基础班.图;
-
-import java.util.HashSet;
-import java.util.LinkedList;
-import java.util.Queue;
-
-public class BFS {
-
-    public static void bfs(Node node){
-        if(node==null)
-            return;
-        Queue<Node>queues=new LinkedList<>();
-        HashSet<Node> sets=new HashSet<>();
-        queues.add(node);
-        sets.add(node);
-        while(!queues.isEmpty())
-        {
-            Node temp=queues.poll();
-            System.out.println(temp.value);
-            for(Node next:temp.nexts)
-            {
-                if(!sets.contains(next))
-                {
-                    queues.add(next);
-                    sets.add(next);
-                }
-            }
-
-        }
-    }
-}
Index: src/左神算法/进阶班一/树相关/高度套路题树形dp/BiggestSubBSTInTree.java
===================================================================
diff --git a/src/左神算法/进阶班一/树相关/高度套路题树形dp/BiggestSubBSTInTree.java b/src/左神算法/进阶班一/树相关/高度套路题树形dp/BiggestSubBSTInTree.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/树相关/高度套路题树形dp/BiggestSubBSTInTree.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,159 +0,0 @@
-package 左神算法.进阶班一.树相关.高度套路题树形dp;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 给定一棵二叉树的头结点，返回其中最大的搜索二叉树的[大小]。
- * @date 2020/1/5 13:17
- */
-public class BiggestSubBSTInTree {
-
-    public static class Node {
-        public int value;
-        public Node left;
-        public Node right;
-
-        public Node(int data) {
-            this.value = data;
-        }
-    }
-
-    public static Node biggestSubBST(Node head) {
-        int[] record = new int[3]; // 0->size, 1->min, 2->max
-        return posOrder(head, record);
-    }
-
-    public static class ReturnType{
-        public int size;//最大搜索二叉树的大小
-        public Node head;//头结点
-        public int min;//子树上的最小值
-        public int max;//子树上的最大值
-
-        public ReturnType(int a, Node b,int c,int d) {
-            this.size =a;
-            this.head = b;
-            this.min = c;
-            this.max = d;
-        }
-    }
-
-    public static ReturnType process(Node head){
-        if(head == null) {
-            return new ReturnType(0,null,Integer.MAX_VALUE, Integer.MIN_VALUE);//使他不影响做判断，最大值给Integer的最小值，最小值给Integer的最大值
-        }
-        Node left = head.left;
-        ReturnType leftSubTressInfo = process(left);
-        Node right = head.right;
-        ReturnType rightSubTressInfo = process(right);
-
-        int includeItSelf = 0; //第三种情况
-        if(leftSubTressInfo.head == left
-                &&rightSubTressInfo.head == right
-                && head.value > leftSubTressInfo.max
-                && head.value < rightSubTressInfo.min
-                ) {
-            includeItSelf = leftSubTressInfo.size + 1 + rightSubTressInfo.size;//满足条件的时候可以连起来，即：情况三
-        }
-        int p1 = leftSubTressInfo.size;//可能性1
-        int p2 = rightSubTressInfo.size;//可能性2
-
-        //以上类似于黑盒，下面的类似拆黑盒的过程。
-        int maxSize = Math.max(Math.max(p1, p2), includeItSelf);
-
-        Node maxHead = p1 > p2 ? leftSubTressInfo.head : rightSubTressInfo.head;
-        if(maxSize == includeItSelf) {
-            maxHead = head;
-        }
-
-        return new ReturnType(maxSize,
-                maxHead,
-                Math.min(Math.min(leftSubTressInfo.min,rightSubTressInfo.min),head.value),
-                Math.max(Math.max(leftSubTressInfo.max,rightSubTressInfo.max),head.value));
-
-
-    }
-
-
-    public static Node posOrder(Node head, int[] record) {
-        if (head == null) {
-            record[0] = 0;
-            record[1] = Integer.MAX_VALUE;
-            record[2] = Integer.MIN_VALUE;
-            return null;
-        }
-        int value = head.value;
-        Node left = head.left;
-        Node right = head.right;
-        Node lBST = posOrder(left, record);
-        int lSize = record[0];
-        int lMin = record[1];
-        int lMax = record[2];
-        Node rBST = posOrder(right, record);
-        int rSize = record[0];
-        int rMin = record[1];
-        int rMax = record[2];
-        record[1] = Math.min(rMin, Math.min(lMin, value)); // lmin, value, rmin -> min
-        record[2] =  Math.max(lMax, Math.max(rMax, value)); // lmax, value, rmax -> max
-        if (left == lBST && right == rBST && lMax < value && value < rMin) {
-            record[0] = lSize + rSize + 1;
-            return head;
-        }
-        record[0] = Math.max(lSize, rSize);
-        return lSize > rSize ? lBST : rBST;
-    }
-
-    // for test -- print tree
-    public static void printTree(Node head) {
-        System.out.println("Binary Tree:");
-        printInOrder(head, 0, "H", 17);
-        System.out.println();
-    }
-
-    public static void printInOrder(Node head, int height, String to, int len) {
-        if (head == null) {
-            return;
-        }
-        printInOrder(head.right, height + 1, "v", len);
-        String val = to + head.value + to;
-        int lenM = val.length();
-        int lenL = (len - lenM) / 2;
-        int lenR = len - lenM - lenL;
-        val = getSpace(lenL) + val + getSpace(lenR);
-        System.out.println(getSpace(height * len) + val);
-        printInOrder(head.left, height + 1, "^", len);
-    }
-
-    public static String getSpace(int num) {
-        String space = " ";
-        StringBuffer buf = new StringBuffer("");
-        for (int i = 0; i < num; i++) {
-            buf.append(space);
-        }
-        return buf.toString();
-    }
-
-    public static void main(String[] args) {
-
-        Node head = new Node(6);
-        head.left = new Node(1);
-        head.left.left = new Node(0);
-        head.left.right = new Node(3);
-        head.right = new Node(12);
-        head.right.left = new Node(10);
-        head.right.left.left = new Node(4);
-        head.right.left.left.left = new Node(2);
-        head.right.left.left.right = new Node(5);
-        head.right.left.right = new Node(14);
-        head.right.left.right.left = new Node(11);
-        head.right.left.right.right = new Node(15);
-        head.right.right = new Node(13);
-        head.right.right.left = new Node(20);
-        head.right.right.right = new Node(16);
-
-        printTree(head);
-        Node bst = biggestSubBST(head);
-        printTree(bst);
-
-    }
-
-}
Index: src/韩顺平算法与数据结构/datastructure/search/BinarySearch.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/search/BinarySearch.java b/src/韩顺平算法与数据结构/datastructure/search/BinarySearch.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/search/BinarySearch.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,80 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.search;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class BinarySearch {
-    public static void main(String[] args) {
-        int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9,9,9,9,9,9,9, 10 , 11, 12, 13,14,15,16,17,18,19,20 };
-        System.out.println(binarySearch2(arr, 0,arr.length, 9));
-    }
-
-    public static int binarySearch(int[] arr,int left,int right,int findVal)
-    {
-        int mid=(left+right)/2;
-        int midVal=arr[mid];
-        if(left>right)
-        {
-            return -1;
-        }
-        if(midVal>findVal)
-        {
-            return binarySearch(arr,left,mid-1,findVal);
-
-        }else if(midVal<findVal){
-            return binarySearch(arr,mid+1,right,findVal);
-        }else{
-            return mid;
-        }
-    }
-
-    //有多个相同的数值时，如何将所有的数值的位置都找到？
-    /**
-     * 思路分析：
-     * 再找到mid索引值后，不要立马返回
-     * 向mid索引的左边扫描，将所有满足元素的下标加入到集合ArrayList中
-     * 向mid索引值的右边扫苗，将所有满足元素的下标加入到集合
-     * 将ArrayList返回
-     */
-
-    public static List<Integer> binarySearch2(int[]arr,int left,int right,int findVal)
-    {
-        int mid=(left+right)/2;
-        int midVal=arr[mid];
-        if(left>right)
-        {
-            return new ArrayList<Integer>();
-        }
-        if(midVal>findVal)
-        {
-            return binarySearch2(arr,left,mid-1,findVal);
-
-        }else if(midVal<findVal){
-            return binarySearch2(arr,mid+1,right,findVal);
-        }else{
-            List<Integer> resIndexList=new ArrayList<>();
-            int temp=mid-1;
-            while(true)
-            {
-                if(temp<0 || arr[temp]!=findVal)
-                {
-                    break;
-                }
-                resIndexList.add(temp);
-                temp--;
-            }
-            resIndexList.add(mid);
-            temp=mid+1;
-            while(true)
-            {
-                if(temp>arr.length-1 || arr[temp]!=findVal)
-                {
-                    break;
-                }
-                resIndexList.add(temp);
-                temp++;
-            }
-            return resIndexList;
-        }
-    }
-}
Index: src/韩顺平算法与数据结构/algorithm/binarysearchnorecursion/BinarySearchNoRecursion.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/algorithm/binarysearchnorecursion/BinarySearchNoRecursion.java b/src/韩顺平算法与数据结构/algorithm/binarysearchnorecursion/BinarySearchNoRecursion.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/algorithm/binarysearchnorecursion/BinarySearchNoRecursion.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,71 +0,0 @@
-package 韩顺平算法与数据结构.algorithm.binarysearchnorecursion;
-
-public class BinarySearchNoRecursion {
-
-    public static void main(String[] args) {
-
-        int[] arr=new int[]{0,1,3,5,7,8,9,12};
-        System.out.println(binarySearchRecursion(arr,4,0,arr.length-1));;
-        System.out.println(binarySearch2(arr,3));
-    }
-
-    //非递归方式
-     public static int  binarySearch1(int[] arr,int value)
-     {   int left=0;
-         int right=arr.length;
-         int mid=0;
-         while(left<right)
-         {
-             mid=(left+right)/2;
-             if(arr[mid]==value)
-             {
-                 return mid;
-             }else if(arr[mid]<value)
-             {
-                 left=mid+1;
-             }else {
-                 right=mid;
-             }
-         }
-         return arr[left]==value? left:-1;//不存在，没有找到要求的值。
-     }
-    //非递归方式2
-     public static int  binarySearch2(int[] arr,int value)
-    {   int left=0;
-        int right=arr.length-1;
-        int mid=0;
-        while(left<=right)
-        {
-            mid=(left+right)/2;
-            if(arr[mid]==value)
-            {
-                return mid;
-            }else if(arr[mid]<value)
-            {
-                left=mid+1;
-            }else {
-                right=mid-1;
-            }
-        }
-        return -1;//不存在，没有找到要求的值。
-    }
-     //递归实现二分查找
-    public static int binarySearchRecursion(int[] arr,int value,int left,int right)
-    {
-        int mid=(left+right)/2;
-        if(left>right)
-        {
-            return -1;
-        }
-        if(arr[mid]==value)
-        {
-            return mid;
-        }else if(arr[mid]<value){
-           return binarySearchRecursion(arr,value,mid+1,right);
-        }else {
-            return binarySearchRecursion(arr,value,left,mid-1);
-        }
-
-
-    }
-}
Index: src/韩顺平算法与数据结构/datastructure/tree/BST/BinarySortTreeDemo.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/tree/BST/BinarySortTreeDemo.java b/src/韩顺平算法与数据结构/datastructure/tree/BST/BinarySortTreeDemo.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/tree/BST/BinarySortTreeDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,275 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.tree.BST;
-
-public class BinarySortTreeDemo {
-
-    public static void main(String[] args) {
-        int[] arr = {7, 3, 10, 12, 5, 1, 9, 2};
-        BinarySortTree binarySortTree = new BinarySortTree();
-        //循环的添加结点到二叉排序树
-        for(int i = 0; i< arr.length; i++) {
-            binarySortTree.add(new Node(arr[i]));
-        }
-
-        //中序遍历二叉排序树
-        System.out.println("中序遍历二叉排序树~");
-        binarySortTree.infixOrder(); // 1, 3, 5, 7, 9, 10, 12
-
-        //测试一下删除叶子结点
-
-
-//        binarySortTree.delNode(12);
-
-
-        binarySortTree.delNode(5);
-//        binarySortTree.delNode(10);
-//        binarySortTree.delNode(2);
-//        binarySortTree.delNode(3);
-//
-//        binarySortTree.delNode(9);
-//        binarySortTree.delNode(1);
-//        binarySortTree.delNode(7);
-
-
-        System.out.println("root=" + binarySortTree.getRoot());
-
-
-        System.out.println("删除结点后");
-        binarySortTree.infixOrder();
-    }
-
-}
-
-//创建二叉排序树
-class BinarySortTree {
-    private Node root;
-
-
-
-
-    public Node getRoot() {
-        return root;
-    }
-
-    //查找要删除的结点
-    public Node search(int value) {
-        if(root == null) {
-            return null;
-        } else {
-            return root.search(value);
-        }
-    }
-
-    //查找父结点
-    public Node searchParent(int value) {
-        if(root == null) {
-            return null;
-        } else {
-            return root.searchParent(value);
-        }
-    }
-
-    //编写方法:
-    //1. 返回的 以node 为根结点的二叉排序树的最小结点的值
-    //2. 删除node 为根结点的二叉排序树的最小结点
-    /**
-     *
-     * @param node 传入的结点(当做二叉排序树的根结点)
-     * @return 返回的 以node 为根结点的二叉排序树的最小结点的值
-     */
-    public int delRightTreeMin(Node node) {
-        Node target = node;
-        //循环的查找左子节点，就会找到最小值
-        while(target.left != null) {
-            target = target.left;
-        }
-        //这时 target就指向了最小结点
-        //删除最小结点
-        delNode(target.value);
-        return target.value;
-    }
-
-
-    //删除结点
-    public void delNode(int value) {
-        if(root == null) {
-            return;
-        }else {
-            //1.需求先去找到要删除的结点  targetNode
-            Node targetNode = search(value);
-            //如果没有找到要删除的结点
-            if(targetNode == null) {
-                return;
-            }
-            //如果我们发现当前这颗二叉排序树只有一个结点
-            if(root.left == null && root.right == null) {
-                root = null;
-                return;
-            }
-
-            //去找到targetNode的父结点
-            Node parent = searchParent(value);
-            //如果要删除的结点是叶子结点
-            if(targetNode.left == null && targetNode.right == null) {
-                //判断targetNode 是父结点的左子结点，还是右子结点
-                if(parent.left != null && parent.left.value == value) { //是左子结点
-                    parent.left = null;
-                } else if (parent.right != null && parent.right.value == value) {//是由子结点
-                    parent.right = null;
-                }
-            } else if (targetNode.left != null && targetNode.right != null) { //删除有两颗子树的节点
-                int minVal = delRightTreeMin(targetNode.right);
-                targetNode.value = minVal;
-
-
-            } else { // 删除只有一颗子树的结点
-                //如果要删除的结点有左子结点
-                if(targetNode.left != null) {
-                    if(parent != null) {
-                        //如果 targetNode 是 parent 的左子结点
-                        if(parent.left.value == value) {
-                            parent.left = targetNode.left;
-                        } else { //  targetNode 是 parent 的右子结点
-                            parent.right = targetNode.left;
-                        }
-                    } else {
-                        root = targetNode.left;
-                    }
-                } else { //如果要删除的结点有右子结点
-                    if(parent != null) {
-                        //如果 targetNode 是 parent 的左子结点
-                        if(parent.left.value == value) {
-                            parent.left = targetNode.right;
-                        } else { //如果 targetNode 是 parent 的右子结点
-                            parent.right = targetNode.right;
-                        }
-                    } else {
-                        root = targetNode.right;
-                    }
-                }
-
-            }
-
-        }
-    }
-
-    //添加结点的方法
-    public void add(Node node) {
-        if(root == null) {
-            root = node;//如果root为空则直接让root指向node
-        } else {
-            root.add(node);
-        }
-    }
-    //中序遍历
-    public void infixOrder() {
-        if(root != null) {
-            root.infixOrder();
-        } else {
-            System.out.println("二叉排序树为空，不能遍历");
-        }
-    }
-}
-
-//创建Node结点
-class Node {
-    int value;
-    Node left;
-    Node right;
-    public Node(int value) {
-
-        this.value = value;
-    }
-
-
-    //查找要删除的结点
-    /**
-     *
-     * @param value 希望删除的结点的值
-     * @return 如果找到返回该结点，否则返回null
-     */
-    public Node search(int value) {
-        if(value == this.value) { //找到就是该结点
-            return this;
-        } else if(value < this.value) {//如果查找的值小于当前结点，向左子树递归查找
-            //如果左子结点为空
-            if(this.left  == null) {
-                return null;
-            }
-            return this.left.search(value);
-        } else { //如果查找的值不小于当前结点，向右子树递归查找
-            if(this.right == null) {
-                return null;
-            }
-            return this.right.search(value);
-        }
-
-    }
-    //查找要删除结点的父结点
-    /**
-     *
-     * @param value 要找到的结点的值
-     * @return 返回的是要删除的结点的父结点，如果没有就返回null
-     */
-    public Node searchParent(int value) {
-        //如果当前结点就是要删除的结点的父结点，就返回
-        if((this.left != null && this.left.value == value) ||
-                (this.right != null && this.right.value == value)) {
-            return this;
-        } else {
-            //如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空
-            if(value < this.value && this.left != null) {
-                return this.left.searchParent(value); //向左子树递归查找
-            } else if (value >= this.value && this.right != null) {
-                return this.right.searchParent(value); //向右子树递归查找
-            } else {
-                return null; // 没有找到父结点
-            }
-        }
-
-    }
-
-    @Override
-    public String toString() {
-        return "Node [value=" + value + "]";
-    }
-
-
-    //添加结点的方法
-    //递归的形式添加结点，注意需要满足二叉排序树的要求
-    public void add(Node node) {
-        if(node == null) {
-            return;
-        }
-
-        //判断传入的结点的值，和当前子树的根结点的值关系
-        if(node.value < this.value) {
-            //如果当前结点左子结点为null
-            if(this.left == null) {
-                this.left = node;
-            } else {
-                //递归的向左子树添加
-                this.left.add(node);
-            }
-        } else { //添加的结点的值大于 当前结点的值
-            if(this.right == null) {
-                this.right = node;
-            } else {
-                //递归的向右子树添加
-                this.right.add(node);
-            }
-
-        }
-    }
-
-    //中序遍历
-    public void infixOrder() {
-        if(this.left != null) {
-            this.left.infixOrder();
-        }
-        System.out.println(this);
-        if(this.right != null) {
-            this.right.infixOrder();
-        }
-    }
-
-}
\ No newline at end of file
Index: src/韩顺平算法与数据结构/datastructure/tree/btree/BinaryTreeDemo.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/tree/btree/BinaryTreeDemo.java b/src/韩顺平算法与数据结构/datastructure/tree/btree/BinaryTreeDemo.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/tree/btree/BinaryTreeDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,267 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.tree.btree;
-
-public class BinaryTreeDemo {
-    public static void main(String[] args) {
-
-        BinaryTree binaryTree=new BinaryTree();
-        HeroNode root = new HeroNode(1, "宋江");
-        HeroNode node2 = new HeroNode(2, "吴用");
-        HeroNode node3 = new HeroNode(3, "卢俊义");
-        HeroNode node4 = new HeroNode(4, "林冲");
-        HeroNode node5 = new HeroNode(5, "关胜");
-
-        root.setLeft(node2);
-        root.setRight(node3);
-        node3.setRight(node4);
-        node3.setLeft(node5);
-        binaryTree.setRoot(root);
-
-
-       // binaryTree.setRoot(root);
-
-//        binaryTree.preOrder();
-//        binaryTree.midOrder();
-        //binaryTree.postOrder();
-
-        System.out.println(root.postOrderSearch(2));
-    }
-}
-
-class BinaryTree{
-
-    private HeroNode root;
-
-    public void setRoot(HeroNode root) {
-        this.root = root;
-    }
-
-    //前序遍历
-    public void preOrder()
-    {
-        root.preOrder();
-    }
-
-    //中序遍历
-    public void midOrder()
-    {
-        root.midOrder();
-    }
-
-    //后序遍历
-    public void postOrder()
-    {
-        root.postOrder();
-    }
-    public HeroNode preOrderSearch(int no) {
-        if(root != null) {
-            return root.preOrderSearch(no);
-        } else {
-            return null;
-        }
-    }
-    //中序遍历
-    public HeroNode midOrderSearch(int no) {
-        if(root != null) {
-            return root.midOrderSearch(no);
-        }else {
-            return null;
-        }
-    }
-    //后序遍历
-    public HeroNode postOrderSearch(int no) {
-        if(root != null) {
-            return this.root.postOrderSearch(no);
-        }else {
-            return null;
-        }
-    }
-
-    public void delNode(int no)
-    {
-        if(root!=null)
-        {
-          if(root.getId()==no)
-          root=null;
-        }else{
-            root.delNode(no);
-        }
-    }
-
-}
-
-class HeroNode{
-
-    private int id;
-    private String name;
-    private HeroNode right;
-    private HeroNode left;
-
-    public void setRight(HeroNode right) {
-        this.right = right;
-    }
-
-    public void setLeft(HeroNode left) {
-        this.left = left;
-    }
-
-    public int getId() {
-        return id;
-    }
-
-    public void setId(int id) {
-        this.id = id;
-    }
-
-    public HeroNode(int id, String name) {
-        this.id = id;
-        this.name = name;
-    }
-
-    @Override
-    public String toString() {
-        return "HeroNode{" +
-                "id=" + id +
-                ", name='" + name + '\'' +
-                '}';
-    }
-
-    //前序遍历
-    public void preOrder(){
-        System.out.println(this);
-        if(this.left!=null)
-        {
-            this.left.preOrder();
-        }
-        if(this.right!=null)
-        {
-            this.right.preOrder();
-        }
-    }
-
-    //中序遍历
-    public void midOrder()
-    {
-        if(this.left!=null)
-        {
-            this.left.midOrder();
-        }
-        //输出父结点
-        System.out.println(this);
-
-        if(this.right!=null)
-            this.right.midOrder();
-    }
-
-    //后序遍历
-    public void postOrder()
-    {
-        if(this.left!=null)
-            this.left.postOrder();
-        if(this.right!=null)
-            this.right.postOrder();
-        System.out.println(this);
-
-    }
-
-    //前序遍历查找
-    public HeroNode preOrderSearch(int no)
-    {
-        System.out.println("进入前序遍历");
-        if(this.id==no)
-        {
-            return this;
-        }
-        //判断当前节点的左子树是否为空，如果不为空，则递归查找
-        HeroNode resNode=null;
-        if(this.left!=null)
-        {
-            resNode=this.left.preOrderSearch(no);
-        }
-        if(resNode!=null)
-        {
-            return resNode;
-        }
-
-        if(this.right!=null)
-        {
-            resNode=this.right.preOrderSearch(no);
-        }
-        return resNode;
-    }
-
-    //中序遍历查找
-    public HeroNode midOrderSearch(int no)
-    {
-      HeroNode resNode=null;
-        if(this.left!=null)
-        {
-           resNode= this.left.midOrderSearch(no);
-        }
-        if(resNode!=null)
-        {
-            return resNode;
-        }
-        if(this.id==no)
-        {
-            return this;
-        }
-        if(this.right!=null)
-        {
-            resNode=this.right.midOrderSearch(no);
-        }
-        return resNode;
-    }
-
-    //后序遍历查找
-    public HeroNode postOrderSearch(int no)
-    {
-        //定义一个结点用来接收返回值
-        HeroNode resNode=null;
-        if(this.left!=null){
-            resNode=this.left.postOrderSearch(no);
-        }
-        if(resNode!=null)
-        {
-            return resNode;
-        }
-        if(this.right!=null)
-        {
-            resNode=this.right.postOrderSearch(no);
-        }
-        if(resNode!=null)
-        {
-            return resNode;
-        }
-        if(this.id==no)
-        {
-            return this;
-        }
-            return resNode;
-    }
-
-    public void delNode(int no)
-    {
-        if(this.left!=null && this.left.id==no)
-        {
-            this.left=null;
-            return;
-        }
-        if(this.right!=null && this.right.id==no)
-        {
-            this.right=null;
-            return;
-        }
-        //递归遍历左子树
-        if(this.left!=null)
-        {
-            this.left.delNode(no);
-        }
-        if(this.right!=null)
-        {
-            this.right.delNode(no);
-        }
-    }
-
-
-
-}
\ No newline at end of file
Index: src/Gof/Factory/factorymethod/pizza/BJCheesePizza.java
===================================================================
diff --git a/src/Gof/Factory/factorymethod/pizza/BJCheesePizza.java b/src/Gof/Factory/factorymethod/pizza/BJCheesePizza.java
deleted file mode 100644
--- a/src/Gof/Factory/factorymethod/pizza/BJCheesePizza.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,9 +0,0 @@
-package Gof.Factory.factorymethod.pizza;
-
-public class BJCheesePizza extends Pizza{
-    @Override
-    public void prepare() {
-        setName("北京的奶酪pizza");
-        System.out.println(" 北京的奶酪pizza 准备原材料");
-    }
-}
Index: src/Gof/Factory/factorymethod/abstractFactoryOrder/BJFactory.java
===================================================================
diff --git a/src/Gof/Factory/factorymethod/abstractFactoryOrder/BJFactory.java b/src/Gof/Factory/factorymethod/abstractFactoryOrder/BJFactory.java
deleted file mode 100644
--- a/src/Gof/Factory/factorymethod/abstractFactoryOrder/BJFactory.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,21 +0,0 @@
-package Gof.Factory.factorymethod.abstractFactoryOrder;
-
-import Gof.Factory.factorymethod.pizza.BJCheesePizza;
-import Gof.Factory.factorymethod.pizza.BJPepperPizza;
-import Gof.Factory.factorymethod.pizza.Pizza;
-
-public class BJFactory implements AbsFactory{
-
-    @Override
-    public Pizza createPizze(String orderType) {
-        Pizza pizza=null;
-        if(orderType.equals("cheese"))
-        {
-            pizza=new BJCheesePizza();
-        }else if(orderType.equals("pepper"))
-        {
-            pizza=new BJPepperPizza();
-        }
-        return pizza;
-    }
-}
Index: src/Gof/Factory/factorymethod/order/BJOrderPizza.java
===================================================================
diff --git a/src/Gof/Factory/factorymethod/order/BJOrderPizza.java b/src/Gof/Factory/factorymethod/order/BJOrderPizza.java
deleted file mode 100644
--- a/src/Gof/Factory/factorymethod/order/BJOrderPizza.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,22 +0,0 @@
-package Gof.Factory.factorymethod.order;
-
-import Gof.Factory.factorymethod.pizza.BJCheesePizza;
-import Gof.Factory.factorymethod.pizza.BJPepperPizza;
-import Gof.Factory.factorymethod.pizza.Pizza;
-
-public class BJOrderPizza extends OrderPizza {
-    @Override
-    Pizza createPizza(String orderPizza) {
-
-        Pizza pizza=null;
-        if(orderPizza.equals("cheese"))
-       {
-           pizza=new BJCheesePizza();
-
-       }else if(orderPizza.equals("pepper"))
-        {
-            pizza=new BJPepperPizza();
-        }
-        return pizza;
-    }
-}
Index: src/Gof/Factory/factorymethod/pizza/BJPepperPizza.java
===================================================================
diff --git a/src/Gof/Factory/factorymethod/pizza/BJPepperPizza.java b/src/Gof/Factory/factorymethod/pizza/BJPepperPizza.java
deleted file mode 100644
--- a/src/Gof/Factory/factorymethod/pizza/BJPepperPizza.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,9 +0,0 @@
-package Gof.Factory.factorymethod.pizza;
-
-public class BJPepperPizza extends Pizza {
-    @Override
-    public void prepare() {
-        setName("北京的胡椒pizza");
-        System.out.println(" 北京的胡椒pizza 准备原材料");
-    }
-}
Index: src/JUC/blockingqueue/BlockingQueueDemo.java
===================================================================
diff --git a/src/JUC/blockingqueue/BlockingQueueDemo.java b/src/JUC/blockingqueue/BlockingQueueDemo.java
deleted file mode 100644
--- a/src/JUC/blockingqueue/BlockingQueueDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,92 +0,0 @@
-package JUC.blockingqueue;
-
-
-import java.util.concurrent.ArrayBlockingQueue;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-
-class MyResource{
-    private volatile boolean flag=true;
-    private AtomicInteger atomicInteger=new AtomicInteger();
-    private BlockingQueue<String> blockingQueue=null;
-
-    public MyResource(BlockingQueue<String> blockingQueue)
-    {
-        this.blockingQueue=blockingQueue;
-        System.out.println(blockingQueue.getClass().getName());
-    }
-
-    public void myProd()throws Exception
-    {
-        String data=null;
-        boolean returnValue;
-        while(flag)
-        {
-            data=atomicInteger.incrementAndGet()+"";
-            returnValue=blockingQueue.offer(data,2L, TimeUnit.SECONDS);
-            if(returnValue)
-            {
-                System.out.println(Thread.currentThread().getName()+"\t 插入队列数据"+data+"成功");
-            }else {
-                System.out.println(Thread.currentThread().getName()+"\t插入队列数据"+data+"失败");
-            }
-
-            TimeUnit.SECONDS.sleep(1);
-        }
-        System.out.println(Thread.currentThread().getName()+"\t:停止表示flag"+flag);
-    }
-
-    public void myConsumer()throws Exception{
-        String result=null;
-        while(flag)
-        {
-            result=blockingQueue.poll(2L,TimeUnit.SECONDS);
-            if(result==null || "".equalsIgnoreCase(result))
-            {
-                flag=false;
-                System.out.println(Thread.currentThread().getName()+"\t"+"超过2m没有收到消费退出");
-                System.out.println();
-                System.out.println();
-            }
-            System.out.println(Thread.currentThread().getName()+"\t消费队列"+result+"成功");
-        }
-    }
-
-    public void stop()throws Exception
-    {
-        flag=false;
-    }
-
-}
-public class BlockingQueueDemo {
-
-    public static void main(String[] args) throws Exception {
-        MyResource myResource=new MyResource(new ArrayBlockingQueue<>(10));
-        new Thread(()->{
-            System.out.println(Thread.currentThread().getName()+"\t 生产线程启动");
-            try {
-                myResource.myProd();
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
-        },"pord").start();
-
-        new Thread(()->{
-            System.out.println(Thread.currentThread().getName()+"\t消费线程启动");
-            try {
-                myResource.myConsumer();
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
-        },"Consumer").start();
-
-        TimeUnit.SECONDS.sleep(8);
-        System.out.println();
-        System.out.println();
-        System.out.println("时间到");
-
-        myResource.stop();
-    }
-
-}
Index: src/org/sd/factory/BMW.java
===================================================================
diff --git a/src/org/sd/factory/BMW.java b/src/org/sd/factory/BMW.java
deleted file mode 100644
--- a/src/org/sd/factory/BMW.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package org.sd.factory;
-
-public class BMW implements Car{
-    public void run()
-    {
-        System.out.println("宝马在跑");
-    }
-}
Index: src/org/sd/factory/BMWFactory.java
===================================================================
diff --git a/src/org/sd/factory/BMWFactory.java b/src/org/sd/factory/BMWFactory.java
deleted file mode 100644
--- a/src/org/sd/factory/BMWFactory.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package org.sd.factory;
-
-public class BMWFactory implements CarFactory {
-    @Override
-    public Car createCar() {
-        return new BMW();
-    }
-}
Index: src/Gof/bridge/Brand.java
===================================================================
diff --git a/src/Gof/bridge/Brand.java b/src/Gof/bridge/Brand.java
deleted file mode 100644
--- a/src/Gof/bridge/Brand.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,7 +0,0 @@
-package Gof.bridge;
-
-public interface Brand {
-    void open();
-    void call();
-    void close();
-}
Index: src/org/sd/bridge/Brand.java
===================================================================
diff --git a/src/org/sd/bridge/Brand.java b/src/org/sd/bridge/Brand.java
deleted file mode 100644
--- a/src/org/sd/bridge/Brand.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,21 +0,0 @@
-package org.sd.bridge;
-
-public interface Brand {
-    void sale();
-}
-class lenovo implements Brand
-{
-
-    @Override
-    public void sale() {
-        System.out.println("销售联想笔记本");
-    }
-}
-class Dell implements Brand{
-
-
-    @Override
-    public void sale() {
-        System.out.println("销售戴尔笔记本");
-    }
-}
Index: src/左神算法/基础班/Sort/BubbleSort.java
===================================================================
diff --git a/src/左神算法/基础班/Sort/BubbleSort.java b/src/左神算法/基础班/Sort/BubbleSort.java
deleted file mode 100644
--- a/src/左神算法/基础班/Sort/BubbleSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,76 +0,0 @@
-package 左神算法.基础班.Sort;
-
-import java.util.Arrays;
-
-public class BubbleSort {
-
-    public static void bubbleSort(int[] array)
-    {
-        if(array==null || array.length<2)
-            return;
-        for(int i=array.length-1;i>=0;i--)
-        {
-            for(int j=0;j<i;j++)
-            {
-                if(array[j]>array[j+1])
-                    swap(array,j,j+1);
-            }
-        }
-    }
-
-    //异或的方式实现两个变量值交换
-    public static void swap(int[]array,int i,int j)
-    {
-        array[i]=array[i]^array[j];
-        array[j]=array[i]^array[j];
-        array[i]=array[i]^array[j];
-    }
-
-    public static int[] genearateRandomArray(int maxSize,int maxValue){
-        int[]array=new int[maxSize];
-        for(int i=0;i<maxSize;i++)
-        {
-            array[i]=(int)((maxValue+1)*Math.random())-(int)(maxValue*Math.random());
-        }
-        return array;
-    }
-
-    public static void comparator(int[] arr)
-    {
-        Arrays.sort(arr);
-    }
-
-    public static int[] arrayCopy(int[] array)
-    {
-        if(array==null)
-            return null;
-        int[]res=new int[array.length];
-        for(int i=0;i<array.length;i++)
-        {
-            res[i]=array[i];
-        }
-        return res;
-    }
-
-    public static boolean isEqual(int[] arr1,int[]arr2)
-    {
-        if((arr1==null && arr2!=null)||(arr1!=null && arr2==null))
-            return false;
-        if(arr1.length!=arr2.length)
-            return false;
-        if(arr1==null && arr2==null)
-            return true;
-        for(int i=0;i<arr1.length;i++)
-        {
-            if(arr1[i]!=arr2[i])
-                return false;
-        }
-        return true;
-    }
-
-    public static void main(String[] args) {
-        int[]arr=new int[]{-2,-3};
-        swap(arr,1,0);
-        System.out.println(arr[0]+"\t"+arr[1]);
-    }
-}
Index: src/韩顺平算法与数据结构/datastructure/sort/BubbleSort.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/sort/BubbleSort.java b/src/韩顺平算法与数据结构/datastructure/sort/BubbleSort.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/sort/BubbleSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,43 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.sort;
-
-import java.awt.*;
-import java.util.Arrays;
-
-public class BubbleSort {
-
-    public static void main(String[] args) {
-        int[] arr=new int[]{3, 9, -1, 10, -2 };
-        BubbleSort bubbleSort=new BubbleSort();
-        bubbleSort.bubbleSort(arr);
-    }
-
-    public boolean flag=false;
-    public int temp;
-
-    public void bubbleSort(int[] arr)
-    {
-        for(int i=0;i<arr.length-1;i++)
-        {
-            {
-                for(int j=0;j<arr.length-1-i;j++)
-                {
-                    if(arr[j]<arr[j+1])
-                    {
-                       flag=true;
-                        temp=arr[j];
-                        arr[j]=arr[j+1];
-                        arr[j+1]=temp;
-                    }
-                }
-                if(!flag)
-                {
-                    break;
-                }else{
-                    flag=false;
-                }
-                System.out.println(Arrays.toString(arr));
-
-            }
-        }
-    }
-}
Index: src/左神算法/基础班/Sort/BucketSort.java
===================================================================
diff --git a/src/左神算法/基础班/Sort/BucketSort.java b/src/左神算法/基础班/Sort/BucketSort.java
deleted file mode 100644
--- a/src/左神算法/基础班/Sort/BucketSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,113 +0,0 @@
-package 左神算法.基础班.Sort;
-
-import java.util.Arrays;
-
-public class BucketSort {
-
-    //only for 0-200 value,桶排序的计数排序
-    public static void bucketSort(int[] arr)
-    {
-        if(arr==null || arr.length<2)
-            return;
-        int max=Integer.MIN_VALUE;
-        for(int i=0;i<arr.length;i++)
-        {
-            max=Math.max(max,arr[i]);
-        }
-        int[] bucket=new int[max+1];
-        for(int i=0;i<arr.length;i++)
-        {
-            bucket[arr[i]]++;
-        }
-        int i=0;
-        for(int j=0;j<bucket.length;j++)
-        {
-            while(bucket[j]-- >0)
-            {
-                arr[i++]=j;
-            }
-        }
-    }
-    // for test
-    public static void comparator(int[] arr) {
-        Arrays.sort(arr);
-    }
-
-    // for test
-    public static int[] generateRandomArray(int maxSize, int maxValue) {
-        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
-        for (int i = 0; i < arr.length; i++) {
-            arr[i] = (int) ((maxValue + 1) * Math.random());
-        }
-        return arr;
-    }
-
-    // for test
-    public static int[] copyArray(int[] arr) {
-        if (arr == null) {
-            return null;
-        }
-        int[] res = new int[arr.length];
-        for (int i = 0; i < arr.length; i++) {
-            res[i] = arr[i];
-        }
-        return res;
-    }
-
-    // for test
-    public static boolean isEqual(int[] arr1, int[] arr2) {
-        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
-            return false;
-        }
-        if (arr1 == null && arr2 == null) {
-            return true;
-        }
-        if (arr1.length != arr2.length) {
-            return false;
-        }
-        for (int i = 0; i < arr1.length; i++) {
-            if (arr1[i] != arr2[i]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    // for test
-    public static void printArray(int[] arr) {
-        if (arr == null) {
-            return;
-        }
-        for (int i = 0; i < arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    // for test
-    public static void main(String[] args) {
-        int testTime = 500000;
-        int maxSize = 100;
-        int maxValue = 150;
-        boolean succeed = true;
-        for (int i = 0; i < testTime; i++) {
-            int[] arr1 = generateRandomArray(maxSize, maxValue);
-            int[] arr2 = copyArray(arr1);
-            bucketSort(arr1);
-            comparator(arr2);
-            if (!isEqual(arr1, arr2)) {
-                succeed = false;
-                printArray(arr1);
-                printArray(arr2);
-                break;
-            }
-        }
-        System.out.println(succeed ? "Nice!" : "Fucking fucked!");
-
-        int[] arr = generateRandomArray(maxSize, maxValue);
-        printArray(arr);
-        bucketSort(arr);
-        printArray(arr);
-
-    }
-}
Index: src/左神算法/面试重写与剑指offer/BucketSort.java
===================================================================
diff --git a/src/左神算法/面试重写与剑指offer/BucketSort.java b/src/左神算法/面试重写与剑指offer/BucketSort.java
deleted file mode 100644
--- a/src/左神算法/面试重写与剑指offer/BucketSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,115 +0,0 @@
-package 左神算法.面试重写与剑指offer;
-
-import java.util.Arrays;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 手寫桶排序
- * @date 2020/3/21 15:12
- */
-public class BucketSort {
-
-    public static  void bucketSort(int[] arr){
-        if(arr==null || arr.length<2)
-            return;
-        int max=Integer.MIN_VALUE;
-        for(int i=0;i<arr.length;i++){
-            max=Math.max(max,arr[i]);
-        }
-        int[] bucket=new int[max+1];
-        for(int i=0;i<arr.length;i++){
-            bucket[arr[i]]++;
-        }
-        int index=0;
-        for(int i=0;i<bucket.length;i++){
-            while(bucket[i]-->0){
-                arr[index++]=i;
-            }
-        }
-    }
-
-    // for test
-    public static void comparator(int[] arr) {
-        Arrays.sort(arr);
-    }
-
-    // for test
-    public static int[] generateRandomArray(int maxSize, int maxValue) {
-        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
-        for (int i = 0; i < arr.length; i++) {
-            arr[i] = (int) ((maxValue + 1) * Math.random());
-        }
-        return arr;
-    }
-
-    // for test
-    public static int[] copyArray(int[] arr) {
-        if (arr == null) {
-            return null;
-        }
-        int[] res = new int[arr.length];
-        for (int i = 0; i < arr.length; i++) {
-            res[i] = arr[i];
-        }
-        return res;
-    }
-
-    // for test
-    public static boolean isEqual(int[] arr1, int[] arr2) {
-        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
-            return false;
-        }
-        if (arr1 == null && arr2 == null) {
-            return true;
-        }
-        if (arr1.length != arr2.length) {
-            return false;
-        }
-        for (int i = 0; i < arr1.length; i++) {
-            if (arr1[i] != arr2[i]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    // for test
-    public static void printArray(int[] arr) {
-        if (arr == null) {
-            return;
-        }
-        for (int i = 0; i < arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    // for test
-    public static void main(String[] args) {
-        int testTime = 500000;
-        int maxSize = 100;
-        int maxValue = 150;
-        boolean succeed = true;
-        for (int i = 0; i < testTime; i++) {
-            int[] arr1 = generateRandomArray(maxSize, maxValue);
-            int[] arr2 = copyArray(arr1);
-            bucketSort(arr1);
-            comparator(arr2);
-            if (!isEqual(arr1, arr2)) {
-                succeed = false;
-                printArray(arr1);
-                printArray(arr2);
-                break;
-            }
-        }
-        System.out.println(succeed ? "Nice!" : "Fucking fucked!");
-
-        int[] arr = generateRandomArray(maxSize, maxValue);
-        printArray(arr);
-        bucketSort(arr);
-        printArray(arr);
-
-    }
-}
Index: src/左神算法/进阶班一/树相关/Building_Outline.java
===================================================================
diff --git a/src/左神算法/进阶班一/树相关/Building_Outline.java b/src/左神算法/进阶班一/树相关/Building_Outline.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/树相关/Building_Outline.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,106 +0,0 @@
-package 左神算法.进阶班一.树相关;
-
-import java.util.*;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一个n*3的矩阵，每一行代表有一座大楼，一共有N座大楼，所有大楼的地步都坐落在X轴上，每一行有三个值（a,b,c）表示每座大楼从
- * （a,0)点开始，到（b,0)点结束，高度为c.输入数据可以保证a<b，且a,b,c均为正数，大楼之间可以有重叠。请输出整体的轮廓线
- * @date 2020/1/3 13:43
- */
-public class Building_Outline {
-
-    //只有高度变化时才会描述轮廓
-    public static class Node {
-        public boolean isUp;
-        public int posi;
-        public int h;
-
-        public Node(boolean bORe, int position, int height) {
-            isUp = bORe;
-            posi = position;
-            h = height;
-        }
-    }
-
-    public static class NodeComparator implements Comparator<Node> {
-        //只按位置排序
-        @Override
-        public int compare(Node o1, Node o2) {
-            if (o1.posi != o2.posi) {
-                return o1.posi - o2.posi;
-            }
-            //相同位置的时候
-            if (o1.isUp != o2.isUp) {
-                return o1.isUp ? -1 : 1;
-            }
-            return 0;
-        }
-    }
-
-    public static List<List<Integer>> buildingOutline(int[][] buildings) {
-        Node[] nodes = new Node[buildings.length * 2];
-        for (int i = 0; i < buildings.length; i++) {
-            nodes[i * 2] = new Node(true, buildings[i][0], buildings[i][2]);
-            nodes[i * 2 + 1] = new Node(false, buildings[i][1], buildings[i][2]);
-        }
-        Arrays.sort(nodes, new NodeComparator());
-        TreeMap<Integer, Integer> htMap = new TreeMap<>();// k:高度，v:高度出现的次数
-        TreeMap<Integer, Integer> pmMap = new TreeMap<>();//存放每一个位置的最大高度，k:位置，v:高度
-        for (int i = 0; i < nodes.length; i++) {
-            if (nodes[i].isUp) {
-                if (!htMap.containsKey(nodes[i].h)) {
-                    htMap.put(nodes[i].h, 1);
-                } else {
-                    htMap.put(nodes[i].h, htMap.get(nodes[i].h) + 1);
-                }
-            } else {
-                if (htMap.containsKey(nodes[i].h)) {
-                    if (htMap.get(nodes[i].h) == 1) {
-                        htMap.remove(nodes[i].h);
-                    } else {
-                        htMap.put(nodes[i].h, htMap.get(nodes[i].h) - 1);
-                    }
-                }
-            }
-            if (htMap.isEmpty()) {
-                pmMap.put(nodes[i].posi, 0);
-            } else {
-                pmMap.put(nodes[i].posi, htMap.lastKey());//lastkey（）取出的是最大的key
-            }
-        }
-        List<List<Integer>> res = new ArrayList<>();
-        int start = 0;
-        int height = 0;
-        for (Map.Entry<Integer, Integer> entry : pmMap.entrySet()) {
-            int curPosition = entry.getKey();
-            int curMaxHeight = entry.getValue();
-            if (height != curMaxHeight) {
-                if (height != 0) {
-                    List<Integer> newRecord = new ArrayList<Integer>();
-                    newRecord.add(start);
-                    newRecord.add(curPosition);
-                    newRecord.add(height);
-                    res.add(newRecord);
-                }
-                start = curPosition;
-                height = curMaxHeight;
-            }
-        }
-        return res;
-    }
-
-    public static void main(String[] args) {
-        TreeMap<Integer,Integer> tree=new TreeMap<>(
-        );
-        tree.put(8,1);
-        tree.put(2,2);
-        tree.put(4,4);
-        tree.put(10,2);
-        tree.put(5,3);
-        tree.put(-1,2);
-        System.out.println(tree.keySet());
-        System.out.println(tree.lastKey());
-    }
-}
Index: src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/Button.java
===================================================================
diff --git a/src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/Button.java b/src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/Button.java
deleted file mode 100644
--- a/src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/Button.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,12 +0,0 @@
-package 重温设计模式.创建型模式.工厂模式.工厂方法模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/18 21:07
- */
-public interface Button {
-    void render();
-    void onClick();
-}
Index: src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/Button.java
===================================================================
diff --git a/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/Button.java b/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/Button.java
deleted file mode 100644
--- a/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/Button.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,11 +0,0 @@
-package 重温设计模式.创建型模式.工厂模式.抽象工厂模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 第一个产品层次结构
- * @date 2021/5/19 16:57
- */
-public interface Button {
-    void paint();
-}
Index: src/codeTop/ByteDance1.java
===================================================================
diff --git a/src/codeTop/ByteDance1.java b/src/codeTop/ByteDance1.java
deleted file mode 100644
--- a/src/codeTop/ByteDance1.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,63 +0,0 @@
-package codeTop;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class ByteDance1 {
-
-
-    public static void main(String[] args) {
-        int[] arr = new int[] {2,3,4,3,5,8,9,11,3,1,5,0,2};
-        List<Integer> minK = getMinK(arr, 6);
-        for(int num : minK){
-            System.out.println(num);
-        }
-
-    }
-    //求一个数组最小的k个数 时间复杂度：o(n)
-    public static List<Integer> getMinK(int[] arr,int k){
-        List<Integer> list = new ArrayList<>();
-        int left = 0,right = arr.length - 1;
-        while(left < right && k > 0){
-            int mid = process(arr,left,right);
-            if(mid - left + 1 < k){
-                for(int i = left;i <= mid;i++){
-                    list.add(arr[i]);
-                }
-                left = mid + 1;
-                k -= (mid + 1);
-            }else if(mid - left + 1 > k){
-                //必须写作mid - 1,不然会出现死循环
-                right = mid - 1;
-            }else {
-                for(int i = left;i <= mid;i++){
-                    list.add(arr[i]);
-                }
-                break;
-            }
-        }
-        return  list;
-    }
-
-    public static int process(int[] arr,int left,int right){
-        int l = left - 1,r = right;
-        while(left < r){
-            if(arr[left] < arr[right]){
-                swap(arr,++l,left++);
-            }else if(arr[left] > arr[right]){
-                swap(arr,--r,left);
-            }else{
-                left++;
-            }
-        }
-        swap(arr,left,right);
-        return left;
-    }
-
-    private static void swap(int[] arr,int left,int right){
-        int tmp = arr[left];
-        arr[left] = arr[right];
-        arr[right] = tmp;
-    }
-
-}
Index: src/codeTop/ByteDance2.java
===================================================================
diff --git a/src/codeTop/ByteDance2.java b/src/codeTop/ByteDance2.java
deleted file mode 100644
--- a/src/codeTop/ByteDance2.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,39 +0,0 @@
-package codeTop;
-
-public class ByteDance2 {
-
-    /**
-     * num1 与 num2 是从小到大排好序的数组，找出num1,num2合并后的第k(k>0)大的元素 时间复杂度O(log(m +n))
-     * @param nums1
-     * @param nums2
-     * @param k
-     * @return
-     */
-    public static int getKthNum(int[] nums1,int[] nums2,int k){
-        int len1 = nums1.length;
-        int len2 = nums2.length;
-        int idx1 = 0,idx2 = 0;
-        while(true) {
-            if (idx1 == len1) {
-                return nums2[idx2 + k - 1];
-            }
-            if (idx2 == len2) {
-                return nums1[idx1 + k - 1];
-            }
-            if (k == 1) {
-                return Math.min(nums1[idx1], nums2[idx2]);
-            }
-            int half = k / 2;
-            int newIdx1 = Math.min(idx1 + half, len1) - 1;
-            int newIdx2 = Math.min(idx2 + half, len2) - 1;
-            int pivot1 = nums1[newIdx1], pivot2 = nums2[newIdx2];
-            if (pivot1 <= pivot2) {
-                k -= (newIdx1 - idx1 + 1);
-                idx1 = newIdx1 + 1;
-            } else {
-                k -= (newIdx2 - idx2 + 1);
-                idx2 = newIdx2 + 1;
-            }
-        }
-    }
-}
Index: src/韩顺平算法与数据结构/datastructure/stack/Calculator.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/stack/Calculator.java b/src/韩顺平算法与数据结构/datastructure/stack/Calculator.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/stack/Calculator.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,185 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.stack;
-
-public class Calculator {
-    public static void main(String[] args) {
-       String s="7*2*2-500+120-5+3-4";
-       Calculator calculator=new Calculator();
-        int i = calculator.resultCal(s);
-        System.out.println(i);
-    }
-
-    public int resultCal(String s){
-        ArrayStack2 numStack=new ArrayStack2(10);
-        ArrayStack2 operStack=new ArrayStack2(10);
-        //定义相关变量
-        int index=0;
-        int num1=0;
-        int num2=0;
-        int oper=0;
-        int res=0;
-        char ch= ' ';//将每次扫描得到的char保存到ch
-        String keepNum="";//用于拼接多位数
-        while (true)
-        {
-            ch=s.substring(index,index+1).charAt(0);
-            if(operStack.isOper(ch))
-            {
-                if(operStack.isEmpty())
-                {
-                    operStack.push(ch);
-                }else {
-                    if(operStack.priority(ch)<=operStack.priority(operStack.peek()))
-                    {
-                       oper = operStack.pop();
-                       num1=numStack.pop();
-                       num2=numStack.pop();
-                       res=numStack.cal(num1,num2,oper);
-                       numStack.push(res);
-                       operStack.push(ch);
-                    }else {
-                        operStack.push(ch);
-                    }
-                }
-            }else{
-                keepNum+=ch;
-                if(index==s.length()-1)
-                {
-                    numStack.push(Integer.parseInt(keepNum));
-                }else{
-                    if(operStack.isOper(s.substring(index+1,index+2).charAt(0))){
-                        numStack.push(Integer.parseInt(keepNum));
-                        keepNum="";
-                    }
-                }
-
-            }
-            index++;
-            if(index>=s.length())
-                break;
-        }
-        while(true)
-        {
-           if(operStack.isEmpty())
-               break;
-           num1=numStack.pop();
-           num2=numStack.pop();
-           oper=operStack.pop();
-           res=numStack.cal(num1,num2,oper);
-           numStack.push(res);
-        }
-        res=numStack.pop();
-        return res;
-
-
-    }
-}
-
-
-class ArrayStack2{
-    private int maxSize;
-    private int[] stack;
-    private int top=-1;
-
-    public ArrayStack2(int maxSize)
-    {
-        this.maxSize=maxSize;
-        stack=new int[maxSize];
-    }
-    //栈满
-    public boolean isFull()
-    {
-        return top==maxSize-1;
-    }
-    //栈空
-    public boolean isEmpty()
-    {
-        return top==-1;
-    }
-    //入栈
-    public void push(int value)
-    {
-        if(isFull())
-        {
-            System.out.println("栈满");
-            return;
-        }else{
-            top++;
-            stack[top]=value;
-        }
-    }
-    //出栈
-    public int pop()
-    {
-        if(isEmpty())
-        {
-            throw new  RuntimeException("栈空，没有数据");
-        }
-        int value=stack[top];
-        top--;
-        return value;
-    }
-
-    //遍历显示栈
-    public void list()
-    {
-        if(isEmpty())
-        {
-            System.out.println("栈空");
-            return;
-        }
-        //需要从栈顶显示数据
-        for(int i=top;i>=0;i--)
-        {
-            System.out.println(stack[i]);
-        }
-    }
-
-    //查看栈顶的元素,不是真的弹出栈
-    public int peek()
-    {
-        return stack[top];
-    }
-
-    //返回运算符的优先级，优先级的高低是由程序员自己来定义的。优先级使用数字表示
-    //数字越大，优先级越高
-    public int priority(int oper)
-    {
-        if(oper=='*' || oper =='/')
-            return 1;
-        else if(oper=='+' || oper =='-')
-            return 0;
-        else
-            return -1;
-    }
-
-    //判断是否是一个运算符
-    public boolean isOper(char val)
-    {
-       return val=='*' || val=='/' || val=='+'|| val=='-';
-
-    }
-
-    //计算方法
-    public int cal (int num1,int num2,int oper)
-    {
-        int res=0;
-        switch(oper){
-            case'+':
-                res=num2+num1;
-                break;
-            case '-':
-                res=num2-num1;
-                break;
-            case '*':
-                res=num2*num1;
-                break;
-            case '/':
-                res=num2/num1;
-                break;
-            default:
-                break;
-        }
-        return res;
-    }
-
-}
\ No newline at end of file
Index: src/JUC/demo3/CallableDemo.java
===================================================================
diff --git a/src/JUC/demo3/CallableDemo.java b/src/JUC/demo3/CallableDemo.java
deleted file mode 100644
--- a/src/JUC/demo3/CallableDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,27 +0,0 @@
-package JUC.demo3;
-
-import com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;
-
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.FutureTask;
-
-class MyThread implements Callable<Integer>{
-
-    @Override
-    public Integer call() throws Exception {
-        System.out.println("Callable实现多线程。。。。");
-        return 121212;
-    }
-}
-public class CallableDemo {
-    public static void main(String[] args) throws ExecutionException, InterruptedException {
-        MyThread myThread=new MyThread();
-        FutureTask<Integer> futureTask=new FutureTask<>(myThread);
-        new Thread(futureTask,"aa").start();
-        Integer integer = futureTask.get();
-        System.out.println(integer);
-    }
-
-
-}
Index: src/Gof/state/CanRaffleState.java
===================================================================
diff --git a/src/Gof/state/CanRaffleState.java b/src/Gof/state/CanRaffleState.java
deleted file mode 100644
--- a/src/Gof/state/CanRaffleState.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,39 +0,0 @@
-package Gof.state;
-
-import java.util.Random;
-
-public class CanRaffleState implements State {
-
-   RaffleActivity activity;
-
-    public CanRaffleState(RaffleActivity activity) {
-        this.activity = activity;
-    }
-
-    @Override
-    public void deductMoney() {
-        System.out.println("已经扣除积分了");
-    }
-
-    @Override
-    public boolean raffle() {
-        System.out.println("正在抽奖。。");
-        Random random=new Random();
-        int num=random.nextInt(10);
-        if(num==0)
-        {
-            activity.setState(activity.getDispenseState());
-            return true;
-        }else{
-            System.out.println("很遗憾没有抽中");
-            activity.setState(activity.getNoRaffleState());
-            return false;
-        }
-
-    }
-
-    @Override
-    public void dispensePrize() {
-        System.out.println("不发放奖品");
-    }
-}
Index: src/org/sd/factory/Car.java
===================================================================
diff --git a/src/org/sd/factory/Car.java b/src/org/sd/factory/Car.java
deleted file mode 100644
--- a/src/org/sd/factory/Car.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,5 +0,0 @@
-package org.sd.factory;
-
-public interface Car {
-    public void run();
-}
Index: src/左神算法/基础班/动态规划与递归/CardsInLine.java
===================================================================
diff --git a/src/左神算法/基础班/动态规划与递归/CardsInLine.java b/src/左神算法/基础班/动态规划与递归/CardsInLine.java
deleted file mode 100644
--- a/src/左神算法/基础班/动态规划与递归/CardsInLine.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,143 +0,0 @@
-package 左神算法.基础班.动态规划与递归;
-
-/**
- * 有一排正数，玩家A和玩家B都可以看到。
- 每位玩家在拿走数字的时候，都只能从最左和最右的数中选择一个。
- 玩家A先拿，玩家B再拿，两人交替拿走所有的数字，
- 两人都力争自己拿到的数的总和比对方多。请返回最后获胜者的分数。
-
- 例如：
- 5,2,3,4
- 玩家A先拿，当前他只能拿走5或者4。
- 如果玩家A拿走5，那么剩下2，3，4。轮到玩家B，此时玩家B可以选择2或4中的一个，…
- 如果玩家A拿走4，那么剩下5，2，3。轮到玩家B，此时玩家B可以选择5或3中的一个，…
-
- */
-public class CardsInLine {
-
-     //暴力递归的方式
-      public static int win1(int[] arr)
-      {
-          if(arr==null || arr.length==0)
-              return 0;
-          return Math.max(f(arr,0,arr.length-1),s(arr,0,arr.length-1));
-      }
-      //首先选择的人,i,j是数组的中可选的首尾位置
-      public static int f(int[] arr,int i,int j)
-      {
-          if(i==j)
-          return arr[i];
-          return Math.max(arr[i]+s(arr,i+1,j),arr[j]+s(arr,i,j-1));
-
-      }
-
-      //第二选的人
-      public static int s(int[] arr,int i,int j )
-      {
-          if(i==j)
-              return 0;
-          return Math.min(f(arr,i+1,j),f(arr,i,j-1));
-      }
-     //win1改为动态规划版本
-      public static int win2(int [] arr)
-      {
-          if(arr==null || arr.length==0)
-              return 0;
-          int[][]s=new int[arr.length][arr.length];
-          int[][]f=new int[arr.length][arr.length];
-          for(int j=0;j<arr.length;j++)
-          {
-              f[j][j]=arr[j];
-              for(int i=j-1;i>=0;i--)
-              {
-                  f[i][j]=Math.max(arr[i]+s[i+1][j],arr[j]+s[i][j-1]);
-                  s[i][j]=Math.min(f[i+1][j],f[i][j-1]);
-              }
-          }
-         return Math.max(f[0][arr.length-1],s[0][arr.length-1]);
-
-      }
-
-    public static int win3(int[] arr) {
-        if (arr == null || arr.length == 0) {
-            return 0;
-        }
-        int sum = 0;
-        for (int i = 0; i < arr.length; i++) {
-            sum += arr[i];
-        }
-        int scores = p(arr, 0, arr.length - 1);
-        return Math.max(sum - scores, scores);
-    }
-
-    public static int p(int[] arr, int i, int j) {
-        if (i == j) {
-            return arr[i];
-        }
-        if (i + 1 == j) {
-            return Math.max(arr[i], arr[j]);
-        }
-        return Math.max(arr[i] + Math.min(p(arr, i + 2, j), p(arr, i + 1, j - 1)),
-                arr[j] + Math.min(p(arr, i + 1, j - 1), p(arr, i, j - 2)));
-    }
-
-
-    public static int win4(int[] arr) {
-        if (arr == null || arr.length == 0) {
-            return 0;
-        }
-        if (arr.length == 1) {
-            return arr[0];
-        }
-        if (arr.length == 2) {
-            return Math.max(arr[0], arr[1]);
-        }
-        int sum = 0;
-        for (int i = 0; i < arr.length; i++) {
-            sum += arr[i];
-        }
-        int[][] dp = new int[arr.length][arr.length];
-        for (int i = 0; i < arr.length - 1; i++) {
-            dp[i][i] = arr[i];
-            dp[i][i + 1] = Math.max(arr[i], arr[i + 1]);//根据win3的if(i+1==j)来写出的
-        }
-        dp[arr.length - 1][arr.length - 1] = arr[arr.length - 1];
-        for (int k = 2; k < arr.length; k++) {
-            for (int j = k; j < arr.length; j++) {
-                int i = j - k;
-                dp[i][j] = Math.max(arr[i] + Math.min(dp[i + 2][j], dp[i + 1][j - 1]),
-                        arr[j] + Math.min(dp[i + 1][j - 1], dp[i][j - 2]));
-            }
-        }
-        return Math.max(dp[0][arr.length - 1], sum - dp[0][arr.length - 1]);
-    }
-
-    public static int[] generateRondomArray(){
-          int[] res= new int[(int)(Math.random()*20)+1];
-          for(int i=0;i<res.length;i++)
-          {
-              res[i]=(int)(Math.random()*20)+1;
-          }
-          return res;
-
-    }
-    public static void main(String[] args) {
-        int testTime = 50000;
-        boolean err = false;
-        for (int i = 0; i < testTime; i++) {
-            int[] arr = generateRondomArray();
-            int r1 = win1(arr);
-            int r2 = win2(arr);
-            int r3 = win3(arr);
-            int r4 = win4(arr);
-            if (r1 != r2 || r1 != r3 || r1 != r4) {
-                err = true;
-            }
-        }
-        if (err) {
-            System.out.println("2333333333");
-        } else {
-            System.out.println("6666666666");
-        }
-    }
-}
Index: src/左神算法/进阶班一/动态规划与递归/CardsInLine.java
===================================================================
diff --git a/src/左神算法/进阶班一/动态规划与递归/CardsInLine.java b/src/左神算法/进阶班一/动态规划与递归/CardsInLine.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/动态规划与递归/CardsInLine.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,143 +0,0 @@
-package 左神算法.进阶班一.动态规划与递归;
-
-/**
- * 有一排正数，玩家A和玩家B都可以看到。
- 每位玩家在拿走数字的时候，都只能从最左和最右的数中选择一个。
- 玩家A先拿，玩家B再拿，两人交替拿走所有的数字，
- 两人都力争自己拿到的数的总和比对方多。请返回最后获胜者的分数。
-
- 例如：
- 5,2,3,4
- 玩家A先拿，当前他只能拿走5或者4。
- 如果玩家A拿走5，那么剩下2，3，4。轮到玩家B，此时玩家B可以选择2或4中的一个，…
- 如果玩家A拿走4，那么剩下5，2，3。轮到玩家B，此时玩家B可以选择5或3中的一个，…
-
- */
-public class CardsInLine {
-
-     //暴力递归的方式
-      public static int win1(int[] arr)
-      {
-          if(arr==null || arr.length==0)
-              return 0;
-          return Math.max(f(arr,0,arr.length-1),s(arr,0,arr.length-1));
-      }
-      //首先选择的人,i,j是数组的中可选的首尾位置
-      public static int f(int[] arr,int i,int j)
-      {
-          if(i==j)
-          return arr[i];
-          return Math.max(arr[i]+s(arr,i+1,j),arr[j]+s(arr,i,j-1));
-
-      }
-
-      //第二选的人
-      public static int s(int[] arr,int i,int j )
-      {
-          if(i==j)
-              return 0;
-          return Math.min(f(arr,i+1,j),f(arr,i,j-1));
-      }
-     //win1改为动态规划版本
-      public static int win2(int [] arr)
-      {
-          if(arr==null || arr.length==0)
-              return 0;
-          int[][]s=new int[arr.length][arr.length];
-          int[][]f=new int[arr.length][arr.length];
-          for(int j=0;j<arr.length;j++)
-          {
-              f[j][j]=arr[j];
-              for(int i=j-1;i>=0;i--)
-              {
-                  f[i][j]=Math.max(arr[i]+s[i+1][j],arr[j]+s[i][j-1]);
-                  s[i][j]=Math.min(f[i+1][j],f[i][j-1]);
-              }
-          }
-         return Math.max(f[0][arr.length-1],s[0][arr.length-1]);
-
-      }
-
-    public static int win3(int[] arr) {
-        if (arr == null || arr.length == 0) {
-            return 0;
-        }
-        int sum = 0;
-        for (int i = 0; i < arr.length; i++) {
-            sum += arr[i];
-        }
-        int scores = p(arr, 0, arr.length - 1);
-        return Math.max(sum - scores, scores);
-    }
-
-    public static int p(int[] arr, int i, int j) {
-        if (i == j) {
-            return arr[i];
-        }
-        if (i + 1 == j) {
-            return Math.max(arr[i], arr[j]);
-        }
-        return Math.max(arr[i] + Math.min(p(arr, i + 2, j), p(arr, i + 1, j - 1)),
-                arr[j] + Math.min(p(arr, i + 1, j - 1), p(arr, i, j - 2)));
-    }
-
-
-    public static int win4(int[] arr) {
-        if (arr == null || arr.length == 0) {
-            return 0;
-        }
-        if (arr.length == 1) {
-            return arr[0];
-        }
-        if (arr.length == 2) {
-            return Math.max(arr[0], arr[1]);
-        }
-        int sum = 0;
-        for (int i = 0; i < arr.length; i++) {
-            sum += arr[i];
-        }
-        int[][] dp = new int[arr.length][arr.length];
-        for (int i = 0; i < arr.length - 1; i++) {
-            dp[i][i] = arr[i];
-            dp[i][i + 1] = Math.max(arr[i], arr[i + 1]);//根据win3的if(i+1==j)来写出的
-        }
-        dp[arr.length - 1][arr.length - 1] = arr[arr.length - 1];
-        for (int k = 2; k < arr.length; k++) {
-            for (int j = k; j < arr.length; j++) {
-                int i = j - k;
-                dp[i][j] = Math.max(arr[i] + Math.min(dp[i + 2][j], dp[i + 1][j - 1]),
-                        arr[j] + Math.min(dp[i + 1][j - 1], dp[i][j - 2]));
-            }
-        }
-        return Math.max(dp[0][arr.length - 1], sum - dp[0][arr.length - 1]);
-    }
-
-    public static int[] generateRondomArray(){
-          int[] res= new int[(int)(Math.random()*20)+1];
-          for(int i=0;i<res.length;i++)
-          {
-              res[i]=(int)(Math.random()*20)+1;
-          }
-          return res;
-
-    }
-    public static void main(String[] args) {
-        int testTime = 50000;
-        boolean err = false;
-        for (int i = 0; i < testTime; i++) {
-            int[] arr = generateRondomArray();
-            int r1 = win1(arr);
-            int r2 = win2(arr);
-            int r3 = win3(arr);
-            int r4 = win4(arr);
-            if (r1 != r2 || r1 != r3 || r1 != r4) {
-                err = true;
-            }
-        }
-        if (err) {
-            System.out.println("2333333333");
-        } else {
-            System.out.println("6666666666");
-        }
-    }
-}
Index: src/左神算法/高频面试题/五/CardsInLine.java
===================================================================
diff --git a/src/左神算法/高频面试题/五/CardsInLine.java b/src/左神算法/高频面试题/五/CardsInLine.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/五/CardsInLine.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,143 +0,0 @@
-package 左神算法.高频面试题.五;
-
-/**
- * 有一排正数，玩家A和玩家B都可以看到。
- 每位玩家在拿走数字的时候，都只能从最左和最右的数中选择一个。
- 玩家A先拿，玩家B再拿，两人交替拿走所有的数字，
- 两人都力争自己拿到的数的总和比对方多。请返回最后获胜者的分数。
-
- 例如：
- 5,2,3,4
- 玩家A先拿，当前他只能拿走5或者4。
- 如果玩家A拿走5，那么剩下2，3，4。轮到玩家B，此时玩家B可以选择2或4中的一个，…
- 如果玩家A拿走4，那么剩下5，2，3。轮到玩家B，此时玩家B可以选择5或3中的一个，…
-
- */
-public class CardsInLine {
-
-     //暴力递归的方式
-      public static int win1(int[] arr)
-      {
-          if(arr==null || arr.length==0)
-              return 0;
-          return Math.max(f(arr,0,arr.length-1),s(arr,0,arr.length-1));
-      }
-      //首先选择的人,i,j是数组的中可选的首尾位置
-      public static int f(int[] arr,int i,int j)
-      {
-          if(i==j)
-          return arr[i];
-          return Math.max(arr[i]+s(arr,i+1,j),arr[j]+s(arr,i,j-1));
-
-      }
-
-      //第二选的人
-      public static int s(int[] arr,int i,int j )
-      {
-          if(i==j)
-              return 0;
-          return Math.min(f(arr,i+1,j),f(arr,i,j-1));
-      }
-     //win1改为动态规划版本
-      public static int win2(int [] arr)
-      {
-          if(arr==null || arr.length==0)
-              return 0;
-          int[][]s=new int[arr.length][arr.length];
-          int[][]f=new int[arr.length][arr.length];
-          for(int j=0;j<arr.length;j++)
-          {
-              f[j][j]=arr[j];
-              for(int i=j-1;i>=0;i--)
-              {
-                  f[i][j]=Math.max(arr[i]+s[i+1][j],arr[j]+s[i][j-1]);
-                  s[i][j]=Math.min(f[i+1][j],f[i][j-1]);
-              }
-          }
-         return Math.max(f[0][arr.length-1],s[0][arr.length-1]);
-
-      }
-
-    public static int win3(int[] arr) {
-        if (arr == null || arr.length == 0) {
-            return 0;
-        }
-        int sum = 0;
-        for (int i = 0; i < arr.length; i++) {
-            sum += arr[i];
-        }
-        int scores = p(arr, 0, arr.length - 1);
-        return Math.max(sum - scores, scores);
-    }
-
-    public static int p(int[] arr, int i, int j) {
-        if (i == j) {
-            return arr[i];
-        }
-        if (i + 1 == j) {
-            return Math.max(arr[i], arr[j]);
-        }
-        return Math.max(arr[i] + Math.min(p(arr, i + 2, j), p(arr, i + 1, j - 1)),
-                arr[j] + Math.min(p(arr, i + 1, j - 1), p(arr, i, j - 2)));
-    }
-
-
-    public static int win4(int[] arr) {
-        if (arr == null || arr.length == 0) {
-            return 0;
-        }
-        if (arr.length == 1) {
-            return arr[0];
-        }
-        if (arr.length == 2) {
-            return Math.max(arr[0], arr[1]);
-        }
-        int sum = 0;
-        for (int i = 0; i < arr.length; i++) {
-            sum += arr[i];
-        }
-        int[][] dp = new int[arr.length][arr.length];
-        for (int i = 0; i < arr.length - 1; i++) {
-            dp[i][i] = arr[i];
-            dp[i][i + 1] = Math.max(arr[i], arr[i + 1]);//根据win3的if(i+1==j)来写出的
-        }
-        dp[arr.length - 1][arr.length - 1] = arr[arr.length - 1];
-        for (int k = 2; k < arr.length; k++) {
-            for (int j = k; j < arr.length; j++) {
-                int i = j - k;
-                dp[i][j] = Math.max(arr[i] + Math.min(dp[i + 2][j], dp[i + 1][j - 1]),
-                        arr[j] + Math.min(dp[i + 1][j - 1], dp[i][j - 2]));
-            }
-        }
-        return Math.max(dp[0][arr.length - 1], sum - dp[0][arr.length - 1]);
-    }
-
-    public static int[] generateRondomArray(){
-          int[] res= new int[(int)(Math.random()*20)+1];
-          for(int i=0;i<res.length;i++)
-          {
-              res[i]=(int)(Math.random()*20)+1;
-          }
-          return res;
-
-    }
-    public static void main(String[] args) {
-        int testTime = 50000;
-        boolean err = false;
-        for (int i = 0; i < testTime; i++) {
-            int[] arr = generateRondomArray();
-            int r1 = win1(arr);
-            int r2 = win2(arr);
-            int r3 = win3(arr);
-            int r4 = win4(arr);
-            if (r1 != r2 || r1 != r3 || r1 != r4) {
-                err = true;
-            }
-        }
-        if (err) {
-            System.out.println("2333333333");
-        } else {
-            System.out.println("6666666666");
-        }
-    }
-}
Index: src/左神算法/高频面试题/动态规划与递归/CardsInLine.java
===================================================================
diff --git a/src/左神算法/高频面试题/动态规划与递归/CardsInLine.java b/src/左神算法/高频面试题/动态规划与递归/CardsInLine.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/动态规划与递归/CardsInLine.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,143 +0,0 @@
-package 左神算法.高频面试题.动态规划与递归;
-
-/**
- * 有一排正数，玩家A和玩家B都可以看到。
- 每位玩家在拿走数字的时候，都只能从最左和最右的数中选择一个。
- 玩家A先拿，玩家B再拿，两人交替拿走所有的数字，
- 两人都力争自己拿到的数的总和比对方多。请返回最后获胜者的分数。
-
- 例如：
- 5,2,3,4
- 玩家A先拿，当前他只能拿走5或者4。
- 如果玩家A拿走5，那么剩下2，3，4。轮到玩家B，此时玩家B可以选择2或4中的一个，…
- 如果玩家A拿走4，那么剩下5，2，3。轮到玩家B，此时玩家B可以选择5或3中的一个，…
-
- */
-public class CardsInLine {
-
-     //暴力递归的方式
-      public static int win1(int[] arr)
-      {
-          if(arr==null || arr.length==0)
-              return 0;
-          return Math.max(f(arr,0,arr.length-1),s(arr,0,arr.length-1));
-      }
-      //首先选择的人,i,j是数组的中可选的首尾位置
-      public static int f(int[] arr,int i,int j)
-      {
-          if(i==j)
-          return arr[i];
-          return Math.max(arr[i]+s(arr,i+1,j),arr[j]+s(arr,i,j-1));
-
-      }
-
-      //第二选的人
-      public static int s(int[] arr,int i,int j )
-      {
-          if(i==j)
-              return 0;
-          return Math.min(f(arr,i+1,j),f(arr,i,j-1));
-      }
-     //win1改为动态规划版本
-      public static int win2(int [] arr)
-      {
-          if(arr==null || arr.length==0)
-              return 0;
-          int[][]s=new int[arr.length][arr.length];
-          int[][]f=new int[arr.length][arr.length];
-          for(int j=0;j<arr.length;j++)
-          {
-              f[j][j]=arr[j];
-              for(int i=j-1;i>=0;i--)
-              {
-                  f[i][j]=Math.max(arr[i]+s[i+1][j],arr[j]+s[i][j-1]);
-                  s[i][j]=Math.min(f[i+1][j],f[i][j-1]);
-              }
-          }
-         return Math.max(f[0][arr.length-1],s[0][arr.length-1]);
-
-      }
-
-    public static int win3(int[] arr) {
-        if (arr == null || arr.length == 0) {
-            return 0;
-        }
-        int sum = 0;
-        for (int i = 0; i < arr.length; i++) {
-            sum += arr[i];
-        }
-        int scores = p(arr, 0, arr.length - 1);
-        return Math.max(sum - scores, scores);
-    }
-
-    public static int p(int[] arr, int i, int j) {
-        if (i == j) {
-            return arr[i];
-        }
-        if (i + 1 == j) {
-            return Math.max(arr[i], arr[j]);
-        }
-        return Math.max(arr[i] + Math.min(p(arr, i + 2, j), p(arr, i + 1, j - 1)),
-                arr[j] + Math.min(p(arr, i + 1, j - 1), p(arr, i, j - 2)));
-    }
-
-
-    public static int win4(int[] arr) {
-        if (arr == null || arr.length == 0) {
-            return 0;
-        }
-        if (arr.length == 1) {
-            return arr[0];
-        }
-        if (arr.length == 2) {
-            return Math.max(arr[0], arr[1]);
-        }
-        int sum = 0;
-        for (int i = 0; i < arr.length; i++) {
-            sum += arr[i];
-        }
-        int[][] dp = new int[arr.length][arr.length];
-        for (int i = 0; i < arr.length - 1; i++) {
-            dp[i][i] = arr[i];
-            dp[i][i + 1] = Math.max(arr[i], arr[i + 1]);//根据win3的if(i+1==j)来写出的
-        }
-        dp[arr.length - 1][arr.length - 1] = arr[arr.length - 1];
-        for (int k = 2; k < arr.length; k++) {
-            for (int j = k; j < arr.length; j++) {
-                int i = j - k;
-                dp[i][j] = Math.max(arr[i] + Math.min(dp[i + 2][j], dp[i + 1][j - 1]),
-                        arr[j] + Math.min(dp[i + 1][j - 1], dp[i][j - 2]));
-            }
-        }
-        return Math.max(dp[0][arr.length - 1], sum - dp[0][arr.length - 1]);
-    }
-
-    public static int[] generateRondomArray(){
-          int[] res= new int[(int)(Math.random()*20)+1];
-          for(int i=0;i<res.length;i++)
-          {
-              res[i]=(int)(Math.random()*20)+1;
-          }
-          return res;
-
-    }
-    public static void main(String[] args) {
-        int testTime = 50000;
-        boolean err = false;
-        for (int i = 0; i < testTime; i++) {
-            int[] arr = generateRondomArray();
-            int r1 = win1(arr);
-            int r2 = win2(arr);
-            int r3 = win3(arr);
-            int r4 = win4(arr);
-            if (r1 != r2 || r1 != r3 || r1 != r4) {
-                err = true;
-            }
-        }
-        if (err) {
-            System.out.println("2333333333");
-        } else {
-            System.out.println("6666666666");
-        }
-    }
-}
Index: src/左神算法/高频面试题/CardsInLine.java
===================================================================
diff --git a/src/左神算法/高频面试题/CardsInLine.java b/src/左神算法/高频面试题/CardsInLine.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/CardsInLine.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,143 +0,0 @@
-package 左神算法.高频面试题;
-
-/**
- * 有一排正数，玩家A和玩家B都可以看到。
- 每位玩家在拿走数字的时候，都只能从最左和最右的数中选择一个。
- 玩家A先拿，玩家B再拿，两人交替拿走所有的数字，
- 两人都力争自己拿到的数的总和比对方多。请返回最后获胜者的分数。
-
- 例如：
- 5,2,3,4
- 玩家A先拿，当前他只能拿走5或者4。
- 如果玩家A拿走5，那么剩下2，3，4。轮到玩家B，此时玩家B可以选择2或4中的一个，…
- 如果玩家A拿走4，那么剩下5，2，3。轮到玩家B，此时玩家B可以选择5或3中的一个，…
-
- */
-public class CardsInLine {
-
-     //暴力递归的方式
-      public static int win1(int[] arr)
-      {
-          if(arr==null || arr.length==0)
-              return 0;
-          return Math.max(f(arr,0,arr.length-1),s(arr,0,arr.length-1));
-      }
-      //首先选择的人,i,j是数组的中可选的首尾位置
-      public static int f(int[] arr,int i,int j)
-      {
-          if(i==j)
-          return arr[i];
-          return Math.max(arr[i]+s(arr,i+1,j),arr[j]+s(arr,i,j-1));
-
-      }
-
-      //第二选的人
-      public static int s(int[] arr,int i,int j )
-      {
-          if(i==j)
-              return 0;
-          return Math.min(f(arr,i+1,j),f(arr,i,j-1));
-      }
-     //win1改为动态规划版本
-      public static int win2(int [] arr)
-      {
-          if(arr==null || arr.length==0)
-              return 0;
-          int[][]s=new int[arr.length][arr.length];
-          int[][]f=new int[arr.length][arr.length];
-          for(int j=0;j<arr.length;j++)
-          {
-              f[j][j]=arr[j];
-              for(int i=j-1;i>=0;i--)
-              {
-                  f[i][j]=Math.max(arr[i]+s[i+1][j],arr[j]+s[i][j-1]);
-                  s[i][j]=Math.min(f[i+1][j],f[i][j-1]);
-              }
-          }
-         return Math.max(f[0][arr.length-1],s[0][arr.length-1]);
-
-      }
-
-    public static int win3(int[] arr) {
-        if (arr == null || arr.length == 0) {
-            return 0;
-        }
-        int sum = 0;
-        for (int i = 0; i < arr.length; i++) {
-            sum += arr[i];
-        }
-        int scores = p(arr, 0, arr.length - 1);
-        return Math.max(sum - scores, scores);
-    }
-
-    public static int p(int[] arr, int i, int j) {
-        if (i == j) {
-            return arr[i];
-        }
-        if (i + 1 == j) {
-            return Math.max(arr[i], arr[j]);
-        }
-        return Math.max(arr[i] + Math.min(p(arr, i + 2, j), p(arr, i + 1, j - 1)),
-                arr[j] + Math.min(p(arr, i + 1, j - 1), p(arr, i, j - 2)));
-    }
-
-
-    public static int win4(int[] arr) {
-        if (arr == null || arr.length == 0) {
-            return 0;
-        }
-        if (arr.length == 1) {
-            return arr[0];
-        }
-        if (arr.length == 2) {
-            return Math.max(arr[0], arr[1]);
-        }
-        int sum = 0;
-        for (int i = 0; i < arr.length; i++) {
-            sum += arr[i];
-        }
-        int[][] dp = new int[arr.length][arr.length];
-        for (int i = 0; i < arr.length - 1; i++) {
-            dp[i][i] = arr[i];
-            dp[i][i + 1] = Math.max(arr[i], arr[i + 1]);//根据win3的if(i+1==j)来写出的
-        }
-        dp[arr.length - 1][arr.length - 1] = arr[arr.length - 1];
-        for (int k = 2; k < arr.length; k++) {
-            for (int j = k; j < arr.length; j++) {
-                int i = j - k;
-                dp[i][j] = Math.max(arr[i] + Math.min(dp[i + 2][j], dp[i + 1][j - 1]),
-                        arr[j] + Math.min(dp[i + 1][j - 1], dp[i][j - 2]));
-            }
-        }
-        return Math.max(dp[0][arr.length - 1], sum - dp[0][arr.length - 1]);
-    }
-
-    public static int[] generateRondomArray(){
-          int[] res= new int[(int)(Math.random()*20)+1];
-          for(int i=0;i<res.length;i++)
-          {
-              res[i]=(int)(Math.random()*20)+1;
-          }
-          return res;
-
-    }
-    public static void main(String[] args) {
-        int testTime = 50000;
-        boolean err = false;
-        for (int i = 0; i < testTime; i++) {
-            int[] arr = generateRondomArray();
-            int r1 = win1(arr);
-            int r2 = win2(arr);
-            int r3 = win3(arr);
-            int r4 = win4(arr);
-            if (r1 != r2 || r1 != r3 || r1 != r4) {
-                err = true;
-            }
-        }
-        if (err) {
-            System.out.println("2333333333");
-        } else {
-            System.out.println("6666666666");
-        }
-    }
-}
Index: src/Gof/momentor/CareTaker.java
===================================================================
diff --git a/src/Gof/momentor/CareTaker.java b/src/Gof/momentor/CareTaker.java
deleted file mode 100644
--- a/src/Gof/momentor/CareTaker.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,19 +0,0 @@
-package Gof.momentor;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class CareTaker {
-
-    private List<Momentor> list=new ArrayList<>();
-
-    public void add(Momentor momentor)
-    {
-        list.add(momentor);
-    }
-
-    public Momentor get(int index)
-    {
-        return list.get(index);
-    }
-}
Index: src/org/sd/factory/CarFactory.java
===================================================================
diff --git a/src/org/sd/factory/CarFactory.java b/src/org/sd/factory/CarFactory.java
deleted file mode 100644
--- a/src/org/sd/factory/CarFactory.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,5 +0,0 @@
-package org.sd.factory;
-
-public interface CarFactory {
-    Car createCar();
-}
Index: src/左神算法/基础班/第三课/CatDogQueue.java
===================================================================
diff --git a/src/左神算法/基础班/第三课/CatDogQueue.java b/src/左神算法/基础班/第三课/CatDogQueue.java
deleted file mode 100644
--- a/src/左神算法/基础班/第三课/CatDogQueue.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,136 +0,0 @@
-package 左神算法.基础班.第三课;
-
-import java.util.LinkedList;
-import java.util.Queue;
-
-public class CatDogQueue {
-
-    public static class Pet {
-        private String type;
-
-        public Pet(String type) {
-            this.type = type;
-        }
-
-        public String getPetType() {
-            return this.type;
-        }
-    }
-
-    public static class Dog extends Pet {
-        public Dog() {
-            super("dog");
-        }
-    }
-
-    public static class Cat extends Pet {
-        public Cat() {
-            super("cat");
-        }
-    }
-
-    public static class PetEnterQueue {
-        private Pet pet;
-        private long index;
-
-
-        public PetEnterQueue(Pet pet, long index) {
-            this.pet = pet;
-            this.index = index;
-        }
-
-
-        public Pet getPet() {
-            return pet;
-        }
-
-        public void setPet(Pet pet) {
-            this.pet = pet;
-        }
-
-        public long getIndex() {
-            return index;
-        }
-
-        public void setIndex(long index) {
-            this.index = index;
-        }
-
-        public String getEnterPetType() {
-            return this.pet.getPetType();
-        }
-    }
-
-        public class DogCat {
-            private Queue<PetEnterQueue> dogQ;
-            private Queue<PetEnterQueue> catQ;
-            private long count;
-
-            public DogCat() {
-                this.dogQ = new LinkedList<PetEnterQueue>();
-                this.catQ = new LinkedList<PetEnterQueue>();
-                this.count = 0;
-            }
-
-            public void add(Pet pet) {
-                if (pet.getPetType().equals("dog"))
-                    this.dogQ.add(new PetEnterQueue(pet, this.count++));
-                else if (pet.getPetType().equals("cat"))
-                    this.catQ.add(new PetEnterQueue(pet, count++));
-                else
-                    throw new RuntimeException("err,not dog or cat");
-
-            }
-            public Pet pollAll()
-            {
-                if(! this.catQ.isEmpty() && !this.dogQ.isEmpty())
-                {
-                    if(this.dogQ.peek().getIndex()<this.catQ.peek().getIndex())
-                    {
-                        return this.dogQ.poll().getPet();
-                    }else{
-                        return this.catQ.poll().getPet();
-                    }
-                }else if(!this.catQ.isEmpty())
-                {
-                    return this.catQ.poll().getPet();
-                }else if(!this.dogQ.isEmpty()){
-                    return this.catQ.poll().getPet();
-                }else {
-                    throw new RuntimeException("err,queue is empty");
-                }
-            }
-            public Dog pollDog() {
-                if (!this.isDogQueueEmpty()) {
-                    return (Dog) this.dogQ.poll().getPet();
-                } else {
-                    throw new RuntimeException("Dog queue is empty!");
-                }
-            }
-
-            public Cat pollCat() {
-                if (!this.isCatQueueEmpty()) {
-                    return (Cat) this.catQ.poll().getPet();
-                } else
-                    throw new RuntimeException("Cat queue is empty!");
-            }
-
-            public boolean isEmpty() {
-                return this.dogQ.isEmpty() && this.catQ.isEmpty();
-            }
-
-            public boolean isDogQueueEmpty() {
-                return this.dogQ.isEmpty();
-            }
-
-            public boolean isCatQueueEmpty() {
-                return this.catQ.isEmpty();
-            }
-
-
-
-        }
-
-
-    }
-
Index: src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/CheckBox.java
===================================================================
diff --git a/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/CheckBox.java b/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/CheckBox.java
deleted file mode 100644
--- a/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/CheckBox.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,11 +0,0 @@
-package 重温设计模式.创建型模式.工厂模式.抽象工厂模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:第二个产品层次结构
- * @date 2021/5/19 16:57
- */
-public interface CheckBox {
-    void paint();
-}
Index: src/Gof/Factory/simpleFactory/CheesePizza.java
===================================================================
diff --git a/src/Gof/Factory/simpleFactory/CheesePizza.java b/src/Gof/Factory/simpleFactory/CheesePizza.java
deleted file mode 100644
--- a/src/Gof/Factory/simpleFactory/CheesePizza.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package Gof.Factory.simpleFactory;
-
-public class CheesePizza extends Pizza {
-    @Override
-    public void prepare() {
-        System.out.println("给中国披散准备原材料！！");
-    }
-}
\ No newline at end of file
Index: src/韩顺平算法与数据结构/datastructure/queue/CircleArrayQueueDemo.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/queue/CircleArrayQueueDemo.java b/src/韩顺平算法与数据结构/datastructure/queue/CircleArrayQueueDemo.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/queue/CircleArrayQueueDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,133 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.queue;
-
-import java.util.Scanner;
-
-public class CircleArrayQueueDemo {
-    public static void main(String[] args) {
-        System.out.println("测试数组模拟环形队列的案例：");
-        CircleArray circleArray=new CircleArray(4);
-        char key=' ';//接受用户的输入
-        Scanner scanner=new Scanner(System.in);
-        boolean loop=true;
-        while(loop)
-        {
-            System.out.println("s(show):显示队列");
-            System.out.println("e(exit): 退出程序");
-            System.out.println("a(add): 添加数据到队列");
-            System.out.println("g(get): 从队列取出数据");
-            System.out.println("h(head): 查看队列头的数据");
-            key=scanner.next().charAt(0);//接受一个字符
-            switch (key){
-                case 's':
-                    circleArray.showQueue();
-                    break;
-                case 'a':
-                    System.out.println("输入一个数");
-                    int value=scanner.nextInt();
-                    circleArray.addQueue(value);
-                    break;
-                case 'g':
-                    try {
-                        int res = circleArray.getQueue();
-                        System.out.printf("取出的数据是%d\n", res);
-                    } catch (Exception e) {
-                        // TODO: handle exception
-                        System.out.println(e.getMessage());
-                    }
-                    break;
-                case 'h':
-                    try {
-                        int res = circleArray.headQueue();
-                        System.out.printf("队列头的数据是%d\n", res);
-                    } catch (Exception e) {
-                        // TODO: handle exception
-                        System.out.println(e.getMessage());
-                    }
-                    break;
-                case 'e': // 退出
-                    scanner.close();
-                    loop = false;
-                    break;
-                default:
-                    break;
-                }
-            }
-        System.out.println("程序退出");
-        }
-    }
-
-class CircleArray{
-    private int maxsize;
-    private int front;
-    private int rear;
-    private int[] arr;
-    public CircleArray(int maxsize)
-    {
-        this.maxsize=maxsize;
-        arr=new int[maxsize];
-    }
-    //判断是否已经满了
-    public boolean isFull()
-    {
-        return (rear+1)%maxsize==front;
-    }
-    //判断是否为空
-    public boolean isEmpty()
-    {
-        return rear==front;
-    }
-
-    //添加数据
-    public void addQueue(int n)
-    {
-        if(isFull())
-        {
-            System.out.println("队列满");
-            return;
-        }
-        //直接将数据插入
-        arr[rear]=n;
-        //将rear后移
-        rear=(rear+1)% maxsize;
-    }
-    //获取数据出队列
-    public int getQueue()
-    {
-        if(isEmpty())
-        {
-            throw new RuntimeException("队列空，不能取数据");
-        }
-        int value=arr[front];
-        front=(front+1)%maxsize;
-        return value;
-    }
-
-    //展示所有数据
-    public void showQueue()
-    {
-        if(isEmpty())
-        {
-            System.out.println("队列空");
-            return;
-        }
-        for(int i=front;i<front+size();i++)
-        {
-            System.out.printf("arr[%d]=%d\n",i%maxsize,arr[i % maxsize]);
-        }
-    }
-
-    public int size()
-    {
-        return (rear+maxsize-front)%maxsize;
-    }
-
-    //显示队列的头数句
-    public int headQueue()
-    {
-        if(isEmpty())
-        {
-            throw new RuntimeException("队列空");
-        }
-        return arr[front];
-    }
-}
Index: src/Gof/Adapter/Client.java
===================================================================
diff --git a/src/Gof/Adapter/Client.java b/src/Gof/Adapter/Client.java
deleted file mode 100644
--- a/src/Gof/Adapter/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package Gof.Adapter;
-
-public class Client {
-    public static void main(String[] args) {
-        Phone phone=new Phone();
-        phone.charging(new VoltageAdapter(new Voltage220()));
-    }
-}
Index: src/Gof/bridge/Client.java
===================================================================
diff --git a/src/Gof/bridge/Client.java b/src/Gof/bridge/Client.java
deleted file mode 100644
--- a/src/Gof/bridge/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,13 +0,0 @@
-package Gof.bridge;
-
-public class Client {
-    public static void main(String[] args) {
-        Phone phone=new UpRightPhone(new XiaoMi());
-        phone.call();
-        phone.open();
-        phone.close();
-
-        Phone phone1=new FoldPhone(new Apple());
-        phone1.open();
-    }
-}
Index: src/Gof/command/Client.java
===================================================================
diff --git a/src/Gof/command/Client.java b/src/Gof/command/Client.java
deleted file mode 100644
--- a/src/Gof/command/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,19 +0,0 @@
-package Gof.command;
-
-public class Client {
-
-    public static void main(String[] args) {
-        LightReceiver lightReceiver=new LightReceiver();
-        LightOnCommand lightOnCommand=new LightOnCommand(lightReceiver);
-        LightOffCommadn lightOffCommadn=new LightOffCommadn(lightReceiver);
-        RemoteController remoteController=new RemoteController(1);
-        remoteController.setCommand(0,lightOnCommand,lightOffCommadn);
-
-        System.out.println("----------开灯---------");
-        remoteController.onButtonWasPush(0);
-        System.out.println("---------关灯----------");
-        remoteController.offButtonWasPush(0);
-        remoteController.undoButtonWasPush();
-
-    }
-}
Index: src/Gof/composite/Client.java
===================================================================
diff --git a/src/Gof/composite/Client.java b/src/Gof/composite/Client.java
deleted file mode 100644
--- a/src/Gof/composite/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,21 +0,0 @@
-package Gof.composite;
-
-public class Client {
-    public static void main(String[] args) {
-        OrganizationComponent university=new University("清华大学","中国顶级大学");
-        //创建 学院
-        OrganizationComponent computerCollege = new College("计算机学院", " 计算机学院 ");
-        OrganizationComponent infoEngineercollege = new College("信息工程学院", " 信息工程学院 ");
-
-        //创建各个学院下面的系(专业)
-        computerCollege.add(new Department("软件工程", " 软件工程不错 "));
-        computerCollege.add(new Department("网络工程", " 网络工程不错 "));
-        computerCollege.add(new Department("计算机科学与技术", " 计算机科学与技术是老牌的专业 "));
-        //
-        infoEngineercollege.add(new Department("通信工程", " 通信工程不好学 "));
-        infoEngineercollege.add(new Department("信息工程", " 信息工程好学 "));
-        university.add(computerCollege);
-        university.add(infoEngineercollege);
-        university.print();
-    }
-}
Index: src/Gof/decorator/Client.java
===================================================================
diff --git a/src/Gof/decorator/Client.java b/src/Gof/decorator/Client.java
deleted file mode 100644
--- a/src/Gof/decorator/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,11 +0,0 @@
-package Gof.decorator;
-
-public class Client {
-    public static void main(String[] args) {
-        Drink drink=new LongBlack();
-
-        MikeCoffee mikeCoffee=new MikeCoffee(drink);
-        System.out.println(mikeCoffee.getDes());
-        System.out.println(mikeCoffee.getPrice());
-    }
-}
Index: src/Gof/facade/Client.java
===================================================================
diff --git a/src/Gof/facade/Client.java b/src/Gof/facade/Client.java
deleted file mode 100644
--- a/src/Gof/facade/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,12 +0,0 @@
-package Gof.facade;
-
-public class Client {
-
-    public static void main(String[] args) {
-        HomeTheaterFacade homeTheaterFacade=new HomeTheaterFacade();
-        homeTheaterFacade.ready();
-        homeTheaterFacade.play();
-        homeTheaterFacade.pause();
-        homeTheaterFacade.end();
-    }
-}
Index: src/Gof/flyweight/Client.java
===================================================================
diff --git a/src/Gof/flyweight/Client.java b/src/Gof/flyweight/Client.java
deleted file mode 100644
--- a/src/Gof/flyweight/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,31 +0,0 @@
-package Gof.flyweight;
-
-public class Client {
-    public static void main(String[] args) {
-        WebSiteFactory factory = new WebSiteFactory();
-
-        // 客户要一个以新闻形式发布的网站
-        WebSite webSite1 = factory.getWebSite("新闻");
-
-
-        webSite1.use(new User("tom"));
-
-        // 客户要一个以博客形式发布的网站
-        WebSite webSite2 = factory.getWebSite("博客");
-
-        webSite2.use(new User("jack"));
-
-        // 客户要一个以博客形式发布的网站
-        WebSite webSite3 = factory.getWebSite("博客");
-
-        webSite3.use(new User("smith"));
-
-        // 客户要一个以博客形式发布的网站
-        WebSite webSite4 = factory.getWebSite("博客");
-
-        webSite4.use(new User("king"));
-
-        System.out.println("网站的分类共=" + factory.getWebSiteCount());
-
-    }
-}
Index: src/Gof/iterator/Client.java
===================================================================
diff --git a/src/Gof/iterator/Client.java b/src/Gof/iterator/Client.java
deleted file mode 100644
--- a/src/Gof/iterator/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,22 +0,0 @@
-package Gof.iterator;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class Client {
-
-    public static void main(String[] args) {
-        // TODO Auto-generated method stub
-        //创建学院
-        List<College> collegeList = new ArrayList<College>();
-
-        ComputerCollege computerCollege = new ComputerCollege();
-        InfoCollege infoCollege = new InfoCollege();
-
-        collegeList.add(computerCollege);
-        collegeList.add(infoCollege);
-
-        OutPutImpl outPutImpl = new OutPutImpl(collegeList);
-        outPutImpl.printCollege();
-    }
-}
Index: src/Gof/observer/Client.java
===================================================================
diff --git a/src/Gof/observer/Client.java b/src/Gof/observer/Client.java
deleted file mode 100644
--- a/src/Gof/observer/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,14 +0,0 @@
-package Gof.observer;
-
-public class Client {
-
-
-    public static void main(String[] args) {
-        Observer observer=new Baidu();
-
-        WetherData wetherData=new WetherData();
-        wetherData.registObserver(observer);
-
-       wetherData.setData(3f,5f,3f);
-    }
-}
Index: src/Gof/proxy/CglibProxy/Client.java
===================================================================
diff --git a/src/Gof/proxy/CglibProxy/Client.java b/src/Gof/proxy/CglibProxy/Client.java
deleted file mode 100644
--- a/src/Gof/proxy/CglibProxy/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,12 +0,0 @@
-package Gof.proxy.CglibProxy;
-
-public class Client {
-
-    public static void main(String[] args) {
-        TeacherDao teacherDao=new TeacherDao();
-        ProxyFactory proxyFactory=new ProxyFactory(teacherDao);
-        TeacherDao proxyInstnce = (TeacherDao)proxyFactory.getProxyInstnce();
-        String teach = proxyInstnce.teach();
-        System.out.println(teach);
-    }
-}
Index: src/Gof/proxy/dynamicProxy/Client.java
===================================================================
diff --git a/src/Gof/proxy/dynamicProxy/Client.java b/src/Gof/proxy/dynamicProxy/Client.java
deleted file mode 100644
--- a/src/Gof/proxy/dynamicProxy/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,11 +0,0 @@
-package Gof.proxy.dynamicProxy;
-
-public class Client {
-    public static void main(String[] args) {
-        ITeacherDao target =new TeacherDao();
-        ITeacherDao proxyInstance= (ITeacherDao) new ProxyFactory(target).getProxyInstance();
-        proxyInstance.teach("ddd");
-        proxyInstance.lesson("语文");
-    }
-
-}
Index: src/Gof/proxy/staticProxy/Client.java
===================================================================
diff --git a/src/Gof/proxy/staticProxy/Client.java b/src/Gof/proxy/staticProxy/Client.java
deleted file mode 100644
--- a/src/Gof/proxy/staticProxy/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,12 +0,0 @@
-package Gof.proxy.staticProxy;
-
-public class Client {
-
-    public static void main(String[] args) {
-        TeacherDao teacherDao=new TeacherDao();
-        TeacherDaoProxy teacherDaoProxy=new TeacherDaoProxy(teacherDao);
-        teacherDaoProxy.teach("小明");
-    }
-
-
-}
Index: src/Gof/responsibilityChain/Client.java
===================================================================
diff --git a/src/Gof/responsibilityChain/Client.java b/src/Gof/responsibilityChain/Client.java
deleted file mode 100644
--- a/src/Gof/responsibilityChain/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,21 +0,0 @@
-package Gof.responsibilityChain;
-
-public class Client {
-
-    public static void main(String[] args) {
-        PurchaseRequest purchaseRequest=new PurchaseRequest(1,31000,1);
-        //创建相关的审批人
-        DepartmentApprover departmentApprover = new DepartmentApprover("张主任");
-        CollegeApprover collegeApprover = new CollegeApprover("李院长");
-        ViceSchoolMasterApprover viceSchoolMasterApprover = new ViceSchoolMasterApprover("王副校");
-        SchoolMasterApprover schoolMasterApprover = new SchoolMasterApprover("佟校长");
-
-        departmentApprover.setApprover(collegeApprover);
-        collegeApprover.setApprover(viceSchoolMasterApprover);
-        viceSchoolMasterApprover.setApprover(schoolMasterApprover);
-        schoolMasterApprover.setApprover(departmentApprover);
-
-        departmentApprover.processRequest(purchaseRequest);
-        viceSchoolMasterApprover.processRequest(purchaseRequest);
-    }
-}
Index: src/Gof/state/Client.java
===================================================================
diff --git a/src/Gof/state/Client.java b/src/Gof/state/Client.java
deleted file mode 100644
--- a/src/Gof/state/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,14 +0,0 @@
-package Gof.state;
-
-public class Client {
-
-    public static void main(String[] args) {
-        RaffleActivity activity=new RaffleActivity(2);
-        for(int i=0;i<30;i++)
-        {
-            System.out.println("第"+(i+1)+"次抽奖---");
-            activity.debuctMoney();
-            activity.raffle();
-        }
-    }
-}
Index: src/Gof/template/Client.java
===================================================================
diff --git a/src/Gof/template/Client.java b/src/Gof/template/Client.java
deleted file mode 100644
--- a/src/Gof/template/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,12 +0,0 @@
-package Gof.template;
-
-public class Client {
-
-    public static void main(String[] args) {
-        PureSoyaMike pureSoyaMike = new PureSoyaMike();
-        pureSoyaMike.make();
-
-        RedBeanSoyaMilk redBeanSoyaMilk = new RedBeanSoyaMilk();
-        redBeanSoyaMilk.make();
-    }
-}
Index: src/Gof/visitor/Client.java
===================================================================
diff --git a/src/Gof/visitor/Client.java b/src/Gof/visitor/Client.java
deleted file mode 100644
--- a/src/Gof/visitor/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,22 +0,0 @@
-package Gof.visitor;
-
-public class Client {
-
-    public static void main(String[] args) {
-        ObjectStructure objectStructure=new ObjectStructure();
-        objectStructure.attach(new Man());
-        objectStructure.attach(new Woman());
-
-        Success success=new Success();
-        objectStructure.display(success);
-
-        System.out.println("=================");
-
-        Fail fail=new Fail();
-        objectStructure.display(fail);
-        System.out.println("==================");
-
-        Wait wait=new Wait();
-        objectStructure.display(wait);
-    }
-}
Index: src/org/sd/bridge/Client.java
===================================================================
diff --git a/src/org/sd/bridge/Client.java b/src/org/sd/bridge/Client.java
deleted file mode 100644
--- a/src/org/sd/bridge/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package org.sd.bridge;
-
-public class Client {
-    public static void main(String[] args) {
-        Desktop desktop=new Desktop(new lenovo());
-        desktop.sale();
-    }
-}
Index: src/org/sd/chainofR/Client.java
===================================================================
diff --git a/src/org/sd/chainofR/Client.java b/src/org/sd/chainofR/Client.java
deleted file mode 100644
--- a/src/org/sd/chainofR/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,19 +0,0 @@
-package org.sd.chainofR;
-
-public class Client {
-        public static void main(String[] args) {
-    Leader a = new Director("张三");
-    Leader b = new Manager("李四");
-
-    Leader c = new GeneralManager("王五");
-    //组织责任链对象的关系
-    a.setNextLeader(b);
-    b.setNextLeader(c);
-
-
-    //开始请假操作
-    LeaveRequest req1 = new LeaveRequest("TOM", 6, "回英国老家探亲！");
-    a.handleRequest(req1);
-
-}
-}
Index: src/org/sd/composite/Client.java
===================================================================
diff --git a/src/org/sd/composite/Client.java b/src/org/sd/composite/Client.java
deleted file mode 100644
--- a/src/org/sd/composite/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,19 +0,0 @@
-package org.sd.composite;
-
-public class Client {
-    public static void main(String[] args) {
-        AbstractFile f2,f3,f4,f5;
-        Folder f1=new Folder("我的收藏");
-        f2 = new ImageFile("老高的大头像.jpg");
-        f3 = new TextFile("Hello.txt");
-        f1.add(f2);
-        f1.add(f3);
-        Folder f11 = new Folder("电影");
-        f4 = new VideoFile("笑傲江湖.avi");
-        f5 = new VideoFile("神雕侠侣.avi");
-        f11.add(f4);
-        f11.add(f5);
-        f1.add(f11);
-        f1.killVirus();
-    }
-}
Index: src/org/sd/decorator/Client.java
===================================================================
diff --git a/src/org/sd/decorator/Client.java b/src/org/sd/decorator/Client.java
deleted file mode 100644
--- a/src/org/sd/decorator/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,16 +0,0 @@
-package org.sd.decorator;
-
-
-
-public class Client {
-    public static void main(String[] args) {
-        ICar car=new Car();
-        car.move();
-        FlyCar flyCar=new FlyCar(car);
-        flyCar.move();
-        SwimmingCar swimmingCar =new SwimmingCar(car);
-        swimmingCar.move();
-        SwimmingCar swimmingCar1=new SwimmingCar(flyCar);
-        swimmingCar1.move();
-    }
-}
Index: src/org/sd/FlyWeight/Client.java
===================================================================
diff --git a/src/org/sd/FlyWeight/Client.java b/src/org/sd/FlyWeight/Client.java
deleted file mode 100644
--- a/src/org/sd/FlyWeight/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,12 +0,0 @@
-package org.sd.FlyWeight;
-
-public class Client {
-    public static void main(String[] args) {
-        ConcreteChess chess1=FlyWeightFactory.getChess("block");
-        ConcreteChess chess2=FlyWeightFactory.getChess("block");
-
-        System.out.println(chess1);
-        System.out.println(chess2);
-    }
-}
-
Index: src/org/sd/mediator/Client.java
===================================================================
diff --git a/src/org/sd/mediator/Client.java b/src/org/sd/mediator/Client.java
deleted file mode 100644
--- a/src/org/sd/mediator/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,15 +0,0 @@
-package org.sd.mediator;
-
-public class Client {
-	public static void main(String[] args) {
-		Mediator m = new President();
-		
-		Market market = new Market(m);
-		Development devp = new Development(m);
-		Finacial f = new Finacial(m);
-		
-		market.selfAction();
-		market.outAction();
-		
-	}
-}
Index: src/org/sd/prototype/Client.java
===================================================================
diff --git a/src/org/sd/prototype/Client.java b/src/org/sd/prototype/Client.java
deleted file mode 100644
--- a/src/org/sd/prototype/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,24 +0,0 @@
-package org.sd.prototype;
-
-import java.util.Date;
-
-public class Client {
-    public static void main(String[] args) throws CloneNotSupportedException {
-        Date date = new Date(1234788848);
-        Sheep s1 = new Sheep("多里", date);
-        System.out.println(s1);
-        System.out.println(s1.getName());
-        System.out.println(s1.getDate());
-        //date.setTime(23432432423L);
-
-        Sheep s2 = (Sheep) s1.clone();
-        date.setTime(23432432423L);
-        System.out.println(s2);
-        System.out.println(s2.getName());
-        System.out.println(s2.getDate());
-        System.out.println(s1.getDate());
-
-
-
-    }
-}
\ No newline at end of file
Index: src/org/sd/StaticProxy/Client.java
===================================================================
diff --git a/src/org/sd/StaticProxy/Client.java b/src/org/sd/StaticProxy/Client.java
deleted file mode 100644
--- a/src/org/sd/StaticProxy/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,18 +0,0 @@
-package org.sd.StaticProxy;
-
-import org.sd.dyanmicProxy.RealStar;
-import org.sd.dyanmicProxy.Star;
-
-public class Client {
-    public static void main(String[] args) throws Throwable {
-        Star real=new RealStar();
-        Star proxy1=new ProxyStar(real);
-        proxy1.confer();
-        proxy1.signContract();
-        proxy1.bookTicket();
-        proxy1.sing();
-        proxy1.collectMoney();
-
-    }
-
-}
Index: src/xml/parse/Client.java
===================================================================
diff --git a/src/xml/parse/Client.java b/src/xml/parse/Client.java
deleted file mode 100644
--- a/src/xml/parse/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,13 +0,0 @@
-package xml.parse;
-
-import java.util.List;
-
-public class Client {
-    public static void main(String[] args) throws Exception {
-        XmlParseUtil xmlParseUtil=new XmlParseUtil();
-        List<Dog> dogs = xmlParseUtil.parseXmlToList("src/xml/parse/dogs.xml");
-        System.out.println(dogs);
-
-
-    }
-}
Index: src/重温设计模式/其他模式/Future模式/Client.java
===================================================================
diff --git a/src/重温设计模式/其他模式/Future模式/Client.java b/src/重温设计模式/其他模式/Future模式/Client.java
deleted file mode 100644
--- a/src/重温设计模式/其他模式/Future模式/Client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,30 +0,0 @@
-package 重温设计模式.其他模式.Future模式;
-
-import com.sun.mail.util.QDecoderStream;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/19 13:20
- */
-public class Client {
-
-    public Data request(String query){
-        FutureData futureData = new FutureData();
-        new Thread(){
-            @Override
-            public void run(){
-                // RealData的构建很慢，所以在单独的线程中进行
-                RealData realData = new RealData(query);
-                //setRealData()的时候会notify()等待在这个future上的对象
-                futureData.setRealData(realData);
-            }
-
-        }.start();
-        return futureData;
-
-    }
-
-
-}
Index: src/Gof/Bulider/client.java
===================================================================
diff --git a/src/Gof/Bulider/client.java b/src/Gof/Bulider/client.java
deleted file mode 100644
--- a/src/Gof/Bulider/client.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,10 +0,0 @@
-package Gof.Bulider;
-
-public class client {
-
-    public static void main(String[] args) {
-        HouseDirector houseDirector = new HouseDirector(new CommonHouse());
-        houseDirector.constructHouse();
-    }
-   
-}
Index: src/org/sd/Adapter/Client1.java
===================================================================
diff --git a/src/org/sd/Adapter/Client1.java b/src/org/sd/Adapter/Client1.java
deleted file mode 100644
--- a/src/org/sd/Adapter/Client1.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,18 +0,0 @@
-package org.sd.Adapter;
-
-public class Client1 extends Person{
-
-    public static void main(String[] args) {
-        Person p=new Client1();
-        System.out.println(p.getName());
-
-    }
-}
-class Person{
-    private String name="person";
-    int age=0;
-
-    public String getName() {
-        return name;
-    }
-}
Index: src/org/sd/singleton/Client1.java
===================================================================
diff --git a/src/org/sd/singleton/Client1.java b/src/org/sd/singleton/Client1.java
deleted file mode 100644
--- a/src/org/sd/singleton/Client1.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,13 +0,0 @@
-package org.sd.singleton;
-
-import java.sql.SQLOutput;
-
-public class Client1 {
-    public static void main(String[] args) {
-        SingletonDemo3 s1=SingletonDemo3.getInstance();
-        SingletonDemo3 s2=SingletonDemo3.getInstance();
-        System.out.println(s1);
-        System.out.println(s2);
-        System.out.println(SingletonDemo4.INSTANCE==SingletonDemo4.INSTANCE);
-    }
-}
Index: src/org/sd/dyanmicProxy/Client2.java
===================================================================
diff --git a/src/org/sd/dyanmicProxy/Client2.java b/src/org/sd/dyanmicProxy/Client2.java
deleted file mode 100644
--- a/src/org/sd/dyanmicProxy/Client2.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,12 +0,0 @@
-package org.sd.dyanmicProxy;
-
-import java.lang.reflect.Proxy;
-
-public class Client2 {
-    public static void main(String[] args) throws Throwable {
-        Star realStar=new RealStar();
-        StarHandler starHandler=new StarHandler(realStar);
-        Star proxy= (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]{Star.class},starHandler);
-        proxy.bookTicket();
-    }
-}
Index: src/org/sd/singleton/Client2.java
===================================================================
diff --git a/src/org/sd/singleton/Client2.java b/src/org/sd/singleton/Client2.java
deleted file mode 100644
--- a/src/org/sd/singleton/Client2.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,34 +0,0 @@
-package org.sd.singleton;
-
-import java.io.*;
-import java.lang.reflect.Constructor;
-
-//测试反射和反序列化破解单例模式
-public class Client2 {
-    public static void main(String[] args) throws Exception {
-        SingletonDemo1 s5=SingletonDemo1.getInstance();
-        System.out.println(s5);
-
-        //反射方式直接调用私有构造器
-        Class<?> clazz=Class.forName("org.sd.singleton.SingletonDemo1");
-        Constructor<?> constructor=clazz.getDeclaredConstructor(null);
-        constructor.setAccessible(true);
-        SingletonDemo1 s1=(SingletonDemo1)constructor.newInstance();
-        SingletonDemo1 s2=(SingletonDemo1)constructor.newInstance();
-        System.out.println(s1);
-        System.out.println(s2);
-
-        //通过反序列化的方式构造多个对象
-        FileOutputStream fos=new FileOutputStream("d:/a.txt");
-        ObjectOutputStream oos=new ObjectOutputStream(fos);
-        oos.writeObject(s5);
-        oos.close();
-        fos.close();
-        ObjectInputStream ois=new ObjectInputStream(new FileInputStream("d:/a.txt"));
-        SingletonDemo1 s6=(SingletonDemo1)ois.readObject();
-        System.out.println(s6);
-
-
-
-    }
-}
Index: src/org/sd/prototype/Client3.java
===================================================================
diff --git a/src/org/sd/prototype/Client3.java b/src/org/sd/prototype/Client3.java
deleted file mode 100644
--- a/src/org/sd/prototype/Client3.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,32 +0,0 @@
-package org.sd.prototype;
-
-import sun.security.x509.FreshestCRLExtension;
-
-import java.io.*;
-import java.util.Date;
-
-public class Client3 {
-    public static void main(String[] args) throws IOException, ClassNotFoundException {
-        Date date = new Date(12312321331L);
-        Sheep s1 = new Sheep("少利",date);
-        System.out.println(s1.getDate());
-
-        //使用序列化与反序列化实现复制
-        ByteArrayOutputStream bs=new ByteArrayOutputStream();
-        ObjectOutputStream oos=new ObjectOutputStream(bs);
-        oos.writeObject(s1);
-        byte[] bytes=bs.toByteArray();
-
-        ByteArrayInputStream bis=new ByteArrayInputStream(bytes);
-        ObjectInputStream ois=new ObjectInputStream(bis);
-        Sheep s2=(Sheep)ois.readObject();//克隆的对象
-
-        //修改原对象的属性
-        date.setTime(12314444);
-        System.out.println(s1.getDate());
-        System.out.println(s2);
-        System.out.println(s2.getDate());
-
-
-    }
-}
Index: src/org/sd/singleton/Client3.java
===================================================================
diff --git a/src/org/sd/singleton/Client3.java b/src/org/sd/singleton/Client3.java
deleted file mode 100644
--- a/src/org/sd/singleton/Client3.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,32 +0,0 @@
-package org.sd.singleton;
-
-import java.util.concurrent.CountDownLatch;
-
-public class Client3 {
-    public static void main(String[] args) throws InterruptedException {
-
-
-    long start=System.currentTimeMillis();
-    int threadNum=10;
-   final CountDownLatch countDownLatch=new CountDownLatch(threadNum);
-  for(int i=0;i<threadNum;i++){
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-
-                for(int i=0;i<1000000;i++){
-					SingletonDemo4 s=SingletonDemo4.INSTANCE;
-
-
-                }
-
-                countDownLatch.countDown();
-            }
-        }).start();
-
-    }
-   countDownLatch.await();
-   long end =System.currentTimeMillis();
-        System.out.println(end-start);
-}
-}
Index: src/重温设计模式/结构型设计模式/适配器模式/示例/ClientDemo.java
===================================================================
diff --git a/src/重温设计模式/结构型设计模式/适配器模式/示例/ClientDemo.java b/src/重温设计模式/结构型设计模式/适配器模式/示例/ClientDemo.java
deleted file mode 100644
--- a/src/重温设计模式/结构型设计模式/适配器模式/示例/ClientDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,43 +0,0 @@
-package 重温设计模式.结构型设计模式.适配器模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/4/29 19:46
- */
-public class ClientDemo {
-
-    public static void main(String[] args) {
-        RoundHole roundHole = new RoundHole(5);
-        RoundPeg roundPeg = new RoundPeg(5);
-        if(roundHole.fits(roundPeg)){
-            System.out.println("fitsssssssssssssss");
-        }
-
-        SquarePeg squareSmall = new SquarePeg(2);
-        SquarePeg squareLarge = new SquarePeg(20);
-
-        //客户端代码想要调用RoundHole的fits接口在看一下SquarePeg是否适合该hole,由于接口不适配，所以这里使用了SquarePeg的适配器
-        SquarePegAdapter smallSquarePegAdapter = new SquarePegAdapter(squareSmall);
-        SquarePegAdapter largeSquarePegAdapter = new SquarePegAdapter(squareLarge);
-
-        if(roundHole.fits(smallSquarePegAdapter)){
-            System.out.println("fitssssssssssssssssss");
-        }else {
-            System.out.println("unfitsssssssssssssssss");
-        }
-
-        if(roundHole.fits(largeSquarePegAdapter)){
-            System.out.println("fitssssssssssssssssss");
-        }else {
-            System.out.println("unfitsssssssssssssssss");
-        }
-
-
-
-    }
-
-
-
-}
Index: src/左神算法/进阶班二/第四章/Code_01_AddMinusMultiDivideByBit.java
===================================================================
diff --git a/src/左神算法/进阶班二/第四章/Code_01_AddMinusMultiDivideByBit.java b/src/左神算法/进阶班二/第四章/Code_01_AddMinusMultiDivideByBit.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第四章/Code_01_AddMinusMultiDivideByBit.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,108 +0,0 @@
-package 左神算法.进阶班二.第四章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 题目一
-只用位运算不用算术运算实现整数的加减乘除运算
-【题目】
-给定两个32位整数a和b，可正、可负、可0。不能使用算术运算
-符，分别实现a和b的加减乘除运算。
-【要求】
-如果给定的a和b执行加减乘除的某些结果本来就会导致数据的
-溢出，那么你实现的函数不必对那些结果负责
- * @date 2020/2/21 16:34
- */
-public class Code_01_AddMinusMultiDivideByBit {
-
-    //位运算实现加法
-    public static int add(int a,int b){
-        int sum=a;
-        while(b!=0){
-            sum=a^b;
-            b=(a&b)<<1;
-            a=sum;
-        }
-        return sum;
-    }
-
-    //位运算实现减法,a-b=a+(-b)
-    public static int minus(int a,int b){
-        return add(a,negNum(b));
-    }
-
-    public static int negNum(int b){
-        return add(~b,1);
-    }
-
-    //实现乘法
-    public static int multi(int a, int b) {
-        int res = 0;
-        while (b != 0) {
-            if ((b & 1) != 0) {
-                res = add(res, a);
-            }
-            a <<= 1;
-            b >>>= 1;
-        }
-        return res;
-    }
-
-    public static boolean isNeg(int n) {
-        return n < 0;
-    }
-
-    public static int div(int a, int b) {
-        int x = isNeg(a) ? negNum(a) : a;
-        int y = isNeg(b) ? negNum(b) : b;
-        int res = 0;
-        for (int i = 31; i > -1; i = minus(i, 1)) {
-            if ((x >> i) >= y) {
-                res |= (1 << i);
-                x = minus(x, y << i);
-            }
-        }
-        return isNeg(a) ^ isNeg(b) ? negNum(res) : res;
-    }
-
-    public static int divide(int a, int b) {
-        if (b == 0) {
-            throw new RuntimeException("divisor is 0");
-        }
-        if (a == Integer.MIN_VALUE && b == Integer.MIN_VALUE) {
-            return 1;
-        } else if (b == Integer.MIN_VALUE) {
-            return 0;
-        } else if (a == Integer.MIN_VALUE) {
-            int res = div(add(a, 1), b);
-            return add(res, div(minus(a, multi(res, b)), b));
-        } else {
-            return div(a, b);
-        }
-    }
-    public static void main(String[] args) {
-        int a = (int) (Math.random() * 100000) - 50000;
-        int b = (int) (Math.random() * 100000) - 50000;
-        System.out.println("a = " + a + ", b = " + b);
-        System.out.println(add(a, b));
-        System.out.println(a + b);
-        System.out.println("=========");
-        System.out.println(minus(a, b));
-        System.out.println(a - b);
-        System.out.println("=========");
-        System.out.println(multi(a, b));
-        System.out.println(a * b);
-        System.out.println("=========");
-        System.out.println(divide(a, b));
-        System.out.println(a / b);
-        System.out.println("=========");
-
-        a = Integer.MIN_VALUE;
-        b = 32;
-        System.out.println(divide(a, b));
-        System.out.println(a / b);
-
-    }
-
-}
Index: src/左神算法/进阶班二/第七章/Code_01_Scramble_String.java
===================================================================
diff --git a/src/左神算法/进阶班二/第七章/Code_01_Scramble_String.java b/src/左神算法/进阶班二/第七章/Code_01_Scramble_String.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第七章/Code_01_Scramble_String.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,119 +0,0 @@
-package 左神算法.进阶班二.第七章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 给定一个长度大于1的字符串，我们可以把这个字符串分成两个非空的部分，
-并且每个部分还能细分下去，
-并且可以用二叉树的形式来表达，比如
-字符串 s1 = "great":
-可以分解成这么一个样子（这只是其中一种分解结构）
-great
-/ \
-gr eat
-/ \ / \
-g r e at
-/ \
-a t
-我们说s1的搅乱串，指的是在任意一种分解结构中，随意交换某个节点的左
-右两个孩子所形成的字符串。
-比如我们可以选择在上面的分解结构中，交换“gr”这个节点的孩子节点，形
-成的树为：
-rgeat
-/ \
-rg eat
-/ \ / \
-r g e at
-/ \
-a t
-那么“rgeat”，是“great”的搅乱串。
-同样，我们可以继续交换“eat”节点的左右孩子，形成：
-rgtae
-/ \
-rg tae
-/ \ / \
-r g ta e
-/ \
-t a
-那么“rgtae”，是“great”的搅乱串。
-所以一个字符串的搅乱串是非常之多的，分解结构本身就有很多种，
-而且每一种分解结构都可以随意交换任意一个节点的左右孩子。
-给定两个字符串s1和s2，判断s2是不是s1的搅乱串。
- * @date 2020/2/29 16:39
- */
-public class Code_01_Scramble_String {
-
-    public static boolean isScramble1(String str1,String str2){
-        if(str1.length()!=str2.length())
-            return false;
-        if(str1.equals(str2))
-            return true;
-        return process(str1.toCharArray(),str2.toCharArray(),0,0,str1.length());
-    }
-    //str1从L1位置开始size的长度，str2从L2位置开始size的长度，二者是否是搅乱串。
-    //三个变量，改动态规划的话是三维的
-    private static boolean process(char[] chs1, char[] chs2, int s1, int s2, int len) {
-
-        if(len==1){
-            return chs1[s1]==chs2[s2];
-        }
-        for(int part=1;part<len;part++){
-            if((process(chs1,chs2,s1,s2,part) &&
-                    process(chs1,chs2,s1+part,s2+part,len-part))
-                    ||(process(chs1,chs2,s1,s2+len-part,part) && process(chs1,chs2,s1+part,s2,len-part)))
-                return true;
-        }
-        return false;
-    }
-
-    //动态规划
-    public static boolean isScramble2(String s1,String s2) {
-        if (s1.length() != s2.length()) {
-            return false;
-        }
-        if (s1.equals(s2)) {
-            return true;
-        }
-
-        int N=s1.length();
-        char[] chs1 = s1.toCharArray();
-        char[] chs2 = s2.toCharArray();
-        boolean[][][] dp=new boolean[N][N][N+1];//三维的dp
-        for(int l1=0;l1<N;l1++){
-            for(int l2=0;l2<N;l2++){
-                  dp[l1][l2][1]=chs1[l1]==chs2[l2];
-              }
-          }
-
-          for(int size=2;size<=N;size++){
-            for(int l1=0;l1<=N-size;l1++){
-                for(int l2=0;l2<=N-size;l2++){
-                    for(int p=1;p<size;p++){
-                        if((dp[l1][l2][p] && dp[l1+p][l2+p][size-p])||(
-                                dp[l1][l2+size-p][p] && dp[l1+p][l2][size-p]
-                        )){
-
-                            dp[l1][l2][size]=true;
-                            break;
-                        }
-                    }
-
-                }
-            }
-          }
-          return dp[0][0][N];
-    }
-
-    public static void main(String[] args) {
-        String test1 = "bcdebcdebcdebcdebcdebcdebcdebcdebcdebcdebcdebcdebcdebcdebcdebcdebcdebcdebcdebcdebcdebcde";
-        String test2 = "cebdcebdcebdcebdcebdcebdcebdcebdcebdcebdcebdcebdcebdcebdcebdcebdcebdcebdcebdcebdcebdcebd";
-        String str2="great";
-        String str1="rgtae";
-        System.out.println(isScramble1(str1, str2));
-        System.out.println(isScramble2(str1, str2));
-    }
-
-
-
-}
Index: src/左神算法/进阶班二/第八章/Code_01_ShuffleProblem.java
===================================================================
diff --git a/src/左神算法/进阶班二/第八章/Code_01_ShuffleProblem.java b/src/左神算法/进阶班二/第八章/Code_01_ShuffleProblem.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第八章/Code_01_ShuffleProblem.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,137 +0,0 @@
-package 左神算法.进阶班二.第八章;
-
-import java.util.Arrays;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:完美洗牌问题
-有一个长度为偶数的数组arr，左边一半叫做左半区，右边一半叫做右半区。
-记为：
-[L1,L2,...,LK,R1,R2,...,RK]
-请调整成
-[L1,R1,L2,R2,...,LK,RK]
-比如
-[1,2,3,4]调整成[1,3,2,4]
-[1,2,3,4,5,6]调整成[1,4,2,5,3,6]
-要求：时间复杂度O(N)，额外空间复杂度O(1)
- * @date 2020/3/3 9:16
- */
-public class Code_01_ShuffleProblem {
-
-
-    // https://arxiv.org/pdf/0805.1598.pdf
-    public static void shuffle(int[] arr) {
-        if (arr != null && arr.length != 0 && (arr.length & 1) == 0) {
-            shuffle(arr, 0, arr.length - 1);
-        }
-    }
-
-    public static void shuffle(int[] arr, int l, int r) {
-        while (r - l + 1 > 0) {
-            int lenAndOne = r - l + 2;
-            int bloom = 3;
-            int k = 1;
-            while (bloom <= lenAndOne / 3) {
-                bloom *= 3;
-                k++;
-            }
-            int m = (bloom - 1) / 2;
-            int mid = (l + r) / 2;
-            rotate(arr, l + m, mid, mid + m);
-            cycles(arr, l - 1, bloom, k);
-            l = l + bloom - 1;
-        }
-    }
-
-    public static void cycles(int[] arr, int base, int bloom, int k) {
-        for (int i = 0, trigger = 1; i < k; i++, trigger *= 3) {
-            int next = (2 * trigger) % bloom;
-            int cur = next;
-            int record = arr[next + base];
-            int tmp = 0;
-            arr[next + base] = arr[trigger + base];
-            while (cur != trigger) {
-                next = (2 * cur) % bloom;
-                tmp = arr[next + base];
-                arr[next + base] = record;
-                cur = next;
-                record = tmp;
-            }
-        }
-    }
-
-    public static void rotate(int[] arr, int l, int m, int r) {
-        reverse(arr, l, m);
-        reverse(arr, m + 1, r);
-        reverse(arr, l, r);
-    }
-
-    public static void reverse(int[] arr, int l, int r) {
-        while (l < r) {
-            int tmp = arr[l];
-            arr[l++] = arr[r];
-            arr[r--] = tmp;
-        }
-    }
-
-    // for test
-    public static void printArray(int[] arr) {
-        for (int i = 0; i < arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    // for test
-    public static int[] generateArray() {
-        int len = (int) (Math.random() * 10) * 2;
-        int[] arr = new int[len];
-        for (int i = 0; i < len; i++) {
-            arr[i] = (int) (Math.random() * 100);
-        }
-        return arr;
-    }
-
-    // for test
-    public static void shuffleTest(int[] arr) {
-        int[] tarr = new int[arr.length];
-        int bloom = arr.length + 1;
-        for (int i = 1; i <= arr.length; i++) {
-            tarr[((2 * i) % bloom) - 1] = arr[i - 1];
-        }
-        for (int i = 0; i < arr.length; i++) {
-            arr[i] = tarr[i];
-        }
-    }
-
-    public static boolean equalArrays(int[] arr1, int[] arr2) {
-        if (arr1 == null || arr2 == null || arr1.length != arr2.length) {
-            return false;
-        }
-        for (int i = 0; i < arr1.length; i++) {
-            if (arr1[i] != arr2[i]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    public static void main(String[] args) {
-        for (int i = 0; i < 5000000; i++) {
-            int[] arr = generateArray();
-            int[] arr1 = Arrays.copyOfRange(arr, 0, arr.length);
-            int[] arr2 = Arrays.copyOfRange(arr, 0, arr.length);
-            shuffle(arr1);
-            shuffleTest(arr2);
-            if (!equalArrays(arr1, arr2)) {
-                System.out.println("ooops!");
-                printArray(arr);
-                printArray(arr1);
-                printArray(arr2);
-                break;
-            }
-        }
-
-    }
-}
Index: src/左神算法/进阶班二/第三章/Code_01_SortedArrayToBalancedBST.java
===================================================================
diff --git a/src/左神算法/进阶班二/第三章/Code_01_SortedArrayToBalancedBST.java b/src/左神算法/进阶班二/第三章/Code_01_SortedArrayToBalancedBST.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第三章/Code_01_SortedArrayToBalancedBST.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,81 +0,0 @@
-package 左神算法.进阶班二.第三章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:通过有序数组生成平衡搜索二叉树
- * 给定一个有序数组sortArr，已知其中没有重复值，用这个有序
-数组生成一棵平衡搜索二叉树，并且该搜索二叉树中序遍历的
-结果与sortArr一致。
-
- * @date 2020/2/19 15:00
- */
-public class Code_01_SortedArrayToBalancedBST {
-
-    public static class Node{
-        private int value;
-        private Node left;
-        private Node right;
-
-        public Node(int value) {
-            this.value = value;
-        }
-    }
-
-    public static Node sortedArrayToBalancedBST(int[] arr){
-        if(arr==null || arr.length==0)
-            return null;
-        Node[] nodes=new Node[arr.length];
-        for(int i=0;i<arr.length;i++){
-            nodes[i]=new Node(arr[i]);
-        }
-        return process(nodes,0,nodes.length-1);
-    }
-
-    private static Node process(Node[] arr,int start,int end){
-
-        if(start<=end){
-            int mid=(start+end)/2;
-            Node head=arr[mid];
-            head.left=process(arr,start,mid-1);
-            head.right=process(arr,mid+1,end);
-            return head;
-        }
-        return null;
-    }
-    // for test -- print tree
-    public static void printTree(Node head) {
-        System.out.println("Binary Tree:");
-        printInOrder(head, 0, "H", 17);
-        System.out.println();
-    }
-
-    public static void printInOrder(Node head, int height, String to, int len) {
-        if (head == null) {
-            return;
-        }
-        printInOrder(head.right, height + 1, "v", len);
-        String val = to + head.value + to;
-        int lenM = val.length();
-        int lenL = (len - lenM) / 2;
-        int lenR = len - lenM - lenL;
-        val = getSpace(lenL) + val + getSpace(lenR);
-        System.out.println(getSpace(height * len) + val);
-        printInOrder(head.left, height + 1, "^", len);
-    }
-
-    public static String getSpace(int num) {
-        String space = " ";
-        StringBuffer buf = new StringBuffer("");
-        for (int i = 0; i < num; i++) {
-            buf.append(space);
-        }
-        return buf.toString();
-    }
-
-    public static void main(String[] args) {
-        int[] arr = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
-        printTree(sortedArrayToBalancedBST(arr));
-
-    }
-}
Index: src/左神算法/进阶班二/第六章/Code_01_SubArrayMaxSum.java
===================================================================
diff --git a/src/左神算法/进阶班二/第六章/Code_01_SubArrayMaxSum.java b/src/左神算法/进阶班二/第六章/Code_01_SubArrayMaxSum.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第六章/Code_01_SubArrayMaxSum.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,98 +0,0 @@
-package 左神算法.进阶班二.第六章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:子数组的最大累加和问题
-【题目】
-给定一个数组arr，返回子数组的最大累加和。
-例如，arr=[1,-2,3,5,-2,6,-1]，所有的子数组中，[3,5,-2,6]
-可以累加出最大的和12，所以返回12。
-【要求】
-如果arr长度为N，要求时间复杂度为O(N)，额外空间复杂度为
-O(1)。
-【补充题目】
-给定一个数组arr，返回两个不相容子数组的最大累加和。
- * @date 2020/2/28 15:54
- */
-public class Code_01_SubArrayMaxSum {
-
-
-    public static int getMax(int[] arr){
-        if(arr==null || arr.length==0)
-            return 0;
-        int cur=0;
-        int max=Integer.MIN_VALUE;
-        for(int i=0;i<arr.length;i++){
-            cur+=arr[i];
-            max=Math.max(cur,max);
-            if(cur<0)
-                cur=0;
-        }
-        return max;
-    }
-
-    //进阶：其实是原来题目的改进，求0~i的子数组的最大累加和以及i~N-1位置的子数组的
-    //最大累加和，然后找出对应的二者相加
-
-    public static int getMax2(int[] arr){
-        if(arr==null || arr.length==0)
-            return 0;
-
-        int[] leftMax = getLeftMax(arr);
-        int[] rightMax = getRightMax(arr);
-        int res=Integer.MIN_VALUE;
-        for(int i=0;i<arr.length-1;i++){
-            res=Math.max(res,leftMax[i]+rightMax[i+1]);
-        }
-        return res;
-
-    }
-
-    //求数组中0~i位置的最大子数组的累加和
-    private static int[] getLeftMax(int[] arr){
-        int[] res=new int[arr.length];
-        res[arr.length-1]=0;
-        for(int i=0;i<arr.length-1;i++){
-            int cur=0;
-            int max=Integer.MIN_VALUE;
-            for(int j=0;j<=i;j++){
-                cur+=arr[j];
-                max=Math.max(cur,max);
-                if(cur<0)
-                    cur=0;
-            }
-            res[i]=max;
-
-        }
-        return res;
-    }
-    //求数组中i~arr.length-1位置的最大子数组的累加和
-    private static int[] getRightMax(int[] arr){
-        int[] res=new int[arr.length];
-        res[0]=0;
-        for(int i=arr.length-1;i>0;i--){
-            int max=Integer.MIN_VALUE;
-            int cur=0;
-            for(int j=i;j<arr.length;j++){
-                cur+=arr[j];
-                max=Math.max(max,cur);
-                cur=cur<0?0:cur;
-            }
-            res[i]=max;
-
-        }
-        return res;
-    }
-    public static void main(String[] args) {
-        int[] arr1 = { -2, -3, -5, 40, -10, -10, 100, 1 };
-        System.out.println(getMax2(arr1));
-
-        int[] arr2 = { -2, -3, -5, 0, 1, 2, -1 };
-        System.out.println(getMax2(arr2));
-
-        int[] arr3 = { -2, -3, -5, -1 };
-        System.out.println(getMax2(arr3));
-
-    }
-}
Index: src/左神算法/进阶班二/第五章/Code_01_Valid_Expression.java
===================================================================
diff --git a/src/左神算法/进阶班二/第五章/Code_01_Valid_Expression.java b/src/左神算法/进阶班二/第五章/Code_01_Valid_Expression.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第五章/Code_01_Valid_Expression.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,42 +0,0 @@
-package 左神算法.进阶班二.第五章;
-
-import java.util.Stack;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 爱编程的小易发现，当自己代码中的括号较多时，如果括号未
-成对出现，或者出现的顺序错误，他的编辑器 总是能立马给出
-错误提示。好奇的小易决定自己尝试实现该功能。 对于一行代
-码(字符串)，里面可能出现大括号"{}"、中括号"[]"和小括号
-"()"，请编程判断该行代码的括号嵌 套是否正确。
-"()","({})","print ('Hello Netease')"等都是括号的正确使
-用方法，"(]","print (Hello Netease]"则是错误的范例
- * @date 2020/2/24 16:02
- */
-public class Code_01_Valid_Expression {
-
-    public static boolean isValid(String str){
-        char[] chs=str.toCharArray();
-        Stack<Character> stack=new Stack<>();
-        for(int i=0;i<chs.length;i++){
-            if(chs[i]=='(' || chs[i]=='[' || chs[i]=='{')
-                stack.push(chs[i]);
-            if(chs[i]==')' || chs[i]==']' || chs[i]=='}'){
-                char match=chs[i]=='}'?'{':(chs[i]==']' ? '[':'(');
-                if(stack.isEmpty() || !stack.pop().equals(match)){
-                    return false;
-                }
-
-            }
-
-        }
-        return stack.isEmpty();
-    }
-
-    public static void main(String[] args) {
-        String test = "{1+(2+3)+[(1+3)+(4*5)]}";
-        System.out.println(isValid(test));
-    }
-}
Index: src/左神算法/进阶班二/第七章/Code_02_IsBalancedTree.java
===================================================================
diff --git a/src/左神算法/进阶班二/第七章/Code_02_IsBalancedTree.java b/src/左神算法/进阶班二/第七章/Code_02_IsBalancedTree.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第七章/Code_02_IsBalancedTree.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,65 +0,0 @@
-package 左神算法.进阶班二.第七章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一棵二叉树的头节点head，判断该树是否是平衡二叉树
- * @date 2020/2/29 16:40
- */
-public class Code_02_IsBalancedTree {
-
-
-    public static class Node {
-        public int value;
-        public Node left;
-        public Node right;
-
-        public Node(int value){
-            this.value=value;
-        }
-    }
-
-    public static class ReturnData{
-        public int height;
-        public boolean isB;
-        public ReturnData(int height,boolean isB){
-            this.height=height;
-            this.isB=isB;
-        }
-    }
-
-    public static boolean isB(Node head){
-        return isBalance(head,1).isB;
-    }
-
-
-    public static ReturnData isBalance(Node head,int level){
-        if(head==null){
-            return new ReturnData(0,true);
-        }
-        ReturnData left = isBalance(head.left, level + 1);
-        if(!left.isB)
-            return new ReturnData(level,false);
-        ReturnData right=isBalance(head.right,level+1);
-        if(!right.isB)
-            return new ReturnData(level,false);
-        if(Math.abs(left.height-right.height)>1)
-            return new ReturnData(level,false);
-        return new ReturnData(Math.max(left.height,right.height),true);
-
-    }
-
-    public static void main(String[] args) {
-        Node head = new Node(1);
-        head.left = new Node(2);
-        head.right = new Node(3);
-        head.left.left = new Node(4);
-        head.left.right = new Node(5);
-        head.right.left = new Node(6);
-        head.right.right = new Node(7);
-
-        System.out.println(isB(head));
-
-    }
-
-}
Index: src/左神算法/进阶班二/第八章/Code_02_KTimesOneTime.java
===================================================================
diff --git a/src/左神算法/进阶班二/第八章/Code_02_KTimesOneTime.java b/src/左神算法/进阶班二/第八章/Code_02_KTimesOneTime.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第八章/Code_02_KTimesOneTime.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,99 +0,0 @@
-package 左神算法.进阶班二.第八章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 数组中有一个数出现了奇数次，剩下的数出现了偶数次，打印
-这个出现奇数次的数
-数组中有两个数出现了奇数次，剩下的数出现了偶数次，打印
-这两个出现奇数次的数
-数组中有一个数出现1次，剩下的数出现了k次，打印这个出现1
-次的数
- * @date 2020/3/3 9:17
- */
-public class Code_02_KTimesOneTime {
-
-    //第一题
-    public static int solution1(int[] arr){
-        if(arr==null || arr.length==0)
-            throw new RuntimeException("数组为空！");
-            int res=0;
-            for(int i =0;i<arr.length;i++){
-                res^=arr[i];
-            }
-            return res;
-    }
-
-    //第二题
-    public static int[] solution2(int[] arr){
-        if(arr==null || arr.length==0)
-            throw new RuntimeException("数组为空！");
-        int res=0;
-        for(int i=0;i<arr.length;i++){
-            res^=arr[i];
-        }
-
-        //找出res最右边的1
-        res=res&(~res+1);
-
-        int ans1=0;
-        int ans2=0;
-        for(int i=0;i<arr.length;i++){
-            if((arr[i] & res)==0)
-                ans1^=arr[i];
-            else{
-                ans2^=arr[i];
-            }
-        }
-        return new int[]{ans1,ans2};
-
-    }
-
-    //第三题
-    public static int onceNum(int[] arr,int k){
-       int[] e=new int[32];
-       for(int i=0;i<arr.length;i++){
-           setExclusiveOr(e,arr[i],k);
-       }
-       int res=getNumFromKSysNum(e,k);
-       return res;
-    }
-
-    private static void setExclusiveOr(int[] eo, int v, int k) {
-        int[] kSystemFromNum = getKSystemFromNum(v, k);
-        for(int i=0;i<kSystemFromNum.length;i++){
-            eo[i]=(eo[i]+kSystemFromNum[i])%k;
-        }
-
-    }
-
-    public static int[] getKSystemFromNum(int value,int k){
-        int[] res=new int[32];
-        int index=0;
-        while(value!=0){
-            res[index++]=value%k;
-            value/=k;
-        }
-        return res;
-
-    }
-
-    //将k进制的数转换成十进制的数
-    public static int getNumFromKSysNum(int[] eO, int k) {
-        int res = 0;
-        for (int i = eO.length - 1; i != -1; i--) {
-            res = res * k + eO[i];
-        }
-        return res;
-    }
-
-    public static void main(String[] args) {
-        int[] test1 = { 1, 1, 1, 2, 6, 6, 2, 2, 10, 10, 10, 12, 12, 12, 6, 9 };
-        System.out.println(onceNum(test1, 3));
-
-        int[] test2 = { -1, -1, -1, -1, -1, 2, 2, 2, 4, 2, 2 };
-        System.out.println(onceNum(test2, 5));
-
-    }
-}
Index: src/左神算法/进阶班二/第五章/Code_02_Max_Damage.java
===================================================================
diff --git a/src/左神算法/进阶班二/第五章/Code_02_Max_Damage.java b/src/左神算法/进阶班二/第五章/Code_02_Max_Damage.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第五章/Code_02_Max_Damage.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,78 +0,0 @@
-package 左神算法.进阶班二.第五章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:某游戏是一个卡牌类游戏，玩家通过战斗或抽牌可以拿到一些
-技能牌，每张技能牌都有对应的伤害值(伤 害值>=0)，当你有
-了组合技属性之后，你可以在自己手头上选择任意张技能牌，
-以组合技的方式来攻击 boss，组合技的总伤害将等于所组合的
-各张技能牌的伤害值的乘积(只有一张牌时，组合技伤害值等于
-这张牌 本身的伤害值)，但是能发动组合技必须有个前提:所有
-被选择的技能牌的伤害系数之和必须等于m(m>0) 以解开封印;
-你为了能赢得最终胜利，需要在所有技能牌中挑出若干张技能
-牌触发组合技(每张牌只能用一 次)，以形成最大威力的组合技
-攻击效果。 例如:你有伤害值分别为1,2,3,4,5的五张牌，给定
-的解开封印的阈值(m)为10，那形成最大组合攻击效果 的组合
-为30(5*3*2)，而不是24(4*3*2*1)，也不是20(5*4*1)，需要输
-出的结果即30。
- * @date 2020/2/24 16:03
- */
-public class Code_02_Max_Damage {
-
-    //递归的方式
-    public static int getMax(int[] arr,int sum){
-        return process(arr,0,sum);
-    }
-
-    //arr中都是正数，表示可以选取数组中index位置及其之后的元素
-    public static int process(int[] arr,int index,int sum){
-
-        if(sum<0)
-            return -1;
-        if(index==arr.length){
-            return sum==0 ? 1:-1;
-        }
-
-        int nonInclu=process(arr,index+1,sum);//不选取当前位置的值
-        int inclu=arr[index]*process(arr,index+1,sum-arr[index]);//选取当前位置的值
-        return Math.max(inclu,nonInclu);
-    }
-
-
-    //动态规划的方式
-    public static int maxDamage(int[] arr,int sum){
-        if(arr==null || arr.length==0)
-            return 0;
-        int[][] dp=new int[arr.length+1][sum+1];
-        dp[arr.length][0]=1;
-        for(int i=1;i<=sum;i++){
-            dp[arr.length][i]=-1;
-        }
-        for(int i=arr.length-1;i>=0;i--){
-            for(int j=0;j<=sum;j++){
-                int noInclu=dp[i+1][j];
-                int only=j-arr[i]==0 ?arr[i]:0;
-                int inclu=j-arr[i]>0 ? arr[i]*dp[i+1][j-arr[i]]:0;
-                dp[i][j]=Math.max(only,Math.max(noInclu,inclu));
-            }
-        }
-        return dp[0][sum];
-    }
-
-    public static void printMatrix(int[][] dp) {
-        for (int i = 0; i < dp.length; i++) {
-            for (int j = 0; j < dp[0].length; j++) {
-                System.out.print(dp[i][j] + " ");
-            }
-            System.out.println();
-        }
-    }
-
-    public static void main(String[] args) {
-        int[] arr = { 1, 2, 3, 4, 5 };
-        int threshold = 11;
-        System.out.println(maxDamage(arr, threshold));
-        System.out.println(getMax(arr,threshold));
-    }
-}
Index: src/左神算法/进阶班二/第四章/Code_02_ProbabilityXPowerK.java
===================================================================
diff --git a/src/左神算法/进阶班二/第四章/Code_02_ProbabilityXPowerK.java b/src/左神算法/进阶班二/第四章/Code_02_ProbabilityXPowerK.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第四章/Code_02_ProbabilityXPowerK.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,41 +0,0 @@
-package 左神算法.进阶班二.第四章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:题目二
-调整[0,x)区间上的数出现的概率
-【题目】
-假设函数Math.random()等概率随机返回一个在[0,1)范围上的
-数，那么我们知道，在[0,x)区间上的数出现的概率为x
-（0<x≤1）。给定一个大于0的整数k，并且可以使用
-Math.random()函数，请实现一个函数依然返回在[0,1)范围上
-的数，但是在[0,x)区间上的数出现的概率为xk(0<x≤1)。
- * @date 2020/2/21 16:35
- */
-public class Code_02_ProbabilityXPowerK {
-
-    public static double rankXPowerK(int k){
-        if(k<1)
-            return 0;
-        double res=-1;
-        for(int i=0;i!=k;i++){
-            res=Math.max(res,Math.random());
-        }
-        return res;
-    }
-
-    public static void main(String[] args) {
-        double range=0.5;
-        int times=500000;
-        int count=0;
-        for(int i=0;i!=times;i++){
-            if(rankXPowerK(2)<range){
-                count++;
-            }
-        }
-        double p=(double)count/(double)times;
-        System.out.println(p);
-
-    }
-}
Index: src/左神算法/进阶班二/第三章/Code_02_SerializeAndReconstructTree.java
===================================================================
diff --git a/src/左神算法/进阶班二/第三章/Code_02_SerializeAndReconstructTree.java b/src/左神算法/进阶班二/第三章/Code_02_SerializeAndReconstructTree.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第三章/Code_02_SerializeAndReconstructTree.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,212 +0,0 @@
-package 左神算法.进阶班二.第三章;
-
-import java.util.LinkedList;
-import java.util.Queue;
-
-public class Code_02_SerializeAndReconstructTree {
-
-    public static class Node {
-        public int value;
-        public Node left;
-        public Node right;
-
-        public Node(int data) {
-            this.value = data;
-        }
-    }
-
-    public static String serialByPre(Node head) {
-        if (head == null) {
-            return "#!";
-        }
-        String res = head.value + "!";
-        res += serialByPre(head.left);
-        res += serialByPre(head.right);
-        return res;
-    }
-
-    public static Node reconByPreString(String preStr) {
-        String[] values = preStr.split("!");
-        Queue<String> queue = new LinkedList<String>();
-        for (int i = 0; i != values.length; i++) {
-            queue.offer(values[i]);
-        }
-        return reconPreOrder(queue);
-    }
-
-    public static Node reconPreOrder(Queue<String> queue) {
-        String value = queue.poll();
-        if (value.equals("#")) {
-            return null;
-        }
-        Node head = new Node(Integer.valueOf(value));
-        head.left = reconPreOrder(queue);
-        head.right = reconPreOrder(queue);
-        return head;
-    }
-
-    public static String serialByLevel(Node head) {
-        if (head == null) {
-            return "#!";
-        }
-        String res = head.value + "!";
-        Queue<Node> queue = new LinkedList<Node>();
-        queue.offer(head);
-        while (!queue.isEmpty()) {
-            head = queue.poll();
-            if (head.left != null) {
-                res += head.left.value + "!";
-                queue.offer(head.left);
-            } else {
-                res += "#!";
-            }
-            if (head.right != null) {
-                res += head.right.value + "!";
-                queue.offer(head.right);
-            } else {
-                res += "#!";
-            }
-        }
-        return res;
-    }
-
-    public static Node reconByLevelString(String levelStr) {
-        String[] values = levelStr.split("!");
-        int index = 0;
-        Node head = generateNodeByString(values[index++]);
-        Queue<Node> queue = new LinkedList<Node>();
-        if (head != null) {
-            queue.offer(head);
-        }
-        Node node = null;
-        while (!queue.isEmpty()) {
-            node = queue.poll();
-            node.left = generateNodeByString(values[index++]);
-            node.right = generateNodeByString(values[index++]);
-            if (node.left != null) {
-                queue.offer(node.left);
-            }
-            if (node.right != null) {
-                queue.offer(node.right);
-            }
-        }
-        return head;
-    }
-
-    public static Node generateNodeByString(String val) {
-        if (val.equals("#")) {
-            return null;
-        }
-        return new Node(Integer.valueOf(val));
-    }
-
-    // for test -- print tree
-    public static void printTree(Node head) {
-        System.out.println("Binary Tree:");
-        printInOrder(head, 0, "H", 17);
-        System.out.println();
-    }
-
-    public static void printInOrder(Node head, int height, String to, int len) {
-        if (head == null) {
-            return;
-        }
-        printInOrder(head.right, height + 1, "v", len);
-        String val = to + head.value + to;
-        int lenM = val.length();
-        int lenL = (len - lenM) / 2;
-        int lenR = len - lenM - lenL;
-        val = getSpace(lenL) + val + getSpace(lenR);
-        System.out.println(getSpace(height * len) + val);
-        printInOrder(head.left, height + 1, "^", len);
-    }
-
-    public static String getSpace(int num) {
-        String space = " ";
-        StringBuffer buf = new StringBuffer("");
-        for (int i = 0; i < num; i++) {
-            buf.append(space);
-        }
-        return buf.toString();
-    }
-
-    public static void main(String[] args) {
-        Node head = null;
-        printTree(head);
-
-        String pre = serialByPre(head);
-        System.out.println("serialize tree by pre-order: " + pre);
-        head = reconByPreString(pre);
-        System.out.print("reconstruct tree by pre-order, ");
-        printTree(head);
-
-        String level = serialByLevel(head);
-        System.out.println("serialize tree by level: " + level);
-        head = reconByLevelString(level);
-        System.out.print("reconstruct tree by level, ");
-        printTree(head);
-
-        System.out.println("====================================");
-
-        head = new Node(1);
-        printTree(head);
-
-        pre = serialByPre(head);
-        System.out.println("serialize tree by pre-order: " + pre);
-        head = reconByPreString(pre);
-        System.out.print("reconstruct tree by pre-order, ");
-        printTree(head);
-
-        level = serialByLevel(head);
-        System.out.println("serialize tree by level: " + level);
-        head = reconByLevelString(level);
-        System.out.print("reconstruct tree by level, ");
-        printTree(head);
-
-        System.out.println("====================================");
-
-        head = new Node(1);
-        head.left = new Node(2);
-        head.right = new Node(3);
-        head.left.left = new Node(4);
-        head.right.right = new Node(5);
-        printTree(head);
-
-        pre = serialByPre(head);
-        System.out.println("serialize tree by pre-order: " + pre);
-        head = reconByPreString(pre);
-        System.out.print("reconstruct tree by pre-order, ");
-        printTree(head);
-
-        level = serialByLevel(head);
-        System.out.println("serialize tree by level: " + level);
-        head = reconByLevelString(level);
-        System.out.print("reconstruct tree by level, ");
-        printTree(head);
-
-        System.out.println("====================================");
-
-        head = new Node(100);
-        head.left = new Node(21);
-        head.left.left = new Node(37);
-        head.right = new Node(-42);
-        head.right.left = new Node(0);
-        head.right.right = new Node(666);
-        printTree(head);
-
-        pre = serialByPre(head);
-        System.out.println("serialize tree by pre-order: " + pre);
-        head = reconByPreString(pre);
-        System.out.print("reconstruct tree by pre-order, ");
-        printTree(head);
-
-        level = serialByLevel(head);
-        System.out.println("serialize tree by level: " + level);
-        head = reconByLevelString(level);
-        System.out.print("reconstruct tree by level, ");
-        printTree(head);
-
-        System.out.println("====================================");
-
-    }
-}
Index: src/左神算法/进阶班二/第六章/Code_02_SubMatrixMaxSum.java
===================================================================
diff --git a/src/左神算法/进阶班二/第六章/Code_02_SubMatrixMaxSum.java b/src/左神算法/进阶班二/第六章/Code_02_SubMatrixMaxSum.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第六章/Code_02_SubMatrixMaxSum.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,82 +0,0 @@
-package 左神算法.进阶班二.第六章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:子矩阵的最大累加和问题
-【题目】
-给定一个矩阵matrix，其中的值有正、有负、有0，返回子矩阵的最大累加和。
-例如，矩阵matrix为：
--90 48 78
-64 -40 64
--81 -7 66
-其中，最大累加和的子矩阵为：
-48 78
--40 64
--7 66
-所以返回累加和209。
-例如，matrix为：
--1 -1 -1
--1 2 2
--1 -1 -1
-其中，最大累加和的子矩阵为：
-2 2
-所以返回累加和4。
- * @date 2020/2/28 15:54
- */
-public class Code_02_SubMatrixMaxSum {
-
-    public static int maxSum1(int[][] matrix){
-        if(matrix==null || matrix.length==0 || matrix[0].length==0)
-            return 0;
-        int res=Integer.MIN_VALUE;
-        int cur=0;
-        int [] help=new int[matrix[0].length];
-        for(int m=0;m<matrix.length;m++){
-             for(int p=0;p<help.length;p++){
-                 help[p]=0;
-             }
-            for(int i=m;i<matrix.length;i++){
-                 cur=0;
-                 for(int j=0;j<matrix[i].length;j++){
-                    help[j]+=matrix[i][j];
-                    cur+=help[j];
-                    res=Math.max(res,cur);
-                    cur=cur>0?cur:0;
-                }
-            }
-        }
-
-        return res;
-
-    }
-
-    public static int maxSum2(int[][] m) {
-        if (m == null || m.length == 0 || m[0].length == 0) {
-            return 0;
-        }
-        int max = Integer.MIN_VALUE;
-        int cur = 0;
-        int[] s = null;
-        for (int i = 0; i != m.length; i++) {
-            s = new int[m[0].length];
-            for (int j = i; j != m.length; j++) {
-                cur = 0;
-                for (int k = 0; k != s.length; k++) {
-                    s[k] += m[j][k];
-                    cur += s[k];
-                    max = Math.max(max, cur);
-                    cur = cur < 0 ? 0 : cur;
-                }
-            }
-        }
-        return max;
-    }
-
-    public static void main(String[] args) {
-        int[][] matrix = { { -90, 48, 78 }, { 64, -40, 64 }, { -81, -7, 66 } };
-        System.out.println(maxSum1(matrix)==maxSum2(matrix));
-
-    }
-
-}
Index: src/左神算法/进阶班二/第七章/Code_03_BiggestSubBSTInTree.java
===================================================================
diff --git a/src/左神算法/进阶班二/第七章/Code_03_BiggestSubBSTInTree.java b/src/左神算法/进阶班二/第七章/Code_03_BiggestSubBSTInTree.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第七章/Code_03_BiggestSubBSTInTree.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,158 +0,0 @@
-package 左神算法.进阶班二.第七章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一棵二叉树的头节点head，已知所有节点的值都不一样，求最大
-的搜索二叉子树的节点数量。
- * @date 2020/2/29 16:40
- */
-public class Code_03_BiggestSubBSTInTree {
-
-    public static class Node {
-        public int  value;
-        public Node left;
-        public Node right;
-
-        public Node(int data) {
-            this.value = data;
-        }
-    }
-
-    public static Node biggestSubBST(Node head) {
-        int[] record = new int[3]; // 0->size, 1->min, 2->max
-        return posOrder(head, record);
-    }
-
-    public static class ReturnType{
-        public int size;
-        public Node head;
-        public int min;
-        public int max;
-
-        public ReturnType(int a, Node b,int c,int d) {
-            this.size =a;
-            this.head = b;
-            this.min = c;
-            this.max = d;
-        }
-    }
-
-    public static ReturnType process(Node head) {
-        if(head == null) {
-            return new ReturnType(0,null,Integer.MAX_VALUE, Integer.MIN_VALUE);
-        }
-        Node left = head.left;
-        ReturnType leftSubTressInfo = process(left);
-        Node right = head.right;
-        ReturnType rightSubTressInfo = process(right);
-
-        int includeItSelf = 0;
-        if(leftSubTressInfo.head == left
-                &&rightSubTressInfo.head == right
-                && head.value > leftSubTressInfo.max
-                && head.value < rightSubTressInfo.min
-                ) {
-            includeItSelf = leftSubTressInfo.size + 1 + rightSubTressInfo.size;
-        }
-        int p1 = leftSubTressInfo.size;
-        int p2 = rightSubTressInfo.size;
-        int maxSize = Math.max(Math.max(p1, p2), includeItSelf);
-
-        Node maxHead = p1 > p2 ? leftSubTressInfo.head : rightSubTressInfo.head;
-        if(maxSize == includeItSelf) {
-            maxHead = head;
-        }
-
-        return new ReturnType(maxSize,
-                maxHead,
-                Math.min(Math.min(leftSubTressInfo.min,rightSubTressInfo.min),head.value),
-                Math.max(Math.max(leftSubTressInfo.max,rightSubTressInfo.max),head.value));
-    }
-
-
-
-
-    public static Node posOrder(Node head, int[] record) {
-        if (head == null) {
-            record[0] = 0;
-            record[1] = Integer.MAX_VALUE;
-            record[2] = Integer.MIN_VALUE;
-            return null;
-        }
-        int value = head.value;
-        Node left = head.left;
-        Node right = head.right;
-        Node lBST = posOrder(left, record);
-        int lSize = record[0];
-        int lMin = record[1];
-        int lMax = record[2];
-        Node rBST = posOrder(right, record);
-        int rSize = record[0];
-        int rMin = record[1];
-        int rMax = record[2];
-        record[1] = Math.min(rMin, Math.min(lMin, value)); // lmin, value, rmin -> min
-        record[2] =  Math.max(lMax, Math.max(rMax, value)); // lmax, value, rmax -> max
-        if (left == lBST && right == rBST && lMax < value && value < rMin) {
-            record[0] = lSize + rSize + 1;
-            return head;
-        }
-        record[0] = Math.max(lSize, rSize);
-        return lSize > rSize ? lBST : rBST;
-    }
-
-    // for test -- print tree
-    public static void printTree(Node head) {
-        System.out.println("Binary Tree:");
-        printInOrder(head, 0, "H", 17);
-        System.out.println();
-    }
-
-    public static void printInOrder(Node head, int height, String to, int len) {
-        if (head == null) {
-            return;
-        }
-        printInOrder(head.right, height + 1, "v", len);
-        String val = to + head.value + to;
-        int lenM = val.length();
-        int lenL = (len - lenM) / 2;
-        int lenR = len - lenM - lenL;
-        val = getSpace(lenL) + val + getSpace(lenR);
-        System.out.println(getSpace(height * len) + val);
-        printInOrder(head.left, height + 1, "^", len);
-    }
-
-    public static String getSpace(int num) {
-        String space = " ";
-        StringBuffer buf = new StringBuffer("");
-        for (int i = 0; i < num; i++) {
-            buf.append(space);
-        }
-        return buf.toString();
-    }
-
-    public static void main(String[] args) {
-
-        Node head = new Node(6);
-        head.left = new Node(1);
-        head.left.left = new Node(0);
-        head.left.right = new Node(3);
-        head.right = new Node(12);
-        head.right.left = new Node(10);
-        head.right.left.left = new Node(4);
-        head.right.left.left.left = new Node(2);
-        head.right.left.left.right = new Node(5);
-        head.right.left.right = new Node(14);
-        head.right.left.right.left = new Node(11);
-        head.right.left.right.right = new Node(15);
-        head.right.right = new Node(13);
-        head.right.right.left = new Node(20);
-        head.right.right.right = new Node(16);
-
-        printTree(head);
-        Node bst = biggestSubBST(head);
-        printTree(bst);
-
-    }
-
-}
Index: src/左神算法/进阶班二/第三章/Code_03_ConvertStringToInteger.java
===================================================================
diff --git a/src/左神算法/进阶班二/第三章/Code_03_ConvertStringToInteger.java b/src/左神算法/进阶班二/第三章/Code_03_ConvertStringToInteger.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第三章/Code_03_ConvertStringToInteger.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,79 +0,0 @@
-package 左神算法.进阶班二.第三章;
-
-/**
- * @author zbl
- * @version 1将整数字符串转成整数值
-【题目】
-给定一个字符串str，如果str符合日常书写的整数形式，并且属于32
-位整数的范围，返回str所代表的整数值，否则返回0。
-【举例】
-str="123"，返回123。
-str="023"，因为"023"不符合日常的书写习惯，所以返回0。
-str="A13"，返回0。
-str="0"，返回0。
-str="2147483647"，返回2147483647。
-str="2147483648"，因为溢出了，所以返回0。
-str="-123"，返回-123。.0
- * @content:
- * @date 2020/2/19 15:01
- */
-public class Code_03_ConvertStringToInteger {
-
-
-    public static int convert(String str){
-        if(str==null || str.length()==0)
-            return 0;
-        char[] chars = str.toCharArray();
-        if(!isValid(chars))
-            return 0;
-        boolean flag=chars[0]=='-' ?false:true;
-        int qmin=Integer.MIN_VALUE%10;
-        int qmax=Integer.MIN_VALUE/10;
-        int res=0;
-        int cur=0;
-        for(int i=flag ? 0:1;i<chars.length;i++){ //注意不能使用Integer.valueOf()方法
-            cur='0'-chars[i];//全部转变成负数
-            if(res<qmax) return 0;
-            if(res==qmax && cur<qmin)return 0;
-            res=res*10+cur;
-        }
-        if(flag && res==Integer.MIN_VALUE){
-            return 0;
-        }
-        return flag ? -res:res;
-    }
-
-    //判断一个是否是有效字符串
-    private static boolean isValid(char[] chars){
-
-        if(chars[0]!='-' && (chars[0]<'1'|| chars[0]>'9'))
-            return false;
-        if(chars[0]=='-' && (chars[1]==0 || chars.length==1))
-            return false;
-
-        for(int i=1;i<chars.length;i++){
-            if(chars[i]<'0' || chars[i]>'9')
-                return false;
-        }
-
-        return true;
-    }
-
-    public static void main(String[] args) {
-        String test1 = "2147483647"; // max in java
-        System.out.println(convert(test1));
-
-        String test2 = "-2147483648"; // min in java
-        System.out.println(convert(test2));
-
-        String test3 = "2147483648"; // overflow
-        System.out.println(convert(test3));
-
-        String test4 = "-2147483649"; // overflow
-        System.out.println(convert(test4));
-
-        String test5 = "-123";
-        System.out.println(convert(test5));
-
-    }
-}
Index: src/左神算法/进阶班二/第五章/Code_03_Min_Gold.java
===================================================================
diff --git a/src/左神算法/进阶班二/第五章/Code_03_Min_Gold.java b/src/左神算法/进阶班二/第五章/Code_03_Min_Gold.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第五章/Code_03_Min_Gold.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,165 +0,0 @@
-package 左神算法.进阶班二.第五章;
-
-import java.util.Arrays;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:你的王国里有n条龙，你希望雇佣一些勇士把它们杀死，王国里一共有m个骑士
-可以雇佣。假定，一个能力值 为x的骑士可以打败战斗力不超过x的恶龙，且
-需要支付x个金币。已知勇士可以重复雇佣，且重复雇佣需要重 复支付金币，
-请求出打败所有的恶龙需要的最小金币数目。 例如，你的王国里有三条龙，
-战斗力分别为10，11，20，同时有三个勇士可以雇佣，能力值分别为
-20,12,30，最省钱的方式是能力值12的勇士攻击战斗力10的龙，能力值12的勇
-士攻击战斗力11的龙，能力值 20的勇士攻击战斗力20的龙，总共付出44金币。
-进阶：
-一条龙可以被勇士合力杀死，求付出的金币数
-举例：
-int[] knights = { 2, 10, 5 };
-int[] dragons = { 3, 8, 6 };
-原问题标准下应返回：25
-进阶的标准下应返回：22
- * @date 2020/2/24 16:04
- */
-public class Code_03_Min_Gold {
-
-
-    public static int minGold1(int[] knights,int[] dragons){
-        Arrays.sort(knights);
-        int res=0;
-        for(int i=0;i<dragons.length;i++){
-            int cost=getMaxLeftMost(knights,dragons[i]);
-            if(cost!=Integer.MAX_VALUE)
-            {
-                res+=cost;
-            }else{
-                return Integer.MAX_VALUE;
-            }
-        }
-        return res;
-    }
-
-    //二分查找法，找到恰好大于等于dragon的值。
-    public static int getMaxLeftMost(int[] sortedArr, int dragon) {
-        int L = 0;
-        int R = sortedArr.length - 1;
-        int index = -1;
-        while (L <= R) {
-            int mid = (L + R) / 2;
-            if (sortedArr[mid] < dragon) {
-                L = mid + 1;
-            } else { //找到第一个大于等于dragon的递归写法。
-                index = mid;
-                R = mid - 1;
-            }
-        }
-        return index == -1 ? Integer.MAX_VALUE : sortedArr[index];
-    }
-
-    //进阶：
-    public static int minGold2(int[] knights,int[] dragons){
-        int sum=0;
-        for(int i=0;i<knights.length;i++){
-            sum+=knights[i];
-        }
-        int[][] dp=new int[knights.length][sum+1];
-        dp[0][knights[0]]=knights[0];
-        for(int i=1;i<knights.length;i++){
-            for(int j=1;j<=sum;j++){
-                if(dp[i-1][j]!=0)
-                    dp[i][j]=dp[i-1][j];
-                if(j-knights[i]>=0 && dp[i-1][j-knights[i]]!=0)
-                    dp[i][j]=knights[i]+dp[i-1][j-knights[i]];
-                if(j==knights[i]){
-                    dp[i][j]=j;
-                }
-            }
-        }
-        int[] help=new int[sum+1];
-        for(int i=1;i<=sum;i++){
-            if(dp[knights.length-1][i]!=0){
-                help[i]=dp[knights.length-1][i];
-            }else{
-                help[i]=Integer.MAX_VALUE;
-            }
-        }
-        //printArray(help);
-        for(int i=sum-1;i>-1;i--){
-            help[i]=Math.min(help[i+1],help[i]);
-        }
-        //printArray(help);
-        int res=0;
-        for(int i=0;i<dragons.length;i++){
-            res+=help[dragons[i]];
-        }
-        return res;
-
-
-
-
-    }
-
-    // 矩阵压缩，使用一维数组.
-    public static int minGold3(int[] knights, int[] dragons) {
-        int sum = 0;
-        for (int i = 0; i < knights.length; i++) {
-            sum += knights[i];
-        }
-        int[] dp = new int[sum + 1];
-        for (int i = 1; i <= sum; i++) {
-            dp[i] = Integer.MAX_VALUE;
-        }
-        dp[knights[0]] = knights[0];
-        // printArray(dp);
-        for (int i = 1; i < knights.length; i++) {
-            for (int j = 1; j <= sum; j++) {
-                if (j - knights[i] >= 0
-                        && dp[j - knights[i]] < Integer.MAX_VALUE) {
-                    dp[j] = Math.min(dp[j], dp[j - knights[i]] + knights[i]);
-                }
-            }
-            // printArray(dp);
-        }
-        for (int i = dp.length - 2; i >= 0; i--) {
-            dp[i] = Math.min(dp[i], dp[i + 1]);
-        }
-         //printArray(dp);
-        int res = 0;
-        //没有必要再二分查找了
-//        for (int i = 0; i < dragons.length; i++) {
-//            int cost = getMaxLeftmost(dp, dragons[i]);
-//            if (cost == Integer.MAX_VALUE) {
-//                return Integer.MAX_VALUE;
-//            }
-//            res += cost;
-//        }
-        for(int i=0;i<dragons.length;i++){
-            res+=dp[dragons[i]];
-        }
-        return res;
-    }
-
-    public static void printArray(int[] dp) {
-        for (int i = 0; i < dp.length; i++) {
-            System.out.print((dp[i] == Integer.MAX_VALUE ? "X" : dp[i]) + " ");
-        }
-        System.out.println();
-    }
-
-
-
-    public static void main(String[] args) {
-        int[] knights1 = { 2, 10, 5 };
-        int[] dragons1 = { 3, 8, 6 };
-        System.out.println(minGold1(knights1, dragons1));
-
-        int[] knights2 = { 2, 10, 5 };
-        int[] dragons2 = { 3, 8, 6 };
-        System.out.println(minGold2(knights2, dragons2));
-
-        int[] knights3 = { 2, 10, 5 };
-        int[] dragons3 = { 3, 8, 6 };
-        System.out.println(minGold3(knights2, dragons2));
-
-    }
-}
Index: src/左神算法/进阶班二/第四章/Code_03_PosArrayToBST.java
===================================================================
diff --git a/src/左神算法/进阶班二/第四章/Code_03_PosArrayToBST.java b/src/左神算法/进阶班二/第四章/Code_03_PosArrayToBST.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第四章/Code_03_PosArrayToBST.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,123 +0,0 @@
-package 左神算法.进阶班二.第四章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:题目三
-KMP算法扩展题目二
-根据后序数组重建搜索二叉树
-【题目】
-给定一个整型数组arr，已知其中没有重复值，判断arr是否可能是节
-点值类型为整型的搜索二叉树后序遍历的结果。
-进阶：如果整型数组arr中没有重复值，且已知是一棵搜索二叉树的后
-序遍历结果，通过数组arr重构二叉树。
- * @date 2020/2/21 16:35
- */
-public class Code_03_PosArrayToBST {
-
-    public static class Node{
-        private int value;
-        private Node left;
-        private Node right;
-
-        public Node(int value) {
-            this.value = value;
-        }
-    }
-
-    public static boolean isPostTree(int[] arr){
-        if(arr==null || arr.length==0)
-            return false;
-        return isPost(arr,0,arr.length-1);
-
-    }
-
-    private static boolean isPost(int[] arr,int begin,int end){
-        if(begin==end)
-            return true;
-        int less=-1;
-        int more=end;
-        for(int i=begin;i<end;i++)
-        {
-            if(arr[i]<arr[end]){
-                less=i;
-            }else{
-                more=more==end ?i:more;
-            }
-        }
-
-        if(more==end || less==-1){
-            return isPost(arr,begin,end-1);
-        }
-        if(less!=more-1)
-            return false;
-        return isPost(arr,begin,less) && isPost(arr,more,end-1);
-    }
-
-
-    //重构二叉树
-    public static Node posArrayToBST(int[] arr){
-        if(arr==null || arr.length==0)
-            return null;
-        return process(arr,0,arr.length-1);
-    }
-
-    public static Node process(int[] arr,int begin,int end){
-
-        if(begin>end)
-            return null;
-        Node head=new Node(arr[end]);
-        int less=-1;
-        int more=end;
-        for(int i=begin;i<end;i++){
-            if(arr[i]<arr[end])
-                less=i;
-            else{
-                more=more==end ? i:more;
-            }
-        }
-        if(less!=-1)
-        head.left=process(arr,begin,less);
-        if(more!=end)
-        head.right=process(arr,more,end-1);
-        return head;
-    }
-
-    // for test -- print tree
-    public static void printTree(Node head) {
-        System.out.println("Binary Tree:");
-        printInOrder(head, 0, "H", 17);
-        System.out.println();
-    }
-
-    public static void printInOrder(Node head, int height, String to, int len) {
-        if (head == null) {
-            return;
-        }
-        printInOrder(head.right, height + 1, "v", len);
-        String val = to + head.value + to;
-        int lenM = val.length();
-        int lenL = (len - lenM) / 2;
-        int lenR = len - lenM - lenL;
-        val = getSpace(lenL) + val + getSpace(lenR);
-        System.out.println(getSpace(height * len) + val);
-        printInOrder(head.left, height + 1, "^", len);
-    }
-
-    public static String getSpace(int num) {
-        String space = " ";
-        StringBuffer buf = new StringBuffer("");
-        for (int i = 0; i < num; i++) {
-            buf.append(space);
-        }
-        return buf.toString();
-    }
-
-    public static void main(String[] args) {
-        int[] arr = { 2, 1, 3, 6, 5, 7, 4 };
-        System.out.println(isPost(arr, 0, arr.length - 1));
-        printTree(posArrayToBST(arr));
-
-    }
-
-}
Index: src/左神算法/进阶班二/第八章/Code_03_Russian_Doll_Envelopes.java
===================================================================
diff --git a/src/左神算法/进阶班二/第八章/Code_03_Russian_Doll_Envelopes.java b/src/左神算法/进阶班二/第八章/Code_03_Russian_Doll_Envelopes.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第八章/Code_03_Russian_Doll_Envelopes.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,81 +0,0 @@
-package 左神算法.进阶班二.第八章;
-
-import java.util.Arrays;
-import java.util.Comparator;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给KM定P算一法个扩N*展2的题矩目阵二，表示N个信封的长和宽，
-例如
-6,4
-3,9
-4,3
-第0个信封，长6宽4
-第1个信封，长3宽9
-第2个信封，长4宽3
-长和宽是两个维度而已，不要把信封旋转让其长变宽，宽变长。
-如果信封a的长和宽都比信封b大，那么说b可以放在a的里面，
-给定这么一个矩阵，求信封最多可以套几层。
-比如上个例子，选[4,3][6,4]，[4,3]可以放在[6,4]里，最多套两层，返回2.
- * @date 2020/3/3 9:17
- */
-public class Code_03_Russian_Doll_Envelopes{
-
-    public static class Dot{
-        public int w;
-        public int h;
-
-        public Dot(int w, int h) {
-            this.w = w;
-            this.h = h;
-        }
-    }
-
-    public static class DotComparator implements Comparator<Dot>{
-
-        @Override
-        public int compare(Dot o1, Dot o2) {
-            if(o1.w==o2.w)
-                return o2.h-o1.h;
-            else
-                return o1.w-o2.w;
-        }
-    }
-
-    public static int maxEnvelopes(int[][]es){
-        if(es==null || es.length==0 || es[0]==null || es[0].length==0)
-            return 0;
-        Dot[] dots=new Dot[es.length];
-        for(int i=0;i<es.length;i++){
-            dots[i]=new Dot(es[i][0],es[i][1]);
-        }
-
-        Arrays.sort(dots,new DotComparator());
-        int[] ens=new int[dots.length];//最小结尾数组
-        ens[0]=dots[0].h;
-        int right=0;
-        int l=0;
-        int r=0;
-        int m=0;
-        for(int i=1;i<dots.length;i++){
-            l=0;
-            r=right;
-            while(l<=r)
-            {
-                m=(l+r)/2;
-                if(dots[i].h>ens[m]){
-                    l=m+1;
-                }else{   //找到在ens数组中最接近dots[i].h的值的位置,即：第一个大于等于dots[i].h的位置
-                                                                  // ，然后替换这个位置的值
-                    r=m-1;
-                }
-            }
-            right=Math.max(l,right);
-            ens[l]=dots[i].h;
-        }
-        return right+1;
-
-    }
-
-}
Index: src/左神算法/进阶班二/第六章/Code_03_SubArrayMaxProduct.java
===================================================================
diff --git a/src/左神算法/进阶班二/第六章/Code_03_SubArrayMaxProduct.java b/src/左神算法/进阶班二/第六章/Code_03_SubArrayMaxProduct.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第六章/Code_03_SubArrayMaxProduct.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,35 +0,0 @@
-package 左神算法.进阶班二.第六章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:数组中子数组的最大累乘积
-【题目】
-给定一个double类型的数组arr，其中的元素可正、可负、可0，返回
-子数组累乘的最大乘积。例如，arr=[-2.5，4，0，3，0.5，8，-1]，
-子数组[3，0.5，8]累乘可以获得最大的乘积12，所以返回12。
- * @date 2020/2/28 15:55
- */
-public class Code_03_SubArrayMaxProduct {
-
-    //以每个位置结尾考虑,求每一个位置的最大值与最小值
-    public static double maxProduct(double[] arr){
-        if(arr==null || arr.length==0)
-            return 0;
-        double max=arr[0];//动态记录以每一个位置结尾的最大值
-        double min=arr[0];//动态记录以每一个位置结尾的最小值
-        double res=arr[0];
-        //int cur=1;
-        for(int i=1;i<arr.length;i++){
-            max=Math.max(arr[i],Math.max(arr[i]*max,arr[i]*min));
-            min=Math.min(arr[i],Math.min(arr[i]*max,arr[i]*min));
-            res=Math.max(res,max);
-        }
-        return res;
-    }
-
-    public static void main(String[] args) {
-        double[] arr = { -2.5, 4, 0, 3, 0.5, 8, -1 };
-        System.out.println(maxProduct(arr));
-    }
-}
Index: src/左神算法/进阶班二/第八章/Code_04_Building_Outline.java
===================================================================
diff --git a/src/左神算法/进阶班二/第八章/Code_04_Building_Outline.java b/src/左神算法/进阶班二/第八章/Code_04_Building_Outline.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第八章/Code_04_Building_Outline.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,22 +0,0 @@
-package 左神算法.进阶班二.第八章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一个N*3的矩阵，每一行表示有一座大楼，一共有N座大楼。
-所有大楼的底部都坐落在x轴上，每一行的三个值(a,b,c)表示每座大楼
-从(a,0)点开始，到(b,0)结束，高度为c.
-输入数据可以保证a<b，且a,b,c均为正数，大楼之间可以有重合。
-请输出整体的轮廓线。
-例如
-1,3,3
-2,4,4
-5,6,1
-输出
-1,2,3
-2,4,4
-5,6,1
- * @date 2020/3/3 9:18
- */
-public class Code_04_Building_Outline {
-}
Index: src/左神算法/进阶班二/第五章/Code_04_Decompress_String.java
===================================================================
diff --git a/src/左神算法/进阶班二/第五章/Code_04_Decompress_String.java b/src/左神算法/进阶班二/第五章/Code_04_Decompress_String.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第五章/Code_04_Decompress_String.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,74 +0,0 @@
-package 左神算法.进阶班二.第五章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:某位程序想出了一个压缩字符串的方法，压缩后的字符串如下:
-3{a}2{bc}，3{a2{c}}，2{abc}3{cd}ef，现在 需要你写一个解
-压的程序，还原原始的字符串。如: s = "3{d}2{bc}", return
-"dddbcbc". s = "3{a2{d}}", return "addaddadd". s =
-"2{efg}3{cd}ef", return "efgefgcdcdcdef". 重复次数可以
-确保是一个正整数。
- * @date 2020/2/24 16:04
- */
-public class Code_04_Decompress_String {
-
-    public static String decompress(String str){
-        char[] chs = str.toCharArray();
-        return process(chs,0).str;
-    }
-
-    public static class ReturnData{
-        public String str;
-        public int index;
-
-        public ReturnData(String str, int index) {
-            this.str = str;
-            this.index = index;
-        }
-    }
-
-    public static ReturnData process(char[] chs,int index){
-        StringBuilder res=new StringBuilder();
-        int times=0;
-        while(index<chs.length && chs[index]!='}'){
-            if(chs[index]=='{'){
-                ReturnData returnData=process(chs,index+1);
-                res.append(getTimesString(times,returnData.str));
-                times=0;
-                index=returnData.index+1;
-
-            }else{
-                if(chs[index]>='0' && chs[index]<='9'){
-                    times=times*10+chs[index]-'0';
-                }
-                if(chs[index]>='a' && chs[index]<='z'){
-                    res.append(chs[index]);
-                }
-                index++;
-            }
-
-        }
-        return new ReturnData(res.toString(),index);
-    }
-
-    public static String getTimesString(int times,String base){
-
-        StringBuilder stringBuilder=new StringBuilder();
-        for(int i=0;i<times;i++){
-            stringBuilder.append(base);
-        }
-        return stringBuilder.toString();
-    }
-
-    public static void main(String[] args) {
-        String test1 = "3{a}2{bc}";
-        String test2 = "3{a2{c}}";
-        String test3 = "2{abc}3{cd}ef";
-        System.out.println(decompress(test1));
-        System.out.println(decompress(test2));
-        System.out.println(decompress(test3));
-
-    }
-
-}
Index: src/左神算法/进阶班二/第三章/Code_04_JumpGame.java
===================================================================
diff --git a/src/左神算法/进阶班二/第三章/Code_04_JumpGame.java b/src/左神算法/进阶班二/第三章/Code_04_JumpGame.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第三章/Code_04_JumpGame.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,45 +0,0 @@
-package 左神算法.进阶班二.第三章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:跳跃游戏
-【题目】
-给定数组arr，arr[i]==k代表可以从位置i向右跳1~k个距离。
-比如，arr[2]==3，代表从位置2可以跳到位置3、位置4或位置5。
-如果从位置0出发，返回最少跳几次能跳到arr最后的位置上。
-【举例】
-arr=[3,2,3,1,1,4]。
-arr[0]==3，选择跳到位置2；arr[2]==3，可以跳到最后的位置。
-所以返回2。
-【要求】
-如果arr长度为N，要求实现时间复杂度为O(N)、额外空间复杂
-度为O(1)的方法。
- * @date 2020/2/19 15:01
- */
-public class Code_04_JumpGame {
-
-
-    public static int jump(int[] arr){
-        if(arr==null || arr.length==0)
-            return 0;
-        int k=0;
-        int cur=0;//表示走了k步最大能做的距离
-        int next=0;//表示走第k+1后后能到的最大距离
-        for(int i=0;i<arr.length;i++){
-            if(cur<i){
-                k++;
-                cur=next;
-                //下面的if可以写也可以不写
-//                if(cur>=arr.length-1)
-//                    break;
-            }
-            next=Math.max(next,i+arr[i]);
-        }
-        return k;
-    }
-    public static void main(String[] args) {
-        int[] arr = { 3, 2, 3, 1, 1, 4 };
-        System.out.println(jump(arr));
-    }
-}
Index: src/左神算法/进阶班二/第七章/Code_04_MaxHappy.java
===================================================================
diff --git a/src/左神算法/进阶班二/第七章/Code_04_MaxHappy.java b/src/左神算法/进阶班二/第七章/Code_04_MaxHappy.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第七章/Code_04_MaxHappy.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,95 +0,0 @@
-package 左神算法.进阶班二.第七章;
-
-import java.util.List;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:某公司要举办一次晚会，每个参加晚会的人都不希望见到自己的直接上
-司，每个人有自己的活跃度，和上下级的关系，
-求邀请哪些人能使晚会的活跃度最大，最后返回活跃度即可。
-例子：给定一个矩阵，
-1 8
-1 9
-1 10
-第0个数组为[1,8]，表示0号员工的直接上级是1号员工，活跃度是8
-第1个数组为[1,9]，表示1号员工的直接上级是1号员工（大老板，头节
-点），活跃度是9
-第2个数组为[1,10]，表示2号员工的直接上级是1号员工，活跃度是10
-为了使气氛最活跃，应该1不来，0和2来，活跃度为18，返回18
- * @date 2020/2/29 16:40
- */
-public class Code_04_MaxHappy {
-
-    public static class Node{
-        public int huo;
-        public List<Node> nexts;
-
-        public Node(int huo, List<Node> nexts) {
-            this.huo = huo;
-            this.nexts = nexts;
-        }
-    }
-
-    public static class ReturnData{
-        public int lai_huo;
-        public int bu_huo;
-
-        public ReturnData(int lai_huo, int bu_huo) {
-            this.lai_huo = lai_huo;
-            this.bu_huo = bu_huo;
-        }
-    }
-
-    public static int getMax(Node head){
-        ReturnData returnData=process(head);
-        return Math.max(returnData.bu_huo,returnData.lai_huo);
-    }
-
-    public static ReturnData process(Node head){
-        List<Node> list=head.nexts;
-        int laihuo=head.huo;
-        int buhuo=0;
-        for(int i=0;i<list.size();i++){
-            ReturnData returnData = process(list.get(i));
-            laihuo+=returnData.bu_huo;
-            buhuo+=Math.max(returnData.bu_huo,returnData.lai_huo);
-        }
-        return new ReturnData(laihuo,buhuo);
-
-    }
-
-
-    //改为动态规划
-    public static int maxHappy(int[][] matrix){
-        int[][] dp=new int[matrix.length][2];  //dp[i][0]:表示i来的欢乐度，dp[i][1]代表i不来的欢乐度
-        boolean [] visited=new boolean[matrix.length]; //visited[i]表示第i个人有没有已经计算过了
-        int root=0;
-        for(int i=0;i<matrix.length;i++){
-            if(i==matrix[i][0])
-                root=i;
-        }
-        process(matrix,dp,visited,root);
-
-        return Math.max(dp[root][0],dp[root][1]);
-    }
-
-    private static void process(int[][] matrix, int[][] dp, boolean[] visited, int root) {
-        visited[root]=true;
-        dp[root][0]=matrix[root][1];
-        for(int i=0;i<matrix.length;i++){
-            if(matrix[i][0]==root && !visited[i]){
-                process(matrix,dp,visited,i);
-                dp[root][0]+=dp[i][1];
-                dp[root][1]+=Math.max(dp[i][0],dp[i][1]);
-            }
-        }
-    }
-
-    public static void main(String[] args) {
-        int[][] matrix = { { 1, 8 }, { 1, 9 }, { 1, 10 } };
-        System.out.println(maxHappy(matrix));
-    }
-
-
-}
Index: src/左神算法/进阶班二/第六章/Code_04_MaximalRectangle.java
===================================================================
diff --git a/src/左神算法/进阶班二/第六章/Code_04_MaximalRectangle.java b/src/左神算法/进阶班二/第六章/Code_04_MaximalRectangle.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第六章/Code_04_MaximalRectangle.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,68 +0,0 @@
-package 左神算法.进阶班二.第六章;
-
-import java.util.Stack;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:求最大子矩阵的大小
-【题目】
-给定一个整型矩阵map，其中的值只有0和1两种，求其中全是1
-的所有矩形区域中，最大的矩形区域为1的数量。
-例如：
-1 1 1 0
-其中，最大的矩形区域有3个1，所以返回3。
-再如：
-1 0 1 1
-1 1 1 1
-1 1 1 0
-其中，最大的矩形区域有6个1，所以返回6。
- * @date 2020/2/28 15:55
- */
-public class Code_04_MaximalRectangle {
-
-
-    public static int maxRecSize(int[][] map) {
-        if (map == null || map.length == 0 || map[0].length == 0) {
-            return 0;
-        }
-        int maxArea = 0;
-        int[] height = new int[map[0].length];
-        for (int i = 0; i < map.length; i++) {
-            for (int j = 0; j < map[0].length; j++) {
-                height[j] = map[i][j] == 0 ? 0 : height[j] + 1;
-            }
-            maxArea = Math.max(maxRecFromBottom(height), maxArea);
-        }
-        return maxArea;
-    }
-
-    public static int maxRecFromBottom(int[] height) {
-        if (height == null || height.length == 0) {
-            return 0;
-        }
-        int maxArea = 0;
-        Stack<Integer> stack = new Stack<Integer>();
-        for (int i = 0; i < height.length; i++) {
-            while (!stack.isEmpty() && height[i] <= height[stack.peek()]) {
-                int j = stack.pop();
-                int k = stack.isEmpty() ? -1 : stack.peek();
-                int curArea = (i - k - 1) * height[j];
-                maxArea = Math.max(maxArea, curArea);
-            }
-            stack.push(i);
-        }
-        while (!stack.isEmpty()) {
-            int j = stack.pop();
-            int k = stack.isEmpty() ? -1 : stack.peek();
-            int curArea = (height.length - k - 1) * height[j];
-            maxArea = Math.max(maxArea, curArea);
-        }
-        return maxArea;
-    }
-
-    public static void main(String[] args) {
-        int[][] map = { { 1, 0, 1, 1 }, { 1, 1, 1, 1 }, { 1, 1, 1, 0 }, };
-        System.out.println(maxRecSize(map));
-    }
-}
Index: src/左神算法/进阶班二/第四章/Code_04_PrintMaxTopK.java
===================================================================
diff --git a/src/左神算法/进阶班二/第四章/Code_04_PrintMaxTopK.java b/src/左神算法/进阶班二/第四章/Code_04_PrintMaxTopK.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第四章/Code_04_PrintMaxTopK.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,146 +0,0 @@
-package 左神算法.进阶班二.第四章;
-
-import java.util.Arrays;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:题目四
-打印N个数组整体最大的Top K
-【题目】
-有N个长度不一的数组，所有的数组都是有序的，请从大到小打
-印这N个数组整体最大的前K个数。
-例如，输入含有N行元素的二维数组可以代表N个一维数组。
-219,405,538,845,971
-148,558
-52,99,348,691
-再输入整数k=5，则打印：
-Top 5: 971,845,691,558,538
-【要求】
-1．如果所有数组的元素个数小于K，则从大到小打印所有的数。
-2．要求时间复杂度为O(KlogN)。
- * @date 2020/2/21 16:36
- */
-public class Code_04_PrintMaxTopK {
-
-    public static class Node{
-        private int value;
-        private int arrNum;
-        private int index;
-
-        public Node(int value, int arrNum, int index) {
-            this.value = value;
-            this.arrNum = arrNum;
-            this.index = index;
-        }
-    }
-
-    public static void printTopK(int[][] arr,int k){
-        Node[] heap=new Node[arr.length];
-        int heapSize=arr.length;
-        for(int i=0;i<arr.length;i++){
-            heap[i]=new Node(arr[i][arr[i].length-1],i,arr[i].length-1);
-            heapInsert(heap,i);
-        }
-        System.out.println("Top "+k+": ");
-        for(int i=0;i!=k;i++){
-            if(heapSize==0)
-                break;
-            System.out.print(heap[0].value+" ");
-            if(heap[0].index!=0){
-                heap[0].value=arr[heap[0].arrNum][--heap[0].index];
-            }else{
-                swap(heap,0,--heapSize);
-            }
-            heapify(heap,0,heapSize);
-
-        }
-
-
-    }
-    //heapInsert是从下往上调整，只要当前调整的坐标不是0，便进入判断调整
-    public static void heapInsert(Node[] heap,int index){
-        while(index!=0){
-            int pre=(index-1)/2;
-
-            if(heap[pre].value<heap[index].value){
-                swap(heap,pre,index);
-                index=pre;
-
-            }else
-                break;
-        }
-    }
-     //heapfify是从上往下调整，可以设置调整的范围
-    public static void heapify(Node[] heap,int index,int heapsize){
-        int left=index*2+1;
-        while(left<heapsize){
-            int largest=(left+1)<heapsize && (heap[left].value<heap[left+1].value) ?left+1:left;
-            if(heap[largest].value<=heap[index].value)
-                break;
-            else
-            {
-                swap(heap,largest,index);
-                index=largest;
-                left=2*index+1;
-            }
-        }
-    }
-
-    public static void swap(Node[] heap,int index,int pre){
-        Node temp=heap[index];
-        heap[index]=heap[pre];
-        heap[pre]=temp;
-    }
-
-    //注意这种生成长度不同的数组的方式
-    public static int[][] generateRandomMatrix(int maxRow, int maxCol,
-                                               int maxValue) {
-        if (maxRow < 0 || maxCol < 0) {
-            return null;
-        }
-        int[][] matrix = new int[(int) (Math.random() * maxRow) + 1][];
-        for (int i = 0; i != matrix.length; i++) {
-            matrix[i] = new int[(int) (Math.random() * maxCol) + 1];
-            for (int j = 0; j != matrix[i].length; j++) {
-                matrix[i][j] = (int) (Math.random() * maxValue);
-            }
-            Arrays.sort(matrix[i]);
-        }
-        return matrix;
-    }
-
-    //自己手写一遍上面的实现方法
-    public static int[][] generateRandomMatrix2(int maxrow,int maxcol,int maxValue){
-        if(maxcol==0 || maxrow==0)
-            return null;
-        int[][] matrix=new int[(int)(Math.random()*maxrow)+1][];
-        for(int i=0;i<matrix.length;i++){
-            matrix[i]=new int[(int)(Math.random()*maxcol)+1];
-            for(int j=0;j<matrix[i].length;j++){
-                matrix[i][j]=(int)(Math.random()*maxValue);
-            }
-            Arrays.sort(matrix[i]);
-        }
-
-        return matrix;
-
-    }
-
-    public static void printMatrix(int[][] matrix) {
-        for (int i = 0; i != matrix.length; i++) {
-            for (int j = 0; j != matrix[i].length; j++) {
-                System.out.print(matrix[i][j] + " ");
-            }
-            System.out.println();
-        }
-    }
-
-    public static void main(String[] args) {
-        int[][] matrix = generateRandomMatrix(5, 10, 1000);
-        printMatrix(matrix);
-        System.out.println("===========================");
-        printTopK(matrix, 10);
-    }
-
-}
Index: src/左神算法/进阶班二/第五章/Code_05_ExpressionNumber.java
===================================================================
diff --git a/src/左神算法/进阶班二/第五章/Code_05_ExpressionNumber.java b/src/左神算法/进阶班二/第五章/Code_05_ExpressionNumber.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第五章/Code_05_ExpressionNumber.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,239 +0,0 @@
-package 左神算法.进阶班二.第五章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:表达式得到期望结果的组成种数
-【题目】
-给定一个只由0（假）、1(真)、&(逻辑与)、|（逻辑或）和^(异或)五种字符组成的字符
-串express，再给定一个布尔值desired。返回express能有多少种组合方式，可以达到
-desired的结果。
-【举例】
-express="1^0|0|1"，desired=false。
-只有1^((0|0)|1)和1^(0|(0|1))的组合可以得到false，返回2。
-express="1"，desired=false。
-无组合则可以得到false，返回0。
- * @date 2020/2/24 16:05
- */
-public class Code_05_ExpressionNumber {
-
-    //判断是否是有效的字符串
-    public static boolean isValid(char[] chs){
-        if((chs.length & 1)==0 )
-            return false;
-        for(int i=0;i<chs.length;i+=2){
-            if(chs[i]!='0' && chs[i]!='1')
-                return false;
-        }
-        for(int i=1;i<chs.length;i+=2){
-            if(chs[i]!='&' && chs[i]!='|' && chs[i]!='^')
-                return false;
-        }
-        return true;
-    }
-
-    public static class ReturnData{
-        public int trueNums;
-        public int falseNums;
-
-        public ReturnData(int trueNums, int falseNums) {
-            this.trueNums = trueNums;//boolean==true的时候的返回数目
-            this.falseNums = falseNums;
-        }
-    }
-
-
-        //递归的方式
-      public static int num1(String str,boolean desired){
-        if(str==null || str.equals("") ){
-            return 0;
-        }
-        if(!isValid(str.toCharArray())){
-            throw new RuntimeException("无效字符串");
-        }
-        char[] chs=str.toCharArray();
-          ReturnData process = process(chs, 0, chs.length - 1);
-          return desired ? process.trueNums:process.falseNums;
-    }
-
-    //l.r为判断的字符数组的最左和最右边界位置,并且一定要是0或者1
-    private static ReturnData process(char[] chs, int l, int r) {
-        if(l==r){
-            if(chs[l]=='0')
-                return new ReturnData(0,1);
-            if(chs[l]=='1')
-                return new ReturnData(1,0);
-        }
-        int trueNums=0;
-        int falseNums=0;
-        for(int i=l+1;i<r;i+=2){//i取逻辑符号的位置进行划分
-            ReturnData leftpart = process(chs, l, i - 1);
-            ReturnData rightpart = process(chs, i + 1, r);
-            int a=leftpart.trueNums;
-            int b=leftpart.falseNums;
-            int c=rightpart.trueNums;
-            int d=rightpart.falseNums;
-            if(chs[i]=='&'){
-                trueNums+=a*c;
-                falseNums+=a*d+b*c+b*d;
-            }else if(chs[i]=='|'){
-                trueNums+=a*c+a*d+b*c;
-                falseNums+=b*d;
-            }else{
-                trueNums+=a*d+b*c;
-                falseNums+=a*c+b*d;
-            }
-
-        }
-        return new ReturnData(trueNums,falseNums);
-    }
-
-    //根据上面的递归改动态规划
-    public static int num2(String str,boolean desire){
-        if(str==null || str.length()==0)
-            throw new RuntimeException("无效字符串");
-        if(!isValid(str.toCharArray()))
-            throw new RuntimeException("无效字符串");
-        if(str.length()==1){
-            return desire ?(str.equals("1")?1:0):(str.equals("0") ? 1:0);
-        }
-        char[] chs=str.toCharArray();
-        int len=chs.length;
-        int[][] trueDp=new int[len][len];
-        int[][] falseDp=new int[len][len];
-        for(int i=0;i<str.length();i+=2){
-            trueDp[i][i]=(chs[i]=='1')?1:0;
-            falseDp[i][i]=chs[i]=='0'?1:0;
-        }
-
-        for(int row=len-3;row>-1;row-=2){
-            for(int col=row+2;col<len;col+=2){
-                int trueNums=0;
-                int falseNums=0;
-                for(int split=row+1;split<col;split+=2){
-                    int a=trueDp[row][split-1];
-                    int b=falseDp[row][split-1];
-                    int c=trueDp[split+1][col];
-                    int d=falseDp[split+1][col];
-
-                    if(chs[split]=='&'){
-                        trueNums+=a*c;
-                        falseNums+=a*d+b*c+b*d;
-                    }else if(chs[split]=='|'){
-                        trueNums+=a*c+a*d+b*c;
-                        falseNums+=b*d;
-                    }else{
-                        trueNums+=a*d+b*c;
-                        falseNums+=a*c+b*d;
-                    }
-                }
-                trueDp[row][col]=trueNums;
-                falseDp[row][col]=falseNums;
-            }
-        }
-        return desire ? trueDp[0][len-1]:falseDp[0][len-1];
-
-    }
-
-
-    public static int num3(String express, boolean desired) {
-        if (express == null || express.equals("")) {
-            return 0;
-        }
-        char[] exp = express.toCharArray();
-        if (!isValid(exp)) {
-            return 0;
-        }
-        return p(exp, desired, 0, exp.length - 1);
-    }
-
-    public static int p(char[] exp, boolean desired, int l, int r) {
-        if (l == r) {
-            if (exp[l] == '1') {
-                return desired ? 1 : 0;
-            } else {
-                return desired ? 0 : 1;
-            }
-        }
-        int res = 0;
-        if (desired) {
-            for (int i = l + 1; i < r; i += 2) {
-                switch (exp[i]) {
-                    case '&':
-                        res += p(exp, true, l, i - 1) * p(exp, true, i + 1, r);
-                        break;
-                    case '|':
-                        res += p(exp, true, l, i - 1) * p(exp, false, i + 1, r);
-                        res += p(exp, false, l, i - 1) * p(exp, true, i + 1, r);
-                        res += p(exp, true, l, i - 1) * p(exp, true, i + 1, r);
-                        break;
-                    case '^':
-                        res += p(exp, true, l, i - 1) * p(exp, false, i + 1, r);
-                        res += p(exp, false, l, i - 1) * p(exp, true, i + 1, r);
-                        break;
-                }
-            }
-        } else {
-            for (int i = l + 1; i < r; i += 2) {
-                switch (exp[i]) {
-                    case '&':
-                        res += p(exp, false, l, i - 1) * p(exp, true, i + 1, r);
-                        res += p(exp, true, l, i - 1) * p(exp, false, i + 1, r);
-                        res += p(exp, false, l, i - 1) * p(exp, false, i + 1, r);
-                        break;
-                    case '|':
-                        res += p(exp, false, l, i - 1) * p(exp, false, i + 1, r);
-                        break;
-                    case '^':
-                        res += p(exp, true, l, i - 1) * p(exp, true, i + 1, r);
-                        res += p(exp, false, l, i - 1) * p(exp, false, i + 1, r);
-                        break;
-                }
-            }
-        }
-        return res;
-    }
-
-    public static int num4(String express, boolean desired) {
-        if (express == null || express.equals("")) {
-            return 0;
-        }
-        char[] exp = express.toCharArray();
-        if (!isValid(exp)) {
-            return 0;
-        }
-        int[][] t = new int[exp.length][exp.length];
-        int[][] f = new int[exp.length][exp.length];
-        t[0][0] = exp[0] == '0' ? 0 : 1;
-        f[0][0] = exp[0] == '1' ? 0 : 1;
-        for (int i = 2; i < exp.length; i += 2) {
-            t[i][i] = exp[i] == '0' ? 0 : 1;
-            f[i][i] = exp[i] == '1' ? 0 : 1;
-            for (int j = i - 2; j >= 0; j -= 2) {
-                for (int k = j; k < i; k += 2) {
-                    if (exp[k + 1] == '&') {
-                        t[j][i] += t[j][k] * t[k + 2][i];
-                        f[j][i] += (f[j][k] + t[j][k]) * f[k + 2][i] + f[j][k] * t[k + 2][i];
-                    } else if (exp[k + 1] == '|') {
-                        t[j][i] += (f[j][k] + t[j][k]) * t[k + 2][i] + t[j][k] * f[k + 2][i];
-                        f[j][i] += f[j][k] * f[k + 2][i];
-                    } else {
-                        t[j][i] += f[j][k] * t[k + 2][i] + t[j][k] * f[k + 2][i];
-                        f[j][i] += f[j][k] * f[k + 2][i] + t[j][k] * t[k + 2][i];
-                    }
-                }
-            }
-        }
-        return desired ? t[0][t.length - 1] : f[0][f.length - 1];
-    }
-
-    public static void main(String[] args) {
-        String express = "1^0&0|1&1^0&0^1|0|1&1";
-        boolean desired = true;
-        System.out.println(num1(express, desired));
-        System.out.println(num2(express, desired));
-        System.out.println(num3(express, desired));
-        System.out.println(num4(express, desired));
-
-    }
-}
Index: src/左神算法/进阶班二/第三章/Code_05_FindStringInContainsNullArray.java
===================================================================
diff --git a/src/左神算法/进阶班二/第三章/Code_05_FindStringInContainsNullArray.java b/src/左神算法/进阶班二/第三章/Code_05_FindStringInContainsNullArray.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第三章/Code_05_FindStringInContainsNullArray.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,20 +0,0 @@
-package 左神算法.进阶班二.第三章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 在有序但含有空的数组中查找字符串
-【题目】
-给定一个字符串数组strs[]，在strs中有些位置为null，但在不为null的位置上，其字
-符串是按照字典顺序由小到大依次出现的。再给定一个字符串str，请返回str在strs中
-出现的最左的位置。
-【举例】
-strs=[null,"a",null,"a",null,"b",null,"c"]，str="a"，返回1。
-strs=[null,"a",null,"a",null,"b",null,"c"]，str=null，只要str为null，就返回-1。
-strs=[null,"a",null,"a",null,"b",null,"c"]，str="d"，返回-1。
- * @date 2020/2/19 15:01
- */
-public class Code_05_FindStringInContainsNullArray {
-
-}
Index: src/左神算法/进阶班二/第七章/Code_05_MaxDistanceInTree.java
===================================================================
diff --git a/src/左神算法/进阶班二/第七章/Code_05_MaxDistanceInTree.java b/src/左神算法/进阶班二/第七章/Code_05_MaxDistanceInTree.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第七章/Code_05_MaxDistanceInTree.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,13 +0,0 @@
-package 左神算法.进阶班二.第七章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:二叉树中由节点a往上或者往下走到节点b，最短路径上节点的数量叫做a到b的距离。
-给定一棵二叉树的头节点head，求整棵树中的最大距离。
- * @date 2020/2/29 16:41
- */
-public class Code_05_MaxDistanceInTree {
-
-
-}
Index: src/左神算法/进阶班二/第四章/Code_05_MaxOneBorderSize.java
===================================================================
diff --git a/src/左神算法/进阶班二/第四章/Code_05_MaxOneBorderSize.java b/src/左神算法/进阶班二/第四章/Code_05_MaxOneBorderSize.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第四章/Code_05_MaxOneBorderSize.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,106 +0,0 @@
-package 左神算法.进阶班二.第四章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:题目五
-边界都是1的最大正方形大小
-【题目】
-给定一个NN的矩阵matrix，在这个矩阵中，只有0和1两种值，返回边框全是1的最大正方
-形的边长长度。
-例如：
-0 1 1 1 1
-0 1 0 0 1
-0 1 0 0 1
-0 1 1 1 1
-0 1 0 1 1
-其中，边框全是1的最大正方形的大小为4*4，所以返回4。
- * @date 2020/2/21 16:36
- */
-public class Code_05_MaxOneBorderSize {
-
-    //构建预处理矩阵down与right,表示当前元素下面和右面连续的1的个数
-    public static void setBorderMap(int[][] m,int[][] right,int[][] down){
-        int r=m.length;
-        int c=m[0].length;
-        if(m[r-1][c-1]==1)
-        {
-            right[r-1][c-1]=1;
-            down[r-1][c-1]=1;
-        }
-        //最后一列
-        for(int i=r-2;i>-1;i--){
-            if(m[i][c-1]==1){
-                right[i][c-1]=1;
-                down[i][c-1]=down[i+1][c-1]+1;
-
-            }
-
-        }
-        //最后一行
-        for(int i=c-2;i>-1;i--){
-            if(m[r-1][i]==1){
-                right[r-1][i]=right[r-1][i+1]+1;
-                down[r-1][i]=1;
-            }
-        }
-
-        for(int i=r-2;i>-1;i--){
-            for(int j=c-2;j>-1;j--){
-                if(m[i][j]==1){
-                    right[i][j]=right[i][j+1]+1;
-                    down[i][j]=down[i+1][j]+1;
-                }
-            }
-        }
-
-    }
-
-    public static int getMaxSize(int[][] m){
-        int[][]right=new int[m.length][m[0].length];
-        int[][]down=new int[m.length][m[0].length];
-        setBorderMap(m,right,down);
-        for(int i=Math.min(m.length,m[0].length);i!=0;i--){
-            if(hasSizeOfBorder(i,right,down))
-                return i;
-        }
-        return 0;
-    }
-    //判断是否是全部为1的矩阵
-    public static boolean hasSizeOfBorder(int size,int[][]right,int[][] down){
-        for(int i=0;i!=right.length-size+1;i++){
-            for(int j=0;j!=right[0].length-size+1;j++){
-                if(right[i][j]>=size && down[i][j]>=size
-                        && down[i][j+size-1]>=size
-                        && right[i+size-1][j]>=size)
-                    return true;
-            }
-
-        }
-        return false;
-    }
-    public static int[][] generateRandom01Matrix(int rowSize, int colSize) {
-        int[][] res = new int[rowSize][colSize];
-        for (int i = 0; i != rowSize; i++) {
-            for (int j = 0; j != colSize; j++) {
-                res[i][j] = (int) (Math.random() * 2);
-            }
-        }
-        return res;
-    }
-
-    public static void printMatrix(int[][] matrix) {
-        for (int i = 0; i != matrix.length; i++) {
-            for (int j = 0; j != matrix[0].length; j++) {
-                System.out.print(matrix[i][j] + " ");
-            }
-            System.out.println();
-        }
-    }
-
-    public static void main(String[] args) {
-        int[][] matrix = generateRandom01Matrix(7, 8);
-        printMatrix(matrix);
-        System.out.println(getMaxSize(matrix));
-    }
-}
Index: src/左神算法/进阶班二/第六章/Code_05_PalindromeMinCut.java
===================================================================
diff --git a/src/左神算法/进阶班二/第六章/Code_05_PalindromeMinCut.java b/src/左神算法/进阶班二/第六章/Code_05_PalindromeMinCut.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第六章/Code_05_PalindromeMinCut.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,62 +0,0 @@
-package 左神算法.进阶班二.第六章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:回文最少分割数
-【题目】
-给定一个字符串str，返回把str全部切成回文子串的最小分割数。
-【举例】
-str="ABA"。
-不需要切割，str本身就是回文串，所以返回0。
-str="ACDCDCDAD"。
-最少需要切2次变成3个回文子串，比如"A"、"CDCDC"和"DAD"，所以返回2。
- * @date 2020/2/28 15:55
- */
-public class Code_05_PalindromeMinCut {
-
-
-    public static int minCut(String str) {
-        if (str == null || str.equals("")) {
-            return 0;
-        }
-        char[] chas = str.toCharArray();
-        int len = chas.length;
-        int[] dp = new int[len + 1];
-        dp[len] = -1;
-        boolean[][] p = new boolean[len][len];
-        for (int i = len - 1; i >= 0; i--) {
-            dp[i] = Integer.MAX_VALUE;
-            for (int j = i; j < len; j++) {
-                if (chas[i] == chas[j] && (j - i < 2 || p[i + 1][j - 1])) {
-                    p[i][j] = true;
-                    dp[i] = Math.min(dp[i], dp[j + 1] + 1);
-                }
-            }
-        }
-        return dp[0];
-    }
-
-    // for test
-    public static String getRandomStringOnlyAToD(int len) {
-        int range = 'D' - 'A' + 1;
-        char[] charArr = new char[(int) (Math.random() * (len + 1))];
-        for (int i = 0; i != charArr.length; i++) {
-            charArr[i] = (char) ((int) (Math.random() * range) + 'A');
-        }
-        return String.valueOf(charArr);
-    }
-
-    public static void main(String[] args) {
-        int maxLen = 10;
-        int testTimes = 5;
-        String str = null;
-        for (int i = 0; i != testTimes; i++) {
-            str = getRandomStringOnlyAToD(maxLen);
-            System.out.print("\"" + str + "\"" + " : ");
-            System.out.println(minCut(str));
-        }
-
-
-    }
-}
Index: src/左神算法/进阶班二/第六章/Code_06_ArtistProblem.java
===================================================================
diff --git a/src/左神算法/进阶班二/第六章/Code_06_ArtistProblem.java b/src/左神算法/进阶班二/第六章/Code_06_ArtistProblem.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第六章/Code_06_ArtistProblem.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,24 +0,0 @@
-package 左神算法.进阶班二.第六章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:画匠问题
-【题目】
-给定一个整型数组arr，数组中的每个值都为正数，表示完成一幅画作需要的时间，再给
-定一个整数num表示画匠的数量，每个画匠只能画连在一起的画作。所有的画家并行工
-作，请返回完成所有的画作需要的最少时间。
-【举例】
-arr=[3,1,4]，num=2。
-最好的分配方式为第一个画匠画3和1，所需时间为4。第二个画匠画4，所需时间为4。
-因为并行工作，所以最少时间为4。如果分配方式为第一个画匠画3，所需时间为3。第
-二个画匠画1和4，所需的时间为5。那么最少时间为5，显然没有第一种分配方式好。所
-以返回4。
-arr=[1,1,1,4,3]，num=3。
-最好的分配方式为第一个画匠画前三个1，所需时间为3。第二个画匠画4，所需时间为4。
-第三个画匠画3，所需时间为3。返回4。
- * @date 2020/2/28 15:55
- */
-public class Code_06_ArtistProblem {
-
-}
Index: src/左神算法/进阶班二/第七章/Code_06_BiggestBSTTopologyInTree.java
===================================================================
diff --git a/src/左神算法/进阶班二/第七章/Code_06_BiggestBSTTopologyInTree.java b/src/左神算法/进阶班二/第七章/Code_06_BiggestBSTTopologyInTree.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第七章/Code_06_BiggestBSTTopologyInTree.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,26 +0,0 @@
-package 左神算法.进阶班二.第七章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:找到二叉树中符合搜索二叉树条件的最大连通结构
-【题目】
-给定一棵二叉树的头节点head，已知所有节点的值都不一样，返回其中最大的且符合搜索二叉树条件的最大连通结构
-的大小。
-其中最大的且符合搜索二叉树条件的最大连通结构。
-二叉树如下：
-__3__
-/ \
-2 1
-符合搜索二叉树条件的最大连通结构为
-__3
-/
-2
-所以返回2
-请注意子树和连通结构的区别
-连通结构：二叉树中的某些节点只要是联通的，这些节点构成的结构都算连通结构。
-子树：从某个节点a开始，往下的节点全部都包括，叫做a的子树。
- * @date 2020/2/29 16:41
- */
-public class Code_06_BiggestBSTTopologyInTree {
-}
Index: src/左神算法/进阶班二/第三章/Code_06_FibonacciProblem.java
===================================================================
diff --git a/src/左神算法/进阶班二/第三章/Code_06_FibonacciProblem.java b/src/左神算法/进阶班二/第三章/Code_06_FibonacciProblem.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第三章/Code_06_FibonacciProblem.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,197 +0,0 @@
-package 左神算法.进阶班二.第三章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:斐波那契系列问题的递归和动态规划
-【题目】
-给定整数N，返回斐波那契数列的第N项。
-【补充题目1】
-给定整数N，代表台阶数，一次可以跨2个或者1个台阶，返回有多少种走法。
-【举例】
-N=3，可以三次都跨1个台阶；也可以先跨2个台阶，再跨1个台阶；还可以先跨1个台阶，再跨2个台阶。所以有
-三种走法，返回3。
-【补充题目2】
-假设农场中成熟的母牛每年只会生1头小母牛，并且永远不会死。第一年农场有1只成熟的母牛，从第二年开始，
-母牛开始生小母牛。每只小母牛3年之后成熟又可以生小母牛。给定整数N，求出N年后牛的数量。
- * @date 2020/2/19 15:01
- */
-public class Code_06_FibonacciProblem {
-
-    //斐波那契数列
-    public static int f1(int n){
-        if(n<1)
-            return 0;
-        if(n==1 || n==2)
-            return 1;
-        return f1(n-1)+f1(n-2);
-    }
-    //非递归方式实现
-    public static int f2(int n){
-        if(n<1)
-            return 0;
-        if(n==1 || n==2)
-            return 1;
-        int res=1;
-        int temp=0;
-        int pre=1;
-        for(int i=3;i<=n;i++){
-            temp=res;
-            res=res+pre;
-            pre=temp;
-        }
-        return res;
-    }
-
-    public static int f3(int n){
-        if(n<1)
-            return 0;
-        if(n==1 || n==2)
-            return 1;
-        int[][]base={{1,1},{1,0}};
-        int[][] res=matrixPower(base,n-2);
-        return res[0][0]+res[0][1];
-    }
-
-    /*
-    题目二台阶问题
-     */
-    //递归方式
-    public static int s1(int n){
-        if(n<1)
-            return 0;
-        if(n==1 || n==2)
-            return n;
-        return s1(n-1)+s1(n-2);
-    }
-    //非递归方式
-    public static int s2(int n){
-        if(n<1)
-            return 0;
-        if(n==1 || n==2)
-            return n;
-
-        int temp=0;
-        int res=2;
-        int pre=1;
-        for(int i=3;i<=n;i++){
-            temp=res;
-            res=res+pre;
-            pre=temp;
-        }
-        return res;
-    }
-
-    //矩阵乘法的方式
-    public static int s3(int n){
-        if(n<1)
-            return 0;
-        if(n==1 || n==2)
-            return n;
-        int[][] base = { { 1, 1 }, { 1, 0 } };
-        int[][] res = matrixPower(base, n - 2);
-        return 2 * res[0][0] + res[1][0];
-    }
-
-    /*
-      生小牛问题
-     */
-
-    //递归实现
-    public static int c1(int n){
-        if(n<1)
-            return 0;
-        if(n==1 || n==2 || n==3)
-            return n;
-        return c1(n-1)+c1(n-3);
-    }
-
-    //非递归实现
-    public static int c2(int n){
-        if(n<1)
-            return 0;
-        if(n==1 || n==2 || n==3)
-            return n;
-        //以下方式和左神的实现不同
-        int temp1=3;
-        int temp2=2;
-        int temp3=1;
-        int res=0;
-        for(int i=4;i<=n;i++){
-            res=temp1+temp3;
-            temp3=temp2;
-            temp2=temp1;
-            temp1=res;
-
-        }
-        return res;
-    }
-
-    //矩阵的方式实现
-    public static int c3(int n){
-        if(n<1)
-            return 0;
-        if(n==1 || n==2 || n==3)
-            return n;
-        int[][] base={{1,1,0},{0,0,1},{1,0,0}};
-        int[][] res = matrixPower(base, n - 3);
-        return 3*res[0][0]+2*res[1][0]+res[2][0];
-    }
-
-
-
-    private static int[][] matrixPower(int[][] base, int p) {
-        int[][]res=new int[base.length][base[0].length];
-        for(int i=0;i<res.length;i++){
-            res[i][i]=1; //单位矩阵
-        }
-        int[][] temp=base;
-        for(;p!=0;p>>=1){
-            if((p & 1)!=0){
-                res=multiMatrix(res,temp);
-            }
-            temp=multiMatrix(temp,temp);
-        }
-        return res;
-
-    }
-
-    //矩阵乘法运算
-    private static int[][] multiMatrix(int[][] m1,int[][]m2){
-        int[][] res=new int[m1.length][m2[0].length];
-        for(int i=0;i<m1.length;i++){
-            for(int j=0;j<m2[0].length;j++){
-                for(int k=0;k<m2.length;k++){
-                    res[i][j]+=m1[i][k]*m2[k][j];
-                }
-            }
-        }
-        return res;
-    }
-
-
-
-
-
-
-    public static void main(String[] args) {
-        int n = 23;
-        System.out.println(f1(n));
-        System.out.println(f2(n));
-        System.out.println(f3(n));
-        System.out.println("===");
-
-        System.out.println(s1(n));
-        System.out.println(s2(n));
-        System.out.println(s3(n));
-        System.out.println("===");
-
-        System.out.println(c1(n));
-        System.out.println(c2(n));
-        System.out.println(c3(n));
-        System.out.println("===");
-
-    }
-
-
-}
Index: src/左神算法/进阶班二/第五章/Code_06_Perfect_Rectangle.java
===================================================================
diff --git a/src/左神算法/进阶班二/第五章/Code_06_Perfect_Rectangle.java b/src/左神算法/进阶班二/第五章/Code_06_Perfect_Rectangle.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第五章/Code_06_Perfect_Rectangle.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,60 +0,0 @@
-package 左神算法.进阶班二.第五章;
-
-import java.util.HashSet;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:假设所有的图形都在第一象限内，
-rectangles = [
-[1,1,3,3],
-[3,1,4,2],
-[3,2,4,4],
-[1,3,2,4],
-[2,3,3,4]
-]
-其中，
-[1,1,3,3]表示第1个矩形左上角的坐标为(1,1)，右下角的坐标为(3,3)
-[3,1,4,2]表示第2个矩形左上角的坐标为(3,1)，右下角的坐标为(4,2)
-...
-按照这种方法可以给你几组矩形，请判断他们能不能正好组成一个完整的大矩形，且没
-有重合的部分。
-完整描述：搜perfect rectangle  https://leetcode-cn.com/problems/perfect-rectangle/
- * @date 2020/2/24 16:05
- */
-public class Code_06_Perfect_Rectangle {
-
-  public static boolean isRectangleCover(int[][] rectangles){
-      if(rectangles.length==0 || rectangles[0].length==0)
-          return false;
-      //用来记记录最后的矩形中x,y的最小值以及最大值
-      int x1=Integer.MAX_VALUE;
-      int x2=Integer.MIN_VALUE;
-      int y1=Integer.MAX_VALUE;
-      int y2=Integer.MIN_VALUE;
-      int area=0;
-      HashSet<String>set=new HashSet<>();
-      for(int[] rec:rectangles){
-          x1=Math.min(x1,rec[0]);
-          x2=Math.max(x2,rec[2]);
-          y1=Math.min(y1,rec[1]);
-          y2=Math.max(y2,rec[3]);
-          area+=(rec[2]-rec[0])*(rec[3]-rec[1]);
-          String s1=rec[0]+"_"+rec[1];
-          String s2=rec[0]+"_"+rec[3];
-          String s3=rec[2]+"_"+rec[1];
-          String s4=rec[2]+"_"+rec[3];
-          if(!set.add(s1)) set.remove(s1);
-          if(!set.add(s2)) set.remove(s2);
-          if(!set.add(s3)) set.remove(s3);
-          if(!set.add(s4)) set.remove(s4);
-
-
-      }
-
-      if(!set.contains(x1+"_"+y1)|| !set.contains(x1+"_"+y2) || !set.contains(x2+"_"+y1)
-              || !set.contains(x2+"_"+y2) || set.size()!=4)
-          return false;
-      return area==(x2-x1)*(y2-y1);
-  }
-}
Index: src/左神算法/进阶班二/第四章/Code_06_SmallestMissNum.java
===================================================================
diff --git a/src/左神算法/进阶班二/第四章/Code_06_SmallestMissNum.java b/src/左神算法/进阶班二/第四章/Code_06_SmallestMissNum.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第四章/Code_06_SmallestMissNum.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,46 +0,0 @@
-package 左神算法.进阶班二.第四章;
-
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
-题目六
-数组中未出现的最小正整数
-【题目】
-给定一个无序整型数组arr，找到数组中未出现的最小正整数。
-【举例】
-arr=[-1,2,3,4]。返回1。
-arr=[1,2,3,4]。返回5。
- * @date 2020/2/21 16:37
- */
-public class Code_06_SmallestMissNum {
-
-    public static int missNum(int[] arr){
-        int l=0;
-        int r=arr.length;
-        while(l<r){
-            if(arr[l]==l+1)
-                l++;
-            else if(arr[l]<=l || arr[l]>r || arr[l]==arr[arr[l]-1] )
-                ////arr[arr[l] - 1] == arr[l]:表示arr中存在1~arr.length的两个两个相同的数
-                arr[l]=arr[--r];
-            else{
-                swap(arr,l,arr[l]-1); //表示1~arr.lenght之间的数大的跑到了前面
-            }
-        }
-        return l+1;
-    }
-
-    private static void swap(int[] arr,int i,int j){
-        int temp=arr[i];
-        arr[i]=arr[j];
-        arr[j]=temp;
-    }
-    public static void main(String[] args) {
-        int[] arr = { -1, 0, 2, 1, 3, 5 };
-        System.out.println(missNum(arr));
-
-    }
-
-}
Index: src/左神算法/进阶班二/第六章/Code_07_RegularExpressionMatch.java
===================================================================
diff --git a/src/左神算法/进阶班二/第六章/Code_07_RegularExpressionMatch.java b/src/左神算法/进阶班二/第六章/Code_07_RegularExpressionMatch.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第六章/Code_07_RegularExpressionMatch.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,23 +0,0 @@
-package 左神算法.进阶班二.第六章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:字符串匹配问题
-【题目】
-给定字符串str，其中绝对不含有字符'.'和'*'。再给定字符串exp，其中可以含有'.'或'*'，'*'
-字符不能是exp的首字符，并且任意两个'*'字符不相邻。exp中的'.'代表任何一个字符，
-exp中的'*'表示'*'的前一个字符可以有0个或者多个。请写一个函数，判断str是否能被exp
-匹配。
-【举例】
-str="abc"，exp="abc"，返回true。
-str="abc"，exp="a.c"，exp中单个'.'可以代表任意字符，所以返回true。
-str="abcd"，exp=".*"。exp中'*'的前一个字符是'.'，所以可表示任意数量的'.'字符，当
-exp是"...."时与"abcd"匹配，返回true。
-str=""，exp="..*"。exp中'*'的前一个字符是'.'，可表示任意数量的'.'字符，但是".*"之前还
-有一个'.'字符，该字符不受'*'的影响，所以str起码有一个字符才能被exp匹配。所以返回
-false。
- * @date 2020/2/28 15:55
- */
-public class Code_07_RegularExpressionMatch {
-}
Index: src/左神算法/进阶班二/第三章/Code_07_ZeroLeftOneStringNumber.java
===================================================================
diff --git a/src/左神算法/进阶班二/第三章/Code_07_ZeroLeftOneStringNumber.java b/src/左神算法/进阶班二/第三章/Code_07_ZeroLeftOneStringNumber.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第三章/Code_07_ZeroLeftOneStringNumber.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,99 +0,0 @@
-package 左神算法.进阶班二.第三章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:【补充题目3】
-0左边必有1的二进制字符串数量
-【题目描述】
-给定一个整数N，求由"0"字符与"1"字符组成的长度为N的所有字符串中，满足"0"字符的左边必有"1"字符的字符
-串数量。
-【举例】
-N=1。只由"0"与"1"组成，长度为1的所有字符串："0"、"1"。只有字符串"1"满足要求，所以返回1。
-N=2。只由"0"与"1"组成，长度为2的所有字符串为："00"、"01"、"10"、"11"。只有字符串"10"和"11"满足要求，
-所以返回2。
-N=3。只由"0"与"1"组成，长度为3的所有字符串为："000"、"001"、"010"、"011"、"100"、"101"、"110"、"111"。
-字符串"101"、"110"、"111"满足要求，所以返回3。
- * @date 2020/2/19 15:02
- */
-public class Code_07_ZeroLeftOneStringNumber {
-
-    public static int getNum1(int n){
-        if(n<1)
-            return 0;
-        return process(1,n);
-    }
-
-    private static int process(int i, int n) { //表示i-1位置为1的情况下，有多少种合法的情况
-        if(n==i)
-            return 1;
-        if(i==n-1)
-            return 2;
-
-        return process(i+1,n)+process(i+2,n);
-    }
-
-    public static int getNum2(int n){
-        if(n<1)
-            return 0;
-        if(n==1 || n==2)
-            return n;
-        int res=2;
-        int pre=1;
-        int tmp=0;
-        for(int i=3;i<=n;i++){
-            tmp=res;
-            res=res+pre;
-            pre=tmp;
-        }
-        return res;
-
-    }
-
-    public static int getNum3(int n){
-        if(n<1)
-            return 0;
-        if(n==1 || n==2)
-            return n;
-        int[][]base={{1,1},{1,0}};
-       int[][] res=MatrixPower(base,n-2);
-       return 2*res[0][0]+res[1][0];
-
-    }
-
-    private static int[][] MatrixPower(int[][] base, int n) {
-        int[][]res=new int[base.length][base.length];
-        for(int i=0;i<base.length;i++){
-            res[i][i]=1;
-        }
-        int[][] temp=base;
-        for(;n!=0;n>>=1){
-            if((n&1)!=0)
-                res=multiMatrix(res,temp);
-            temp=multiMatrix(temp,temp);
-        }
-        return res;
-    }
-
-    private static int[][] multiMatrix(int[][] m1,int[][]m2){
-
-        int[][]res=new int[m1.length][m2[0].length];
-        for(int i=0;i<m1.length;i++){
-            for(int j=0;j<m2[0].length;j++)
-                for(int k=0;k<m2.length;k++){
-                res[i][j]+=m1[i][k]*m2[k][j];
-                }
-        }
-        return res;
-    }
-
-    public static void main(String[] args) {
-        for (int i = 0; i != 20; i++) {
-            System.out.println(getNum1(i));
-            System.out.println(getNum2(i));
-            //System.out.println(getNum3(i));
-            System.out.println("===================");
-        }
-
-    }
-}
Index: src/Gof/decorator/Coffee.java
===================================================================
diff --git a/src/Gof/decorator/Coffee.java b/src/Gof/decorator/Coffee.java
deleted file mode 100644
--- a/src/Gof/decorator/Coffee.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,9 +0,0 @@
-package Gof.decorator;
-
-public class Coffee extends Drink {
-
-    @Override
-    public float cost() {
-        return super.getPrice();
-    }
-}
\ No newline at end of file
Index: src/Gof/mediator/CoffeeMachine.java
===================================================================
diff --git a/src/Gof/mediator/CoffeeMachine.java b/src/Gof/mediator/CoffeeMachine.java
deleted file mode 100644
--- a/src/Gof/mediator/CoffeeMachine.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,27 +0,0 @@
-package Gof.mediator;
-
-public class CoffeeMachine extends Colleague {
-
-    public CoffeeMachine(Mediator mediator, String name) {
-        super(mediator, name);
-        // TODO Auto-generated constructor stub
-        mediator.register(name, this);
-    }
-
-    @Override
-    public void sendMessage(int stateChange) {
-        // TODO Auto-generated method stub
-        this.getMediator().getMessage(this.name,stateChange );
-    }
-
-    public void startCoffee() {
-        System.out.println("It's time to startcoffee!");
-    }
-
-    public void FinishCoffee() {
-
-        System.out.println("After 5 minutes!");
-        System.out.println("Coffee is ok!");
-        sendMessage(0);
-    }
-}
Index: src/左神算法/进阶班一/动态规划与递归/CoinsWay.java
===================================================================
diff --git a/src/左神算法/进阶班一/动态规划与递归/CoinsWay.java b/src/左神算法/进阶班一/动态规划与递归/CoinsWay.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/动态规划与递归/CoinsWay.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,205 +0,0 @@
-package 左神算法.进阶班一.动态规划与递归;
-
-import java.util.HashMap;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 换钱的方法数
- * 给定一个数组arr，arr中所有的值都是正数且不重复。每个值代表一个面值的货币，每种面值的货币可以使用任意张，
- * 再给定一个一个整数aim,代表要找的钱数，求换钱有多少种方法。
- * @date 2020/1/15 14:49
- */
-public class CoinsWay {
-
-    public static int coins1(int[] arr, int aim) {
-        if (arr == null || arr.length == 0 || aim < 0) {
-            return 0;
-        }
-        return process1(arr, 0, aim);
-    }
-    //index:可以任意使用index及其之后所有的钱
-    public static int process1(int[] arr, int index, int aim) {
-        int res = 0;
-        if (index == arr.length) {
-            res = aim == 0 ? 1 : 0;
-        } else {
-            for (int i = 0; arr[index] * i <= aim; i++) { //i表示张数
-                res += process1(arr, index + 1, aim - arr[index] * i);
-            }
-        }
-        return res;
-    }
-
-    //记忆化搜索的方式
-    //K:index_aim
-    //v：返回值
-    public static HashMap<String,Integer> map=new HashMap<>();
-
-    public static int process_map(int[] arr,int index,int aim){
-        int res=0;
-        if(index==arr.length)
-        {
-            return res==aim ? 1:0;
-        }else{
-            for(int i=0;arr[index]*i<=aim;i++){
-                int nextAim=aim-arr[index]*i;
-                String key=String.valueOf(index+1)+"_"+String.valueOf(nextAim);
-                if(map.containsKey(key)){
-                    res+=map.get(key);
-                }else{
-                    res+=process_map(arr,index+1,aim-arr[index]*i);
-                }
-            }
-            map.put(String.valueOf(index)+"_"+String.valueOf(aim),res);
-            return res;
-        }
-    }
-
-
-    public static int coinsOther(int[] arr, int aim) {
-        if (arr == null || arr.length == 0 || aim < 0) {
-            return 0;
-        }
-        return processOther(arr, arr.length - 1, aim);
-    }
-
-    public static int processOther(int[] arr, int index, int aim) {
-        int res = 0;
-        if (index == -1) {
-            res = aim == 0 ? 1 : 0;
-        } else {
-            for (int i = 0; arr[index] * i <= aim; i++) {
-                res += processOther(arr, index - 1, aim - arr[index] * i);
-            }
-        }
-        return res;
-    }
-
-    public static int coins2(int[] arr, int aim) {
-        if (arr == null || arr.length == 0 || aim < 0) {
-            return 0;
-        }
-        int[][] map = new int[arr.length + 1][aim + 1];
-        return process2(arr, 0, aim, map);
-    }
-
-    public static int process2(int[] arr, int index, int aim, int[][] map) {
-        int res = 0;
-        if (index == arr.length) {
-            res = aim == 0 ? 1 : 0;
-        } else {
-            int mapValue = 0;
-            for (int i = 0; arr[index] * i <= aim; i++) {
-                mapValue = map[index + 1][aim - arr[index] * i];
-                if (mapValue != 0) {
-                    res += mapValue == -1 ? 0 : mapValue;
-                } else {
-                    res += process2(arr, index + 1, aim - arr[index] * i, map);
-                }
-            }
-        }
-        map[index][aim] = res == 0 ? -1 : res;
-        return res;
-    }
-
-    public static int coins3(int[] arr, int aim) {
-        if (arr == null || arr.length == 0 || aim < 0) {
-            return 0;
-        }
-        int[][] dp = new int[arr.length][aim + 1];
-        for (int i = 0; i < arr.length; i++) {
-            dp[i][0] = 1;
-        }
-        for (int j = 1; arr[0] * j <= aim; j++) {
-            dp[0][arr[0] * j] = 1;
-        }
-        int num = 0;
-        for (int i = 1; i < arr.length; i++) {
-            for (int j = 1; j <= aim; j++) {
-                num = 0;
-                for (int k = 0; j - arr[i] * k >= 0; k++) {
-                    num += dp[i - 1][j - arr[i] * k];
-                }
-                dp[i][j] = num;
-            }
-        }
-        return dp[arr.length - 1][aim];
-    }
-
-    public static int coins4(int[] arr, int aim) {
-        if (arr == null || arr.length == 0 || aim < 0) {
-            return 0;
-        }
-        int[][] dp = new int[arr.length][aim + 1];
-        for (int i = 0; i < arr.length; i++) {
-            dp[i][0] = 1;
-        }
-        for (int j = 1; arr[0] * j <= aim; j++) {
-            dp[0][arr[0] * j] = 1;
-        }
-        for (int i = 1; i < arr.length; i++) {
-            for (int j = 1; j <= aim; j++) {
-                dp[i][j] = dp[i - 1][j];
-                dp[i][j] += j - arr[i] >= 0 ? dp[i][j - arr[i]] : 0;
-            }
-        }
-        return dp[arr.length - 1][aim];
-    }
-
-    public static int coins5(int[] arr, int aim) {
-        if (arr == null || arr.length == 0 || aim < 0) {
-            return 0;
-        }
-        int[] dp = new int[aim + 1];
-        for (int j = 0; arr[0] * j <= aim; j++) {
-            dp[arr[0] * j] = 1;
-        }
-        for (int i = 1; i < arr.length; i++) {
-            for (int j = 1; j <= aim; j++) {
-                dp[j] += j - arr[i] >= 0 ? dp[j - arr[i]] : 0;
-            }
-        }
-        return dp[aim];
-    }
-
-    public static void main(String[] args) {
-        int[] coins = { 10, 5, 1, 25 };
-        int aim = 2000;
-
-        long start = 0;
-        long end = 0;
-        start = System.currentTimeMillis();
-        System.out.println(coins1(coins, aim));
-        end = System.currentTimeMillis();
-        System.out.println("cost time : " + (end - start) + "(ms)");
-
-        start = System.currentTimeMillis();
-        System.out.println(coinsOther(coins, aim));
-        end = System.currentTimeMillis();
-        System.out.println("cost time : " + (end - start) + "(ms)");
-
-        aim = 20000;
-
-        start = System.currentTimeMillis();
-        System.out.println(coins2(coins, aim));
-        end = System.currentTimeMillis();
-        System.out.println("cost time : " + (end - start) + "(ms)");
-
-        start = System.currentTimeMillis();
-        System.out.println(coins3(coins, aim));
-        end = System.currentTimeMillis();
-        System.out.println("cost time : " + (end - start) + "(ms)");
-
-        start = System.currentTimeMillis();
-        System.out.println(coins4(coins, aim));
-        end = System.currentTimeMillis();
-        System.out.println("cost time : " + (end - start) + "(ms)");
-
-        start = System.currentTimeMillis();
-        System.out.println(coins5(coins, aim));
-        end = System.currentTimeMillis();
-        System.out.println("cost time : " + (end - start) + "(ms)");
-
-    }
-}
Index: src/Gof/mediator/Colleague.java
===================================================================
diff --git a/src/Gof/mediator/Colleague.java b/src/Gof/mediator/Colleague.java
deleted file mode 100644
--- a/src/Gof/mediator/Colleague.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,21 +0,0 @@
-package Gof.mediator;
-
-
-
-public abstract class Colleague {
-
-    private Mediator mediator;
-    public String name;
-
-    public Colleague(Mediator mediator, String name) {
-        this.mediator = mediator;
-        this.name = name;
-    }
-
-    public Mediator getMediator(){
-        return this.mediator;
-    }
-
-    public abstract void sendMessage(int stageChange);
-
-}
Index: src/Gof/composite/College.java
===================================================================
diff --git a/src/Gof/composite/College.java b/src/Gof/composite/College.java
deleted file mode 100644
--- a/src/Gof/composite/College.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,54 +0,0 @@
-package Gof.composite;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class College extends OrganizationComponent{
-
-    //List 中 存放的Department
-    List<OrganizationComponent> organizationComponents = new ArrayList<OrganizationComponent>();
-
-    // 构造器
-    public College(String name, String des) {
-        super(name, des);
-        // TODO Auto-generated constructor stub
-    }
-
-    // 重写add
-    @Override
-    protected void add(OrganizationComponent organizationComponent) {
-        // TODO Auto-generated method stub
-        //  将来实际业务中，Colleage 的 add 和  University add 不一定完全一样
-        organizationComponents.add(organizationComponent);
-    }
-
-    // 重写remove
-    @Override
-    protected void remove(OrganizationComponent organizationComponent) {
-        // TODO Auto-generated method stub
-        organizationComponents.remove(organizationComponent);
-    }
-
-    @Override
-    public String getName() {
-        // TODO Auto-generated method stub
-        return super.getName();
-    }
-
-    @Override
-    public String getDes() {
-        // TODO Auto-generated method stub
-        return super.getDes();
-    }
-
-    // print方法，就是输出University 包含的学院
-    @Override
-    protected void print() {
-        // TODO Auto-generated method stub
-        System.out.println("--------------" + getName() + "--------------");
-        //遍历 organizationComponents
-        for (OrganizationComponent organizationComponent : organizationComponents) {
-            organizationComponent.print();
-        }
-    }
-}
Index: src/Gof/iterator/College.java
===================================================================
diff --git a/src/Gof/iterator/College.java b/src/Gof/iterator/College.java
deleted file mode 100644
--- a/src/Gof/iterator/College.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,11 +0,0 @@
-package Gof.iterator;
-
-public interface College  {
-
-    public String getName();
-
-    public Iterator createIterator();
-
-    public void addDepartment(String name,String desc);
-
-}
Index: src/Gof/responsibilityChain/CollegeApprover.java
===================================================================
diff --git a/src/Gof/responsibilityChain/CollegeApprover.java b/src/Gof/responsibilityChain/CollegeApprover.java
deleted file mode 100644
--- a/src/Gof/responsibilityChain/CollegeApprover.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,19 +0,0 @@
-package Gof.responsibilityChain;
-
-public class CollegeApprover extends Approver{
-
-    public CollegeApprover(String name) {
-        // TODO Auto-generated constructor stub
-        super(name);
-    }
-
-    @Override
-    public void processRequest(PurchaseRequest purchaseRequest) {
-        // TODO Auto-generated method stub
-        if(purchaseRequest.getPrice() < 5000 && purchaseRequest.getPrice() <= 10000) {
-            System.out.println(" 请求编号 id= " + purchaseRequest.getId() + " 被 " + this.name + " 处理");
-        }else {
-            approver.processRequest(purchaseRequest);
-        }
-    }
-}
Index: src/Gof/command/Command.java
===================================================================
diff --git a/src/Gof/command/Command.java b/src/Gof/command/Command.java
deleted file mode 100644
--- a/src/Gof/command/Command.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,7 +0,0 @@
-package Gof.command;
-
-public interface Command {
-
-    void execute();
-    void undo();
-}
Index: src/Gof/Bulider/CommonHouse.java
===================================================================
diff --git a/src/Gof/Bulider/CommonHouse.java b/src/Gof/Bulider/CommonHouse.java
deleted file mode 100644
--- a/src/Gof/Bulider/CommonHouse.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,18 +0,0 @@
-package Gof.Bulider;
-
-public class CommonHouse extends HouseBuilder{
-    @Override
-    public void buildBaise() {
-        System.out.println(" 普通房子打地基5米 ");
-    }
-
-    @Override
-    public void buildWalls() {
-        System.out.println(" 普通房子砌墙10cm ");
-    }
-
-    @Override
-    public void roofed() {
-        System.out.println(" 普通房子屋顶 ");
-    }
-}
Index: src/左神算法/基础班/树/CompleteTreeNodeNumber.java
===================================================================
diff --git a/src/左神算法/基础班/树/CompleteTreeNodeNumber.java b/src/左神算法/基础班/树/CompleteTreeNodeNumber.java
deleted file mode 100644
--- a/src/左神算法/基础班/树/CompleteTreeNodeNumber.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,61 +0,0 @@
-package 左神算法.基础班.树;
-
-/**
- * 已知一颗完全二叉树，求其结点个数，要求时间复杂度低于O（N），N为树的结点的个数
- */
-public class CompleteTreeNodeNumber {
-
-    public static class Node {
-        public int value;
-        public Node left;
-        public Node right;
-
-        public Node(int value) {
-            this.value = value;
-        }
-    }
-    public static int nodeNum(Node head)
-    {
-        if(head==null)
-            return 0;
-        return bs(head,1,mostLeftLevel(head,1));
-    }
-
-    //返回以head为头结点的树的元素的个数
-    //node是当前结点，l是node所在的层数，h是我不管你是第几层，h表示整个树的最大深度
-    public static int bs(Node head,int level,int h)
-    {
-        if(level==h)
-            return 1;
-        if(mostLeftLevel(head.right,level+1)==h)
-        {
-            return (1<<(h-level))+bs(head.right,level+1,h);
-        }else {
-            return (1<<(h-level-1))+bs(head.left,level+1,h);
-        }
-
-    }
-
-    //node为当前结点，level为当前节点在第几层.返回的是node结点最左边的结点所在整棵树中的深度
-    public static int mostLeftLevel(Node node,int level)
-    {
-        Node cur=node ;
-        while(cur!=null)
-        {
-            level++;
-            cur=cur.left;
-        }
-        return level-1;
-    }
-    public static void main(String[] args) {
-        Node head = new Node(1);
-        head.left = new Node(2);
-        head.right = new Node(3);
-        head.left.left = new Node(4);
-        head.left.right = new Node(5);
-        head.right.left = new Node(6);
-        System.out.println(nodeNum(head));
-    }
-
-
-}
Index: src/org/sd/composite/Component.java
===================================================================
diff --git a/src/org/sd/composite/Component.java b/src/org/sd/composite/Component.java
deleted file mode 100644
--- a/src/org/sd/composite/Component.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,18 +0,0 @@
-package org.sd.composite;
-
-
-//抽象组件
-public interface Component {
-    void operation();
-}
-//叶子组件
-interface leaf extends Component
-{
-
-}
-//容器组件
-interface Composite extends Component{
-    void add(Component c);
-    void remove(Component c);
-    Component getChild(int index);
-}
\ No newline at end of file
Index: src/重温设计模式/结构型设计模式/装饰器模式/示例/CompressionDecorator.java
===================================================================
diff --git a/src/重温设计模式/结构型设计模式/装饰器模式/示例/CompressionDecorator.java b/src/重温设计模式/结构型设计模式/装饰器模式/示例/CompressionDecorator.java
deleted file mode 100644
--- a/src/重温设计模式/结构型设计模式/装饰器模式/示例/CompressionDecorator.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,76 +0,0 @@
-package 重温设计模式.结构型设计模式.装饰器模式.示例;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.Base64;
-import java.util.zip.Deflater;
-import java.util.zip.DeflaterOutputStream;
-import java.util.zip.InflaterInputStream;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 压缩装饰
- * @date 2021/5/13 14:10
- */
-public class CompressionDecorator extends DataSourceDecorator {
-
-    private int compLevel = 6;
-
-    public CompressionDecorator(DataSource source) {
-        super(source);
-    }
-
-    public int getCompressionLevel() {
-        return compLevel;
-    }
-
-    public void setCompressionLevel(int value) {
-        compLevel = value;
-    }
-
-    @Override
-    public void writeData(String data) {
-        super.writeData(compress(data));
-    }
-
-    @Override
-    public String readData() {
-        return decompress(super.readData());
-    }
-
-    private String compress(String stringData) {
-        byte[] data = stringData.getBytes();
-        try {
-            ByteArrayOutputStream bout = new ByteArrayOutputStream(512);
-            DeflaterOutputStream dos = new DeflaterOutputStream(bout, new Deflater(compLevel));
-            dos.write(data);
-            dos.close();
-            bout.close();
-            return Base64.getEncoder().encodeToString(bout.toByteArray());
-        } catch (IOException ex) {
-            return null;
-        }
-    }
-
-    private String decompress(String stringData) {
-        byte[] data = Base64.getDecoder().decode(stringData);
-        try {
-            InputStream in = new ByteArrayInputStream(data);
-            InflaterInputStream iin = new InflaterInputStream(in);
-            ByteArrayOutputStream bout = new ByteArrayOutputStream(512);
-            int b;
-            while ((b = iin.read()) != -1) {
-                bout.write(b);
-            }
-            in.close();
-            iin.close();
-            bout.close();
-            return new String(bout.toByteArray());
-        } catch (IOException ex) {
-            return null;
-        }
-    }
-}
Index: src/org/sd/bridge/Computer.java
===================================================================
diff --git a/src/org/sd/bridge/Computer.java b/src/org/sd/bridge/Computer.java
deleted file mode 100644
--- a/src/org/sd/bridge/Computer.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,38 +0,0 @@
-package org.sd.bridge;
-
-import javax.sound.midi.SoundbankResource;
-
-public class Computer {
-     protected  Brand brand;
-    public  Computer(Brand b)
-    {this.brand=b;}
-    public  void sale()
-    {
-        brand.sale();
-    }
-}
-class Desktop extends Computer{
-    public Desktop(Brand b)
-    {
-        super(b);
-    }
-
-    @Override
-    public void sale() {
-        super.sale();
-        System.out.println("销售台式机");
-    }
-}
-class Laptop extends Computer
-{
-    public  Laptop(Brand b)
-    {
-        super(b);
-    }
-
-    @Override
-    public void sale() {
-        super.sale();
-        System.out.println("销售笔记本");
-    }
-}
\ No newline at end of file
Index: src/Gof/iterator/ComputerCollege.java
===================================================================
diff --git a/src/Gof/iterator/ComputerCollege.java b/src/Gof/iterator/ComputerCollege.java
deleted file mode 100644
--- a/src/Gof/iterator/ComputerCollege.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,31 +0,0 @@
-package Gof.iterator;
-
-public class ComputerCollege implements College{
-
-    Department[] departments;
-    int numOfDepartment=0;//保存当前数组的对象个数
-
-    public ComputerCollege() {
-        departments=new Department[5];
-        addDepartment("java","java");
-        addDepartment("PHP","PHP");
-        addDepartment("math","math");
-    }
-
-    @Override
-    public String getName() {
-        return "计算机学院";
-    }
-
-    @Override
-    public Iterator createIterator() {
-       return  new ComputerCollegeIterator(departments);
-    }
-
-    @Override
-    public void addDepartment(String name, String desc) {
-        Department department=new Department(name,desc);
-        departments[numOfDepartment]=department;
-        numOfDepartment++;
-    }
-}
Index: src/Gof/iterator/ComputerCollegeIterator.java
===================================================================
diff --git a/src/Gof/iterator/ComputerCollegeIterator.java b/src/Gof/iterator/ComputerCollegeIterator.java
deleted file mode 100644
--- a/src/Gof/iterator/ComputerCollegeIterator.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,31 +0,0 @@
-package Gof.iterator;
-
-public class ComputerCollegeIterator implements Iterator {
-
-    Department[] departments;
-    int position=0;//遍历的位置
-
-    public ComputerCollegeIterator(Department[] departments) {
-        this.departments = departments;
-    }
-
-    @Override
-    public boolean hasNext() {
-        if(position>=departments.length || departments[position]==null)
-            return false;
-        else
-            return true;
-    }
-
-    @Override
-    public Object next() {
-       Department department=departments[position];
-       position++;
-       return  department;
-    }
-
-    @Override
-    public void remove() {
-
-    }
-}
Index: src/Gof/mediator/ConcreteMediator.java
===================================================================
diff --git a/src/Gof/mediator/ConcreteMediator.java b/src/Gof/mediator/ConcreteMediator.java
deleted file mode 100644
--- a/src/Gof/mediator/ConcreteMediator.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,46 +0,0 @@
-package Gof.mediator;
-
-import java.util.HashMap;
-
-public class ConcreteMediator extends Mediator {
-
-   private HashMap<String,Object> colleagueMap;
-   private HashMap<String,String> interMap;
-
-    public ConcreteMediator() {
-       colleagueMap=new HashMap<>();
-       interMap=new HashMap<>();
-    }
-
-    @Override
-    public void register(String colleagueName, Colleague colleague) {
-        colleagueMap.put(colleagueName,colleague);
-
-        if(colleague instanceof Alarm)
-            interMap.put("Alarm",colleagueName);
-        else if (colleague instanceof CoffeeMachine) {
-            interMap.put("CoffeeMachine", colleagueName);
-        }
-        else if (colleague instanceof Curtains) {
-            interMap.put("Curtains", colleagueName);
-        }
-
-    }
-
-    @Override
-    public void getMessage(String colleagueName, int stateChange) {
-
-        if(colleagueMap.get(colleagueName) instanceof Alarm)
-        {
-            if(stateChange==0){
-                ((CoffeeMachine) (colleagueMap.get(interMap
-                        .get("CoffeeMachine")))).startCoffee();
-            }
-        }
-    }
-
-    @Override
-    public void sendMessage() {
-
-    }
-}
Index: src/Gof/flyweight/ConcreteWebSite.java
===================================================================
diff --git a/src/Gof/flyweight/ConcreteWebSite.java b/src/Gof/flyweight/ConcreteWebSite.java
deleted file mode 100644
--- a/src/Gof/flyweight/ConcreteWebSite.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,16 +0,0 @@
-package Gof.flyweight;
-
-public class ConcreteWebSite extends WebSite{
-
-    //共享部分，内部状态
-    private String type="";
-
-    public ConcreteWebSite(String type) {
-        this.type = type;
-    }
-
-    @Override
-    public void use(User user) {
-        System.out.println("网站的发布形式为:" + type + " 在使用中 .. 使用者是" + user.getName());
-    }
-}
Index: src/JUC/demo2/ConditionDemo.java
===================================================================
diff --git a/src/JUC/demo2/ConditionDemo.java b/src/JUC/demo2/ConditionDemo.java
deleted file mode 100644
--- a/src/JUC/demo2/ConditionDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,108 +0,0 @@
-package JUC.demo2;
-
-import java.util.concurrent.locks.Condition;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-
-class ShareData{
-    private int number=1;//标志位，用来控制哪个线程来执行
-    private Lock lock=new ReentrantLock();
-    Condition c1=lock.newCondition();
-    Condition c2=lock.newCondition();
-    Condition c3=lock.newCondition();
-
-    public void print5()
-    {
-        lock.lock();
-        try{
-            while(number!=1)
-            {
-                c1.await();
-
-            }
-
-            for(int i=0;i<5;i++)
-            {
-                System.out.println(Thread.currentThread().getName()+"\t"+i );
-            }
-
-            number=2;
-            c2.signal();
-        } catch (InterruptedException e) {
-            e.printStackTrace();
-        }finally {
-            lock.unlock();
-        }
-    }
-
-    public void print10()
-    {
-        lock.lock();
-        try{
-            while(number!=2)
-            {
-                c2.await();
-
-            }
-
-            for(int i=0;i<10;i++)
-            {
-                System.out.println(Thread.currentThread().getName()+"\t"+i );
-            }
-
-            number=3;
-            c3.signal();
-        } catch (InterruptedException e) {
-            e.printStackTrace();
-        }finally {
-            lock.unlock();
-        }
-    }
-
-    public void print15()
-    {
-        lock.lock();
-        try{
-            while(number!=3)
-            {
-                c3.await();
-
-            }
-
-            for(int i=0;i<15;i++)
-            {
-                System.out.println(Thread.currentThread().getName()+"\t"+i );
-            }
-
-            number=1;
-            c1.signal();
-        } catch (InterruptedException e) {
-            e.printStackTrace();
-        }finally {
-            lock.unlock();
-        }
-    }
-}
-
-/**
- * 多个线程之间按顺序调用，实现A->B-C
- *
- */
-public class ConditionDemo {
-
-    public static void main(String[] args) {
-        ShareData shareData=new ShareData();
-        new Thread(()->{
-            for(int i=0;i<5;i++)
-                shareData.print5();
-        },"AA").start();
-        new Thread(()->{
-            for(int i=0;i<5;i++)
-                shareData.print10();
-        },"BB").start();
-        new Thread(()->{
-            for(int i=0;i<5;i++)
-                shareData.print15();
-        },"CC").start();
-    }
-}
Index: src/org/sd/FlyWeight/Coordinate.java
===================================================================
diff --git a/src/org/sd/FlyWeight/Coordinate.java b/src/org/sd/FlyWeight/Coordinate.java
deleted file mode 100644
--- a/src/org/sd/FlyWeight/Coordinate.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,26 +0,0 @@
-package org.sd.FlyWeight;
-
-public class Coordinate {
-    private int x,y;
-
-    public Coordinate(int x, int y) {
-        this.x = x;
-        this.y = y;
-    }
-
-    public int getX() {
-        return x;
-    }
-
-    public void setX(int x) {
-        this.x = x;
-    }
-
-    public int getY() {
-        return y;
-    }
-
-    public void setY(int y) {
-        this.y = y;
-    }
-}
Index: src/左神算法/高频面试题/CopyList.java
===================================================================
diff --git a/src/左神算法/高频面试题/CopyList.java b/src/左神算法/高频面试题/CopyList.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/CopyList.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,132 +0,0 @@
-package 左神算法.高频面试题;
-
-import java.util.HashMap;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:  实现对一个特殊链表的拷贝
- * @date 2020/1/5 10:30
- */
-public class CopyList {
-
-    public static class Node{
-        public int data;
-        public Node next;
-        public Node random;
-
-        public Node(int data) {
-            this.data = data;
-        }
-    }
-
-
-    //通过hashmap的方式来拷贝
-    public static Node copy1(Node head){
-        HashMap<Node,Node>map=new HashMap<>();
-        Node cur=head;
-        while(cur!=null){
-            map.put(cur,new Node(cur.data));
-            cur=cur.next;
-        }
-        cur=head;
-        while(cur!=null){
-            map.get(cur).next=map.get(cur.next);
-            map.get(cur).random=map.get(cur.random);
-            cur=cur.next;
-        }
-        return map.get(head);
-    }
-
-    //非map的方法
-    public static Node copy2(Node head){
-        Node cur=head;
-        Node next=null;
-        if(head==null){
-            return null;
-        }
-        while(cur!=null){
-            next=cur.next;
-            Node node=new Node(cur.data);
-            cur.next=node;
-            node.next=next;
-            cur=next;
-
-        }
-        Node copy=null;
-        cur=head;
-        while(cur!=null){
-            next=cur.next.next;
-            copy=cur.next;
-            copy.random=cur.random!=null?cur.random.next:null;//注意判断是否为null
-            cur=next;
-        }
-        //split
-        Node res=head.next;
-        cur=head;
-        while(cur!=null){
-            next=cur.next.next;
-            copy=cur.next;
-            copy.next=next!=null ? next.next:null;//注意这里要判断是否为空
-            cur.next=next;//断开连接
-            cur=next;
-        }
-        return res;
-    }
-
-    public static void printRandLinkedList(CopyList.Node head)
-    {
-        CopyList.Node cur=head;
-        System.out.print("order: ");
-        while(cur!=null)
-        {
-            System.out.print(cur.data+"\t");
-            cur=cur.next;
-        }
-        System.out.println();
-        cur=head;
-        System.out.print("rand: ");
-        while(cur!=null)
-        {
-            System.out.print(cur.random==null? "-":cur.random.data+"\t");
-            cur=cur.next;
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-        CopyList.Node head = null;
-        CopyList.Node res1 = null;
-        CopyList.Node res2 = null;
-        printRandLinkedList(head);
-        res1 = copy1(head);
-        printRandLinkedList(res1);
-        res2 = copy2(head);
-        printRandLinkedList(res2);
-        printRandLinkedList(head);
-        System.out.println("=========================");
-
-        head = new CopyList.Node(1);
-        head.next = new CopyList.Node(2);
-        head.next.next = new CopyList.Node(3);
-        head.next.next.next = new CopyList.Node(4);
-        head.next.next.next.next = new CopyList.Node(5);
-        head.next.next.next.next.next = new CopyList.Node(6);
-
-        head.random = head.next.next.next.next.next; // 1 -> 6
-        head.next.random = head.next.next.next.next.next; // 2 -> 6
-        head.next.next.random = head.next.next.next.next; // 3 -> 5
-        head.next.next.next.random = head.next.next; // 4 -> 3
-        head.next.next.next.next.random = null; // 5 -> null
-        head.next.next.next.next.next.random = head.next.next.next; // 6 -> 4
-
-        printRandLinkedList(head);
-        res1 = copy1(head);
-        printRandLinkedList(res1);
-        res2 = copy2(head);
-        printRandLinkedList(res2);
-        printRandLinkedList(head);
-        System.out.println("=========================");
-
-    }
-}
Index: src/左神算法/基础班/第三课/CopyListWithRandom.java
===================================================================
diff --git a/src/左神算法/基础班/第三课/CopyListWithRandom.java b/src/左神算法/基础班/第三课/CopyListWithRandom.java
deleted file mode 100644
--- a/src/左神算法/基础班/第三课/CopyListWithRandom.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,146 +0,0 @@
-package 左神算法.基础班.第三课;
-
-import java.util.HashMap;
-
-/**
- * 实现链表的拷贝
- */
-public class CopyListWithRandom {
-
-    public static class Node {
-        public int value;
-        public Node next;
-        public Node rand;
-
-        public Node(int data) {
-            this.value = data;
-        }
-    }
-
-    //放入一个hashmap，找对应关系
-    public static Node copyListWithRand1(Node head){
-        //借助map进行复制
-        if(head==null)
-            return null;
-        if( head.next==null) {
-            Node newHead= new Node(head.value);
-            newHead.rand=head.rand!=null ? newHead:null;
-        }
-
-        HashMap<Node,Node>map=new HashMap<>();
-        Node cur=head;
-        while(cur!=null)
-        {
-            map.put(cur,new Node(cur.value));
-            cur=cur.next;
-        }
-        cur=head;
-        while(cur!=null)
-        {
-            map.get(cur).next=map.get(cur.next);
-            map.get(cur).rand=map.get(cur.rand);
-            cur=cur.next;
-        }
-        return map.get(head);
-    }
-    public static Node copyListWithRand2(Node head){
-
-         if(head==null)
-         {
-             return null;
-         }
-        Node cur=head;
-        Node next=null;
-        //copy node and link
-        while(cur!=null)
-        {
-            next=cur.next;
-            Node node=new Node(cur.value);
-            node.next=cur.next;
-            cur.next=node;
-            cur=next;
-        }
-        cur=head;
-        Node curCopy=null;
-
-        //set copyNode rand
-        while(cur!=null)
-        {
-            next=cur.next.next;
-            curCopy=cur.next;
-            curCopy.rand=cur.rand!=null?cur.rand.next:null;//注意判断是否为null
-            cur=next;
-        }
-        Node res=head.next;
-        cur=head;
-        //split              cur.next=next;//断开连接
-        while(cur!=null)
-        {
-            next=cur.next.next;
-            curCopy=cur.next;
-            cur.next=next;//断开连接
-            curCopy.next=next!=null?next.next:null;//注意判断是否为null,将复制的结点连接起来
-            cur=next;
-
-        }
-        return res;
-
-    }
-
-    public static void printRandLinkedList(Node head)
-    {
-        Node cur=head;
-        System.out.print("order: ");
-        while(cur!=null)
-        {
-            System.out.print(cur.value+"\t");
-            cur=cur.next;
-        }
-        System.out.println();
-        cur=head;
-        System.out.print("rand: ");
-        while(cur!=null)
-        {
-            System.out.print(cur.rand==null? "-":cur.rand.value+"\t");
-            cur=cur.next;
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-        Node head = null;
-        Node res1 = null;
-        Node res2 = null;
-        printRandLinkedList(head);
-        res1 = copyListWithRand1(head);
-        printRandLinkedList(res1);
-        res2 = copyListWithRand2(head);
-        printRandLinkedList(res2);
-        printRandLinkedList(head);
-        System.out.println("=========================");
-
-        head = new Node(1);
-        head.next = new Node(2);
-        head.next.next = new Node(3);
-        head.next.next.next = new Node(4);
-        head.next.next.next.next = new Node(5);
-        head.next.next.next.next.next = new Node(6);
-
-        head.rand = head.next.next.next.next.next; // 1 -> 6
-        head.next.rand = head.next.next.next.next.next; // 2 -> 6
-        head.next.next.rand = head.next.next.next.next; // 3 -> 5
-        head.next.next.next.rand = head.next.next; // 4 -> 3
-        head.next.next.next.next.rand = null; // 5 -> null
-        head.next.next.next.next.next.rand = head.next.next.next; // 6 -> 4
-
-        printRandLinkedList(head);
-        res1 = copyListWithRand1(head);
-        printRandLinkedList(res1);
-        res2 = copyListWithRand2(head);
-        printRandLinkedList(res2);
-        printRandLinkedList(head);
-        System.out.println("=========================");
-
-    }
-
-}
Index: .idea/libraries/core_3_1_0.xml
===================================================================
diff --git a/.idea/libraries/core_3_1_0.xml b/.idea/libraries/core_3_1_0.xml
deleted file mode 100644
--- a/.idea/libraries/core_3_1_0.xml	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,10 +0,0 @@
-<component name="libraryTable">
-  <library name="core-3.1.0">
-    <CLASSES>
-      <root url="jar://$PROJECT_DIR$/src/lib/core-3.1.0.jar!/" />
-      <root url="jar://$PROJECT_DIR$/src/lib/javase-3.1.0.jar!/" />
-    </CLASSES>
-    <JAVADOC />
-    <SOURCES />
-  </library>
-</component>
\ No newline at end of file
Index: .idea/libraries/core_3_3_0.xml
===================================================================
diff --git a/.idea/libraries/core_3_3_0.xml b/.idea/libraries/core_3_3_0.xml
deleted file mode 100644
--- a/.idea/libraries/core_3_3_0.xml	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,7 +0,0 @@
-<component name="libraryTable">
-  <library name="core-3.3.0">
-    <CLASSES />
-    <JAVADOC />
-    <SOURCES />
-  </library>
-</component>
\ No newline at end of file
Index: .idea/libraries/core_3_3_0__2_.xml
===================================================================
diff --git a/.idea/libraries/core_3_3_0__2_.xml b/.idea/libraries/core_3_3_0__2_.xml
deleted file mode 100644
--- a/.idea/libraries/core_3_3_0__2_.xml	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,7 +0,0 @@
-<component name="libraryTable">
-  <library name="core-3.3.0 (2)">
-    <CLASSES />
-    <JAVADOC />
-    <SOURCES />
-  </library>
-</component>
\ No newline at end of file
Index: src/JUC/CoutDownLatchDemo/CountDownLatchDemo.java
===================================================================
diff --git a/src/JUC/CoutDownLatchDemo/CountDownLatchDemo.java b/src/JUC/CoutDownLatchDemo/CountDownLatchDemo.java
deleted file mode 100644
--- a/src/JUC/CoutDownLatchDemo/CountDownLatchDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,25 +0,0 @@
-package JUC.CoutDownLatchDemo;
-
-import java.util.concurrent.CountDownLatch;
-
-public class CountDownLatchDemo {
-
-    public static void closeDoor() throws InterruptedException {
-        CountDownLatch countDownLatch=new CountDownLatch(6);
-        for(int i=1;i<7;i++)
-        {
-            new Thread(()->{
-                System.out.println(Thread.currentThread().getName()+"\t 国，被灭");
-                countDownLatch.countDown();
-            },CountryEnum.forEach(i).getName()).start();
-        }
-        countDownLatch.await();
-        System.out.println("秦统一");
-    }
-    public static void main(String[] args) throws InterruptedException {
-       closeDoor();
-        System.out.println(CountryEnum.ONE);
-        System.out.println(CountryEnum.ONE.getCode());
-        System.out.println(CountryEnum.ONE.getName());
-    }
-}
Index: src/JUC/CoutDownLatchDemo/CountryEnum.java
===================================================================
diff --git a/src/JUC/CoutDownLatchDemo/CountryEnum.java b/src/JUC/CoutDownLatchDemo/CountryEnum.java
deleted file mode 100644
--- a/src/JUC/CoutDownLatchDemo/CountryEnum.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,47 +0,0 @@
-package JUC.CoutDownLatchDemo;
-
-public enum CountryEnum {
-
-    ONE(1,"齐"),
-    TWO(2,"楚"),
-    THREE(3,"燕"),
-    FOUR(4,"赵"),
-    FIVE(5,"魏"),
-    SIX(6,"韩");
-
-    CountryEnum(Integer code,String name)
-    {
-        this.code=code;
-        this.name=name;
-    }
-
-
-    private Integer code;
-    private String name;
-
-    public Integer getCode() {
-        return code;
-    }
-
-    public void setCode(Integer code) {
-        this.code = code;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-     public static CountryEnum forEach(int index) {
-         CountryEnum[] countryEnums = CountryEnum.values();//返回枚举数组
-         for (CountryEnum countryEnum : countryEnums) {
-             if (index == countryEnum.getCode())
-                 return countryEnum;
-         }
-         return null;
-     }
-
-}
Index: src/左神算法/基础班/动态规划与递归/Cow.java
===================================================================
diff --git a/src/左神算法/基础班/动态规划与递归/Cow.java b/src/左神算法/基础班/动态规划与递归/Cow.java
deleted file mode 100644
--- a/src/左神算法/基础班/动态规划与递归/Cow.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,39 +0,0 @@
-package 左神算法.基础班.动态规划与递归;
-
-/**
- * 母牛每年生一个母牛，新出生的母牛成长三年后也能每年生一只母牛，假设不会死，求N年后，母牛的数量
- */
-public class Cow {
-
-    //自己多写出几年的情况，找规律,
-    public static int cowNumber(int n)
-    {
-        if(n<1)return 0;
-        if(n==1 || n==2 || n==3)
-            return n;
-        return cowNumber(n-1)+cowNumber(n-3);
-    }
-    //非递归的写法
-    public static int cowNumber2(int n)
-    {
-        if(n<1) return 0;
-        if(n==1 || n==2 || n==3)
-            return n;
-        int res=3;
-        int pre=2;
-        int prepre=1;
-        int temp1=0;
-        int temp2=0;
-        for(int i=4;i<=n;i++){
-            temp1=res;//保存一下当前的值
-            temp2=pre;
-            res=res+prepre;
-            pre=temp1;
-            prepre=temp2;
-        }
-        return res;
-    }
-    public static void main(String[] args) {
-        System.out.println(cowNumber(5));
-    }
-}
Index: src/Gof/mediator/Curtains.java
===================================================================
diff --git a/src/Gof/mediator/Curtains.java b/src/Gof/mediator/Curtains.java
deleted file mode 100644
--- a/src/Gof/mediator/Curtains.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,19 +0,0 @@
-package Gof.mediator;
-
-public class Curtains extends Colleague {
-    public Curtains(Mediator mediator, String name) {
-        super(mediator, name);
-        // TODO Auto-generated constructor stub
-        mediator.register(name, this);
-    }
-
-    @Override
-    public void sendMessage(int stateChange) {
-        // TODO Auto-generated method stub
-        this.getMediator().getMessage(this.name,stateChange);
-    }
-
-    public void UpCurtains() {
-        System.out.println("I am holding Up Curtains!");
-    }
-}
Index: src/JUC/CyclicBarrierDemo/CyclicBarrierDemo.java
===================================================================
diff --git a/src/JUC/CyclicBarrierDemo/CyclicBarrierDemo.java b/src/JUC/CyclicBarrierDemo/CyclicBarrierDemo.java
deleted file mode 100644
--- a/src/JUC/CyclicBarrierDemo/CyclicBarrierDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,29 +0,0 @@
-package JUC.CyclicBarrierDemo;
-
-import java.util.concurrent.BrokenBarrierException;
-import java.util.concurrent.CyclicBarrier;
-
-public class CyclicBarrierDemo {
-
-    public static void main(String[] args) {
-
-        CyclicBarrier cyclicBarrier=new CyclicBarrier(7,()->{
-            System.out.println(Thread.currentThread().getName()+"集齐龙珠，召唤神龙");
-        });
-        for(int i=1;i<=7;i++)
-        {
-           final int temp=i;//用于lambda表达式中
-          new Thread(()->{
-              System.out.println(Thread.currentThread().getName()+"\t得到第"+temp+"颗龙珠");
-              try {
-                  cyclicBarrier.await();
-              } catch (InterruptedException e) {
-                  e.printStackTrace();
-              } catch (BrokenBarrierException e) {
-                  e.printStackTrace();
-              }
-          },String.valueOf(i)).start();
-        }
-
-    }
-}
Index: src/重温设计模式/其他模式/Future模式/Data.java
===================================================================
diff --git a/src/重温设计模式/其他模式/Future模式/Data.java b/src/重温设计模式/其他模式/Future模式/Data.java
deleted file mode 100644
--- a/src/重温设计模式/其他模式/Future模式/Data.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,12 +0,0 @@
-package 重温设计模式.其他模式.Future模式;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/19 13:10
- */
-public interface Data {
-
-    String getResult();
-}
Index: src/重温设计模式/结构型设计模式/装饰器模式/示例/DataSource.java
===================================================================
diff --git a/src/重温设计模式/结构型设计模式/装饰器模式/示例/DataSource.java b/src/重温设计模式/结构型设计模式/装饰器模式/示例/DataSource.java
deleted file mode 100644
--- a/src/重温设计模式/结构型设计模式/装饰器模式/示例/DataSource.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,13 +0,0 @@
-package 重温设计模式.结构型设计模式.装饰器模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 定义了读和写的通用数据接口
- * @date 2021/5/13 13:57
- */
-public interface DataSource {
-
-    void writeData(String str);
-    String readData();
-}
Index: src/重温设计模式/结构型设计模式/装饰器模式/示例/DataSourceDecorator.java
===================================================================
diff --git a/src/重温设计模式/结构型设计模式/装饰器模式/示例/DataSourceDecorator.java b/src/重温设计模式/结构型设计模式/装饰器模式/示例/DataSourceDecorator.java
deleted file mode 100644
--- a/src/重温设计模式/结构型设计模式/装饰器模式/示例/DataSourceDecorator.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,26 +0,0 @@
-package 重温设计模式.结构型设计模式.装饰器模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 抽象基础封装
- * @date 2021/5/13 14:02
- */
-public class DataSourceDecorator implements DataSource{
-
-    private DataSource wrappee;
-
-    public DataSourceDecorator(DataSource wrappee){
-        this.wrappee = wrappee;
-    }
-
-    @Override
-    public void writeData(String str) {
-        wrappee.writeData(str);
-    }
-
-    @Override
-    public String readData() {
-        return wrappee.readData();
-    }
-}
Index: src/JUC/DeadLockDemo/DeadLockDemo.java
===================================================================
diff --git a/src/JUC/DeadLockDemo/DeadLockDemo.java b/src/JUC/DeadLockDemo/DeadLockDemo.java
deleted file mode 100644
--- a/src/JUC/DeadLockDemo/DeadLockDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,42 +0,0 @@
-package JUC.DeadLockDemo;
-
-import java.util.concurrent.TimeUnit;
-
-class HoldThread implements Runnable{
-
-   private String lockA;
-   private String lockB;
-
-    public HoldThread(String lockA, String lockB) {
-        this.lockA = lockA;
-        this.lockB = lockB;
-    }
-
-    @Override
-    public void run() {
-      synchronized (lockA)
-      {
-          System.out.println(Thread.currentThread().getName()+"\t自己持有锁"+lockA+"尝试获得锁"+lockB);
-          try {
-              TimeUnit.SECONDS.sleep(1);
-          } catch (InterruptedException e) {
-              e.printStackTrace();
-          }
-          synchronized (lockB)
-          {
-              System.out.println(Thread.currentThread().getName()+"\t自己持有锁"+lockB+"尝试获得"+lockA);
-          }
-      }
-    }
-}
-public class DeadLockDemo {
-
-    public static void main(String[] args) {
-        String lockA="lockA";
-        String lockB="lockB";
-        new Thread(new HoldThread(lockA, lockB),"threadAAA").start();
-        new Thread(new HoldThread(lockB, lockA),"threadBBB").start();
-
-
-    }
-}
Index: src/JUC/DeadLockDemo/DeadLockDemo2.java
===================================================================
diff --git a/src/JUC/DeadLockDemo/DeadLockDemo2.java b/src/JUC/DeadLockDemo/DeadLockDemo2.java
deleted file mode 100644
--- a/src/JUC/DeadLockDemo/DeadLockDemo2.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,50 +0,0 @@
-package JUC.DeadLockDemo;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2020/3/22 18:26
- */
-public class DeadLockDemo2 implements Runnable {
-
-    private Account account1;
-    private Account account2;
-    private int count;
-
-    public DeadLockDemo2(Account account1, Account account2, int count) {
-        this.account1 = account1;
-        this.account2 = account2;
-        this.count = count;
-    }
-
-    @Override
-    public void run() {
-        synchronized (account1){
-            try {
-                Thread.sleep(1000);
-            } catch (InterruptedException e) {
-                e.printStackTrace();
-            }
-            synchronized (account2){
-                account1.money-=count;
-                account2.money-=count;
-                System.out.println(account1.money);
-                System.out.println(account2.money);
-            }
-        }
-    }
-
-
-    public static class Account{
-        private int money;
-    }
-
-
-    public static void main(String[] args) {
-        Account account1=new Account();
-        Account account2=new Account();
-        new Thread(new DeadLockDemo2(account1,account2,10),"thread1").start();;
-        new Thread(new DeadLockDemo2(account2,account1,10),"thread2").start();
-    }
-}
Index: src/Gof/decorator/Decorator.java
===================================================================
diff --git a/src/Gof/decorator/Decorator.java b/src/Gof/decorator/Decorator.java
deleted file mode 100644
--- a/src/Gof/decorator/Decorator.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,21 +0,0 @@
-package Gof.decorator;
-
-public class Decorator extends Drink{
-
-    public Drink drink;
-    public Decorator(Drink drink)
-    {
-        this.drink=drink;
-    }
-
-    @Override
-    public float cost() {
-        return super.getPrice()+drink.cost();
-    }
-
-    @Override
-    public String getDes() {
-        return des +" "+getPrice()+" && "+drink.getDes();
-
-    }
-}
Index: src/Gof/Prototype/DeepCopyChild.java
===================================================================
diff --git a/src/Gof/Prototype/DeepCopyChild.java b/src/Gof/Prototype/DeepCopyChild.java
deleted file mode 100644
--- a/src/Gof/Prototype/DeepCopyChild.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,36 +0,0 @@
-package Gof.Prototype;
-
-import java.io.Serializable;
-
-public class DeepCopyChild implements Serializable,Cloneable {
-    String name;
-     int age;
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    public int getAge() {
-        return age;
-    }
-
-    public void setAge(int age) {
-        this.age = age;
-    }
-
-    public DeepCopyChild(String name, int age) {
-        this.name = name;
-        this.age = age;
-    }
-
-
-
-    @Override
-    protected DeepCopyChild clone() throws CloneNotSupportedException {
-        return (DeepCopyChild) super.clone();
-    }
-}
Index: src/Gof/Prototype/deepCopyDemo.java
===================================================================
diff --git a/src/Gof/Prototype/deepCopyDemo.java b/src/Gof/Prototype/deepCopyDemo.java
deleted file mode 100644
--- a/src/Gof/Prototype/deepCopyDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,19 +0,0 @@
-package Gof.Prototype;
-
-public class deepCopyDemo {
-    public static void main(String[] args) throws CloneNotSupportedException {
-        DeepCopyChild deepCopyChild=new DeepCopyChild("zs",12);
-        DeepCopyParent deepCopyParent=new DeepCopyParent("man", deepCopyChild);
-        DeepCopyParent deepCopyParent1=deepCopyParent.clone();
-        DeepCopyParent deepCopyParent2=deepCopyParent.clone();
-        DeepCopyParent deepCopyParent3=deepCopyParent.clone();
-        DeepCopyParent deepCopyParent4=deepCopyParent.clone();
-        System.out.println(deepCopyParent);
-        System.out.println(deepCopyParent1);
-        System.out.println(deepCopyParent2);
-        System.out.println(deepCopyParent3);
-
-
-
-    }
-}
Index: src/Gof/Prototype/DeepCopyParent.java
===================================================================
diff --git a/src/Gof/Prototype/DeepCopyParent.java b/src/Gof/Prototype/DeepCopyParent.java
deleted file mode 100644
--- a/src/Gof/Prototype/DeepCopyParent.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,71 +0,0 @@
-package Gof.Prototype;
-
-import com.sun.org.apache.regexp.internal.RE;
-
-import java.io.*;
-
-public class DeepCopyParent implements Serializable,Cloneable{
-    String sex;
-    DeepCopyChild deepCopyChild;
-
-    public String getSex() {
-        return sex;
-    }
-
-    public void setSex(String sex) {
-        this.sex = sex;
-    }
-
-    public DeepCopyParent(String sex, DeepCopyChild deepCopyChild) {
-        this.sex = sex;
-        this.deepCopyChild = deepCopyChild;
-    }
-
-    @Override
-    public String toString() {
-        return "DeepCopyParent{" +
-                "sex='" + sex + '\'' +
-                ", deepCopyChild=" + deepCopyChild +
-                '}';
-    }
-
-
-    protected DeepCopyParent clone1() throws CloneNotSupportedException {
-        ByteArrayOutputStream bao=null;
-        ObjectOutputStream oos=null;
-        ByteArrayInputStream bis=null;
-        ObjectInputStream ois=null;
-        try {
-               bao=new ByteArrayOutputStream();
-              oos=new ObjectOutputStream(bao);
-             oos.writeObject(this);
-            bis=new ByteArrayInputStream(bao.toByteArray());
-              ois=new ObjectInputStream(bis);
-             Object object = ois.readObject();
-             return (DeepCopyParent) object;
-        } catch (Exception e) {
-            e.printStackTrace();
-            return null;
-        }finally {
-            try {
-                bao.close();
-                oos.close();
-                bis.close();
-                ois.close();
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-
-        }
-
-    }
-
-    protected DeepCopyParent clone() throws CloneNotSupportedException {
-       DeepCopyParent deepCopyParent=null;
-        deepCopyParent =(DeepCopyParent) super.clone();
-        //对引用类型单独处理
-        deepCopyParent.deepCopyChild=deepCopyChild.clone();
-        return deepCopyParent;
-
-    }
-}
Index: src/剑指offer牛客上没有的题目/DeleteLinkedNode.java
===================================================================
diff --git a/src/剑指offer牛客上没有的题目/DeleteLinkedNode.java b/src/剑指offer牛客上没有的题目/DeleteLinkedNode.java
deleted file mode 100644
--- a/src/剑指offer牛客上没有的题目/DeleteLinkedNode.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,32 +0,0 @@
-package 剑指offer牛客上没有的题目;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定链表的头指针和一个结点指针，在O(1)时间删除该结点
- * @date 2020/3/29 11:49
- */
-public class DeleteLinkedNode {
-
-    public static class Node{
-        private int val;
-        private Node next;
-        public  Node(int val){
-            this.val=val;
-        }
-    }
-    public static void delete(Node head,Node del){
-        if(head==null) return;
-        if(head==del) head=head.next;
-        if(del.next!=null){
-            del.val=del.next.val;
-            del.next=del.next.next;
-        }else{
-            Node temp=head;
-            while(temp.next.next==null){
-                temp=temp.next;
-            }
-            temp.next=null;
-        }
-    }
-}
Index: src/重温设计模式/其他模式/Future模式/Demo.java
===================================================================
diff --git a/src/重温设计模式/其他模式/Future模式/Demo.java b/src/重温设计模式/其他模式/Future模式/Demo.java
deleted file mode 100644
--- a/src/重温设计模式/其他模式/Future模式/Demo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,28 +0,0 @@
-package 重温设计模式.其他模式.Future模式;
-
-import sun.util.cldr.CLDRLocaleDataMetaInfo;
-import 重温设计模式.行为模式.责任链模式.示例.ThrottlingMiddleware;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/19 13:10
- */
-public class Demo {
-
-    public static void main(String[] args) {
-        Client client = new Client();
-        Data data = client.request("name");
-        System.out.println("请求完毕");
-        try{
-            //这里可以用一个sleep代替了对其他业务逻辑的处理
-            //在处理这些业务逻辑的过程中，RealData被创建，从而充分利用了等待时间
-            Thread.sleep(2000);
-        } catch (InterruptedException e) {
-            e.printStackTrace();
-        }
-        //使用真实的数据，如果到这里数据还没有准备好，getResult()会等待数据准备完，再返回
-        System.out.println("数据 = " + data.getResult());
-    }
-}
Index: src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/Demo.java
===================================================================
diff --git a/src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/Demo.java b/src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/Demo.java
deleted file mode 100644
--- a/src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/Demo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,10 +0,0 @@
-package 重温设计模式.创建型模式.工厂模式.工厂方法模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/18 21:07
- */
-public class Demo {
-}
Index: src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/Demo.java
===================================================================
diff --git a/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/Demo.java b/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/Demo.java
deleted file mode 100644
--- a/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/Demo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,14 +0,0 @@
-package 重温设计模式.创建型模式.工厂模式.抽象工厂模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/19 16:51
- */
-public class Demo {
-
-    public static void main(String[] args) {
-        System.out.println("abb".compareTo("b"));
-    }
-}
Index: src/重温设计模式/结构型设计模式/外观模式/示例/Demo.java
===================================================================
diff --git a/src/重温设计模式/结构型设计模式/外观模式/示例/Demo.java b/src/重温设计模式/结构型设计模式/外观模式/示例/Demo.java
deleted file mode 100644
--- a/src/重温设计模式/结构型设计模式/外观模式/示例/Demo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,10 +0,0 @@
-package 重温设计模式.结构型设计模式.外观模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/20 14:02
- */
-public class Demo {
-}
Index: src/重温设计模式/结构型设计模式/装饰器模式/示例/Demo.java
===================================================================
diff --git a/src/重温设计模式/结构型设计模式/装饰器模式/示例/Demo.java b/src/重温设计模式/结构型设计模式/装饰器模式/示例/Demo.java
deleted file mode 100644
--- a/src/重温设计模式/结构型设计模式/装饰器模式/示例/Demo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,26 +0,0 @@
-package 重温设计模式.结构型设计模式.装饰器模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/13 13:56
- */
-public class Demo {
-
-    public static void main(String[] args) {
-        String test = "Name,Salary\nJohn Smith,100000\nSteven Jobs,912000";
-        DataSourceDecorator encoded = new CompressionDecorator(new EncryptionDecorator(new FileDataSource("test.txt")));
-        encoded.writeData(test);
-
-        DataSource plain = new FileDataSource("test.txt");
-
-        System.out.println("- Input ----------------");
-        System.out.println(test);
-        System.out.println("- Encoded --------------");
-        System.out.println(plain.readData());
-        System.out.println("- Decoded --------------");
-        System.out.println(encoded.readData());
-
-    }
-}
Index: src/重温设计模式/行为模式/模版方法模式/示例/Demo.java
===================================================================
diff --git a/src/重温设计模式/行为模式/模版方法模式/示例/Demo.java b/src/重温设计模式/行为模式/模版方法模式/示例/Demo.java
deleted file mode 100644
--- a/src/重温设计模式/行为模式/模版方法模式/示例/Demo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,11 +0,0 @@
-package 重温设计模式.行为模式.模版方法模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/9 17:27
- */
-public class Demo {
-
-}
Index: src/重温设计模式/行为模式/策略模式/示例/Demo.java
===================================================================
diff --git a/src/重温设计模式/行为模式/策略模式/示例/Demo.java b/src/重温设计模式/行为模式/策略模式/示例/Demo.java
deleted file mode 100644
--- a/src/重温设计模式/行为模式/策略模式/示例/Demo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,14 +0,0 @@
-package 重温设计模式.行为模式.策略模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/8 22:28
- */
-public class Demo {
-
-    public static void main(String[] args) {
-
-    }
-}
Index: src/重温设计模式/行为模式/观察者模式/示例/Demo.java
===================================================================
diff --git a/src/重温设计模式/行为模式/观察者模式/示例/Demo.java b/src/重温设计模式/行为模式/观察者模式/示例/Demo.java
deleted file mode 100644
--- a/src/重温设计模式/行为模式/观察者模式/示例/Demo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,23 +0,0 @@
-package 重温设计模式.行为模式.观察者模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/8 16:42
- */
-public class Demo {
-
-    public static void main(String[] args) {
-        Editor editor = new Editor();
-        editor.managers.subscribe("open", new LogOpenListener("/path/to/log/file.txt"));
-        editor.managers.subscribe("save", new EmailNotificationListener("admin@example.com"));
-
-        try {
-            editor.openFile("test.txt");
-            editor.saveFile();
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-    }
-}
Index: src/重温设计模式/行为模式/责任链模式/示例/Demo.java
===================================================================
diff --git a/src/重温设计模式/行为模式/责任链模式/示例/Demo.java b/src/重温设计模式/行为模式/责任链模式/示例/Demo.java
deleted file mode 100644
--- a/src/重温设计模式/行为模式/责任链模式/示例/Demo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,49 +0,0 @@
-package 重温设计模式.行为模式.责任链模式.示例;
-
-import Gof.flyweight.User;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:本例与许多作者给出的该模式的标准版本有些不同。 绝大多数模式示例都会寻找正确的处理者，
- * 并在处理后退出链。 但在这里我们会执行每个处理者， 直至某个处理者无法处理请求。 请注意， 尽管流程略有不同，
- * 但这仍是责任链模式。
- * @date 2021/5/14 21:33
- */
-public class Demo {
-
-    private static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
-    private static Server server;
-
-
-
-    public static void init() {
-        server = new Server();
-        server.register("admin@example.com", "admin_pass");
-        server.register("user@example.com", "user_pass");
-
-        Middleware middleware = new ThrottlingMiddleware(2)
-                .linkedWith(new UserExistsMiddleware(server))
-                .linkedWith(new RoleCheckMiddleware());
-
-        server.setMiddleware(middleware);
-
-    }
-
-    public static void main(String[] args) throws IOException {
-        init();
-        boolean success;
-        do{
-            System.out.print("Enter email: ");
-            String email = reader.readLine();
-            System.out.print("Input password: ");
-            String password = reader.readLine();
-            success = server.logIn(email, password);
-        }while(!success);
-    }
-
-}
Index: src/org/sd/Demo1.java
===================================================================
diff --git a/src/org/sd/Demo1.java b/src/org/sd/Demo1.java
deleted file mode 100644
--- a/src/org/sd/Demo1.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,56 +0,0 @@
-package org.sd;
-
-import com.sun.org.apache.bcel.internal.classfile.ClassParser;
-import com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;
-import javassist.*;
-
-import java.io.IOException;
-import java.lang.reflect.Method;
-import java.util.Arrays;
-
-public class Demo1 {
-    public static void main(String[] args) throws Exception {
-
-     //test01();
-     //test02();
-
-        Parent a=new Parent();
-        Parent[][] b=new Parent[2][1];
-        System.out.println(b.getClass());
-
-
-    }
-    public static void test01() throws NotFoundException, IOException, CannotCompileException {
-        ClassPool pool= ClassPool.getDefault();
-        CtClass cc=pool.get("org.sd.Emp");
-        byte[] bytes=cc.toBytecode();
-        System.out.println(Arrays.toString(bytes));
-        System.out.println(cc.getName());
-        System.out.println(cc.getSimpleName());
-        System.out.println(cc.getSuperclass());
-        System.out.println(cc.getInterfaces());
-    }
-
-    public static void test02() throws Exception {
-        ClassPool pool = ClassPool.getDefault();
-        CtClass cc = pool.get("org.sd.Emp");
-        CtMethod m=new CtMethod(CtClass.intType,"add",new CtClass[]{CtClass.intType,CtClass.intType},cc);
-        m.setModifiers(Modifier.PUBLIC);
-        m.setBody("{System.out.println(\"ss\");returun $1+$2}");
-        cc.addMethod(m);
-
-        //通过反射调用新生成的方法
-        Class clazz=cc.toClass();
-        Object obj=clazz.newInstance();
-        Method method=clazz.getDeclaredMethod("add",int.class,int.class);
-        Object result=method.invoke(obj,200,200);
-        System.out.println(result);
-
-
-    }
-}
-class Parent{
-    static{
-        System.out.println("helleo");
-    }
-        }
Index: src/面试相关/面试之出奇制胜策略/Demo1.java
===================================================================
diff --git a/src/面试相关/面试之出奇制胜策略/Demo1.java b/src/面试相关/面试之出奇制胜策略/Demo1.java
deleted file mode 100644
--- a/src/面试相关/面试之出奇制胜策略/Demo1.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,20 +0,0 @@
-package 面试相关.面试之出奇制胜策略;
-
-import java.util.Objects;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2020/2/15 9:18
- */
-public class Demo1 {
-
-    public static void main(String[] args) {
-        String str="abc";
-        //判断str是否等于abc的写法
-        System.out.println(str.equals("abc"));//最普遍的写法
-        System.out.println("abc".equals(str));//建议写法一
-        System.out.println(Objects.equals(str,"abc"));//建议写法二
-    }
-}
Index: src/Gof/composite/Department.java
===================================================================
diff --git a/src/Gof/composite/Department.java b/src/Gof/composite/Department.java
deleted file mode 100644
--- a/src/Gof/composite/Department.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,33 +0,0 @@
-package Gof.composite;
-
-public class Department extends OrganizationComponent {
-
-
-    //没有集合
-
-    public Department(String name, String des) {
-        super(name, des);
-        // TODO Auto-generated constructor stub
-    }
-
-
-    //add , remove 就不用写了，因为他是叶子节点
-
-    @Override
-    public String getName() {
-        // TODO Auto-generated method stub
-        return super.getName();
-    }
-
-    @Override
-    public String getDes() {
-        // TODO Auto-generated method stub
-        return super.getDes();
-    }
-
-    @Override
-    protected void print() {
-        // TODO Auto-generated method stub
-        System.out.println(getName());
-    }
-}
Index: src/Gof/iterator/Department.java
===================================================================
diff --git a/src/Gof/iterator/Department.java b/src/Gof/iterator/Department.java
deleted file mode 100644
--- a/src/Gof/iterator/Department.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,28 +0,0 @@
-package Gof.iterator;
-
-public class Department {
-
-    private String name;
-    private String desc;
-
-    public Department(String name, String desc) {
-        this.name = name;
-        this.desc = desc;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    public String getDesc() {
-        return desc;
-    }
-
-    public void setDesc(String desc) {
-        this.desc = desc;
-    }
-}
Index: src/org/sd/mediator/Department.java
===================================================================
diff --git a/src/org/sd/mediator/Department.java b/src/org/sd/mediator/Department.java
deleted file mode 100644
--- a/src/org/sd/mediator/Department.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,6 +0,0 @@
-package org.sd.mediator;
-
-public interface Department {
-    void selfAction();
-    void outAction();
-}
Index: src/Gof/responsibilityChain/DepartmentApprover.java
===================================================================
diff --git a/src/Gof/responsibilityChain/DepartmentApprover.java b/src/Gof/responsibilityChain/DepartmentApprover.java
deleted file mode 100644
--- a/src/Gof/responsibilityChain/DepartmentApprover.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,20 +0,0 @@
-package Gof.responsibilityChain;
-
-public class DepartmentApprover extends Approver {
-
-
-    public DepartmentApprover(String name)
-    {
-        super(name);
-    }
-
-    @Override
-    public void processRequest(PurchaseRequest purchaseRequest) {
-        if(purchaseRequest.getPrice() <= 5000) {
-            System.out.println(" 请求编号 id= " + purchaseRequest.getId() + " 被 " + this.name + " 处理");
-        }else {
-            approver.processRequest(purchaseRequest);
-        }
-    }
-
-}
Index: src/左神算法/基础班/第四课/DescendantNode.java
===================================================================
diff --git a/src/左神算法/基础班/第四课/DescendantNode.java b/src/左神算法/基础班/第四课/DescendantNode.java
deleted file mode 100644
--- a/src/左神算法/基础班/第四课/DescendantNode.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,93 +0,0 @@
-package 左神算法.基础班.第四课;
-
-public class DescendantNode {
-
-    public static class Node{
-        Node right;
-        Node left;
-        Node parent;
-        int value;
-        public Node(int data)
-        {
-            this.value=data;
-        }
-    }
-
-
-    public static Node getNextNode(Node node)
-    {
-        if(node==null)
-            return null;
-        //存在左孩子
-        if(node.right!=null)
-        {
-            return getLeftMost(node);
-        }else
-        {
-            Node parent =node.parent;
-            while(parent!=null && parent.left!=node)
-            {   //一直往上找
-                node=node.parent;
-                parent=node.parent;
-            }
-            return parent;
-        }
-    }
-
-    public static Node getLeftMost(Node node)
-    {
-        if(node==null)
-            return node;
-        //一直找到他的最左边的结点
-        while (node.left!=null)
-        {
-            node=node.left;
-        }
-        return node;
-    }
-
-    public static void main(String[] args) {
-        Node head = new Node(6);
-        head.parent = null;
-        head.left = new Node(3);
-        head.left.parent = head;
-        head.left.left = new Node(1);
-        head.left.left.parent = head.left;
-        head.left.left.right = new Node(2);
-        head.left.left.right.parent = head.left.left;
-        head.left.right = new Node(4);
-        head.left.right.parent = head.left;
-        head.left.right.right = new Node(5);
-        head.left.right.right.parent = head.left.right;
-        head.right = new Node(9);
-        head.right.parent = head;
-        head.right.left = new Node(8);
-        head.right.left.parent = head.right;
-        head.right.left.left = new Node(7);
-        head.right.left.left.parent = head.right.left;
-        head.right.right = new Node(10);
-        head.right.right.parent = head.right;
-
-        Node test = head.left.left;
-        System.out.println(test.value + " next: " + getNextNode(test).value);
-        test = head.left.left.right;
-        System.out.println(test.value + " next: " + getNextNode(test).value);
-        test = head.left;
-        System.out.println(test.value + " next: " + getNextNode(test).value);
-        test = head.left.right;
-        System.out.println(test.value + " next: " + getNextNode(test).value);
-        test = head.left.right.right;
-        System.out.println(test.value + " next: " + getNextNode(test).value);
-        test = head;
-        System.out.println(test.value + " next: " + getNextNode(test).value);
-        test = head.right.left.left;
-        System.out.println(test.value + " next: " + getNextNode(test).value);
-        test = head.right.left;
-        System.out.println(test.value + " next: " + getNextNode(test).value);
-        test = head.right;
-        System.out.println(test.value + " next: " + getNextNode(test).value);
-        test = head.right.right; // 10's next is null
-        System.out.println(test.value + " next: " + getNextNode(test));
-    }
-
-}
Index: src/org/sd/mediator/Development.java
===================================================================
diff --git a/src/org/sd/mediator/Development.java b/src/org/sd/mediator/Development.java
deleted file mode 100644
--- a/src/org/sd/mediator/Development.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,22 +0,0 @@
-package org.sd.mediator;
-
-public class Development implements Department {
-
-    private Mediator m;
-    public Development(Mediator m)
-    {
-        super();
-        this.m=m;
-        m.register("development",this);
-    }
-
-    @Override
-    public void selfAction() {
-        System.out.println("专心科研，开发项目！");
-    }
-
-    @Override
-    public void outAction() {
-        System.out.println("汇报工作！没钱了，需要资金支持！！");
-    }
-}
Index: src/左神算法/基础班/图/DFS.java
===================================================================
diff --git a/src/左神算法/基础班/图/DFS.java b/src/左神算法/基础班/图/DFS.java
deleted file mode 100644
--- a/src/左神算法/基础班/图/DFS.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,33 +0,0 @@
-package 左神算法.基础班.图;
-
-import java.util.HashSet;
-import java.util.Stack;
-
-public class DFS {
-
-    public static void dfs(Node node){
-        if(node==null)
-            return;
-        Stack<Node>stacks=new Stack<>();
-        HashSet<Node>sets=new HashSet<>();
-        stacks.push(node);
-        sets.add(node);
-        System.out.println(node.value);
-        while(!stacks.isEmpty())
-        {
-            Node cur = stacks.pop();
-            for(Node next:cur.nexts)
-            {
-                if(!sets.contains(next))
-                {
-                    stacks.push(cur);
-                    stacks.push(next);
-                    sets.add(next);
-                    System.out.println(next.value);
-                    break;
-                }
-            }
-
-        }
-    }
-}
Index: src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/Dialog.java
===================================================================
diff --git a/src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/Dialog.java b/src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/Dialog.java
deleted file mode 100644
--- a/src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/Dialog.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,22 +0,0 @@
-package 重温设计模式.创建型模式.工厂模式.工厂方法模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 基础建造者。
- * @date 2021/5/18 21:09
- */
-public abstract class Dialog {
-    public void renderWindow() {
-        // ... other code ...
-
-        Button okButton = createButton();
-        okButton.render();
-    }
-
-    /**
-     * 工厂方法
-     * @return
-     */
-    abstract Button createButton();
-}
Index: src/韩顺平算法与数据结构/algorithm/Dijkstra/DijkstraAlgorithm.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/algorithm/Dijkstra/DijkstraAlgorithm.java b/src/韩顺平算法与数据结构/algorithm/Dijkstra/DijkstraAlgorithm.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/algorithm/Dijkstra/DijkstraAlgorithm.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,198 +0,0 @@
-package 韩顺平算法与数据结构.algorithm.Dijkstra;
-
-import java.util.Arrays;
-
-public class DijkstraAlgorithm {
-
-    public static void main(String[] args) {
-        char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
-        //邻接矩阵
-        int[][] matrix = new int[vertex.length][vertex.length];
-        final int N = 65535;// 表示不可以连接
-        matrix[0]=new int[]{N,5,7,N,N,N,2};
-        matrix[1]=new int[]{5,N,N,9,N,N,3};
-        matrix[2]=new int[]{7,N,N,N,8,N,N};
-        matrix[3]=new int[]{N,9,N,N,N,4,N};
-        matrix[4]=new int[]{N,N,8,N,N,5,4};
-        matrix[5]=new int[]{N,N,N,4,5,N,6};
-        matrix[6]=new int[]{2,3,N,N,4,6,N};
-        //创建 Graph对象
-        Graph graph = new Graph(vertex, matrix);
-        //测试, 看看图的邻接矩阵是否ok
-        graph.showGraph();
-        //测试迪杰斯特拉算法
-        graph.dsj(6);//C
-        graph.showDijkstra();
-
-
-    }
-
-}
-
-class Graph {
-    private char[] vertex; // 顶点数组
-    private int[][] matrix; // 邻接矩阵
-    private VisitedVertex vv; //已经访问的顶点的集合
-
-    // 构造器
-    public Graph(char[] vertex, int[][] matrix) {
-        this.vertex = vertex;
-        this.matrix = matrix;
-    }
-
-    //显示结果
-    public void showDijkstra() {
-        vv.show();
-    }
-
-    // 显示图
-    public void showGraph() {
-        for (int[] link : matrix) {
-            System.out.println(Arrays.toString(link));
-        }
-    }
-
-    //迪杰斯特拉算法实现
-    /**
-     *
-     * @param index 表示出发顶点对应的下标
-     */
-    public void dsj(int index) {
-        vv = new VisitedVertex(vertex.length, index);
-        update(index);//更新index顶点到周围顶点的距离和前驱顶点
-        for(int j = 1; j <vertex.length; j++) {
-            index = vv.updateArr();// 选择并返回新的访问顶点
-            update(index); // 更新index顶点到周围顶点的距离和前驱顶点
-        }
-    }
-
-
-
-    //更新index下标顶点到周围顶点的距离和周围顶点的前驱顶点,
-    private void update(int index) {
-        int len = 0;
-        //根据遍历我们的邻接矩阵的  matrix[index]行
-        for(int j = 0; j < matrix[index].length; j++) {
-            // len 含义是 : 出发顶点到index顶点的距离 + 从index顶点到j顶点的距离的和
-            len = vv.getDis(index) + matrix[index][j];
-            // 如果j顶点没有被访问过，并且 len 小于出发顶点到j顶点的距离，就需要更新
-            if(!vv.in(j) && len < vv.getDis(j)) {
-                vv.updatePre(j, index); //更新j顶点的前驱为index顶点
-                vv.updateDis(j, len); //更新出发顶点到j顶点的距离
-            }
-        }
-    }
-}
-
-// 已访问顶点集合
-class VisitedVertex {
-    // 记录各个顶点是否访问过 1表示访问过,0未访问,会动态更新
-    public int[] already_arr;
-    // 每个下标对应的值为前一个顶点下标, 会动态更新
-    public int[] pre_visited;
-    // 记录出发顶点到其他所有顶点的距离,比如G为出发顶点，就会记录G到其它顶点的距离，会动态更新，求的最短距离就会存放到dis
-    public int[] dis;
-
-    //构造器
-    /**
-     *
-     * @param length :表示顶点的个数
-     * @param index: 出发顶点对应的下标, 比如G顶点，下标就是6
-     */
-    public VisitedVertex(int length, int index) {
-        this.already_arr = new int[length];
-        this.pre_visited = new int[length];
-        this.dis = new int[length];
-        //初始化 dis数组
-        Arrays.fill(dis, 65535);
-        this.already_arr[index] = 1; //设置出发顶点被访问过
-        this.dis[index] = 0;//设置出发顶点的访问距离为0
-
-    }
-    /**
-     * 功能: 判断index顶点是否被访问过
-     * @param index
-     * @return 如果访问过，就返回true, 否则访问false
-     */
-    public boolean in(int index) {
-        return already_arr[index] == 1;
-    }
-
-    /**
-     * 功能: 更新出发顶点到index顶点的距离
-     * @param index
-     * @param len
-     */
-    public void updateDis(int index, int len) {
-        dis[index] = len;
-    }
-    /**
-     * 功能: 更新pre这个顶点的前驱顶点为index顶点
-     * @param pre
-     * @param index
-     */
-    public void updatePre(int pre, int index) {
-        pre_visited[pre] = index;
-    }
-    /**
-     * 功能:返回出发顶点到index顶点的距离
-     * @param index
-     */
-    public int getDis(int index) {
-        return dis[index];
-    }
-
-
-    /**
-     * 继续选择并返回新的访问顶点， 比如这里的G 完后，就是 A点作为新的访问顶点(注意不是出发顶点)
-     * @return
-     */
-    public int updateArr() {
-        int min = 65535, index = 0;
-        for(int i = 0; i < already_arr.length; i++) {
-            if(already_arr[i] == 0 && dis[i] < min ) {
-                min = dis[i];
-                index = i;
-            }
-        }
-        //更新 index 顶点被访问过
-        already_arr[index] = 1;
-        return index;
-    }
-
-    //显示最后的结果
-    //即将三个数组的情况输出
-    public void show() {
-
-        System.out.println("==========================");
-        //输出already_arr
-        for(int i : already_arr) {
-            System.out.print(i + " ");
-        }
-        System.out.println();
-        //输出pre_visited
-        for(int i : pre_visited) {
-            System.out.print(i + " ");
-        }
-        System.out.println();
-        //输出dis
-        for(int i : dis) {
-            System.out.print(i + " ");
-        }
-        System.out.println();
-        //为了好看最后的最短距离，我们处理
-        char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
-        int count = 0;
-        for (int i : dis) {
-            if (i != 65535) {
-                System.out.print(vertex[count] + "("+i+") ");
-            } else {
-                System.out.println("N ");
-            }
-            count++;
-        }
-        System.out.println();
-
-    }
-
-}
\ No newline at end of file
Index: src/JUC/Directbuffermemory/DirectBufferMemory.java
===================================================================
diff --git a/src/JUC/Directbuffermemory/DirectBufferMemory.java b/src/JUC/Directbuffermemory/DirectBufferMemory.java
deleted file mode 100644
--- a/src/JUC/Directbuffermemory/DirectBufferMemory.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,11 +0,0 @@
-package JUC.Directbuffermemory;
-
-import java.nio.ByteBuffer;
-
-public class DirectBufferMemory {
-
-    public static void main(String[] args) {
-        System.out.println("配置的maxDirectMemory:"+(sun.misc.VM.maxDirectMemory()/(double)1024/1024)+"MB");
-        ByteBuffer.allocateDirect(6*1024*1024);
-    }
-}
Index: src/org/sd/chainofR/Director.java
===================================================================
diff --git a/src/org/sd/chainofR/Director.java b/src/org/sd/chainofR/Director.java
deleted file mode 100644
--- a/src/org/sd/chainofR/Director.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,18 +0,0 @@
-package org.sd.chainofR;
-
-public class Director extends Leader {
-    public Director(String name)
-    {
-        super(name);
-    }
-    public void handleRequest(LeaveRequest request) {
-        if (request.getLeaveDays() < 3) {
-            System.out.println("员工：" + request.getEmpName() + "请假，天数：" + request.getLeaveDays() + ",理由：" + request.getReason());
-            System.out.println("主任：" + this.name + ",审批通过！");
-        } else {
-            if (this.nextLeader != null) {
-                this.nextLeader.handleRequest(request);
-            }
-        }
-
-    }}
\ No newline at end of file
Index: src/Gof/state/DispenseOutState.java
===================================================================
diff --git a/src/Gof/state/DispenseOutState.java b/src/Gof/state/DispenseOutState.java
deleted file mode 100644
--- a/src/Gof/state/DispenseOutState.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,27 +0,0 @@
-package Gof.state;
-
-public class DispenseOutState implements State{
-
-    RaffleActivity activity;
-
-    public DispenseOutState(RaffleActivity activity) {
-        this.activity = activity;
-    }
-
-    @Override
-    public void deductMoney() {
-        System.out.println("奖品领完了，请下次参加");
-    }
-
-    @Override
-    public boolean raffle() {
-        System.out.println("奖品发送完了，请下次再参加");
-        return false;
-    }
-
-    @Override
-    public void dispensePrize() {
-        System.out.println("奖品发送完了，请下次再参加");
-
-    }
-}
Index: src/Gof/state/DispenseState.java
===================================================================
diff --git a/src/Gof/state/DispenseState.java b/src/Gof/state/DispenseState.java
deleted file mode 100644
--- a/src/Gof/state/DispenseState.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,34 +0,0 @@
-package Gof.state;
-
-public class DispenseState implements State{
-
-    RaffleActivity activity;
-
-    public DispenseState(RaffleActivity activity) {
-        this.activity = activity;
-    }
-
-    @Override
-    public void deductMoney() {
-        System.out.println("不能扣除积分");
-    }
-
-    @Override
-    public boolean raffle() {
-        System.out.println("不能抽奖");
-        return false;
-    }
-
-    @Override
-    public void dispensePrize() {
-      if(activity.getCount()>0)
-      {
-          System.out.println("恭喜中奖了");
-          activity.setState(activity.getNoRaffleState());
-      }else{
-          System.out.println("很遗憾奖品领完了");
-          activity.setState(activity.getDispenseOutState());
-          System.exit(0);
-      }
-    }
-}
Index: src/xml/parse/Dog.java
===================================================================
diff --git a/src/xml/parse/Dog.java b/src/xml/parse/Dog.java
deleted file mode 100644
--- a/src/xml/parse/Dog.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,44 +0,0 @@
-package xml.parse;
-//
-public class Dog {
-    private int score;
-    private int level;
-    private String name;
-    private int id;
-
-    public int getId() {
-        return id;
-    }
-
-    public void setId(int id) {
-        this.id = id;
-    }
-
-    public Dog() {
-
-    }
-
-    public int getScore() {
-        return score;
-    }
-
-    public void setScore(int score) {
-        this.score = score;
-    }
-
-    public int getLevel() {
-        return level;
-    }
-
-    public void setLevel(int level) {
-        this.level = level;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-}
Index: out/production/exercise2/xml/parse/dogs.xml
===================================================================
diff --git a/out/production/exercise2/xml/parse/dogs.xml b/out/production/exercise2/xml/parse/dogs.xml
deleted file mode 100644
--- a/out/production/exercise2/xml/parse/dogs.xml	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,19 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" ?>
-<dogs>
-    <dog id="1">
-        <name>yaya1</name>
-        <score>99</score>
-        <level>2</level>
-    </dog>
-    <dog id="2">
-        <name>yaya1</name>
-        <score>100</score>
-        <level>22</level>
-    </dog>
-    <dog id="3">
-        <name>yaya3</name>
-        <score>93</score>
-        <level>3</level>
-    </dog>
-
-</dogs>
\ No newline at end of file
Index: src/xml/parse/dogs.xml
===================================================================
diff --git a/src/xml/parse/dogs.xml b/src/xml/parse/dogs.xml
deleted file mode 100644
--- a/src/xml/parse/dogs.xml	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,19 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" ?>
-<dogs>
-    <dog id="1">
-        <name>yaya1</name>
-        <score>99</score>
-        <level>2</level>
-    </dog>
-    <dog id="2">
-        <name>yaya1</name>
-        <score>100</score>
-        <level>22</level>
-    </dog>
-    <dog id="3">
-        <name>yaya3</name>
-        <score>93</score>
-        <level>3</level>
-    </dog>
-
-</dogs>
\ No newline at end of file
Index: src/韩顺平算法与数据结构/datastructure/list/DoubleLinkedListDemo.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/list/DoubleLinkedListDemo.java b/src/韩顺平算法与数据结构/datastructure/list/DoubleLinkedListDemo.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/list/DoubleLinkedListDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,185 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.list;
-
-public class DoubleLinkedListDemo {
-    public static void main(String[] args) {
-        HeroNode2 hero1 = new HeroNode2(1, "宋江", "及时雨");
-        HeroNode2 hero2 = new HeroNode2(2, "卢俊义", "玉麒麟");
-        HeroNode2 hero3 = new HeroNode2(3, "吴用", "智多星");
-        HeroNode2 hero4 = new HeroNode2(4, "林冲", "豹子头");
-        HeroNode2 hero5 = new HeroNode2(5, "林冲", "豹子头");
-
-        // 创建一个双向链表
-        SingleLinkedList2 doubleLinkedList = new SingleLinkedList2();
-        doubleLinkedList.addByOrder(hero5);
-        doubleLinkedList.addByOrder(hero3);
-        doubleLinkedList.addByOrder(hero1);
-        doubleLinkedList.addByOrder(hero2);
-        doubleLinkedList.addByOrder(hero4);
-        doubleLinkedList.addByOrder(hero5);
-
-
-        doubleLinkedList.list();
-//
-//        HeroNode2 newHeroNode = new HeroNode2(4, "公孙胜", "入云龙");
-//        doubleLinkedList.updata(newHeroNode);
-//        System.out.println("修改后的链表情况");
-//        doubleLinkedList.list();
-//        // 删除
-//        doubleLinkedList.delete(3);
-//        System.out.println("删除后的链表情况~~");
-//        doubleLinkedList.list();
-    }
-}
-
-
-class SingleLinkedList2 {
-    //先初始化一个头结点，头结点不要动，不存放具体的数据
-    private HeroNode2 head = new HeroNode2(0, " ", " ");
-
-    //获取头结点
-    public HeroNode2 getHead() {
-        return head;
-    }
-
-    //依次添加新的结点
-
-    public void add(HeroNode2 heroNode) {
-        HeroNode2 temp = head;
-        while (true) {
-            if (temp.next == null) {
-                break;
-            } else {
-                temp = temp.next;
-            }
-        }
-        temp.next = heroNode;
-        heroNode.pre = temp;
-    }
-
-    //插入指定位置,找到插入结点的后一个结点
-    public void addByOrder(HeroNode2 heroNode) {
-
-        HeroNode2 temp = head;
-        boolean flag = false;//flag标志添加的编号是否存在，默认为false
-        while (true) {
-            if (temp.next == null) {
-                break;
-            }
-            if (temp.next.no > heroNode.no) //找到插入的位置，
-            {
-                break;
-            } else if (temp.next.no == heroNode.no) {
-                flag = true;
-                break;
-            }
-            temp = temp.next;
-        }
-        if (flag) {
-            System.out.println("准备插入的结点已经存在");
-
-        } else {
-            if(temp.next!=null)
-            {
-               temp.next.pre=heroNode;
-               heroNode.next=temp.next;
-               temp.next=heroNode;
-               heroNode.pre=temp;
-            }else
-            {
-                temp.next=heroNode;
-                heroNode.pre=temp;
-            }
-        }
-    }
-
-    //根据no来修改结点，即，结点的no值不能修改
-    public void updata(HeroNode2 heroNode) {
-        //判断是否为空
-        if (head.next == null) {
-            System.out.println("链表为空");
-            return;
-        }
-        HeroNode2 temp = head.next;
-        boolean flag = false;//用来判断是否找到了要修改的结点
-        while (true) {
-            if (temp == null)//说明要修改的结点不存在
-            {
-                break;
-            }
-            if (temp.no == heroNode.no)//已经找到了
-            {
-                flag = true;
-                break;
-            }
-            temp = temp.next;
-        }
-        if (flag) {
-            temp.name = heroNode.name;
-            temp.nickName = heroNode.nickName;
-        } else {
-            System.out.println("没有找到要修改的结点！！！");
-        }
-    }
-
-    //根据指定的no值，删除指定的结点,并且需要找到要删除的结点的前一个结点
-    public void delete(int no) {
-        HeroNode2 temp = head.next;
-        boolean flag = false;//标志着我们是否找到要删除的结点
-        while (true) {
-            if (temp == null) {
-                break;
-            }
-            if (temp.no == no) {
-                flag = true;
-                break;
-            }
-            temp = temp.next;
-
-        }
-        //判断flag
-        if (flag) {
-            temp.pre.next=temp.next;
-            if(temp.next!=null)
-            temp.next.pre=temp.pre;
-        } else {
-            System.out.println("要删除的结点不存在");
-        }
-    }
-
-    //显示链表的内容，遍历
-    public void list() {
-        //先判断链表是否为空
-        if (head.next == null) {
-            System.out.println("链表为空");
-            return;
-        }
-        //因为头结点不能动，因此我们需要一个辅助变量来遍历
-        HeroNode2 temp = head.next;
-        while (true) {
-            System.out.println(temp);
-            temp = temp.next;
-            if (temp == null) {
-                break;
-            }
-        }
-    }
-}
-
-    class HeroNode2 {
-        public int no;
-        public String name;
-        public String nickName;
-        public HeroNode2 next;
-        public HeroNode2 pre;
-
-        public HeroNode2(int no, String name, String nickName) {
-            this.no = no;
-            this.name = name;
-            this.nickName = nickName;
-        }
-
-        public String toString() {
-            return "HeroNode [no=" + no + ", name=" + name + ", nickname=" + nickName + "]";
-        }
-    }
-
Index: src/Gof/decorator/Drink.java
===================================================================
diff --git a/src/Gof/decorator/Drink.java b/src/Gof/decorator/Drink.java
deleted file mode 100644
--- a/src/Gof/decorator/Drink.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,24 +0,0 @@
-package Gof.decorator;
-
-public abstract class Drink {
-   public String des;
-    private float price=0.0f;
-
-    public String getDes() {
-        return des;
-    }
-
-    public void setDes(String des) {
-        this.des = des;
-    }
-
-    public float getPrice() {
-        return price;
-    }
-
-    public void setPrice(float price) {
-        this.price = price;
-    }
-
-    public abstract float cost();
-}
Index: src/Gof/Strategy/Duck.java
===================================================================
diff --git a/src/Gof/Strategy/Duck.java b/src/Gof/Strategy/Duck.java
deleted file mode 100644
--- a/src/Gof/Strategy/Duck.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,39 +0,0 @@
-package Gof.Strategy;
-
-public abstract class Duck {
-
-    FlyBehavior flyBehavior;
-    QuackBehavior quackBehavior;
-
-    public Duck(){
-
-    }
-
-    public abstract void display();//显示鸭子信息
-
-    public void quack() {
-        System.out.println("鸭子嘎嘎叫~~");
-    }
-
-    public void swim() {
-        System.out.println("鸭子会游泳~~");
-    }
-
-    public void fly() {
-
-        //改进
-        if(flyBehavior != null) {
-            flyBehavior.fly();
-        }
-    }
-
-    public void setFlyBehavior(FlyBehavior flyBehavior) {
-        this.flyBehavior = flyBehavior;
-    }
-
-
-    public void setQuackBehavior(QuackBehavior quackBehavior) {
-        this.quackBehavior = quackBehavior;
-    }
-
-}
Index: src/Gof/facade/DVDPlayer.java
===================================================================
diff --git a/src/Gof/facade/DVDPlayer.java b/src/Gof/facade/DVDPlayer.java
deleted file mode 100644
--- a/src/Gof/facade/DVDPlayer.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,30 +0,0 @@
-package Gof.facade;
-
-public class DVDPlayer {
-
-    private static final DVDPlayer instance=new DVDPlayer();
-    private DVDPlayer(){};
-
-    public static DVDPlayer getInstance()
-    {
-        return instance;
-    }
-
-    public void on()
-    {
-        System.out.println("dvd on");
-    }
-    public void off()
-    {
-        System.out.println("dvd off");
-    }
-
-    public void pause()
-    {
-        System.out.println("dvd pause");
-    }
-    public void play()
-    {
-        System.out.println("dvd play");
-    }
-}
Index: src/左神算法/基础班/图/Edge.java
===================================================================
diff --git a/src/左神算法/基础班/图/Edge.java b/src/左神算法/基础班/图/Edge.java
deleted file mode 100644
--- a/src/左神算法/基础班/图/Edge.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,40 +0,0 @@
-package 左神算法.基础班.图;
-
-public class Edge { //图中的边
-
-    public Node from;
-    public int weight;
-    public Node to;
-
-
-    public Node getFrom() {
-        return from;
-    }
-
-    public void setFrom(Node from) {
-        this.from = from;
-    }
-
-    public int getWeight() {
-        return weight;
-    }
-
-    public void setWeight(int weight) {
-        this.weight = weight;
-    }
-
-    public Node getTo() {
-        return to;
-    }
-
-    public void setTo(Node to) {
-        this.to = to;
-    }
-
-
-    public Edge(Node from, int weight, Node to) {
-        this.from = from;
-        this.weight = weight;
-        this.to = to;
-    }
-}
Index: src/重温设计模式/行为模式/观察者模式/示例/Editor.java
===================================================================
diff --git a/src/重温设计模式/行为模式/观察者模式/示例/Editor.java b/src/重温设计模式/行为模式/观察者模式/示例/Editor.java
deleted file mode 100644
--- a/src/重温设计模式/行为模式/观察者模式/示例/Editor.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,35 +0,0 @@
-package 重温设计模式.行为模式.观察者模式.示例;
-
-import java.io.File;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/8 16:35
- */
-public class Editor {
-
-    public EventManager managers;
-    private File file;
-
-    public Editor(){
-        this.managers = new EventManager("open","close");
-    }
-
-    public void openFile(String filePath){
-        this.file = new File(filePath);
-        managers.notify("open",file);
-    }
-
-    public void saveFile() throws Exception{
-        if(this.file != null){
-            managers.notify("close",file);
-        }else{
-            throw new Exception("Please open a file first..");
-
-        }
-    }
-
-
-}
Index: src/重温设计模式/行为模式/观察者模式/示例/EmailNotificationListener.java
===================================================================
diff --git a/src/重温设计模式/行为模式/观察者模式/示例/EmailNotificationListener.java b/src/重温设计模式/行为模式/观察者模式/示例/EmailNotificationListener.java
deleted file mode 100644
--- a/src/重温设计模式/行为模式/观察者模式/示例/EmailNotificationListener.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,25 +0,0 @@
-package 重温设计模式.行为模式.观察者模式.示例;
-
-import java.io.File;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/8 16:38
- */
-public class EmailNotificationListener implements EventListener{
-
-    private String email;
-
-    public EmailNotificationListener(String email){
-        this.email = email;
-    }
-
-    @Override
-    public void update(String eventType, File file) {
-        System.out.println("Email to " + email +" : Someone has performed "+
-                eventType + " operation with the following file: " + file.getName());
-
-    }
-}
Index: .idea/encodings.xml
===================================================================
diff --git a/.idea/encodings.xml b/.idea/encodings.xml
deleted file mode 100644
--- a/.idea/encodings.xml	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,10 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="Encoding" defaultCharsetForPropertiesFiles="UTF-8">
-    <file url="file://$PROJECT_DIR$/src/lib/asm-commons.jar" charset="GBK" />
-    <file url="file://$PROJECT_DIR$/src/lib/asm-tree.jar" charset="GBK" />
-    <file url="file://$PROJECT_DIR$/src/lib/asm.jar" charset="GBK" />
-    <file url="file://$PROJECT_DIR$/src/lib/cglib-2.2.jar" charset="GBK" />
-    <file url="PROJECT" charset="UTF-8" />
-  </component>
-</project>
\ No newline at end of file
Index: src/重温设计模式/结构型设计模式/装饰器模式/示例/EncryptionDecorator.java
===================================================================
diff --git a/src/重温设计模式/结构型设计模式/装饰器模式/示例/EncryptionDecorator.java b/src/重温设计模式/结构型设计模式/装饰器模式/示例/EncryptionDecorator.java
deleted file mode 100644
--- a/src/重温设计模式/结构型设计模式/装饰器模式/示例/EncryptionDecorator.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,46 +0,0 @@
-package 重温设计模式.结构型设计模式.装饰器模式.示例;
-
-import java.util.Base64;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 加密装饰
- * @date 2021/5/13 14:05
- */
-public class EncryptionDecorator extends DataSourceDecorator {
-
-    public EncryptionDecorator(DataSource wrappee) {
-        super(wrappee);
-    }
-
-    @Override
-    public void writeData(String str){
-        super.writeData(encode(str));
-    }
-
-    @Override
-    public String readData(){
-        return decode(super.readData());
-    }
-
-    public String encode(String data){
-        byte[] bytes = data.getBytes();
-        for(int i = 0;i < bytes.length;i++){
-            bytes[i] +=(byte)1;
-        }
-        return Base64.getEncoder().encodeToString(bytes);
-
-    }
-
-    public String decode(String data){
-        byte[] bytes = Base64.getDecoder().decode(data);
-        for(int i = 0;i < bytes.length;i++){
-            bytes[i] -=(byte)1;
-        }
-        return new String(bytes);
-    }
-
-
-
-}
Index: src/算法重写练习/排序/ErFen.java
===================================================================
diff --git a/src/算法重写练习/排序/ErFen.java b/src/算法重写练习/排序/ErFen.java
deleted file mode 100644
--- a/src/算法重写练习/排序/ErFen.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,65 +0,0 @@
-package 算法重写练习.排序;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:统计一个数字在排序数组中出现的次数。
-
- 
-
-示例 1:
-
-输入: nums = [5,7,7,8,8,10], target = 8
-输出: 2
-示例 2:
-
-输入: nums = [5,7,7,8,8,10], target = 6
-输出: 0
- 
-
-限制：
-
-0 <= 数组长度 <= 50000
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/9/15 16:11
- */
-public class ErFen {
-
-    public static int search(int[] nums, int target) {
-        if(nums==null || nums.length==0) return 0;
-        int n=nums.length;
-        int left=0,right=n-1;
-        int start=-1,end=-1;
-        while(left<right){//寻找第一次出现的位置
-            int mid=(left+right)>>>1;
-            if(nums[mid]<target){
-                left=mid+1;
-            }else{
-                right=mid;
-            }
-        }
-        start=left;
-        if(nums[start]!=target) return 0;
-        left=0;
-        right=n-1;
-        while(left<right){//寻找最后一次出现的位置
-            int mid=(left+right+1)>>>1;
-            if(nums[mid]>target){
-                right=mid-1;
-            }else{
-                left=mid;
-            }
-        }
-        end=left;
-        return end-start+1;
-    }
-
-    public static void main(String[] args) {
-        int[] arr=new int[]{5,7,7,8,8,10};
-        System.out.println(search(arr,7));
-    }
-
-}
Index: src/重温设计模式/行为模式/观察者模式/示例/EventListener.java
===================================================================
diff --git a/src/重温设计模式/行为模式/观察者模式/示例/EventListener.java b/src/重温设计模式/行为模式/观察者模式/示例/EventListener.java
deleted file mode 100644
--- a/src/重温设计模式/行为模式/观察者模式/示例/EventListener.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,14 +0,0 @@
-package 重温设计模式.行为模式.观察者模式.示例;
-
-import java.io.File;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/8 16:29
- */
-public interface EventListener {
-
-    void update(String eventType,File file);
-}
Index: src/重温设计模式/行为模式/观察者模式/示例/EventManager.java
===================================================================
diff --git a/src/重温设计模式/行为模式/观察者模式/示例/EventManager.java b/src/重温设计模式/行为模式/观察者模式/示例/EventManager.java
deleted file mode 100644
--- a/src/重温设计模式/行为模式/观察者模式/示例/EventManager.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,46 +0,0 @@
-package 重温设计模式.行为模式.观察者模式.示例;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:观察者模式在文本编辑器对象之间建立了间接的合作关系。每当编辑器对象改变时，他都会通知其他订阅者
- * 订阅者类不与编辑器类直接耦合，且能在需要时在其他应用中复用。编辑器类仅依赖于抽象订阅者接口，这样就能允许在不改变编辑器代码的
- * 的情况下添加新的订阅者类型
- * @date 2021/5/8 13:38
- */
-public class EventManager {
-
-    //key:订阅的事件，value:订阅者
-    Map<String,List<EventListener>> listeners = new HashMap<>();
-
-    public EventManager(String... operations){
-        for(String operation : operations){
-            this.listeners.put(operation,new ArrayList<>());
-        }
-    }
-
-    public void subscribe(String eventType,EventListener listener){
-        List<EventListener> eventListeners = listeners.get(eventType);
-        eventListeners.add(listener);
-    }
-
-    public void unSubscribe(String eventType,EventListener eventListener){
-        List<EventListener> eventListeners = listeners.get(eventType);
-        eventListeners.remove(eventListener);
-    }
-
-    public void notify(String eventType,File file){
-        List<EventListener> eventListeners = listeners.get(eventType);
-        for(EventListener eventListener : eventListeners){
-            eventListener.update(eventType,file);
-        }
-    }
-
-
-}
Index: src/JUC/美团笔面试题/类似问题/Exercise.java
===================================================================
diff --git a/src/JUC/美团笔面试题/类似问题/Exercise.java b/src/JUC/美团笔面试题/类似问题/Exercise.java
deleted file mode 100644
--- a/src/JUC/美团笔面试题/类似问题/Exercise.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,88 +0,0 @@
-package JUC.美团笔面试题.类似问题;
-
-import java.util.concurrent.locks.Condition;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 各个线程按序打印输出1,2,3
- * @date 2020/4/16 17:40
- */
-public class Exercise {
-
-    public static void main(String[] args) {
-        Resource resource=new Resource();
-        new Thread(()->{
-            while(true){
-                resource.print1();
-            }
-        },"AA").start();
-        new Thread(()->{
-            while(true){
-                resource.print2();
-            }
-        },"BB").start();
-        new Thread(()->{
-            while(true){
-                resource.print3();
-            }
-        },"CC").start();
-    }
-}
-
-class Resource{
-
-    private int num=1; //标志位，控制打印顺序
-    private Lock lock=new ReentrantLock();
-    Condition c1=lock.newCondition();
-    Condition c2=lock.newCondition();
-    Condition c3=lock.newCondition();
-
-    public void print1(){
-        lock.lock();
-        try{
-            while(num!=1){
-                c1.await();
-            }
-
-            System.out.println(Thread.currentThread().getName()+"输出"+num);
-            Thread.sleep(500);
-            num=2;
-            c2.signal();
-        } catch (InterruptedException e) {
-            e.printStackTrace();
-        }
-    }
-    public void print2(){
-        lock.lock();
-        try{
-            while(num!=2){
-                c2.await();
-            }
-
-            System.out.println(Thread.currentThread().getName()+"输出"+num);
-            Thread.sleep(500);
-            num=3;
-            c3.signal();
-        } catch (InterruptedException e) {
-            e.printStackTrace();
-        }
-    }
-    public void print3(){
-        lock.lock();
-        try{
-            while(num!=3){
-                c3.await();
-            }
-
-            System.out.println(Thread.currentThread().getName()+"输出"+num);
-            Thread.sleep(500);
-            num=1;
-            c1.signal();
-        } catch (InterruptedException e) {
-            e.printStackTrace();
-        }
-    }
-}
Index: src/Leetcode/辗转相除法求最大公约数与最小公倍数/Exercise.java
===================================================================
diff --git a/src/Leetcode/辗转相除法求最大公约数与最小公倍数/Exercise.java b/src/Leetcode/辗转相除法求最大公约数与最小公倍数/Exercise.java
deleted file mode 100644
--- a/src/Leetcode/辗转相除法求最大公约数与最小公倍数/Exercise.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,33 +0,0 @@
-package Leetcode.辗转相除法求最大公约数与最小公倍数;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2020/5/2 22:58
- */
-public class Exercise {
-
-    //辗转相除法求a与b的最大公约数
-    public int getMax(int a,int b){
-        //使a等于a,b中较大的那个
-        if(a<b){
-            int m=a;
-            a=b;
-            b=a;
-        }
-        while(b!=0){
-            int tmp=a%b;
-            a=b;
-            b=tmp;
-        }
-        return a;
-
-
-    }
-    //求a与b的最小公倍数
-    public int getMin(int a,int b){
-        int tmp = getMax(a, b);
-        return a*b/tmp;
-    }
-}
Index: src/org/sd/Exercise.java
===================================================================
diff --git a/src/org/sd/Exercise.java b/src/org/sd/Exercise.java
deleted file mode 100644
--- a/src/org/sd/Exercise.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,26 +0,0 @@
-package org.sd;
-
-import java.util.Scanner;
-
-public class Exercise {
-
-    public static int getLength(String str)
-    {
-        if(str==null || str.length()==0)
-            return 0;
-        String[] strArray=str.split(" ");
-        int len=strArray.length;
-        return strArray[len-1].length();
-    }
-
-    public static void main(String[] args)
-    {
-        Scanner scanner=new Scanner(System.in);
-        while(scanner.hasNextLine())
-        {
-            String str=scanner.nextLine();
-            int len=getLength(str);
-            System.out.println(len);
-        }
-    }
-}
Index: exercise2.iml
===================================================================
diff --git a/exercise2.iml b/exercise2.iml
deleted file mode 100644
--- a/exercise2.iml	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,27 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module type="JAVA_MODULE" version="4">
-  <component name="NewModuleRootManager" inherit-compiler-output="true">
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
-    </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-    <orderEntry type="module-library">
-      <library>
-        <CLASSES>
-          <root url="jar://$MODULE_DIR$/src/javassist.jar!/" />
-        </CLASSES>
-        <JAVADOC />
-        <SOURCES />
-      </library>
-    </orderEntry>
-    <orderEntry type="library" name="core-3.3.0" level="project" />
-    <orderEntry type="library" name="core-3.3.0 (2)" level="project" />
-    <orderEntry type="library" name="QRCode" level="project" />
-    <orderEntry type="library" name="core-3.1.0" level="project" />
-    <orderEntry type="library" name="javax.mail" level="project" />
-    <orderEntry type="library" name="asm-commons" level="project" />
-    <orderEntry type="library" name="guava-25.1-jre" level="project" />
-  </component>
-</module>
\ No newline at end of file
Index: src/左神算法/进阶班一/结构设计/ExpressionCompute.java
===================================================================
diff --git a/src/左神算法/进阶班一/结构设计/ExpressionCompute.java b/src/左神算法/进阶班一/结构设计/ExpressionCompute.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/结构设计/ExpressionCompute.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,93 +0,0 @@
-package 左神算法.进阶班一.结构设计;
-
-import java.util.LinkedList;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 给你一个字符串str,str表示一个公式，公式里可能有整数，加减乘除和括号，返回公式的计算结果。可以认为给定的字符串一定是正确的公式。即不需要
- * //对str做公式有效性检查。
- * @date 2020/1/9 13:33
- */
-public class ExpressionCompute {
-
-    public static int getValue(String str) {
-        return value(str.toCharArray(), 0)[0];
-    }
-    //返回值为数组，长度为2
-    //arr[0]:表示我计算的结果
-    //arr[1]：表示我计算到的位置
-    public static int[] value(char[] str, int i) { //i表示计算str从i下标处开始的元素，知道遇到“)”或者字符串的末尾
-        LinkedList<String> que = new LinkedList<String>();
-        int pre = 0;
-        int[] bra = null;
-        while (i < str.length && str[i] != ')') {
-            if (str[i] >= '0' && str[i] <= '9') {
-                pre = pre * 10 + str[i++] - '0';
-            } else if (str[i] != '(') { //遇到了加减乘除符号
-                addNum(que, pre);
-                que.addLast(String.valueOf(str[i++]));
-                pre = 0;
-            } else {//遇到了左括号
-                bra = value(str, i + 1);
-                pre = bra[0];
-                i = bra[1] + 1;
-            }
-        }
-        addNum(que, pre);
-        return new int[] { getNum(que), i };//返回计算的结果以及，算到哪个位置了
-    }
-
-    //不带括号的算术表达式的计算过程。每个加入的数字以某个运算符号结尾在加入一个数字的时候，首先判断顶部的元素是否为乘除，如果是，则先弹出做计算,然后将计算的结果压入。
-    public static void addNum(LinkedList<String> que, int num) {
-        if (!que.isEmpty()) {
-            int cur = 0;
-            String top = que.pollLast();
-            if (top.equals("+") || top.equals("-")) {
-                que.addLast(top);
-            } else {
-                cur = Integer.valueOf(que.pollLast());
-                num = top.equals("*") ? (cur * num) : (cur / num);
-            }
-        }
-        que.addLast(String.valueOf(num));
-    }
-
-    public static int getNum(LinkedList<String> que) { //计算经过上面的方法处理后的表达值，只含有加减运算了
-        int res = 0;
-        boolean add = true;
-        String cur = null;
-        int num = 0;
-        while (!que.isEmpty()) {
-            cur = que.pollFirst();
-            if (cur.equals("+")) {
-                add = true;
-            } else if (cur.equals("-")) {
-                add = false;
-            } else {
-                num = Integer.valueOf(cur);
-                res += add ? num : (-num); //将加减号作为了运算数的符号
-            }
-        }
-        return res;
-    }
-
-    public static void main(String[] args) {
-        String exp = "48*((70-65)-43)+8*1";
-        System.out.println(getValue(exp));
-
-        exp = "4*(6+78)+53-9/2+45*8";
-        System.out.println(getValue(exp));
-
-        exp = "10-5*3";
-        System.out.println(getValue(exp));
-
-        exp = "-3*4";
-        System.out.println(getValue(exp));
-
-        exp = "3+1*4";
-        System.out.println(getValue(exp));
-
-    }
-
-}
Index: src/左神算法/面试重写与剑指offer/Fabonacci.java
===================================================================
diff --git a/src/左神算法/面试重写与剑指offer/Fabonacci.java b/src/左神算法/面试重写与剑指offer/Fabonacci.java
deleted file mode 100644
--- a/src/左神算法/面试重写与剑指offer/Fabonacci.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,27 +0,0 @@
-package 左神算法.面试重写与剑指offer;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 斐波那契数列的非递归实现
- * @date 2020/3/21 15:18
- */
-public class Fabonacci {
-
-    public static int fabonacci(int index){
-        if(index==1)
-            return 1;
-        if(index==2)
-            return 2;
-        int nowMinuOne=2;
-        int nowMinusTwo=1;
-        int now=0;
-        for(int i=3;i<=index;i++){
-            now=nowMinuOne+nowMinusTwo;
-            nowMinusTwo=nowMinuOne;
-            nowMinuOne=now;
-        }
-        return now;
-    }
-}
Index: src/重温设计模式/行为模式/模版方法模式/示例/FaceBook.java
===================================================================
diff --git a/src/重温设计模式/行为模式/模版方法模式/示例/FaceBook.java b/src/重温设计模式/行为模式/模版方法模式/示例/FaceBook.java
deleted file mode 100644
--- a/src/重温设计模式/行为模式/模版方法模式/示例/FaceBook.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,62 +0,0 @@
-package 重温设计模式.行为模式.模版方法模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 具体社交网络，对基础类中的模版方法进行重写。
- * @date 2021/5/11 15:08
- */
-public class FaceBook extends NetWork {
-
-    public FaceBook(String userName,String password){
-        this.userName = userName;
-        this.password = password;
-    }
-
-
-
-
-    @Override
-    boolean logIn(String userName, String password) {
-        System.out.println("\nChecking user's parameters");
-        System.out.println("Name: " + this.userName);
-        System.out.print("Password: ");
-        for (int i = 0; i < this.password.length(); i++) {
-            System.out.print("*");
-        }
-        simulateNetworkLatency();
-        System.out.println("\n\nLogIn success on Facebook");
-        return true;
-    }
-
-    private void simulateNetworkLatency() {
-
-        try{
-            int i = 0;
-            System.out.println();
-            while(i < 10){
-                System.out.println(",");
-                Thread.sleep(100);
-                i++;
-            }
-        } catch (InterruptedException e) {
-            e.printStackTrace();
-        }
-    }
-
-    @Override
-    boolean sendData(byte[] data) {
-        boolean messagePosted = true;
-        if (messagePosted) {
-            System.out.println("Message: '" + new String(data) + "' was posted on Facebook");
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    @Override
-    void logOut() {
-        System.out.println("User: '" + userName + "' was logged out from Facebook");
-    }
-}
Index: src/Gof/visitor/Fail.java
===================================================================
diff --git a/src/Gof/visitor/Fail.java b/src/Gof/visitor/Fail.java
deleted file mode 100644
--- a/src/Gof/visitor/Fail.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,15 +0,0 @@
-package Gof.visitor;
-
-public class Fail extends Action {
-    @Override
-    public void getManResult(Man man) {
-        System.out.println(" 男人给的评价该歌手失败 !");
-
-    }
-
-    @Override
-    public void getWomanResult(Woman woman) {
-        System.out.println(" 女人给的评价该歌手失败 !");
-
-    }
-}
Index: src/韩顺平算法与数据结构/datastructure/search/FibonacciSearch.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/search/FibonacciSearch.java b/src/韩顺平算法与数据结构/datastructure/search/FibonacciSearch.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/search/FibonacciSearch.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,89 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.search;
-
-import java.util.Arrays;
-
-public class FibonacciSearch {
-
-    public static int maxSize = 20;
-    public static void main(String[] args) {
-        int [] arr = {1,8, 10, 89, 1000, 1234};
-
-        System.out.println("index=" + fibSearch(arr, 189));// 0
-
-    }
-
-    //因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列
-    //非递归方法得到一个斐波那契数列
-    public static int[] fib() {
-        int[] f = new int[maxSize];
-        f[0] = 1;
-        f[1] = 1;
-        for (int i = 2; i < maxSize; i++) {
-            f[i] = f[i - 1] + f[i - 2];
-        }
-        return f;
-    }
-
-    //编写斐波那契查找算法
-    //使用非递归的方式编写算法
-    /**
-     *
-     * @param a  数组
-     * @param key 我们需要查找的关键码(值)
-     * @return 返回对应的下标，如果没有-1
-     */
-    public static int fibSearch(int[] a, int key) {
-        int low = 0;
-        int high = a.length - 1;
-        int k = 0; //表示斐波那契分割数值的下标
-        int mid = 0; //存放mid值
-        int f[] = fib(); //获取到斐波那契数列
-        //获取到斐波那契分割数值的下标
-        while(high > f[k] - 1) {
-            k++;
-        }
-        //因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]
-        //不足的部分会使用0填充
-        int[] temp = Arrays.copyOf(a, f[k]);
-        //实际上需求使用a数组最后的数填充 temp
-        //举例:
-        //temp = {1,8, 10, 89, 1000, 1234, 0, 0}  => {1,8, 10, 89, 1000, 1234, 1234, 1234,}
-        for(int i = high + 1; i < temp.length; i++) {
-            temp[i] = a[high];
-        }
-
-        // 使用while来循环处理，找到我们的数 key
-        while (low <= high) { // 只要这个条件满足，就可以找
-            mid = low + f[k - 1] - 1;
-            if(key < temp[mid]) { //我们应该继续向数组的前面查找(左边)
-                high = mid - 1;
-                //为甚是 k--
-                //说明
-                //1. 全部元素 = 前面的元素 + 后边元素
-                //2. f[k] = f[k-1] + f[k-2]
-                //因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]
-                //即 在 f[k-1] 的前面继续查找 k--
-                //即下次循环 mid = f[k-1-1]-1
-                k--;
-            } else if ( key > temp[mid]) { // 我们应该继续向数组的后面查找(右边)
-                low = mid + 1;
-                //为什么是k -=2
-                //说明
-                //1. 全部元素 = 前面的元素 + 后边元素
-                //2. f[k] = f[k-1] + f[k-2]
-                //3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4]
-                //4. 即在f[k-2] 的前面进行查找 k -=2
-                //5. 即下次循环 mid = f[k - 1 - 2] - 1
-                k -= 2;
-            } else { //找到
-                //需要确定，返回的是哪个下标,原因是数组可能扩展了
-                if(mid <= high) {
-                    return mid;
-                } else {
-                    return high;
-                }
-            }
-        }
-        return -1;
-    }
-}
\ No newline at end of file
Index: src/重温设计模式/结构型设计模式/装饰器模式/示例/FileDataSource.java
===================================================================
diff --git a/src/重温设计模式/结构型设计模式/装饰器模式/示例/FileDataSource.java b/src/重温设计模式/结构型设计模式/装饰器模式/示例/FileDataSource.java
deleted file mode 100644
--- a/src/重温设计模式/结构型设计模式/装饰器模式/示例/FileDataSource.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,46 +0,0 @@
-package 重温设计模式.结构型设计模式.装饰器模式.示例;
-
-import java.io.*;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 简单数据读写器
- * @date 2021/5/13 13:58
- */
-public class FileDataSource implements DataSource{
-
-    private String name;
-
-    public FileDataSource(String name){
-        this.name = name;
-    }
-
-    @Override
-    public void writeData(String str) {
-        File file = new File(name);
-        try(OutputStream fos = new FileOutputStream(file)){
-            fos.write(str.getBytes(),0,str.length());
-        } catch (FileNotFoundException e) {
-            e.printStackTrace();
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-
-    }
-
-    @Override
-    public String readData() {
-        char[] buffer = null;
-        File file = new File(name);
-        try(FileReader reader = new FileReader(file)) {
-            buffer = new char[(int)file.length()];
-            reader.read(buffer);
-        } catch (FileNotFoundException e) {
-            e.printStackTrace();
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-        return new String(buffer);
-    }
-}
Index: src/org/sd/mediator/Finacial.java
===================================================================
diff --git a/src/org/sd/mediator/Finacial.java b/src/org/sd/mediator/Finacial.java
deleted file mode 100644
--- a/src/org/sd/mediator/Finacial.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,21 +0,0 @@
-package org.sd.mediator;
-
-public class Finacial implements Department {
-    private Mediator m;  //持有中介者(总经理)的引用
-
-    public Finacial(Mediator m) {
-        super();
-        this.m = m;
-        m.register("finacial", this);
-    }
-
-    @Override
-    public void outAction() {
-        System.out.println("汇报工作！没钱了，钱太多了！怎么花?");
-    }
-
-    @Override
-    public void selfAction() {
-        System.out.println("数钱！");
-    }
-}
Index: src/左神算法/基础班/第三课/FindFirstIntersectNode.java
===================================================================
diff --git a/src/左神算法/基础班/第三课/FindFirstIntersectNode.java b/src/左神算法/基础班/第三课/FindFirstIntersectNode.java
deleted file mode 100644
--- a/src/左神算法/基础班/第三课/FindFirstIntersectNode.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,207 +0,0 @@
-package 左神算法.基础班.第三课;
-
-import java.util.HashSet;
-
-/**
- * 给定两个单链表的头结点head1和head2,这两个链表可能有环，也可能无环，这两个链表可能相交，也可能不相交，实现一个函数
- * 如果两个链表相交，请返回相交的第一个结点，如果不相交，返回null.
- * 如果链表1的长度为n，链表2的长度为m，本题的实现中，时间复杂度为O（m+n),额外空间复杂度为O（1），
- */
-
-public class FindFirstIntersectNode {
-
-    public static class Node {
-        public int value;
-        public Node next;
-
-        public Node(int data) {
-            this.value = data;
-        }
-    }
-
-    public static Node getIntersectNode(Node head1, Node head2){
-         if(head1==null || head2==null)
-             return null;
-         Node loop1=getLoopNode(head1);
-         Node loop2=getLoopNode(head2);
-         if(loop1==null && loop2==null)
-         {
-             return noLoop(head1,head2);
-         }else if(loop1!=null && loop2!=null)
-         {
-             return bothLoop(head1,loop1,head2,loop2);
-         }else {
-             return null;
-         }
-    }
-
-    //判断一个链表是否有环，并且返回入环结点，使用hashset的方式
-    public static Node getLoopNode1(Node head)
-    {
-        if(head==null)
-            return null;
-        HashSet<Node>set=new HashSet<>(); //hashset中存储的引用，也就是地址
-        Node cur=head;
-        while(cur!=null)
-        {
-            if(set.contains(cur))
-            {
-                return cur;
-            }
-            set.add(cur);
-            cur=cur.next;
-        }
-        return null;
-    }
-
-    //不使用hashset的方式判断
-    public static Node getLoopNode(Node head)
-    {
-        if(head==null || head.next==null || head.next.next==null)
-            return null;
-        Node fast=head.next.next;
-        Node slow=head.next;
-        while(fast!=slow)
-        {
-            if(fast.next==null || fast.next.next==null)//即：快指针能够走到终点
-                return null;
-            fast=fast.next.next;
-            slow=slow.next;
-        }
-        fast=head;  //快指针从头开始重新走
-        while(fast!=slow)
-        {
-            fast=fast.next;
-            slow=slow.next;
-        }
-        return fast;
-
-    }
-
-    public static Node noLoop(Node head1,Node head2)
-    {
-        if(head1==null || head2==null)
-            return null;
-        Node cur1=head1;
-        Node cur2=head2;
-        int n=0;
-        while(cur1.next!=null)
-        {
-            n++;
-            cur1=cur1.next;
-        }
-        while(cur2.next!=null)
-        {
-            n--;
-            cur2=cur2.next;
-        }
-        if(cur1!=cur2) //两个链表的最后一个结点是否相同
-            return null;
-
-        cur1=n>0?head1:head2;//cur1指向长链表
-        cur2=cur1==head1?head2:head1; //cur2指向短链表
-
-        n=Math.abs(n);
-        while(n!=0)//长链表先走二者之间的长度差
-        {    n--;
-            cur1=cur1.next;
-        }
-        while(cur1!=cur2)
-        {
-            cur1=cur1.next;
-            cur2=cur2.next;
-        }
-        return cur1;
-
-    }
-
-    public static Node bothLoop(Node head1,Node loop1,Node head2,Node loop2)
-    {
-        Node cur1=null;
-        Node cur2=null;
-        if(loop1==loop2)
-        {
-            cur1=head1;
-            cur2=head2;
-            int n=0;
-            while(cur1!=loop1)
-            {
-                n++;
-                cur1=cur1.next;
-            }
-            while(cur2!=loop2)
-            {
-                n--;
-                cur2=cur2.next;
-            }
-            cur1=n>0?head1:head2;
-            cur2=cur1==head1?head2:head1;
-            n=Math.abs(n);
-            while(n!=0)
-            {   n--;
-                cur1=cur1.next;
-            }
-            while(cur1!=cur2)
-            {
-                cur1=cur1.next;
-                cur2=cur2.next;
-            }
-            return cur1;
-        }else{
-            cur1=loop1.next;
-            while(cur1!=loop1)
-            {
-                if(cur1==loop2)
-                    return loop1;
-                cur1=cur1.next;
-            }
-            return null;
-
-        }
-    }
-
-    public static void main(String[] args) {
-        // 1->2->3->4->5->6->7->null
-        Node head1 = new Node(1);
-        head1.next = new Node(2);
-        head1.next.next = new Node(3);
-        head1.next.next.next = new Node(4);
-        head1.next.next.next.next = new Node(5);
-        head1.next.next.next.next.next = new Node(6);
-        head1.next.next.next.next.next.next = new Node(7);
-
-        // 0->9->8->6->7->null
-        Node head2 = new Node(0);
-        head2.next = new Node(9);
-        head2.next.next = new Node(8);
-        head2.next.next.next = head1.next.next.next.next.next; // 8->6
-        System.out.println(getIntersectNode(head1, head2).value);
-
-        // 1->2->3->4->5->6->7->4...
-        head1 = new Node(1);
-        head1.next = new Node(2);
-        head1.next.next = new Node(3);
-        head1.next.next.next = new Node(4);
-        head1.next.next.next.next = new Node(5);
-        head1.next.next.next.next.next = new Node(6);
-        head1.next.next.next.next.next.next = new Node(7);
-        head1.next.next.next.next.next.next = head1.next.next.next; // 7->4
-
-        // 0->9->8->2...
-        head2 = new Node(0);
-        head2.next = new Node(9);
-        head2.next.next = new Node(8);
-        head2.next.next.next = head1.next; // 8->2
-        System.out.println(getIntersectNode(head1, head2).value);
-
-        // 0->9->8->6->4->5->6..
-        head2 = new Node(0);
-        head2.next = new Node(9);
-        head2.next.next = new Node(8);
-        head2.next.next.next = head1.next.next.next.next.next; // 8->6
-        System.out.println(getIntersectNode(head1, head2).value);
-
-    }
-
-
-}
Index: src/左神算法/高频面试题/FindFirstIntersectNode.java
===================================================================
diff --git a/src/左神算法/高频面试题/FindFirstIntersectNode.java b/src/左神算法/高频面试题/FindFirstIntersectNode.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/FindFirstIntersectNode.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,207 +0,0 @@
-package 左神算法.高频面试题;
-
-import java.util.HashSet;
-
-/**
- * 给定两个单链表的头结点head1和head2,这两个链表可能有环，也可能无环，这两个链表可能相交，也可能不相交，实现一个函数
- * 如果两个链表相交，请返回相交的第一个结点，如果不相交，返回null.
- * 如果链表1的长度为n，链表2的长度为m，本题的实现中，时间复杂度为O（m+n),额外空间复杂度为O（1），
- */
-
-public class FindFirstIntersectNode {
-
-    public static class Node {
-        public int value;
-        public Node next;
-
-        public Node(int data) {
-            this.value = data;
-        }
-    }
-
-    public static Node getIntersectNode(Node head1, Node head2){
-         if(head1==null || head2==null)
-             return null;
-         Node loop1=getLoopNode(head1);
-         Node loop2=getLoopNode(head2);
-         if(loop1==null && loop2==null)
-         {
-             return noLoop(head1,head2);
-         }else if(loop1!=null && loop2!=null)
-         {
-             return bothLoop(head1,loop1,head2,loop2);
-         }else {
-             return null;
-         }
-    }
-
-    //判断一个链表是否有环，并且返回入环结点，使用hashset的方式
-    public static Node getLoopNode1(Node head)
-    {
-        if(head==null)
-            return null;
-        HashSet<Node>set=new HashSet<>(); //hashset中存储的引用，也就是地址
-        Node cur=head;
-        while(cur!=null)
-        {
-            if(set.contains(cur))
-            {
-                return cur;
-            }
-            set.add(cur);
-            cur=cur.next;
-        }
-        return null;
-    }
-
-    //不使用hashset的方式判断
-    public static Node getLoopNode(Node head)
-    {
-        if(head==null || head.next==null || head.next.next==null)
-            return null;
-        Node fast=head.next.next;
-        Node slow=head.next;
-        while(fast!=slow)
-        {
-            if(fast.next==null || fast.next.next==null)//即：快指针能够走到终点
-                return null;
-            fast=fast.next.next;
-            slow=slow.next;
-        }
-        fast=head;  //快指针从头开始重新走
-        while(fast!=slow)
-        {
-            fast=fast.next;
-            slow=slow.next;
-        }
-        return fast;
-
-    }
-
-    public static Node noLoop(Node head1,Node head2)
-    {
-        if(head1==null || head2==null)
-            return null;
-        Node cur1=head1;
-        Node cur2=head2;
-        int n=0;
-        while(cur1.next!=null)
-        {
-            n++;
-            cur1=cur1.next;
-        }
-        while(cur2.next!=null)
-        {
-            n--;
-            cur2=cur2.next;
-        }
-        if(cur1!=cur2) //两个链表的最后一个结点是否相同
-            return null;
-
-        cur1=n>0?head1:head2;//cur1指向长链表
-        cur2=cur1==head1?head2:head1; //cur2指向短链表
-
-        n=Math.abs(n);
-        while(n!=0)//长链表先走二者之间的长度差
-        {    n--;
-            cur1=cur1.next;
-        }
-        while(cur1!=cur2)
-        {
-            cur1=cur1.next;
-            cur2=cur2.next;
-        }
-        return cur1;
-
-    }
-
-    public static Node bothLoop(Node head1,Node loop1,Node head2,Node loop2)
-    {
-        Node cur1=null;
-        Node cur2=null;
-        if(loop1==loop2)
-        {
-            cur1=head1;
-            cur2=head2;
-            int n=0;
-            while(cur1!=loop1)
-            {
-                n++;
-                cur1=cur1.next;
-            }
-            while(cur2!=loop2)
-            {
-                n--;
-                cur2=cur2.next;
-            }
-            cur1=n>0?head1:head2;
-            cur2=cur1==head1?head2:head1;
-            n=Math.abs(n);
-            while(n!=0)
-            {   n--;
-                cur1=cur1.next;
-            }
-            while(cur1!=cur2)
-            {
-                cur1=cur1.next;
-                cur2=cur2.next;
-            }
-            return cur1;
-        }else{
-            cur1=loop1.next;
-            while(cur1!=loop1)
-            {
-                if(cur1==loop2)
-                    return loop1;
-                cur1=cur1.next;
-            }
-            return null;
-
-        }
-    }
-
-    public static void main(String[] args) {
-        // 1->2->3->4->5->6->7->null
-        Node head1 = new Node(1);
-        head1.next = new Node(2);
-        head1.next.next = new Node(3);
-        head1.next.next.next = new Node(4);
-        head1.next.next.next.next = new Node(5);
-        head1.next.next.next.next.next = new Node(6);
-        head1.next.next.next.next.next.next = new Node(7);
-
-        // 0->9->8->6->7->null
-        Node head2 = new Node(0);
-        head2.next = new Node(9);
-        head2.next.next = new Node(8);
-        head2.next.next.next = head1.next.next.next.next.next; // 8->6
-        System.out.println(getIntersectNode(head1, head2).value);
-
-        // 1->2->3->4->5->6->7->4...
-        head1 = new Node(1);
-        head1.next = new Node(2);
-        head1.next.next = new Node(3);
-        head1.next.next.next = new Node(4);
-        head1.next.next.next.next = new Node(5);
-        head1.next.next.next.next.next = new Node(6);
-        head1.next.next.next.next.next.next = new Node(7);
-        head1.next.next.next.next.next.next = head1.next.next.next; // 7->4
-
-        // 0->9->8->2...
-        head2 = new Node(0);
-        head2.next = new Node(9);
-        head2.next.next = new Node(8);
-        head2.next.next.next = head1.next; // 8->2
-        System.out.println(getIntersectNode(head1, head2).value);
-
-        // 0->9->8->6->4->5->6..
-        head2 = new Node(0);
-        head2.next = new Node(9);
-        head2.next.next = new Node(8);
-        head2.next.next.next = head1.next.next.next.next.next; // 8->6
-        System.out.println(getIntersectNode(head1, head2).value);
-
-    }
-
-
-}
Index: src/左神算法/高频面试题/十二十三/FindKMajor.java
===================================================================
diff --git a/src/左神算法/高频面试题/十二十三/FindKMajor.java b/src/左神算法/高频面试题/十二十三/FindKMajor.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/十二十三/FindKMajor.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,138 +0,0 @@
-package 左神算法.高频面试题.十二十三;
-
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:在数组中找到出现次数大于N/k的数
- * 给定一个整形数组arr,打印其中出现次数大于一半的数，如果没有这样的数，打印提示信息。
- * 进阶：给定一个整型数组arr,在给定一个整数k,打印所有出现次数大于N/k的数，如果没有这样的数，打印提示信息
- * @date 2020/2/5 18:56
- */
-public class FindKMajor {
-
-    public static void printHalfMajor(int[] arr){
-        int cand=0;
-        int times=0;
-        for(int i=0;i<arr.length;i++){
-            if(times==0)
-                cand=arr[i];
-            else if(arr[i]==cand)
-                times++;
-            else
-                times--;
-        }
-        times=0;
-        for(int i=0;i<arr.length;i++){
-            if(arr[i]==cand)
-                times++;
-        }
-        if(times>arr.length/2){
-            System.out.println(cand);
-        }else
-            System.out.println("no such number..");
-    }
-
-    //一个数组中至多有k-1个数出现的次数满足大于N/K
-    public static void printKMajor(int[] arr,int k){
-        if(k<2){
-            System.out.println("the value is invalid");
-            return;
-        }
-        HashMap<Integer,Integer> map=new HashMap<>();
-        for(int i=0;i<arr.length;i++){
-            if(map.containsKey(arr[i])){
-                map.put(arr[i],map.get(arr[i])+1);
-            }else{
-                if(map.size()==k-1)
-                    allMinusOne(map);
-                else
-                    map.put(arr[i],1);
-            }
-        }
-        HashMap<Integer, Integer> res = getReals(map, arr);
-        boolean isPrint=false;
-        for(Map.Entry<Integer,Integer> entry:res.entrySet()){
-            if(entry.getValue()>arr.length/k){
-                System.out.print(entry.getKey()+" ");
-                isPrint=true;
-            }
-        }
-        if(!isPrint)
-            System.out.println("no such number..");
-    }
-
-    public static void allMinusOne(HashMap<Integer,Integer> map){
-
-        List<Integer> list=new LinkedList<>();
-        for(Map.Entry<Integer,Integer> entry: map.entrySet()){
-            if(entry.getValue()==1){
-                list.add(entry.getKey());
-            }else{
-                map.put(entry.getKey(),entry.getValue()-1);
-            }
-        }
-        for(Integer integer:list){
-            map.remove(integer);
-        }
-    }
-
-    //得到候选人中真正出现次数
-    public static HashMap<Integer,Integer> getReals(HashMap<Integer,Integer>cands,int[] arr){
-        HashMap<Integer,Integer> res=new HashMap<>();
-        for(Map.Entry<Integer,Integer> entry:cands.entrySet()){
-            int times=0;
-            for(int i=0;i<arr.length;i++){
-                if(arr[i]==entry.getKey()){
-                    times++;
-                }
-            }
-            res.put(entry.getKey(),times);
-        }
-        return res;
-    }
-
-
-
-    public static void allCandsMinusOne(HashMap<Integer, Integer> map) {
-        List<Integer> removeList = new LinkedList<Integer>();
-        for (Map.Entry<Integer, Integer> set : map.entrySet()) {
-            Integer key = set.getKey();
-            Integer value = set.getValue();
-            if (value == 1) {
-                removeList.add(key);
-            }
-            map.put(key, value - 1);
-        }
-        for (Integer removeKey : removeList) {
-            map.remove(removeKey);
-        }
-    }
-    //优化
-    public static HashMap<Integer, Integer> getReals(int[] arr,
-                                                     HashMap<Integer, Integer> cands) {
-        HashMap<Integer, Integer> reals = new HashMap<Integer, Integer>();
-        for (int i = 0; i != arr.length; i++) {
-            int curNum = arr[i];
-            if (cands.containsKey(curNum)) {
-                if (reals.containsKey(curNum)) {
-                    reals.put(curNum, reals.get(curNum) + 1);
-                } else {
-                    reals.put(curNum, 1);
-                }
-            }
-        }
-        return reals;
-    }
-
-    public static void main(String[] args) {
-        int[] arr = { 1, 2, 3, 1, 1, 2, 1 };
-        printHalfMajor(arr);
-        int K = 4;
-        printKMajor(arr, K);
-    }
-}
Index: src/左神算法/基础班/第三课/FindNumberSortedArray.java
===================================================================
diff --git a/src/左神算法/基础班/第三课/FindNumberSortedArray.java b/src/左神算法/基础班/第三课/FindNumberSortedArray.java
deleted file mode 100644
--- a/src/左神算法/基础班/第三课/FindNumberSortedArray.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,34 +0,0 @@
-package 左神算法.基础班.第三课;
-
-public class FindNumberSortedArray {
-
-
-     public static boolean hasNum(int[][] arr,int num) {
-         int row = 0;
-         int col = arr[0].length - 1;
-         while (row < arr.length && col > -1) {
-             if (arr[row][col] == num)
-                 return true;
-             else if (arr[row][col] > num) {
-                 col--;
-             } else {
-                 row++;
-             }
-         }
-         return false;
-     }
-
-    public static void main(String[] args) {
-        int[][] matrix = new int[][] { { 0, 1, 2, 3, 4, 5, 6 },// 0
-                { 10, 12, 13, 15, 16, 17, 18 },// 1
-                { 23, 24, 25, 26, 27, 28, 29 },// 2
-                { 44, 45, 46, 47, 48, 49, 50 },// 3
-                { 65, 66, 67, 68, 69, 70, 71 },// 4
-                { 96, 97, 98, 99, 100, 111, 122 },// 5
-                { 166, 176, 186, 187, 190, 195, 200 },// 6
-                { 233, 243, 321, 341, 356, 370, 380 } // 7
-        };
-        int K = 233;
-        System.out.println(hasNum(matrix,K));
-}
-     }
\ No newline at end of file
Index: src/左神算法/基础班/findOneLessValueIndex/FindOneLessValueIndex.java
===================================================================
diff --git a/src/左神算法/基础班/findOneLessValueIndex/FindOneLessValueIndex.java b/src/左神算法/基础班/findOneLessValueIndex/FindOneLessValueIndex.java
deleted file mode 100644
--- a/src/左神算法/基础班/findOneLessValueIndex/FindOneLessValueIndex.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,50 +0,0 @@
-package 左神算法.基础班.findOneLessValueIndex;
-
-/**
- * 二分法的应用：
- * 定义局部最小的概念。arr长度为1时，arr[0]是局部最小。arr的长度 为N(N>1)时，如果arr[0]<arr[1]，
- * 那么arr[0]是局部最小；如果 arr[N-1]<arr[N-2]，那么arr[N-1]是局部最小；如果0<i<N-1，既有 arr[i]<arr[i-1]，
- * 又有arr[i]<arr[i+1]，那么arr[i]是局部最小。给定无序数组arr，已知arr中任意两个相邻的数都不相等。
- * 写一个函 数，只需返回arr中任意一个局部最小出现的位置即可。
- */
-public class FindOneLessValueIndex {
-
-    public static int getLessIndex(int[] arr)
-    {
-       if(arr==null || arr.length==0)
-           return -1;
-       if(arr.length==1 || arr[0]<arr[1])
-           return 0;
-       if(arr[arr.length-1]<arr[arr.length-2])
-           return arr.length-1;
-       int left=1,right=arr.length-2;
-       int mid=0;
-       while(left<right){
-           mid=(left+right)>>>1;
-           if(arr[mid]>arr[mid-1]){
-               right=mid-1;
-           }else if(arr[mid]>arr[mid+1]){
-               left=mid+1;
-           }else{
-               return mid;
-           }
-       }
-       return left;
-    }
-    public static void printArray(int[] arr) {
-        for (int i = 0; i != arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-        int[] arr = { 6, 4, 3, 5, 6, 7, 8 };
-        printArray(arr);
-        int index = getLessIndex(arr);
-        System.out.println("index: " + index + ", value: " + arr[index]);
-
-    }
-
-
-}
Index: src/左神算法/基础班/第四课/FindOneLessValueIndex.java
===================================================================
diff --git a/src/左神算法/基础班/第四课/FindOneLessValueIndex.java b/src/左神算法/基础班/第四课/FindOneLessValueIndex.java
deleted file mode 100644
--- a/src/左神算法/基础班/第四课/FindOneLessValueIndex.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,49 +0,0 @@
-package 左神算法.基础班.第四课;
-
-public class FindOneLessValueIndex {
-
-    public static int getLessIndex(int[] arr)
-    {
-        if(arr==null || arr.length==0)
-            return -1;
-        if(arr.length==1 || arr[0]<arr[1])
-            return 0;
-        if(arr[arr.length-1]<arr[arr.length-2])
-        {
-            return arr.length-1;
-        }
-        int left=1;
-        int right=arr.length-2;
-        int mid=0;
-        while(left<right)
-        {
-            mid=left+(right-left)/2;
-            if(arr[mid]>arr[mid+1])
-            {
-                left=mid+1;
-            }
-            else if(arr[mid]>arr[mid-1])
-            {
-                right=mid-1;
-            }else{
-                return mid;
-            }
-        }
-        return left;
-    }
-
-    public static void printArray(int[] arr) {
-        for (int i = 0; i != arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-        int[] arr = { 6, 5, 3, 4, 6, 7, 8 };
-        printArray(arr);
-        int index = getLessIndex(arr);
-        System.out.println("index: " + index + ", value: " + arr[index]);
-
-    }
-}
Index: src/后端进阶小专栏/FisherYatesShuffle.java
===================================================================
diff --git a/src/后端进阶小专栏/FisherYatesShuffle.java b/src/后端进阶小专栏/FisherYatesShuffle.java
deleted file mode 100644
--- a/src/后端进阶小专栏/FisherYatesShuffle.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,28 +0,0 @@
-package 后端进阶小专栏;
-
-import java.util.Random;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:用于随机打乱一组数，并且时间复杂度为 O(N)。
-
-算法的基本思想是，每次从一组数中随机选出一个数，然后与最后一个数交换位置，并且不再考虑最后一个数。
- * @date 2020/7/5 10:47
- */
-public class FisherYatesShuffle {
-
-    public static void shuffle(int[] nums){
-        Random random=new Random();
-        for(int i=nums.length-1;i>=0;i--){
-            int j=random.nextInt(i+1);//选择[0,i]之间的某个随机位置
-            swap(nums,i,j);
-        }
-    }
-
-    private static void swap(int[] nums,int i,int j){
-        int tmp=nums[i];
-        nums[i]=nums[j];
-        nums[j]=tmp;
-    }
-}
Index: src/韩顺平算法与数据结构/algorithm/floyd/FloydAlgorithm.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/algorithm/floyd/FloydAlgorithm.java b/src/韩顺平算法与数据结构/algorithm/floyd/FloydAlgorithm.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/algorithm/floyd/FloydAlgorithm.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,96 +0,0 @@
-package 韩顺平算法与数据结构.algorithm.floyd;
-
-import java.util.Arrays;
-
-public class FloydAlgorithm {
-
-    public static void main(String[] args) {
-        // 测试看看图是否创建成功
-        char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
-        //创建邻接矩阵
-        int[][] matrix = new int[vertex.length][vertex.length];
-        final int N = 65535;
-        matrix[0] = new int[] { 0, 5, 7, N, N, N, 2 };
-        matrix[1] = new int[] { 5, 0, N, 9, N, N, 3 };
-        matrix[2] = new int[] { 7, N, 0, N, 8, N, N };
-        matrix[3] = new int[] { N, 9, N, 0, N, 4, N };
-        matrix[4] = new int[] { N, N, 8, N, 0, 5, 4 };
-        matrix[5] = new int[] { N, N, N, 4, 5, 0, 6 };
-        matrix[6] = new int[] { 2, 3, N, N, 4, 6, 0 };
-
-        //创建 Graph 对象
-        Graph graph = new Graph(vertex.length, matrix, vertex);
-        //调用弗洛伊德算法
-        graph.floyd();
-        graph.show();
-    }
-
-}
-
-// 创建图
-class Graph {
-    private char[] vertex; // 存放顶点的数组
-    private int[][] dis; // 保存，从各个顶点出发到其它顶点的距离，最后的结果，也是保留在该数组
-    private int[][] pre;// 保存到达目标顶点的前驱顶点
-
-    // 构造器
-    /**
-     *
-     * @param length
-     *            大小
-     * @param matrix
-     *            邻接矩阵
-     * @param vertex
-     *            顶点数组
-     */
-    public Graph(int length, int[][] matrix, char[] vertex) {
-        this.vertex = vertex;
-        this.dis = matrix;
-        this.pre = new int[length][length];
-        // 对pre数组初始化, 注意存放的是前驱顶点的下标
-        for (int i = 0; i < length; i++) {
-            Arrays.fill(pre[i], i);
-        }
-    }
-
-    // 显示pre数组和dis数组
-    public void show() {
-
-        //为了显示便于阅读，我们优化一下输出
-        char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
-        for (int k = 0; k < dis.length; k++) {
-            // 先将pre数组输出的一行
-            for (int i = 0; i < dis.length; i++) {
-                System.out.print(vertex[pre[k][i]] + " ");
-            }
-            System.out.println();
-            // 输出dis数组的一行数据
-            for (int i = 0; i < dis.length; i++) {
-                System.out.print("("+vertex[k]+"到"+vertex[i]+"的最短路径是" + dis[k][i] + ") ");
-            }
-            System.out.println();
-            System.out.println();
-
-        }
-
-    }
-
-    //弗洛伊德算法, 比较容易理解，而且容易实现
-    public void floyd() {
-        int len = 0; //变量保存距离
-        //对中间顶点遍历， k 就是中间顶点的下标 [A, B, C, D, E, F, G]
-        for(int k = 0; k < dis.length; k++) { //
-            //从i顶点开始出发 [A, B, C, D, E, F, G]
-            for(int i = 0; i < dis.length; i++) {
-                //到达j顶点 // [A, B, C, D, E, F, G]
-                for(int j = 0; j < dis.length; j++) {
-                    len = dis[i][k] + dis[k][j];// => 求出从i 顶点出发，经过 k中间顶点，到达 j 顶点距离
-                    if(len < dis[i][j]) {//如果len小于 dis[i][j]
-                        dis[i][j] = len;//更新距离
-                        pre[i][j] = pre[k][j];//更新前驱顶点
-                    }
-                }
-            }
-        }
-    }
-}
\ No newline at end of file
Index: src/Gof/Strategy/FlyBehavior.java
===================================================================
diff --git a/src/Gof/Strategy/FlyBehavior.java b/src/Gof/Strategy/FlyBehavior.java
deleted file mode 100644
--- a/src/Gof/Strategy/FlyBehavior.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,5 +0,0 @@
-package Gof.Strategy;
-
-public interface FlyBehavior {
-    void fly();
-}
Index: src/org/sd/FlyWeight/FlyWeight.java
===================================================================
diff --git a/src/org/sd/FlyWeight/FlyWeight.java b/src/org/sd/FlyWeight/FlyWeight.java
deleted file mode 100644
--- a/src/org/sd/FlyWeight/FlyWeight.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,30 +0,0 @@
-package org.sd.FlyWeight;
-
-public interface FlyWeight {
-    void setColor(String c);
-    String getColor();
-    void display(Coordinate c);
-}
-class ConcreteChess implements FlyWeight{
-    private String color;
-
-    public ConcreteChess(String color) {
-        this.color = color;
-    }
-
-    @Override
-    public void setColor(String c) {
-        this.color=c;
-    }
-
-    @Override
-    public String getColor() {
-        return color;
-    }
-
-    @Override
-    public void display(Coordinate c) {
-        System.out.println("棋子颜色："+color);
-        System.out.println("棋子位置： "+c.getX()+"---------"+c.getY());
-    }
-}
\ No newline at end of file
Index: src/org/sd/FlyWeight/FlyWeightFactory.java
===================================================================
diff --git a/src/org/sd/FlyWeight/FlyWeightFactory.java b/src/org/sd/FlyWeight/FlyWeightFactory.java
deleted file mode 100644
--- a/src/org/sd/FlyWeight/FlyWeightFactory.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,21 +0,0 @@
-package org.sd.FlyWeight;
-
-import java.util.HashMap;
-import java.util.Map;
-
-//享元池
-public class FlyWeightFactory {
-    private static Map<String,ConcreteChess> map=new HashMap<>() ;
-
-    public static  ConcreteChess getChess(String color)
-    {
-        if(map.get(color)!=null) {
-            return map.get(color);
-        }else{
-            ConcreteChess concreteChess=new ConcreteChess(color);
-            map.put(color,concreteChess);
-            return concreteChess;
-        }
-
-    }
-}
Index: src/Gof/bridge/FoldPhone.java
===================================================================
diff --git a/src/Gof/bridge/FoldPhone.java b/src/Gof/bridge/FoldPhone.java
deleted file mode 100644
--- a/src/Gof/bridge/FoldPhone.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,26 +0,0 @@
-package Gof.bridge;
-
-public class FoldPhone extends Phone{
-
-    public FoldPhone(Brand brand)
-    {
-        super(brand);
-
-    }
-    public void open()
-    {
-        super.open();
-        System.out.println("折叠样式手机");
-    }
-    public void close()
-    {
-        super.close();
-        System.out.println("折叠样式手机");
-
-    }
-    public void call()
-    {
-        super.call();
-        System.out.println("折叠样式手机");
-    }
-}
Index: src/重温设计模式/其他模式/Future模式/FutureData.java
===================================================================
diff --git a/src/重温设计模式/其他模式/Future模式/FutureData.java b/src/重温设计模式/其他模式/Future模式/FutureData.java
deleted file mode 100644
--- a/src/重温设计模式/其他模式/Future模式/FutureData.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,38 +0,0 @@
-package 重温设计模式.其他模式.Future模式;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/19 13:10
- */
-public class FutureData implements Data{
-
-    private RealData realData;
-    private boolean isReady;
-
-    public synchronized void setRealData(RealData realData){
-        if(isReady){
-            return;
-        }
-        this.realData = realData;
-        isReady = true;
-        notifyAll();
-        return;
-    }
-
-
-
-    @Override
-    public String getResult() {
-        while(!isReady){
-            try{
-                //一直等待
-                wait();
-            } catch (InterruptedException e) {
-                e.printStackTrace();
-            }
-        }
-        return realData.result;
-    }
-}
Index: src/JUC/demo6/GCDemo.java
===================================================================
diff --git a/src/JUC/demo6/GCDemo.java b/src/JUC/demo6/GCDemo.java
deleted file mode 100644
--- a/src/JUC/demo6/GCDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,18 +0,0 @@
-package JUC.demo6;
-
-import java.util.Random;
-
-public class GCDemo {
-    public static void main(String[] args) {
-        long l = Runtime.getRuntime().maxMemory();
-        System.out.println("-Xmx memory= "+(double)l/1024/1024+"MB");
-        long l1 = Runtime.getRuntime().totalMemory();
-        System.out.println((double)l1/1024/1024);
-
-        String str="wwww";
-//        while(true)
-//        {
-//            str=str+ new Random().nextInt(999)+new Random().nextInt(888);
-//        }
-    }
-}
Index: src/JUC/GCOverheadDemo/GCOverheadDemo.java
===================================================================
diff --git a/src/JUC/GCOverheadDemo/GCOverheadDemo.java b/src/JUC/GCOverheadDemo/GCOverheadDemo.java
deleted file mode 100644
--- a/src/JUC/GCOverheadDemo/GCOverheadDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,24 +0,0 @@
-package JUC.GCOverheadDemo;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class GCOverheadDemo {
-
-    public static void main(String[] args) {
-
-        int i=0;
-        List<String> list=new ArrayList<>();
-        try{
-            while(true)
-            {
-                list.add(String.valueOf(++i).intern());
-            }
-        }catch (Exception e)
-        {
-            System.out.println("***************i= "+i);
-            e.printStackTrace();
-            throw e;
-        }
-    }
-}
Index: src/org/sd/chainofR/GeneralManager.java
===================================================================
diff --git a/src/org/sd/chainofR/GeneralManager.java b/src/org/sd/chainofR/GeneralManager.java
deleted file mode 100644
--- a/src/org/sd/chainofR/GeneralManager.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,19 +0,0 @@
-package org.sd.chainofR;
-
-public class GeneralManager extends Leader {
-
-    public GeneralManager(String name) {
-        super(name);
-    }
-
-    @Override
-    public void handleRequest(LeaveRequest request) {
-        if(request.getLeaveDays()<30){
-            System.out.println("员工："+request.getEmpName()+"请假，天数："+request.getLeaveDays()+",理由："+request.getReason());
-            System.out.println("总经理："+this.name+",审批通过！");
-        }else{
-            System.out.println("莫非"+request.getEmpName()+"想辞职，居然请假"+request.getLeaveDays()+"天！");
-        }
-    }
-
-}
\ No newline at end of file
Index: src/后端进阶小专栏/GeneratePacketsByDoubleMean.java
===================================================================
diff --git a/src/后端进阶小专栏/GeneratePacketsByDoubleMean.java b/src/后端进阶小专栏/GeneratePacketsByDoubleMean.java
deleted file mode 100644
--- a/src/后端进阶小专栏/GeneratePacketsByDoubleMean.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,27 +0,0 @@
-package 后端进阶小专栏;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Random;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 抢红包算法之二倍均值法
- * @date 2020/7/5 15:02
- */
-public class GeneratePacketsByDoubleMean {
-
-    public List<Integer> generatePackets(int people,int money){
-        Random random=new Random();
-        List<Integer>list=new ArrayList<>();
-        while(people>1){
-            int p=random.nextInt(2*money/people);
-            people--;
-            money-=p;
-            list.add(p);
-        }
-        list.add(money);
-        return list;
-    }
-}
Index: src/剑指offer牛客上没有的题目/GetDuplication.java
===================================================================
diff --git a/src/剑指offer牛客上没有的题目/GetDuplication.java b/src/剑指offer牛客上没有的题目/GetDuplication.java
deleted file mode 100644
--- a/src/剑指offer牛客上没有的题目/GetDuplication.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,55 +0,0 @@
-package 剑指offer牛客上没有的题目;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:不修改数组找出数组中的重复的数字
- * 在一个长度为n+1的数组里的所有的数字都在1~n的范围内，所以数组中至少有一个重复的数字，请找出数组中任意的一个重复的数字
- * 要求：空间复杂度为O(1)
- *
- * @date 2020/3/14 19:17
- */
-public class GetDuplication {
-
-    public static int getResult(int [] arr,int len){
-        if(arr==null || len<1)
-            return -1;
-        int start=1;
-        int end=len-1;
-        int mid=0;
-        while(start<=end){
-            mid=((end-start)>>1)+start;
-            int count=countRange(arr,len,start,mid);
-            if(start==end){
-                if(count>1)
-                    return start;
-                else
-                    break;
-            }
-            if(count>mid-start+1){
-                end=mid;
-            }else{
-                start=mid+1;
-            }
-
-        }
-        return -1;
-    }
-
-    //统计数组中的元素在start-end的个数
-    private static int countRange(int[] arr,int len,int start,int end){
-
-        int count=0;
-        for(int i=0;i<len;i++){
-            if(arr[i]>=start && arr[i]<=end)
-                count++;
-        }
-        return count;
-    }
-
-
-    public static void main(String[] args) {
-
-
-    }
-}
Index: src/左神算法/基础班/第三课/GetMinStack.java
===================================================================
diff --git a/src/左神算法/基础班/第三课/GetMinStack.java b/src/左神算法/基础班/第三课/GetMinStack.java
deleted file mode 100644
--- a/src/左神算法/基础班/第三课/GetMinStack.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,101 +0,0 @@
-package 左神算法.基础班.第三课;
-
-import java.util.Stack;
-
-public class GetMinStack {
-
-
-    //方式一
-    public static class MyStack01{
-
-        private Stack<Integer> stackData;
-        private Stack<Integer> stackMin;
-
-        public MyStack01()
-        {
-            this.stackData=new Stack<>();
-            this.stackMin=new Stack<>();
-
-        }
-        public void push(int newNum)
-        {
-            if(this.stackMin.isEmpty())
-                stackMin.push(newNum);
-            else if(this.stackMin.peek()>=newNum)
-                stackMin.push(newNum);
-            stackData.push(newNum);
-        }
-
-        public Integer pop()
-        {
-            if(this.stackData.isEmpty())
-                throw new RuntimeException("your stack is empty");
-            int value=this.stackData.pop();
-            if(value==this.getmin())
-                stackMin.pop();
-            return value;
-
-        }
-        public int getmin() {
-            if (this.stackMin.isEmpty()) {
-                throw new RuntimeException("Your stack is empty.");
-            }
-            return this.stackMin.peek();
-        }
-
-
-
-
-    }
-
-    //方式二
-    public static class MyStack02{
-        private Stack<Integer> stackData;
-        private Stack<Integer> stackMin;
-
-        public MyStack02() {
-            this.stackData = new Stack<Integer>();
-            this.stackMin = new Stack<Integer>();
-        }
-        public void push(int newNum)
-        {
-            if(this.stackMin.isEmpty())
-                stackMin.push(newNum);
-            else if(newNum<=stackMin.peek())
-                stackMin.push(newNum);
-            else
-                stackMin.push(stackMin.peek());
-            stackData.push(newNum);
-        }
-
-        public Integer pop(){
-            if(this.stackData.isEmpty())
-                throw new RuntimeException("Your stack is empty");
-            this.stackMin.pop();
-            return this.stackData.pop();
-        }
-    }
-    public static void main(String[] args) {
-        MyStack01 stack1 = new MyStack01();
-        stack1.push(3);
-        System.out.println(stack1.getmin());
-        stack1.push(4);
-        System.out.println(stack1.getmin());
-        stack1.push(1);
-        System.out.println(stack1.getmin());
-        System.out.println(stack1.pop());
-        System.out.println(stack1.getmin());
-
-        System.out.println("=============");
-
-        MyStack01 stack2 = new MyStack01();
-        stack2.push(3);
-        System.out.println(stack2.getmin());
-        stack2.push(4);
-        System.out.println(stack2.getmin());
-        stack2.push(1);
-        System.out.println(stack2.getmin());
-        System.out.println(stack2.pop());
-        System.out.println(stack2.getmin());
-    }
-}
Index: src/Gof/Strategy/GoodFlyBehavior.java
===================================================================
diff --git a/src/Gof/Strategy/GoodFlyBehavior.java b/src/Gof/Strategy/GoodFlyBehavior.java
deleted file mode 100644
--- a/src/Gof/Strategy/GoodFlyBehavior.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package Gof.Strategy;
-
-public class GoodFlyBehavior implements FlyBehavior {
-    @Override
-    public void fly() {
-        System.out.println("飞行技术高超");
-    }
-}
Index: src/Gof/Strategy/GoodQuackBehavior.java
===================================================================
diff --git a/src/Gof/Strategy/GoodQuackBehavior.java b/src/Gof/Strategy/GoodQuackBehavior.java
deleted file mode 100644
--- a/src/Gof/Strategy/GoodQuackBehavior.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package Gof.Strategy;
-
-public class GoodQuackBehavior implements QuackBehavior{
-    @Override
-    public void quack() {
-        System.out.println("大声的叫");
-    }
-}
Index: src/左神算法/基础班/图/Graph.java
===================================================================
diff --git a/src/左神算法/基础班/图/Graph.java b/src/左神算法/基础班/图/Graph.java
deleted file mode 100644
--- a/src/左神算法/基础班/图/Graph.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,15 +0,0 @@
-package 左神算法.基础班.图;
-
-import java.util.HashMap;
-import java.util.HashSet;
-
-public class Graph {
-    //由结点和边组成
-    public HashMap<Integer,Node> nodes; //Integer的值与Node中的value值相同
-    public HashSet<Edge> edges;
-
-    public Graph() {
-        nodes=new HashMap<>();
-        edges=new HashSet<>();
-    }
-}
Index: src/韩顺平算法与数据结构/datastructure/Graph/Graph.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/Graph/Graph.java b/src/韩顺平算法与数据结构/datastructure/Graph/Graph.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/Graph/Graph.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,176 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.Graph;
-
-import javax.naming.LinkLoopException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.LinkedList;
-
-public class Graph {
-    private ArrayList<String> vertexList;//存储顶点集合
-    private int[][] edges;//存储图对应的邻接矩阵
-    private int numOfEdges;//存储边的数量
-    private boolean[] isVisited;
-
-    public static void main(String[] args) {
-        int n=8;//结点的个数
-      String vertexs[] = {"1", "2", "3", "4", "5", "6", "7", "8"};
-      Graph graph=new Graph(n);
-      for(String vertex:vertexs)
-      {
-          graph.insertVertex(vertex);
-      }
-
-        graph.insertEdge(0, 1, 1);
-        graph.insertEdge(0, 2, 1);
-        graph.insertEdge(1, 3, 1);
-        graph.insertEdge(1, 4, 1);
-        graph.insertEdge(3, 7, 1);
-        graph.insertEdge(4, 7, 1);
-        graph.insertEdge(2, 5, 1);
-        graph.insertEdge(2, 6, 1);
-        graph.insertEdge(5, 6, 1);
-
-        //graph.showGraph();//显示
-        graph.dfs();
-        System.out.println();
-        graph.bfs();
-    }
-
-    public Graph(int n)
-    {
-        vertexList=new ArrayList<>(n);
-        edges=new int[n][n];
-        numOfEdges=0;
-    }
-
-    //得到第一个邻接结点
-    public int getFirstNeighbor(int index)
-    {
-        for(int i=0;i<vertexList.size();i++)
-        {
-            if(edges[index][i]>0)
-            {
-                return i;
-            }
-        }
-        return -1;
-    }
-    //根据前一个邻接结点饿坐标来获取下一个邻接结点
-    public int getNextNeighbor(int v1,int v2)
-    {
-        for(int i=v2+1;i<vertexList.size();i++)
-        {
-            if(edges[v1][i]>0)
-            {
-                return i;
-            }
-        }
-        return -1;//如果不存在返回-1；
-    }
-    //深度优先遍历，i第一次就是0
-    private void dfs(boolean[]isVisited,int i)
-    {
-        //首先我们访问该结点，输出
-        System.out.print(vertexList.get(i)+"->");
-        isVisited[i]=true;
-        int w=getFirstNeighbor(i);
-        while (w!=-1)
-        {
-            if(!isVisited[w])
-            {
-                dfs(isVisited,w);
-            }
-            //如果w被访问过了
-            w=getNextNeighbor(i,w);//查找w的下一个节点
-        }
-    }
-
-    public void dfs()
-    {
-        isVisited=new boolean[vertexList.size()];
-        for(int i=0;i<vertexList.size();i++)
-        {
-            if(!isVisited[i])
-            dfs(isVisited,i);
-        }
-    }
-
-    //对一个结点进行广度优先遍历算法
-    private void bfs(boolean[] isVisited,int i)
-    {
-        int u;//表示队列头结点对应的结点下标
-        int w;//邻接结点
-        LinkedList queue=new LinkedList();
-        System.out.print(getValueByIndex(i)+"->");
-        isVisited[i]=true;
-        queue.addLast(i);//利用队列来记录访问的结点的顺序
-        while(!queue.isEmpty())
-        {
-            //取出队列的头结点的下标
-            u=(int)queue.removeFirst();
-            w=getFirstNeighbor(u);
-            while(w!=-1)
-            {
-                if(!isVisited[w])
-                {   isVisited[w]=true;
-                    System.out.print(getValueByIndex(w)+"->");
-                    queue.addLast(w);
-                }
-                //以u为前驱结点，找w后面的下一个邻节点
-                w=getNextNeighbor(u,w);
-
-            }
-        }
-    }
-
-    public void bfs()
-    {   isVisited=new boolean[vertexList.size()];
-        for(int i=0;i<vertexList.size();i++)
-        {
-            if(isVisited[i])
-                bfs(isVisited,i);
-        }
-    }
-    //返回顶点的个数
-    public int getNumOfVertex()
-    {
-        return vertexList.size();
-    }
-    //显示图对应的矩阵
-    public void showGraph()
-    {
-        for(int[] arr:edges)
-        {
-            System.out.println(Arrays.toString(arr));
-        }
-    }
-
-    //得到边的个数
-    public int getNumOfEdges()
-    {
-        return numOfEdges;
-    }
-
-    //返回结点（i）对应的数据
-    public String getValueByIndex(int i)
-    {
-        return vertexList.get(i);
-    }
-    //返回 v1 v2对应的权值
-     public int getWeight(int v1,int v2)
-     {
-         return edges[v1][v2];
-     }
-    //插入结点
-    public void insertVertex(String vertex)
-    {
-        vertexList.add(vertex);
-    }
-    //添加边
-    public void insertEdge(int v1,int v2,int weight)
-    {
-        edges[v1][v2]=weight;
-        edges[v2][v1]=weight;
-        numOfEdges++;//边的数量加1
-    }
-}
Index: src/左神算法/基础班/图/GraphGenerator.java
===================================================================
diff --git a/src/左神算法/基础班/图/GraphGenerator.java b/src/左神算法/基础班/图/GraphGenerator.java
deleted file mode 100644
--- a/src/左神算法/基础班/图/GraphGenerator.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,33 +0,0 @@
-package 左神算法.基础班.图;
-
-public class GraphGenerator {
-
-    public static Graph createGraph(Integer[][] matrix){
-        Graph graph=new Graph();
-        for(int i=0;i<matrix.length;i++)
-        {
-            Integer from=matrix[i][0];
-            Integer to=matrix[i][1];
-            Integer weight=matrix[i][2];
-            if(!graph.nodes.containsKey(from))
-            {
-                graph.nodes.put(from,new Node(from));
-            }
-            if(!graph.nodes.containsKey(to))
-            {
-                graph.nodes.put(to,new Node(to));
-            }
-            Node fromNode=graph.nodes.get(from);
-            Node toNode=graph.nodes.get(to);
-            Edge newEdge=new Edge(fromNode,weight,toNode);
-            graph.edges.add(newEdge);
-            fromNode.out++;
-            toNode.in++;
-            fromNode.edges.add(newEdge);
-            fromNode.nexts.add(toNode);
-
-        }
-        return graph;
-    }
-
-}
Index: src/韩顺平算法与数据结构/algorithm/greedy/GreedyAlgorithm.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/algorithm/greedy/GreedyAlgorithm.java b/src/韩顺平算法与数据结构/algorithm/greedy/GreedyAlgorithm.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/algorithm/greedy/GreedyAlgorithm.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,87 +0,0 @@
-package 韩顺平算法与数据结构.algorithm.greedy;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-
-public class GreedyAlgorithm {
-    public static void main(String[] args) {
-        //创建电台的集合
-        HashMap<String, HashSet<String>> broadcast=new HashMap<>();
-        //创建单个电台
-        HashSet<String> hashSet1=new HashSet<>();
-        hashSet1.add("北京");
-        hashSet1.add("上海");
-        hashSet1.add("天津");
-
-        HashSet<String> hashSet2=new HashSet<>();
-        hashSet2.add("广州");
-        hashSet2.add("北京");
-        hashSet2.add("深圳");
-
-        HashSet<String> hashSet3=new HashSet<>();
-        hashSet3.add("成都");
-        hashSet3.add("上海");
-        hashSet3.add("杭州");
-
-        HashSet<String> hashSet4=new HashSet<>();
-        hashSet4.add("上海");
-        hashSet4.add("天津");
-
-        HashSet<String> hashSet5=new HashSet<>();
-        hashSet5.add("杭州");
-        hashSet5.add("大连");
-        broadcast.put("k1",hashSet1);
-        broadcast.put("k2",hashSet2);
-        broadcast.put("k3",hashSet3);
-        broadcast.put("k4",hashSet4);
-        broadcast.put("k5",hashSet5);
-
-        //存放所有的地区
-        HashSet<String>allAreas =new HashSet<>();
-        allAreas.add("北京");
-        allAreas.add("上海");
-        allAreas.add("天津");
-        allAreas.add("广州");
-        allAreas.add("深圳");
-        allAreas.add("成都");
-        allAreas.add("杭州");
-        allAreas.add("大连");
-
-        //存放选择出来的电台
-        ArrayList<String >selects=new ArrayList<>();
-        String maxKey=null;
-        HashSet<String> temp=new HashSet<>();//临时变量用来存放遍历过程中电台覆盖的地区和当前还没有覆盖地区的交集
-        while(allAreas.size()!=0)
-        {   //每进行一次while都将maxKey置空
-            maxKey=null;
-            for(String key:broadcast.keySet())
-            {
-                temp.clear();//每次循环都要清空temp。
-                HashSet<String> area=broadcast.get(key);
-                temp.addAll(area);
-                temp.retainAll(allAreas);//求交集，结果保存在temp中。
-                if(temp.size()>0 && (maxKey==null || temp.size()>broadcast.get(maxKey).size()))
-               {
-                   maxKey=key;
-               }
-            }
-            if(maxKey!=null)
-            {
-                selects.add(maxKey);
-                //将maxkey所指向的广播电台覆盖的地区，从allareas中去电
-                allAreas.removeAll(broadcast.get(maxKey));//removeAll:删除二者的交集
-            }
-
-
-        }
-
-        System.out.println(selects);
-
-
-
-
-
-    }
-
-}
Index: src/Gof/Factory/simpleFactory/GreekPizza.java
===================================================================
diff --git a/src/Gof/Factory/simpleFactory/GreekPizza.java b/src/Gof/Factory/simpleFactory/GreekPizza.java
deleted file mode 100644
--- a/src/Gof/Factory/simpleFactory/GreekPizza.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package Gof.Factory.simpleFactory;
-
-public class GreekPizza extends Pizza {
-    @Override
-    public void prepare() {
-        System.out.println("给希腊披散准备原材料！！");
-    }
-}
Index: .idea/libraries/guava_25_1_jre.xml
===================================================================
diff --git a/.idea/libraries/guava_25_1_jre.xml b/.idea/libraries/guava_25_1_jre.xml
deleted file mode 100644
--- a/.idea/libraries/guava_25_1_jre.xml	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,9 +0,0 @@
-<component name="libraryTable">
-  <library name="guava-25.1-jre">
-    <CLASSES>
-      <root url="jar://$PROJECT_DIR$/src/guava-25.1-jre.jar!/" />
-    </CLASSES>
-    <JAVADOC />
-    <SOURCES />
-  </library>
-</component>
\ No newline at end of file
Index: src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/GUIFactory.java
===================================================================
diff --git a/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/GUIFactory.java b/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/GUIFactory.java
deleted file mode 100644
--- a/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/GUIFactory.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,15 +0,0 @@
-package 重温设计模式.创建型模式.工厂模式.抽象工厂模式.示例;
-
-import java.awt.*;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 抽象工厂
- * @date 2021/5/19 17:01
- */
-public interface GUIFactory {
-
-    Button createButton();
-    CheckBox createCheckbox();
-}
Index: src/韩顺平算法与数据结构/algorithm/dac/hannuota.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/algorithm/dac/hannuota.java b/src/韩顺平算法与数据结构/algorithm/dac/hannuota.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/algorithm/dac/hannuota.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,25 +0,0 @@
-package 韩顺平算法与数据结构.algorithm.dac;
-
-public class hannuota {
-
-    public static void main(String[] args) {
-       hannuota(5, 'A', 'B', 'C');
-    }
-
-    public static void hannuota(int num,char a,char b,char c)
-    {
-        if(num==1)
-        {
-            System.out.println("第一个盘子从："+a+"->"+c);
-        }else {
-            //将前num-1个盘子看做是一个盘子，最下面的看做是一个盘子。
-            //1.先把最上面的所有盘子a->b，移动过程中会使用到c
-            hannuota(num-1,a,c,b);
-            //最下面的盘子移动到c
-            System.out.println("第"+num+"个盘子从："+a+"->"+c);
-            //将b上的盘子移动到c
-            hannuota(num-1,b,a,c);
-
-        }
-    }
-}
Index: src/左神算法/基础班/动态规划与递归/Hanoi.java
===================================================================
diff --git a/src/左神算法/基础班/动态规划与递归/Hanoi.java b/src/左神算法/基础班/动态规划与递归/Hanoi.java
deleted file mode 100644
--- a/src/左神算法/基础班/动态规划与递归/Hanoi.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,30 +0,0 @@
-package 左神算法.基础班.动态规划与递归;
-
-/**
- * d打印N层汉诺塔从最左边移动到最右边的全部过程
- */
-public class Hanoi {
-
-    public static void hanio(int n){
-
-        if(n>=1){
-            process(n,"left","right","help");
-        }
-    }
-
-    public static void process(int n,String from,String to,String help)//注意这里有个表示数量的变量
-    {
-        if(n==1)
-        {
-            System.out.println("move[1] from "+from +" to "+to);
-        }else {
-            process(n - 1, from, help, to);
-            System.out.println("move "+ n+" from "+ from +" to "+to);
-            process(n - 1, help, to, from);
-        }
-    }
-
-    public static void main(String[] args) {
-        hanio(3);
-    }
-}
Index: src/韩顺平算法与数据结构/datastructure/HashTabDemo.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/HashTabDemo.java b/src/韩顺平算法与数据结构/datastructure/HashTabDemo.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/HashTabDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,182 +0,0 @@
-package 韩顺平算法与数据结构.datastructure;
-
-import java.util.Hashtable;
-import java.util.Scanner;
-
-public class HashTabDemo {
-    public static void main(String[] args) {
-        HashTab hashTab=new HashTab(7);
-        //写一个简单的菜单
-        String key="";
-        Scanner scanner=new Scanner(System.in);
-        while(true){
-            System.out.println("add: 添加雇员信息");
-            System.out.println("list:显示雇员");
-            System.out.println("find:查找雇员");
-            System.out.println("exit:退出系统");
-            key=scanner.next();
-            switch (key){
-                case "add":
-                    System.out.println("输入id");
-                    int id=scanner.nextInt();
-                    System.out.println("请输入名字");
-                    String name=scanner.next();
-                    //创建雇员
-                    Emp emp=new Emp(id,name);
-                    hashTab.add(emp);
-                    break;
-                case"list":
-                    hashTab.list();
-                    break;
-                case "find":
-                    System.out.println("请输入要查找的id");
-                    id=scanner.nextInt();
-                    hashTab.findEmpById(id);
-                    break;
-                case"exit":
-                    scanner.close();
-                    System.exit(0);
-                default:
-                    break;
-
-            }
-        }
-    }
-
-
-}
-class HashTab{
-
-    private EmpLinkList[] empLinkListArray;
-    private int size;//表示有多少条链表
-
-     public HashTab(int size)
-     {
-         this.size=size;
-         empLinkListArray=new EmpLinkList[size];
-         for(int i=0;i<size;i++)
-         {
-             empLinkListArray[i]=new EmpLinkList();
-         }
-     }
-
-     //添加雇员
-    public void add(Emp emp)
-    {
-        int empLinkedListNo=hashFun(emp.id);
-        empLinkListArray[empLinkedListNo].add(emp);
-    }
-
-    //遍历所有的链表，遍历hashtab
-    public void list()
-    {
-        for(int i=0;i<size;i++)
-            empLinkListArray[i].list(i);
-    }
-    //根据输入的id，查找雇员
-    public void findEmpById(int id){
-         int empLinkedListNo=hashFun(id);
-         Emp emp=empLinkListArray[empLinkedListNo].findEmpById(id);
-         if(emp!=null) {//找到
-             System.out.printf("在第%d条链表中找到 雇员 id = %d\n", (empLinkedListNo + 1), id);
-         }else{
-             System.out.println("在哈希表中，没有找到该雇员~");
-         }
-    }
-    //编写散列函数
-    public int hashFun(int id){
-         return id%size;
-    }
-
-}
-class Emp{
-    public int id;
-    public String name;
-    public Emp next;
-
-    public Emp(int id, String name) {
-        this.id = id;
-        this.name = name;
-    }
-}
-
-class EmpLinkList{
-
-    //头指针,指向第一个Emp,因此我们这个链表的head是直接指向第一个emp
-    private Emp head;
-
-    //添加,不带头结点，即链表的第一个头结点就存放雇员信息
-    public void add(Emp emp){
-
-        if(head==null){
-            head=emp;
-            return;
-        }
-        //如果不是第一个雇员，就使用辅助接点，插入到指定位置
-        Emp curEmp=head;
-        boolean flag=false;//标志位，判断插入点是否已经存在
-
-        while(true){
-            if(curEmp.next==null){
-                break;
-
-            }
-            if(curEmp.next.id>emp.id){
-                break;
-            }
-            if(curEmp.id==emp.id)
-            {
-                flag=true;
-                break;
-            }
-            curEmp=curEmp.next;
-        }
-        //插入点不存在
-        if(!flag){
-            emp.next=curEmp.next;
-            curEmp.next=emp;
-        }else{
-            System.out.println("插入结点已经存在！！！");
-        }
-    }
-
-    //遍历雇员信息
-    public void list(int no){
-        if(head==null){
-            System.out.println("第 "+(no+1)+"链表为空");
-            return;
-        }
-        System.out.print("第 "+(no+1)+" 链表的信息为");
-        Emp curEmp = head; //辅助指针
-        while(true)
-        {
-            System.out.printf("=>id=%d name=%s\t",curEmp.id,curEmp.name);
-            if(curEmp.next==null){
-                break;
-            }
-            curEmp=curEmp.next;
-        }
-        System.out.println();
-    }
-
-    public Emp findEmpById(int id){
-        if(head==null){
-            System.out.println("链表为空");
-            return null;
-        }
-        Emp curEmp=head;
-        while(true){
-            if(curEmp.id==id)
-            {
-                break;
-            }
-            if(curEmp.next==null){
-                curEmp=null;
-                break;
-            }
-            curEmp=curEmp.next;
-        }
-        return curEmp;
-    }
-
-}
\ No newline at end of file
Index: src/左神算法/基础班/Sort/HeapSort.java
===================================================================
diff --git a/src/左神算法/基础班/Sort/HeapSort.java b/src/左神算法/基础班/Sort/HeapSort.java
deleted file mode 100644
--- a/src/左神算法/基础班/Sort/HeapSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,138 +0,0 @@
-package 左神算法.基础班.Sort;
-
-import java.util.Arrays;
-
-public class HeapSort {
-
-
-    public static void heapSort(int[] arr)
-    {
-        if(arr==null || arr.length<2)
-            return ;
-        //模拟构建大顶堆的过程，对数组中每一个元素进行处理
-        for(int i=0;i<arr.length;i++)
-        {
-            heapInsert(arr,i);
-        }
-        int size=arr.length;
-        swap(arr,0,--size);//将大根堆顶头顶的元素与最后一个元素互换，即实现将最大的元素放在数组的最后一个位置
-        while(size>0)
-        {
-            heapify(arr,0,size);
-            swap(arr,0,--size);
-        }
-
-    }
-
-    //仅仅是完成了数组中一个结点的位置构建
-    public static void heapInsert(int[] arr,int index)
-    {
-        while (arr[index] > arr[(index-1)/2]) {// i=-1;i/2的结果是0
-            swap(arr,index,(index-1)/2);//和父位置交换
-            index=(index-1)/2;//当前位置到父位置，继续判断
-        }
-    }
-
-    public static void heapify(int[] arr,int index,int size)
-    {
-        int left = index * 2 + 1;
-        while (left < size) {
-            int largest = left + 1 < size && arr[left + 1] > arr[left] ? left + 1 : left; //运算符的优先级注意
-            largest = arr[largest] > arr[index] ? largest : index;  //可能存在重复的元素
-            if (largest == index) {
-                break;
-            }
-            swap(arr, largest, index);
-            index = largest;
-            left = index * 2 + 1;
-        }
-    }
-
-    public static void swap(int[] arr, int i, int j) {
-        int tmp = arr[i];
-        arr[i] = arr[j];
-        arr[j] = tmp;
-    }
-
-    // for test
-    public static void comparator(int[] arr) {
-        Arrays.sort(arr);
-    }
-
-    // for test
-    public static int[] generateRandomArray(int maxSize, int maxValue) {
-        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
-        for (int i = 0; i < arr.length; i++) {
-            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
-        }
-        return arr;
-    }
-
-    // for test
-    public static int[] copyArray(int[] arr) {
-        if (arr == null) {
-            return null;
-        }
-        int[] res = new int[arr.length];
-        for (int i = 0; i < arr.length; i++) {
-            res[i] = arr[i];
-        }
-        return res;
-    }
-
-    // for test
-    public static boolean isEqual(int[] arr1, int[] arr2) {
-        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
-            return false;
-        }
-        if (arr1 == null && arr2 == null) {
-            return true;
-        }
-        if (arr1.length != arr2.length) {
-            return false;
-        }
-        for (int i = 0; i < arr1.length; i++) {
-            if (arr1[i] != arr2[i]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    // for test
-    public static void printArray(int[] arr) {
-        if (arr == null) {
-            return;
-        }
-        for (int i = 0; i < arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    // for test
-    public static void main(String[] args) {
-//        int testTime = 500000;
-//        int maxSize = 100;
-//        int maxValue = 100;
-//        boolean succeed = true;
-//        for (int i = 0; i < testTime; i++) {
-//            int[] arr1 = generateRandomArray(maxSize, maxValue);
-//            int[] arr2 = copyArray(arr1);
-//            heapSort(arr1);
-//            comparator(arr2);
-//            if (!isEqual(arr1, arr2)) {
-//                succeed = false;
-//                break;
-//            }
-//        }
-//        System.out.println(succeed ? "Nice!" : "Fucking fucked!");
-//
-//        int[] arr = generateRandomArray(maxSize, maxValue);
-//        printArray(arr);
-//        heapSort(arr);
-//        printArray(arr);
-        System.out.println(-14 / 12);
-
-    }
-}
Index: src/左神算法/面试重写与剑指offer/HeapSort.java
===================================================================
diff --git a/src/左神算法/面试重写与剑指offer/HeapSort.java b/src/左神算法/面试重写与剑指offer/HeapSort.java
deleted file mode 100644
--- a/src/左神算法/面试重写与剑指offer/HeapSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,135 +0,0 @@
-package 左神算法.面试重写与剑指offer;
-
-import java.util.Arrays;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2020/3/20 8:05
- */
-public class HeapSort {
-
-    //从小到大排序
-    public static void heapSort(int[] arr){
-       if(arr==null || arr.length<2)
-           return;
-       int n=arr.length;
-       for(int i=0;i<n;i++){
-           heapInsert(arr,i);
-       }
-       swap(arr,0,--n);
-       while(n>0){
-           heapify(arr,0,n);
-           swap(arr,0,--n);
-       }
-    }
-    private static void heapInsert(int[] arr,int index){
-
-        while(arr[index]>arr[(index-1)/2]){
-            swap(arr,index,(index-1)/2);
-            index=(index-1)/2;
-        }
-    }
-    private static void heapify(int[] arr,int start,int end){
-        int left=start*2+1;
-        while(left<end){
-            int indexMax=left+1<end && arr[left+1]>arr[left] ? left+1:left;
-            if(arr[start]>arr[indexMax]){
-                break;
-            }
-            swap(arr,start,indexMax);
-            start=indexMax;
-            left=start*2+1;
-        }
-    }
-
-
-
-    private static void swap(int[] arr, int l, int r) {
-        int temp=arr[l];
-        arr[l]=arr[r];
-        arr[r]=temp;
-    }
-    // for test
-    public static void comparator(int[] arr) {
-        Arrays.sort(arr);
-    }
-
-    // for test
-    public static int[] generateRandomArray(int maxSize, int maxValue) {
-        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
-        for (int i = 0; i < arr.length; i++) {
-            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
-        }
-        return arr;
-    }
-
-    // for test
-    public static int[] copyArray(int[] arr) {
-        if (arr == null) {
-            return null;
-        }
-        int[] res = new int[arr.length];
-        for (int i = 0; i < arr.length; i++) {
-            res[i] = arr[i];
-        }
-        return res;
-    }
-
-    // for test
-    public static boolean isEqual(int[] arr1, int[] arr2) {
-        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
-            return false;
-        }
-        if (arr1 == null && arr2 == null) {
-            return true;
-        }
-        if (arr1.length != arr2.length) {
-            return false;
-        }
-        for (int i = 0; i < arr1.length; i++) {
-            if (arr1[i] != arr2[i]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    // for test
-    public static void printArray(int[] arr) {
-        if (arr == null) {
-            return;
-        }
-        for (int i = 0; i < arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    // for test
-    public static void main(String[] args) {
-        int testTime = 500000;
-        int maxSize = 100;
-        int maxValue = 100;
-        boolean succeed = true;
-        for (int i = 0; i < testTime; i++) {
-            int[] arr1 = generateRandomArray(maxSize, maxValue);
-            int[] arr2 = copyArray(arr1);
-            heapSort(arr1);
-            comparator(arr2);
-            if (!isEqual(arr1, arr2)) {
-                succeed = false;
-                break;
-            }
-        }
-        System.out.println(succeed ? "Nice!" : "Fucking fucked!");
-
-        int[] arr = generateRandomArray(maxSize, maxValue);
-        printArray(arr);
-        heapSort(arr);
-        printArray(arr);
-
-
-    }
-}
Index: src/算法重写练习/排序/HeapSort.java
===================================================================
diff --git a/src/算法重写练习/排序/HeapSort.java b/src/算法重写练习/排序/HeapSort.java
deleted file mode 100644
--- a/src/算法重写练习/排序/HeapSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,155 +0,0 @@
-package 算法重写练习.排序;
-
-import java.util.Arrays;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2020/6/28 19:28
- */
-public class HeapSort {
-
-    //从小到大实现堆排序
-
-    public static void heapSort(int[] nums){
-        if(nums==null || nums.length<2) return ;
-
-        int n=nums.length;
-        for(int i=0;i<n;i++){
-            heapInsert(nums,i);
-        }
-        swap(nums,0,--n);
-        while(n>0){
-            heapify(nums,0,n);
-            swap(nums,0,--n);
-        }
-
-
-    }
-    //从小到大实现堆排序的部分一：构建大根堆的过程。在数组中，从后往前
-    private static void heapInsert(int[] nums,int index){
-
-        while(nums[(index-1)/2]<nums[index]){
-            swap(nums,index,(index-1)/2);
-            index=(index-1)/2;
-        }
-    }
-
-    //从前往后，heapify的过程,size:代表数组参与heapify的长度大小
-    private static void heapify(int [] nums,int index,int size){
-         int left=index*2+1;//左孩子
-         while(left<size){
-             int largest=left+1<size && nums[left]<nums[left+1] ? left+1 : left;//largest记录左右孩子最大值的坐标
-             largest=nums[largest]<=nums[index] ? index : largest;
-             if(largest==index){
-                 break;
-             }else{
-                 swap(nums,largest,index);
-                 index=largest;
-                 left=index*2+1;
-             }
-
-         }
-    }
-
-    //通过异或运算实现交换数组中说的两个值
-    private static void swap(int[] nums,int i,int j){
-//        nums[i]=nums[i]^nums[j];
-////        nums[j]=nums[j]^nums[i];
-////        nums[i]=nums[i]^nums[j];
-        int tmp = nums[i];
-        nums[i] = nums[j];
-        nums[j] = tmp;
-    }
-
-
-
-
-
-    // for test
-    public static void comparator(int[] arr) {
-        Arrays.sort(arr);
-    }
-
-    // for test
-    public static int[] generateRandomArray(int maxSize, int maxValue) {
-        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
-        for (int i = 0; i < arr.length; i++) {
-            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
-        }
-        return arr;
-    }
-
-    // for test
-    public static int[] copyArray(int[] arr) {
-        if (arr == null) {
-            return null;
-        }
-        int[] res = new int[arr.length];
-        for (int i = 0; i < arr.length; i++) {
-            res[i] = arr[i];
-        }
-        return res;
-    }
-
-    // for test
-    public static boolean isEqual(int[] arr1, int[] arr2) {
-        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
-            return false;
-        }
-        if (arr1 == null && arr2 == null) {
-            return true;
-        }
-        if (arr1.length != arr2.length) {
-            return false;
-        }
-        for (int i = 0; i < arr1.length; i++) {
-            if (arr1[i] != arr2[i]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    // for test
-    public static void printArray(int[] arr) {
-        if (arr == null) {
-            return;
-        }
-        for (int i = 0; i < arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    // for test
-    public static void main(String[] args) {
-        int testTime = 500000;
-        int maxSize = 100;
-        int maxValue = 100;
-        boolean succeed = true;
-        for (int i = 0; i < testTime; i++) {
-            int[] arr1 = generateRandomArray(maxSize, maxValue);
-            int[] arr2 = copyArray(arr1);
-            heapSort(arr1);
-            comparator(arr2);
-            if (!isEqual(arr1, arr2)) {
-                succeed = false;
-                break;
-            }
-        }
-        System.out.println(succeed ? "Nice!" : "Fucking fucked!");
-
-        int[] arr = generateRandomArray(maxSize, maxValue);
-        printArray(arr);
-        heapSort(arr);
-        printArray(arr);
-        int[]nums={-2,2,1,3,4,-4,5,0};
-        swap(nums,0,5);
-        System.out.println(nums[0]);
-
-    }
-
-
-}
Index: src/韩顺平算法与数据结构/datastructure/tree/heapTree/HeapSortDemo.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/tree/heapTree/HeapSortDemo.java b/src/韩顺平算法与数据结构/datastructure/tree/heapTree/HeapSortDemo.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/tree/heapTree/HeapSortDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,60 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.tree.heapTree;
-
-import java.lang.reflect.Array;
-import java.util.Arrays;
-
-public class HeapSortDemo{
-    public static void main(String[] args) {
-      int[] arr={ 4, 9, 8, 5, 6};
-      heapSort(arr);
-        System.out.println(Arrays.toString(arr));
-    }
-
-    public static void heapSort(int[]arr)
-    {
-        int temp=0;
-        System.out.println("堆排序");
-        for(int i=arr.length/2-1;i>=0;i--)
-        {
-            adjustHeap(arr,i,arr.length);
-        }
-
-        for(int j=arr.length-1;j>0;j--)
-        {
-            temp=arr[j];
-            arr[j]=arr[0];
-            arr[0]=temp;
-            adjustHeap(arr,0,j);//因为数组中arr[0]-arr[j]这些元素构成的新数组所对应的的二叉树，
-                                   // 除了根节点外，剩余的子树均已经调整好，符合大顶堆，所以可以直接令i=0
-        }
-    }
-
-    /**
-     *
-     * @param arr:待调整的数组
-     * @param i：表示非叶子结点在数组中的索引
-     * @param length：每次对多少个元素进行调整，length是逐渐缩短的
-     */
-    public static void adjustHeap(int[] arr,int i,int length)
-    {
-        int temp=arr[i];//先取出当前值，保存在一个临时变量中
-
-        for(int k=i*2+1;k<length;k=k*2+1)
-        {
-            if(k+1<length && arr[k]<arr[k+1])//说明左子树的值小于右子树的值
-            {
-                k++;
-            }
-            if(arr[k]>temp)
-            {
-                arr[i]=arr[k];
-                i=k;//i指向k,继续循环比较
-            }else {
-                break;//因为是从左往右，从下往上，依次构建大顶堆
-            }
-        }
-
-        //当for循环结束后，我们已经将以i为父结点的树的最大值放在了最顶部（局部）
-        arr[i]=temp;
-    }
-}
Index: src/Gof/facade/HomeTheaterFacade.java
===================================================================
diff --git a/src/Gof/facade/HomeTheaterFacade.java b/src/Gof/facade/HomeTheaterFacade.java
deleted file mode 100644
--- a/src/Gof/facade/HomeTheaterFacade.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,40 +0,0 @@
-package Gof.facade;
-
-public class HomeTheaterFacade {
-    private DVDPlayer dvdPlayer;
-    private Stereo stereo;
-    private Screen screen;
-
-    public HomeTheaterFacade()
-    {
-        super();
-        this.dvdPlayer=DVDPlayer.getInstance();
-        this.screen=Screen.getInstance();
-        this.stereo=Stereo.getInstance();
-    }
-
-    //操作分成四部
-    public void ready()
-    {
-        dvdPlayer.off();
-        stereo.on();;
-        screen.down();
-    }
-
-    public void play()
-    {
-        dvdPlayer.play();
-    }
-    public void pause()
-    {
-        dvdPlayer.pause();
-    }
-
-    public void end()
-    {
-        dvdPlayer.off();;
-        screen.up();
-        stereo.off();
-    }
-
-}
Index: src/韩顺平算法与数据结构/algorithm/horse/HorseChessboard.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/algorithm/horse/HorseChessboard.java b/src/韩顺平算法与数据结构/algorithm/horse/HorseChessboard.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/algorithm/horse/HorseChessboard.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,146 +0,0 @@
-package 韩顺平算法与数据结构.algorithm.horse;
-
-import java.awt.Point;
-import java.util.ArrayList;
-import java.util.Comparator;
-
-public class HorseChessboard {
-
-    private static int X; // 棋盘的列数
-    private static int Y; // 棋盘的行数
-    //创建一个数组，标记棋盘的各个位置是否被访问过
-    private static boolean visited[];
-    //使用一个属性，标记是否棋盘的所有位置都被访问
-    private static boolean finished; // 如果为true,表示成功
-
-    public static void main(String[] args) {
-        System.out.println("骑士周游算法，开始运行~~");
-        //测试骑士周游算法是否正确
-        X = 8;
-        Y = 8;
-        int row = 1; //马儿初始位置的行，从1开始编号
-        int column = 1; //马儿初始位置的列，从1开始编号
-        //创建棋盘
-        int[][] chessboard = new int[X][Y];
-        visited = new boolean[X * Y];//初始值都是false
-        //测试一下耗时
-        long start = System.currentTimeMillis();
-        traversalChessboard(chessboard, row - 1, column - 1, 1);
-        long end = System.currentTimeMillis();
-        System.out.println("共耗时: " + (end - start) + " 毫秒");
-
-        //输出棋盘的最后情况
-        for(int[] rows : chessboard) {
-            for(int step: rows) {
-                System.out.print(step + "\t");
-            }
-            System.out.println();
-        }
-
-    }
-
-    /**
-     * 完成骑士周游问题的算法
-     * @param chessboard 棋盘
-     * @param row 马儿当前的位置的行 从0开始
-     * @param column 马儿当前的位置的列  从0开始
-     * @param step 是第几步 ,初始位置就是第1步
-     */
-    public static void traversalChessboard(int[][] chessboard, int row, int column, int step) {
-        chessboard[row][column] = step;
-        //row = 4 X = 8 column = 4 = 4 * 8 + 4 = 36
-        visited[row * X + column] = true; //标记该位置已经访问
-        //获取当前位置可以走的下一个位置的集合
-        ArrayList<Point> ps = next(new Point(column, row));
-        //对ps进行排序,排序的规则就是对ps的所有的Point对象的下一步的位置的数目，进行非递减排序
-        sort(ps);
-        //遍历 ps
-        while(!ps.isEmpty()) {
-            Point p = ps.remove(0);//取出下一个可以走的位置
-            //判断该点是否已经访问过
-            if(!visited[p.y * X + p.x]) {//说明还没有访问过
-                traversalChessboard(chessboard, p.y, p.x, step + 1);
-            }
-        }
-        //判断马儿是否完成了任务，使用   step 和应该走的步数比较 ，
-        //如果没有达到数量，则表示没有完成任务，将整个棋盘置0
-        //说明: step < X * Y  成立的情况有两种
-        //1. 棋盘到目前位置,仍然没有走完
-        //2. 棋盘处于一个回溯过程
-        if(step < X * Y && !finished ) {
-            chessboard[row][column] = 0;
-            visited[row * X + column] = false;
-        } else {
-            finished = true;
-        }
-
-    }
-
-    /**
-     * 功能： 根据当前位置(Point对象)，计算马儿还能走哪些位置(Point)，并放入到一个集合中(ArrayList), 最多有8个位置
-     * @param curPoint
-     * @return
-     */
-    public static ArrayList<Point> next(Point curPoint) {
-        //创建一个ArrayList
-        ArrayList<Point> ps = new ArrayList<Point>();
-        //创建一个Point
-        Point p1 = new Point();
-        //表示马儿可以走5这个位置
-        if((p1.x = curPoint.x - 2) >= 0 && (p1.y = curPoint.y -1) >= 0) {
-            ps.add(new Point(p1));
-        }
-        //判断马儿可以走6这个位置
-        if((p1.x = curPoint.x - 1) >=0 && (p1.y=curPoint.y-2)>=0) {
-            ps.add(new Point(p1));
-        }
-        //判断马儿可以走7这个位置
-        if ((p1.x = curPoint.x + 1) < X && (p1.y = curPoint.y - 2) >= 0) {
-            ps.add(new Point(p1));
-        }
-        //判断马儿可以走0这个位置
-        if ((p1.x = curPoint.x + 2) < X && (p1.y = curPoint.y - 1) >= 0) {
-            ps.add(new Point(p1));
-        }
-        //判断马儿可以走1这个位置
-        if ((p1.x = curPoint.x + 2) < X && (p1.y = curPoint.y + 1) < Y) {
-            ps.add(new Point(p1));
-        }
-        //判断马儿可以走2这个位置
-        if ((p1.x = curPoint.x + 1) < X && (p1.y = curPoint.y + 2) < Y) {
-            ps.add(new Point(p1));
-        }
-        //判断马儿可以走3这个位置
-        if ((p1.x = curPoint.x - 1) >= 0 && (p1.y = curPoint.y + 2) < Y) {
-            ps.add(new Point(p1));
-        }
-        //判断马儿可以走4这个位置
-        if ((p1.x = curPoint.x - 2) >= 0 && (p1.y = curPoint.y + 1) < Y) {
-            ps.add(new Point(p1));
-        }
-        return ps;
-    }
-
-    //根据当前这个一步的所有的下一步的选择位置，进行非递减排序, 减少回溯的次数
-    public static void sort(ArrayList<Point> ps) {
-        ps.sort(new Comparator<Point>() {
-
-            @Override
-            public int compare(Point o1, Point o2) {
-                // TODO Auto-generated method stub
-                //获取到o1的下一步的所有位置个数
-                int count1 = next(o1).size();
-                //获取到o2的下一步的所有位置个数
-                int count2 = next(o2).size();
-                if(count1 < count2) {
-                    return -1;
-                } else if (count1 == count2) {
-                    return 0;
-                } else {
-                    return 1;
-                }
-            }
-
-        });
-    }
-}
Index: src/Gof/Bulider/House.java
===================================================================
diff --git a/src/Gof/Bulider/House.java b/src/Gof/Bulider/House.java
deleted file mode 100644
--- a/src/Gof/Bulider/House.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,32 +0,0 @@
-package Gof.Bulider;
-
-public class House {
-
-    private String baise;
-    private String wall;
-    private String roofed;
-
-    public String getBaise() {
-        return baise;
-    }
-
-    public void setBaise(String baise) {
-        this.baise = baise;
-    }
-
-    public String getWall() {
-        return wall;
-    }
-
-    public void setWall(String wall) {
-        this.wall = wall;
-    }
-
-    public String getRoofed() {
-        return roofed;
-    }
-
-    public void setRoofed(String roofed) {
-        this.roofed = roofed;
-    }
-}
Index: src/Gof/Bulider/HouseBuilder.java
===================================================================
diff --git a/src/Gof/Bulider/HouseBuilder.java b/src/Gof/Bulider/HouseBuilder.java
deleted file mode 100644
--- a/src/Gof/Bulider/HouseBuilder.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,15 +0,0 @@
-package Gof.Bulider;
-
-public abstract class HouseBuilder {
-
-    protected House house=new House();
-    public abstract void buildBaise();
-    public abstract void buildWalls();
-    public abstract void roofed();
-
-    //建造好房子将房子返回
-    public House buildHouse()
-    {
-        return house;
-    }
-}
Index: src/Gof/Bulider/HouseDirector.java
===================================================================
diff --git a/src/Gof/Bulider/HouseDirector.java b/src/Gof/Bulider/HouseDirector.java
deleted file mode 100644
--- a/src/Gof/Bulider/HouseDirector.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,22 +0,0 @@
-package Gof.Bulider;
-
-public class HouseDirector {
-    HouseBuilder houseBuilder=null;
-
-    public void setHouseBuilder(HouseBuilder houseBuilder) {
-        this.houseBuilder = houseBuilder;
-    }
-
-    public HouseDirector(HouseBuilder houseBuilder) {
-        this.houseBuilder = houseBuilder;
-    }
-
-    //如何处理建造房子的流程交给指挥者
-    public House constructHouse()
-    {
-        houseBuilder.buildBaise();
-        houseBuilder.buildWalls();
-        houseBuilder.roofed();
-       return houseBuilder.buildHouse();
-    }
-}
Index: src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/HtmlButton.java
===================================================================
diff --git a/src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/HtmlButton.java b/src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/HtmlButton.java
deleted file mode 100644
--- a/src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/HtmlButton.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,20 +0,0 @@
-package 重温设计模式.创建型模式.工厂模式.工厂方法模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/18 21:08
- */
-public class HtmlButton implements Button {
-    @Override
-    public void render() {
-        System.out.println("<button>Test Button</button>");
-        onClick();
-    }
-
-    @Override
-    public void onClick() {
-        System.out.println("Click! Button says - 'Hello World!'");
-    }
-}
Index: src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/HtmlDialog.java
===================================================================
diff --git a/src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/HtmlDialog.java b/src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/HtmlDialog.java
deleted file mode 100644
--- a/src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/HtmlDialog.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,14 +0,0 @@
-package 重温设计模式.创建型模式.工厂模式.工厂方法模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 具体创建者
- * @date 2021/5/18 21:10
- */
-public class HtmlDialog extends Dialog {
-    @Override
-    Button createButton() {
-        return new HtmlButton();
-    }
-}
Index: src/韩顺平算法与数据结构/datastructure/tree/HuffmanCode.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/tree/HuffmanCode.java b/src/韩顺平算法与数据结构/datastructure/tree/HuffmanCode.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/tree/HuffmanCode.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,388 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.tree;
-
-import java.io.*;
-import java.lang.reflect.Array;
-import java.util.*;
-
-public class HuffmanCode {
-
-    public static void main(String[] args) {
-//        String content = "i like like like java do you like a java";
-//        byte[] bytes = content.getBytes();
-//        byte[] bytes1 = huffmanZip(bytes);
-//        System.out.println(Arrays.toString(bytes1));
-//        List<Node> nodes = getNodes(bytes);
-//        Node huffmanTree = createHuffmanTree(nodes);
-//        Map<Byte, String> codes = getCodes(huffmanTree);
-//        byte[] decodes = decode(codes, bytes1);
-//        System.out.println(new String(decodes));
-        zipFile("E:\\qq.txt", "E:\\flower.zip");
-        
-
-    }
-    //编写一个方法，完成对压缩文件的解压
-    /**
-     *
-     * @param zipFile 准备解压的文件
-     * @param dstFile 将文件解压到哪个路径
-     */
-    public static void unZipFile(String zipFile, String dstFile) {
-
-        //定义文件输入流
-        InputStream is = null;
-        //定义一个对象输入流
-        ObjectInputStream ois = null;
-        //定义文件的输出流
-        OutputStream os = null;
-        try {
-            //创建文件输入流
-            is = new FileInputStream(zipFile);
-            //创建一个和  is关联的对象输入流
-            ois = new ObjectInputStream(is);
-            //读取byte数组  huffmanBytes
-            byte[] huffmanBytes = (byte[])ois.readObject();
-            //读取赫夫曼编码表
-            Map<Byte,String> huffmanCodes = (Map<Byte,String>)ois.readObject();
-
-            //解码
-            byte[] bytes = decode(huffmanCodes, huffmanBytes);
-            //将bytes 数组写入到目标文件
-            os = new FileOutputStream(dstFile);
-            //写数据到 dstFile 文件
-            os.write(bytes);
-        } catch (Exception e) {
-            // TODO: handle exception
-            System.out.println(e.getMessage());
-        } finally {
-
-            try {
-                os.close();
-                ois.close();
-                is.close();
-            } catch (Exception e2) {
-                // TODO: handle exception
-                System.out.println(e2.getMessage());
-            }
-
-        }
-    }
-
-    //编写方法，将一个文件进行压缩
-    /**
-     *
-     * @param srcFile 你传入的希望压缩的文件的全路径
-     * @param dstFile 我们压缩后将压缩文件放到哪个目录
-     */
-    public static void zipFile(String srcFile, String dstFile) {
-
-        //创建输出流
-        OutputStream os = null;
-        ObjectOutputStream oos = null;
-        //创建文件的输入流
-        FileInputStream is = null;
-        try {
-            //创建文件的输入流
-            is = new FileInputStream(srcFile);
-            //创建一个和源文件大小一样的byte[]
-            byte[] b = new byte[is.available()];
-            //读取文件
-            is.read(b);
-            //直接对源文件压缩
-            byte[] huffmanBytes = huffmanZip(b);
-            //创建文件的输出流, 存放压缩文件
-            os = new FileOutputStream(dstFile);
-            //创建一个和文件输出流关联的ObjectOutputStream
-            oos = new ObjectOutputStream(os);
-            //把 赫夫曼编码后的字节数组写入压缩文件
-            oos.writeObject(huffmanBytes); //我们是把
-            //这里我们以对象流的方式写入 赫夫曼编码，是为了以后我们恢复源文件时使用
-            //注意一定要把赫夫曼编码 写入压缩文件
-            oos.writeObject(huffmanCodes);
-
-
-        }catch (Exception e) {
-            // TODO: handle exception
-            System.out.println(e.getMessage());
-        }finally {
-            try {
-                is.close();
-                oos.close();
-                os.close();
-            }catch (Exception e) {
-                // TODO: handle exception
-                System.out.println(e.getMessage());
-            }
-        }
-
-    }
-    //编写一个方法，完成对压缩数据的解码
-    /**
-     *
-     * @param huffmanCodes 赫夫曼编码表 map
-     * @param huffmanBytes 赫夫曼编码得到的字节数组
-     * @return 就是原来的字符串对应的数组
-     */
-    private static byte[] decode(Map<Byte,String> huffmanCodes, byte[] huffmanBytes) {
-
-        //1. 先得到 huffmanBytes 对应的 二进制的字符串 ， 形式 1010100010111...
-        StringBuilder stringBuilder = new StringBuilder();
-        //将byte数组转成二进制的字符串
-        for(int i = 0; i < huffmanBytes.length; i++) {
-            byte b = huffmanBytes[i];
-            //判断是不是最后一个字节
-            boolean flag = (i == huffmanBytes.length - 1);
-            stringBuilder.append(byteToBitString(b,!flag));
-        }
-        //把字符串安装指定的赫夫曼编码进行解码
-        //把赫夫曼编码表进行调换，因为反向查询 a->100 100->a
-        Map<String, Byte>  map = new HashMap<String,Byte>();
-        for(Map.Entry<Byte, String> entry: huffmanCodes.entrySet()) {
-            map.put(entry.getValue(), entry.getKey());
-        }
-
-        //创建要给集合，存放byte
-        List<Byte> list = new ArrayList<>();
-        //i 可以理解成就是索引,扫描 stringBuilder
-        for(int  i = 0; i < stringBuilder.length(); ) {
-            int count = 1; // 小的计数器
-            boolean flag = true;
-            Byte b = null;
-
-            while(flag) {
-                //1010100010111...
-                //递增的取出 key 1
-                String key = stringBuilder.substring(i, i+count);//i 不动，让count移动，指定匹配到一个字符
-                b = map.get(key);
-                if(b == null) {//说明没有匹配到
-                    count++;
-                }else {
-                    //匹配到
-                    flag = false;
-                }
-            }
-            list.add(b);
-            i += count;//i 直接移动到 count
-        }
-        //当for循环结束后，我们list中就存放了所有的字符  "i like like like java do you like a java"
-        //把list 中的数据放入到byte[] 并返回
-        byte b[] = new byte[list.size()];
-        for(int i = 0;i < b.length; i++) {
-            b[i] = list.get(i);
-        }
-        return b;
-
-    }
-
-    /**
-     * 将一个byte转换成二进制的字符串
-     * @param b:传入的byte
-     * @param flag：标志是否需要补高位，如果true,表示需要补高位，如果是false,表示不需要，如果是最后一个这字节，无需补高位
-     * @return：对应的二进制字符串，（注意是按照补码返回）。
-     */
-    public static String byteToBitString(byte b,boolean flag)
-    {
-      int temp=b;
-      //如果是正数，我们还存在补高位
-      if(flag)
-      {
-          temp |=256;
-      }
-      String str=Integer.toBinaryString(temp);//返回的是补码对应的字符串形式
-      if(flag)
-      {
-          return str.substring(str.length()-8);
-      }else {
-          return str;
-      }
-    }
-    //使用一个方法将下述方法进行封装
-    public static byte[] huffmanZip(byte[] bytes)
-    {
-        //构建huffman树的结点
-        List<Node> nodes = getNodes(bytes);
-        //构建霍夫曼树
-        Node huffmanTree = createHuffmanTree(nodes);
-        //得到对应的huffman编码
-        Map<Byte, String> codes = getCodes(huffmanTree);
-        //根据编码表得到得的压缩后的huffman编码字节数组
-        byte[] zip = zip(bytes, codes);
-        return zip;
-    }
-
-
-    //编写一个方法，将字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码 压缩后的byte[]
-    /**
-     *
-     * @param bytes 这时原始的字符串对应的 byte[]
-     * @param huffmanCodes 生成的赫夫曼编码map
-     * @return 返回赫夫曼编码处理后的 byte[]
-     * 举例： String content = "i like like like java do you like a java"; =》 byte[] contentBytes = content.getBytes();
-     * 返回的是 字符串 "1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100"
-     * => 对应的 byte[] huffmanCodeBytes  ，即 8位对应一个 byte,放入到 huffmanCodeBytes
-     * huffmanCodeBytes[0] =  10101000(补码) => byte  [推导  10101000=> 10101000 - 1 => 10100111(反码)=> 11011000= -88 ]
-     * huffmanCodeBytes[1] = -88
-     */
-    private static byte[] zip(byte[] bytes, Map<Byte, String> huffmanCodes) {
-
-        //1.利用 huffmanCodes 将  bytes 转成  赫夫曼编码对应的字符串
-        StringBuilder stringBuilder = new StringBuilder();
-        //遍历bytes 数组
-        for(byte b: bytes) {
-            stringBuilder.append(huffmanCodes.get(b));
-        }
-
-        //System.out.println("测试 stringBuilder~~~=" + stringBuilder.toString());
-
-        //将 "1010100010111111110..." 转成 byte[]
-
-        //统计返回  byte[] huffmanCodeBytes 长度
-        //一句话 int len = (stringBuilder.length() + 7) / 8;
-        int len;
-        if(stringBuilder.length() % 8 == 0) {
-            len = stringBuilder.length() / 8;
-        } else {
-            len = stringBuilder.length() / 8 + 1;
-        }
-        //创建 存储压缩后的 byte数组
-        byte[] huffmanCodeBytes = new byte[len];
-        int index = 0;//记录是第几个byte
-        for (int i = 0; i < stringBuilder.length(); i += 8) { //因为是每8位对应一个byte,所以步长 +8
-            String strByte;
-            if(i+8 > stringBuilder.length()) {//不够8位
-                strByte = stringBuilder.substring(i);
-            }else{
-                strByte = stringBuilder.substring(i, i + 8);
-            }
-            //将strByte 转成一个byte,放入到 huffmanCodeBytes
-            huffmanCodeBytes[index] = (byte)Integer.parseInt(strByte, 2);//二进制的形式
-            index++;
-        }
-        return huffmanCodeBytes;
-    }
-
-    //生成赫夫曼树对应的赫夫曼编码
-    //思路:
-    //1. 将赫夫曼编码表存放在 Map<Byte,String> 形式
-    //   生成的赫夫曼编码表{32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011}
-    static Map<Byte, String> huffmanCodes = new HashMap<Byte,String>();
-    //2. 在生成赫夫曼编码表示，需要去拼接路径, 定义一个StringBuilder 存储某个叶子结点的路径
-    static StringBuilder stringBuilder = new StringBuilder();
-    private static Map<Byte, String> getCodes(Node root) {
-        if(root == null) {
-            return null;
-        }
-        //处理root的左子树
-        getCodes(root.left, "0", stringBuilder);
-        //处理root的右子树
-        getCodes(root.right, "1", stringBuilder);
-        return huffmanCodes;
-    }
-    /**
-     * 功能：将传入的node结点的所有叶子结点的赫夫曼编码得到，并放入到huffmanCodes集合
-     * @param node  传入结点
-     * @param code  路径： 左子结点是 0, 右子结点 1
-     * @param stringBuilder 用于拼接路径
-     */
-    private static void getCodes(Node node, String code, StringBuilder stringBuilder) {
-        StringBuilder stringBuilder2 = new StringBuilder(stringBuilder);
-        //将code 加入到 stringBuilder2
-        stringBuilder2.append(code);
-        if(node != null) { //如果node == null不处理
-            //判断当前node 是叶子结点还是非叶子结点
-            if(node.data == null) { //非叶子结点
-                //递归处理
-                //向左递归
-                getCodes(node.left, "0", stringBuilder2);
-                //向右递归
-                getCodes(node.right, "1", stringBuilder2);
-            } else { //说明是一个叶子结点
-                //就表示找到某个叶子结点的最后
-                huffmanCodes.put(node.data, stringBuilder2.toString());
-            }
-        }
-    }
-
-    //可以通过List 创建对应的赫夫曼树
-    private static Node createHuffmanTree(List<Node> nodes) {
-
-        while(nodes.size() > 1) {
-            //排序, 从小到大
-            Collections.sort(nodes);
-            //取出第一颗最小的二叉树
-            Node leftNode = nodes.get(0);
-            //取出第二颗最小的二叉树
-            Node rightNode = nodes.get(1);
-            //创建一颗新的二叉树,它的根节点 没有data, 只有权值
-            Node parent = new Node(null, leftNode.weight + rightNode.weight);
-            parent.left = leftNode;
-            parent.right = rightNode;
-
-            //将已经处理的两颗二叉树从nodes删除
-            nodes.remove(leftNode);
-            nodes.remove(rightNode);
-            //将新的二叉树，加入到nodes
-            nodes.add(parent);
-
-        }
-        //nodes 最后的结点，就是赫夫曼树的根结点
-        return nodes.get(0);
-
-    }
-
-    private static List<Node> getNodes(byte[] bytes) {
-
-        //1创建一个ArrayList
-        ArrayList<Node> nodes = new ArrayList<Node>();
-
-        //遍历 bytes , 统计 每一个byte出现的次数->map[key,value]
-        Map<Byte, Integer> counts = new HashMap<>();
-        for (byte b : bytes) {
-            Integer count = counts.get(b);
-            if (count == null) { // Map还没有这个字符数据,第一次
-                counts.put(b, 1);
-            } else {
-                counts.put(b, count + 1);
-            }
-        }
-
-        //把每一个键值对转成一个Node 对象，并加入到nodes集合
-        //遍历map
-        for(Map.Entry<Byte, Integer> entry: counts.entrySet()) {
-            nodes.add(new Node(entry.getKey(), entry.getValue()));
-        }
-        return nodes;
-
-    }
-}
-//创建Node ,待数据和权值
-class Node implements Comparable<Node>  {
-    Byte data; // 存放数据(字符)本身，比如'a' => 97 ' ' => 32
-    int weight; //权值, 表示字符出现的次数
-    Node left;//
-    Node right;
-    public Node(Byte data, int weight) {
-
-        this.data = data;
-        this.weight = weight;
-    }
-    @Override
-    public int compareTo(Node o) {
-        // 从小到大排序
-        return this.weight - o.weight;
-    }
-
-    public String toString() {
-        return "Node [data = " + data + " weight=" + weight + "]";
-    }
-
-    //前序遍历
-    public void preOrder() {
-        System.out.println(this);
-        if(this.left != null) {
-            this.left.preOrder();
-        }
-        if(this.right != null) {
-            this.right.preOrder();
-        }
-    }
-}
\ No newline at end of file
Index: src/韩顺平算法与数据结构/datastructure/tree/huffmantree/HuffmanTree.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/tree/huffmantree/HuffmanTree.java b/src/韩顺平算法与数据结构/datastructure/tree/huffmantree/HuffmanTree.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/tree/huffmantree/HuffmanTree.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,117 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.tree.huffmantree;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-public class HuffmanTree {
-
-    public static void main(String[] args) {
-        int arr[] = { 13, 7, 8, 3, 29, 6, 1 };
-        Node root = createHuffmanTree(arr);
-        preOrder(root);
-
-    }
-    public static void preOrder(Node root)
-    {
-        if(root!=null)
-        {
-            root.preOrder();
-        }else{
-            System.out.println("空树");
-        }
-    }
-
-    public static Node createHuffmanTree(int[] arrs)
-    {
-
-        List<Node> nodes=new ArrayList<>();
-        //将数组遍历，转化为一个链表
-        for(int arr:arrs)
-        {
-          Node node=new Node(arr);
-          nodes.add(node);
-        }
-
-        while(nodes.size()>1) {
-            //对数组元素进行排序
-            Collections.sort(nodes);
-            //取出最小的两个元素，组合成新的结点
-            Node leftNode = nodes.get(0);
-            Node rightNode = nodes.get(1);
-            Node node = new Node(leftNode.getValue() + rightNode.getValue());
-            node.setLeft(leftNode);
-            node.setRight(rightNode);
-            nodes.remove(leftNode);
-            nodes.remove(rightNode);
-            nodes.add(node);
-        }
-        return nodes.get(0);//返回根节点
-    }
-
-
-}
-
-
-//
-class Node implements Comparable<Node>
-{
-    private int value;
-    private char c;
-    private Node left;
-    private Node right;
-
-    //写一个前序遍历
-    public void preOrder(){
-        System.out.println(this);
-        if(this.left!=null)
-        {
-            this.left.preOrder();
-        }
-        if(this.right!=null)
-        {
-            this.right.preOrder();
-        }
-    }
-
-    public Node(int value) {
-        this.value = value;
-    }
-
-    public int getValue() {
-        return value;
-    }
-
-    public void setValue(int value) {
-        this.value = value;
-    }
-
-    public Node getLeft() {
-        return left;
-    }
-
-    public void setLeft(Node left) {
-        this.left = left;
-    }
-
-    public Node getRight() {
-        return right;
-    }
-
-    public void setRight(Node right) {
-        this.right = right;
-    }
-
-    @Override
-    public String toString() {
-        return "Node{" +
-                "value=" + value +
-                '}';
-    }
-
-    @Override
-    public int compareTo(Node o) {
-       //从小到大排序
-        return this.value-o.value;
-    }
-}
\ No newline at end of file
Index: src/org/sd/decorator/ICar.java
===================================================================
diff --git a/src/org/sd/decorator/ICar.java b/src/org/sd/decorator/ICar.java
deleted file mode 100644
--- a/src/org/sd/decorator/ICar.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,63 +0,0 @@
-package org.sd.decorator;
-
-import javax.swing.*;
-
-public interface ICar {
-    void move();
-}
-
-//concrete component
-class Car implements ICar{
-
-    @Override
-    public void move() {
-        System.out.println("在陆地上跑");
-    }
-}
-//装饰角色
-class SuperCar implements ICar{
-
-    protected  ICar car;
-
-    public SuperCar(ICar car) {
-        this.car = car;
-    }
-
-    @Override
-    public void move() {
-       car.move();
-    }
-}
-
-//concreter decorator
-class FlyCar extends SuperCar
-{
-    public FlyCar(ICar car)
-    {super(car);}
-    public void fly()
-    {
-        System.out.println("天上飞");
-    }
-
-    @Override
-    public void move() {
-        super.move();
-        fly();
-    }
-}
-class SwimmingCar extends SuperCar{
-    public SwimmingCar(ICar car)
-    {
-        super(car);
-    }
-    public void swim()
-    {
-        System.out.println("水中游");
-    }
-
-    @Override
-    public void move() {
-        super.move();
-        swim();
-    }
-}
Index: src/面试相关/面试手撕代码/ImplementSecureBlockingQueue.java
===================================================================
diff --git a/src/面试相关/面试手撕代码/ImplementSecureBlockingQueue.java b/src/面试相关/面试手撕代码/ImplementSecureBlockingQueue.java
deleted file mode 100644
--- a/src/面试相关/面试手撕代码/ImplementSecureBlockingQueue.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,83 +0,0 @@
-package 面试相关.面试手撕代码;
-
-import java.util.LinkedList;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.locks.Condition;
-import java.util.concurrent.locks.ReentrantLock;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 实现一个线程安全的阻塞队列
- * @date 2020/7/6 20:11
- */
-public class ImplementSecureBlockingQueue {
-
-    class MyBlockingQueue{
-        //通过List来实现
-        private LinkedList<Integer> list=new LinkedList<>();
-        private int max;//最大容量
-        private int min=0;
-        private AtomicInteger count=new AtomicInteger();
-        private ReentrantLock lock=new ReentrantLock();//锁
-        private Condition notEmpty=lock.newCondition();//非空
-        private Condition notFull=lock.newCondition();//非满
-
-        public MyBlockingQueue(int max){
-            this.max=max;
-        }
-
-        //放入
-        public void put(Integer num){
-            lock.lock();
-            try{
-              while(count.get()==max){
-                  notFull.await();
-              }
-              list.add(num);
-              count.incrementAndGet();
-              notEmpty.signal();
-            } catch (InterruptedException e) {
-                e.printStackTrace();
-            }finally {
-                lock.unlock();
-            }
-        }
-
-        //取出
-        public int poll(){
-            lock.lock();
-            int res=0;
-            try{
-                while (count.get()==min){
-                    notEmpty.await();
-                }
-                res=list.pollFirst();
-                count.decrementAndGet();
-                notFull.signal();
-            } catch (InterruptedException e) {
-                e.printStackTrace();
-            }finally {
-                lock.unlock();
-            }
-            return  res;
-        }
-    }
-
-    public static void main(String[] args) {
-        ImplementSecureBlockingQueue implementSecureBlockingQueue=
-                new ImplementSecureBlockingQueue();
-        MyBlockingQueue myBlockingQueue=implementSecureBlockingQueue.new MyBlockingQueue(3);
-        myBlockingQueue.put(1);
-        myBlockingQueue.put(2);
-        myBlockingQueue.put(3);
-        int res=myBlockingQueue.poll();
-        System.out.println(res);
-        myBlockingQueue.put(4);
-
-    }
-
-
-
-}
Index: src/Gof/iterator/InfoCollege.java
===================================================================
diff --git a/src/Gof/iterator/InfoCollege.java b/src/Gof/iterator/InfoCollege.java
deleted file mode 100644
--- a/src/Gof/iterator/InfoCollege.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,33 +0,0 @@
-package Gof.iterator;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class InfoCollege implements College {
-
-    List<Department> departments;
-
-
-    public InfoCollege() {
-        departments=new ArrayList<>();
-        departments.add(new Department("信息安全","信息安全"));
-        addDepartment("网络安全专业", " 网络安全专业 ");
-        addDepartment("服务器安全专业", " 服务器安全专业 ");
-    }
-
-    @Override
-    public String getName() {
-        return "信息学院";
-    }
-
-    @Override
-    public Iterator createIterator() {
-        return new InfoCollegeIterator(departments);
-    }
-
-    @Override
-    public void addDepartment(String name, String desc) {
-         Department department=new Department(name,desc);
-         departments.add(department);
-    }
-}
Index: src/Gof/iterator/InfoCollegeIterator.java
===================================================================
diff --git a/src/Gof/iterator/InfoCollegeIterator.java b/src/Gof/iterator/InfoCollegeIterator.java
deleted file mode 100644
--- a/src/Gof/iterator/InfoCollegeIterator.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,34 +0,0 @@
-package Gof.iterator;
-
-import java.util.List;
-
-public class InfoCollegeIterator implements Iterator {
-
-    List<Department> departmentList;
-    int index=-1;
-
-    public InfoCollegeIterator(List<Department> departmentList) {
-        this.departmentList = departmentList;
-    }
-
-    @Override
-    public boolean hasNext() {
-        if(index>=departmentList.size()-1)
-            return false;
-        else{
-            index++;
-            return true;
-        }
-
-    }
-
-    @Override
-    public Object next() {
-        return departmentList.get(index);
-    }
-
-    @Override
-    public void remove() {
-
-    }
-}
Index: src/codeTop/InOrderSuccessor.java
===================================================================
diff --git a/src/codeTop/InOrderSuccessor.java b/src/codeTop/InOrderSuccessor.java
deleted file mode 100644
--- a/src/codeTop/InOrderSuccessor.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,47 +0,0 @@
-package codeTop;
-
-/**
- * 给定一棵二叉搜索树和其中的一个节点 node ，找到该节点在树中的中序后继。
- *
- * 如果节点没有中序后继，请返回 null 。
- *
- * 一个结点 node 的中序后继是键值比 node.val大所有的结点中键值最小的那个。
- *
- * 你可以直接访问结点，但无法直接访问树。每个节点都会有其父节点的引用。节点定义如下：
- *
- * class Node {undefined
- *
- * public int val;
- *
- * public Node left;
- *
- * public Node right;
- *
- * public Node parent;
- *
- * }
- */
-
-public class InOrderSuccessor {
-
-    static class TreeNode{
-        public int val;
-        public TreeNode left;
-        public TreeNode right;
-        public TreeNode parent;
-    }
-
-    public static TreeNode inOrderSuccessor(TreeNode node){
-        //右子树存在，则右子树的最左子树为下一个节点
-        if(node.right != null){
-            node = node.right;
-            while(node.left != null){
-                node = node.left;
-            }
-            return node;
-        }
-        //否则向上遍历，如果该节点是父节点的左子树则直接返回父节点，如果是父节点的右子树，则到父节点继续遍历
-        while(node.parent != null && node.parent.right == node) node = node.parent;
-        return node.parent;
-    }
-}
Index: src/左神算法/基础班/Sort/InsertSort.java
===================================================================
diff --git a/src/左神算法/基础班/Sort/InsertSort.java b/src/左神算法/基础班/Sort/InsertSort.java
deleted file mode 100644
--- a/src/左神算法/基础班/Sort/InsertSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,25 +0,0 @@
-package 左神算法.基础班.Sort;
-
-public class InsertSort {
-
-    public static void insertSort(int[] arr)
-    {
-        if(arr==null || arr.length<2)
-            return;
-        for(int i=1;i<arr.length;i++)
-        {
-            for(int j=i-1;j>=0 && arr[j]>arr[j+1];j--)//注意这里的写法
-            {
-
-                    swap(arr,j+1,j);
-            }
-        }
-    }
-    //异或的方式实现两个变量值交换
-    public static void swap(int[]array,int i,int j)
-    {
-        array[i]=array[i]^array[j];
-        array[j]=array[i]^array[j];
-        array[i]=array[i]^array[j];
-    }
-}
Index: src/韩顺平算法与数据结构/datastructure/sort/InsertSort.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/sort/InsertSort.java b/src/韩顺平算法与数据结构/datastructure/sort/InsertSort.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/sort/InsertSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,48 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.sort;
-
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Date;
-
-public class InsertSort {
-    public static void main(String[] args) {
-
-        int[] arr = new int[80000];
-        for (int i = 0; i < 80000; i++) {
-            arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数
-        }
-
-        System.out.println("插入排序前");
-        Date data1 = new Date();
-        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
-        String date1Str = simpleDateFormat.format(data1);
-        System.out.println("排序前的时间是=" + date1Str);
-
-        insertSort(arr); //调用插入排序算法
-
-        Date data2 = new Date();
-        String date2Str = simpleDateFormat.format(data2);
-        System.out.println("排序前的时间是=" + date2Str);
-
-    }
-
-    public static void insertSort(int[] arr)
-    {   int insertValue=0;
-        int insertIndex=0;
-        for(int i=1;i<arr.length;i++){
-            insertValue=arr[i];
-            insertIndex=i-1;//插入点的初步位置
-            while(insertIndex>=0  &&  insertValue>arr[insertIndex]) ///注意，这两个判断条件不能写反了，
-                                                                    // 如果写反了，可能会出现数组越界
-            {   arr[insertIndex+1]=arr[insertIndex];
-                insertIndex--;
-            }//退出while循环说明插入位置找到
-            if(insertIndex+1!=i){
-                arr[insertIndex+1]=insertValue;
-            }
-
-//            System.out.println("第"+i+"轮插入");
-//            System.out.println(Arrays.toString(arr));
-        }
-    }
-}
Index: src/韩顺平算法与数据结构/datastructure/search/InsertValueSearch.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/search/InsertValueSearch.java b/src/韩顺平算法与数据结构/datastructure/search/InsertValueSearch.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/search/InsertValueSearch.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,28 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.search;
-
-import com.google.zxing.common.detector.WhiteRectangleDetector;
-
-public class InsertValueSearch {
-    public static void main(String[] args) {
-
-    }
-
-    public static int insertValueSearch(int[] arr,int low,int high,int findVal)
-    {
-        if(findVal<arr[0] || findVal>arr[high] || low > high)
-        {
-            return -1;
-        }
-        int mid=low+(high-low)*(findVal-arr[low])/(arr[high]-arr[low]);
-        if(findVal>arr[mid])
-        {
-            return insertValueSearch(arr,mid+1,high,findVal);
-
-        }else if(findVal<arr[mid])
-        {
-            return insertValueSearch(arr,low,mid-1,findVal);
-        }else {
-            return mid;
-        }
-    }
-}
Index: src/左神算法/基础班/第四课/IOP.java
===================================================================
diff --git a/src/左神算法/基础班/第四课/IOP.java b/src/左神算法/基础班/第四课/IOP.java
deleted file mode 100644
--- a/src/左神算法/基础班/第四课/IOP.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,102 +0,0 @@
-package 左神算法.基础班.第四课;
-
-import java.util.Comparator;
-import java.util.PriorityQueue;
-import java.util.Scanner;
-
-/**
- * 假设 力扣（LeetCode）即将开始其 IPO。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前
- * 完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。给定若干个项目。对于每个项目 i，它都有一个纯利润 Pi，并且需要最小的资本 Ci 来启动相应
- * 的项目。最初，你有 W 资本。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。总而言之，从给定项目中选择最多 k 个不同项目的列表，以最大化最终资本，并输出最
- * 终可获得的最多资本
-   来源：力扣（LeetCode）
-   链接：https://leetcode-cn.com/problems/ipo
-   著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- */
-public class IOP {
-
-
-    //构造一个内部类来封装指出与收益
-    public static class Node{
-
-        int cost;
-        int profit;
-
-        public  Node (int cost,int profit)
-        {
-            this.cost=cost;
-            this.profit=profit;
-        }
-    }
-
-    public static class MaxProfitHeap implements Comparator<Node>{
-
-
-        @Override
-        public int compare(Node o1, Node o2) {
-            return o2.profit-o1.profit;
-        }
-    }
-
-    public static class MinCostHeap implements Comparator<Node>{
-
-
-        @Override
-        public int compare(Node o1, Node o2) {
-            return o1.cost-o2.cost;
-        }
-    }
-
-    //k 表示最多可以完成的任务数目，m表示初始资金
-    public static int getMaxProfit(int k,int m,int[] cost,int[] profit)
-    {
-        Node[] arr=new Node[cost.length];
-        for(int i=0;i<cost.length;i++)
-        {
-            arr[i]=new Node(cost[i],profit[i]);
-        }
-
-        PriorityQueue<Node> minCost=new PriorityQueue<>(new MinCostHeap());
-        PriorityQueue<Node> maxProfit=new PriorityQueue<>(new MaxProfitHeap());
-
-        for(int i=0;i<arr.length;i++)
-        {
-           minCost.add(arr[i]);
-        }
-        for(int i=0;i<k;i++)
-        {
-            while(!minCost.isEmpty() && minCost.peek().cost<=m)
-            {
-                maxProfit.add(minCost.poll());
-            }
-            if(maxProfit.isEmpty())
-            {
-                return m;
-            }
-            m+=maxProfit.poll().profit;
-        }
-        return m;
-
-    }
-
-    public static void main(String[] args) {
-        Scanner scanner=new Scanner(System.in);
-        int[] cost=new int[4];
-        int[] profit=new int[4];
-        int k=0;
-        int m=0;
-        //int i=0;
-        System.out.println("输入：");
-        while(scanner.hasNext())
-        {
-        for(int i=0;i<4;i++)
-            cost[i]=scanner.nextInt();
-        for(int j=0;j<4;j++)
-            profit[j]=scanner.nextInt();
-        k=scanner.nextInt();
-        m=scanner.nextInt();
-            System.out.println("最大输出为： "+getMaxProfit(k,m,cost,profit));
-        }
-
-    }
-}
Index: src/左神算法/基础班/树/IsBalancedTree.java
===================================================================
diff --git a/src/左神算法/基础班/树/IsBalancedTree.java b/src/左神算法/基础班/树/IsBalancedTree.java
deleted file mode 100644
--- a/src/左神算法/基础班/树/IsBalancedTree.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,86 +0,0 @@
-package 左神算法.基础班.树;
-
-/**
- * 判断一颗二叉树是否是平衡二叉树
- */
-public class IsBalancedTree {
-
-    public static class Node{
-       public  int value;
-       public Node left;
-       public Node right;
-
-        public Node(int value) {
-            this.value = value;
-        }
-    }
-
-    public static class ReturnData{
-        public boolean isBalanced;
-        public int height;
-
-        public ReturnData(boolean isBalanced, int height) {
-            this.isBalanced = isBalanced;
-            this.height = height;
-        }
-    }
-
-    public static boolean isBal(Node head)
-    {
-        return process(head).isBalanced;
-    }
-    public static ReturnData process(Node head)
-    {
-        if(head==null)
-        {
-            return new ReturnData(true,0);
-        }
-        ReturnData leftData = process(head.left);
-        if(!leftData.isBalanced)
-            return new ReturnData(false,0);
-        ReturnData rightData = process(head.right);
-        if(! rightData.isBalanced)
-            return new ReturnData(false,0);
-        if(Math.abs(leftData.height-rightData.height)>1)
-            return new ReturnData(false,0);
-        return new ReturnData(true,Math.max(leftData.height,rightData.height)+1);
-
-    }
-
-    //法二：
-    public static int getHeight(Node head,int level,boolean[] res)
-    {
-        if(head==null)
-            return level;
-        int lH=getHeight(head.left,level+1,res);
-        if(!res[0])
-            return level;
-        int rH=getHeight(head.right,level+1,res);
-        if(!res[0])
-            return level;
-        if(Math.abs(lH-rH)>1)
-            res[0]=false;
-        return Math.max(lH,rH);
-    }
-
-    public static boolean  isBalance(Node head)
-    {
-        boolean[]res=new boolean[1];
-        res[0]=true;
-        getHeight(head,1,res);
-        return res[0];
-    }
-
-    public static void main(String[] args) {
-        Node head = new Node(1);
-        head.left = new Node(2);
-        head.right = new Node(3);
-        head.left.left = new Node(4);
-        head.left.right = new Node(5);
-        head.right.left = new Node(6);
-        head.right.right = new Node(7);
-
-        System.out.println(isBalance(head)==isBal(head));
-
-    }
-}
Index: src/左神算法/进阶班一/树相关/高度套路题树形dp/IsBalancedTree.java
===================================================================
diff --git a/src/左神算法/进阶班一/树相关/高度套路题树形dp/IsBalancedTree.java b/src/左神算法/进阶班一/树相关/高度套路题树形dp/IsBalancedTree.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/树相关/高度套路题树形dp/IsBalancedTree.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,86 +0,0 @@
-package 左神算法.进阶班一.树相关.高度套路题树形dp;
-
-/**
- * 判断一颗二叉树是否是平衡二叉树
- */
-public class IsBalancedTree {
-
-    public static class Node{
-       public  int value;
-       public Node left;
-       public Node right;
-
-        public Node(int value) {
-            this.value = value;
-        }
-    }
-
-    public static class ReturnData{
-        public boolean isBalanced;
-        public int height;
-
-        public ReturnData(boolean isBalanced, int height) {
-            this.isBalanced = isBalanced;
-            this.height = height;
-        }
-    }
-
-    public static boolean isBal(Node head)
-    {
-        return process(head).isBalanced;
-    }
-    public static ReturnData process(Node head)
-    {
-        if(head==null)
-        {
-            return new ReturnData(true,0);
-        }
-        ReturnData leftData = process(head.left);
-        if(!leftData.isBalanced)
-            return new ReturnData(false,0);
-        ReturnData rightData = process(head.right);
-        if(! rightData.isBalanced)
-            return new ReturnData(false,0);
-        if(Math.abs(leftData.height-rightData.height)>1)
-            return new ReturnData(false,0);
-        return new ReturnData(true,Math.max(leftData.height,rightData.height)+1);
-
-    }
-
-    //法二：
-    public static int getHeight(Node head,int level,boolean[] res)
-    {
-        if(head==null)
-            return level;
-        int lH=getHeight(head.left,level+1,res);
-        if(!res[0])
-            return level;
-        int rH=getHeight(head.right,level+1,res);
-        if(!res[0])
-            return level;
-        if(Math.abs(lH-rH)>1)
-            res[0]=false;
-        return Math.max(lH,rH);
-    }
-
-    public static boolean  isBalance(Node head)
-    {
-        boolean[]res=new boolean[1];
-        res[0]=true;
-        getHeight(head,1,res);
-        return res[0];
-    }
-
-    public static void main(String[] args) {
-        Node head = new Node(1);
-        head.left = new Node(2);
-        head.right = new Node(3);
-        head.left.left = new Node(4);
-        head.left.right = new Node(5);
-        head.right.left = new Node(6);
-        head.right.right = new Node(7);
-
-        System.out.println(isBalance(head)==isBal(head));
-
-    }
-}
Index: src/左神算法/基础班/树/IsBSTAndCBT.java
===================================================================
diff --git a/src/左神算法/基础班/树/IsBSTAndCBT.java b/src/左神算法/基础班/树/IsBSTAndCBT.java
deleted file mode 100644
--- a/src/左神算法/基础班/树/IsBSTAndCBT.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,130 +0,0 @@
-package 左神算法.基础班.树;
-
-import java.util.LinkedList;
-import java.util.Queue;
-
-/**
- * 判断一颗树是否是搜索二叉树，判断一颗树是否是完全二叉树
- */
-public class IsBSTAndCBT {
-
-    public static class Node{
-        public int value;
-        public Node right;
-        public Node left;
-
-        public Node(int value) {
-            this.value = value;
-        }
-    }
-
-    //moris中序遍历的方式
-    public static boolean isBST(Node head)
-    {
-        if(head==null)
-            return true;
-        boolean res=true;
-        Node pre=null;
-        Node cur1=head;
-        Node cur2=null;
-        while(cur1!=null)
-        {
-            cur2=cur1.left;
-            if(cur2!=null)
-            {
-                while(cur2.right!=null && cur2.right!=cur1)
-                {
-                    cur2=cur2.right;
-                }
-                if(cur2.right==null)
-                {
-                    cur2.right=cur1;
-                    cur1=cur1.left;
-                    continue;
-                }else{
-                    cur2.right=null;
-                    }
-            }
-            if(pre!=null && pre.value>cur1.value)
-                res=false;
-            pre=cur1;
-            cur1=cur1.right;
-        }
-        return res;
-    }
-
-    //判断你是否是完全二叉树
-    public static boolean isCBT(Node head)
-    {
-       if(head==null)
-           return true;
-        Queue<Node>queue=new LinkedList<>();
-        boolean leaf=false;////是否开启了叶节点的阶段，即：存在左孩子，但没有右孩子，开启叶节点的阶段。此时遍历遇到的结点应该都是叶节点，
-        queue.offer(head);
-        Node left=null;
-        Node right=null;
-        while(!queue.isEmpty())
-        {
-            head=queue.poll();
-            left=head.left;
-            right=head.right;
-            if((leaf && (left!=null || right!=null)) || (left==null && right!=null)) //左子节点不存在，右子节点存在，为false；开启叶子结点步骤后，还存在叶子结点，为false
-                return false;
-            if(left!=null)
-            {
-                queue.offer(left);
-            }
-            if(right!=null)
-                queue.offer(right);
-            // 即当两个节点不都存在的时候开启叶子结点步骤
-            if(left==null || right==null)
-                leaf=true;
-        }
-        return true;
-
-    }
-
-    // for test -- print tree
-    public static void printTree(Node head) {
-        System.out.println("Binary Tree:");
-        printInOrder(head, 0, "H", 17);
-        System.out.println();
-    }
-
-    public static void printInOrder(Node head, int height, String to, int len) {
-        if (head == null) {
-            return;
-        }
-        printInOrder(head.right, height + 1, "v", len);
-        String val = to + head.value + to;
-        int lenM = val.length();
-        int lenL = (len - lenM) / 2;
-        int lenR = len - lenM - lenL;
-        val = getSpace(lenL) + val + getSpace(lenR);
-        System.out.println(getSpace(height * len) + val);
-        printInOrder(head.left, height + 1, "^", len);
-    }
-
-    public static String getSpace(int num) {
-        String space = " ";
-        StringBuffer buf = new StringBuffer("");
-        for (int i = 0; i < num; i++) {
-            buf.append(space);
-        }
-        return buf.toString();
-    }
-
-    public static void main(String[] args) {
-        Node head = new Node(4);
-        head.left = new Node(2);
-        head.right = new Node(6);
-        head.left.left = new Node(1);
-        head.left.right = new Node(3);
-        head.right.left = new Node(5);
-
-        printTree(head);
-        System.out.println(isBST(head));
-        System.out.println(isCBT(head));
-
-    }
-}
Index: src/左神算法/进阶班一/树相关/IsBSTAndCBT.java
===================================================================
diff --git a/src/左神算法/进阶班一/树相关/IsBSTAndCBT.java b/src/左神算法/进阶班一/树相关/IsBSTAndCBT.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/树相关/IsBSTAndCBT.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,130 +0,0 @@
-package 左神算法.进阶班一.树相关;
-
-import java.util.LinkedList;
-import java.util.Queue;
-
-/**
- * 判断一颗树是否是搜索二叉树，判断一颗树是否是完全二叉树
- */
-public class IsBSTAndCBT {
-
-    public static class Node{
-        public int value;
-        public Node right;
-        public Node left;
-
-        public Node(int value) {
-            this.value = value;
-        }
-    }
-
-    //moris中序遍历的方式
-    public static boolean isBST(Node head)
-    {
-        if(head==null)
-            return true;
-        boolean res=true;
-        Node pre=null;
-        Node cur1=head;
-        Node cur2=null;
-        while(cur1!=null)
-        {
-            cur2=cur1.left;
-            if(cur2!=null)
-            {
-                while(cur2.right!=null && cur2.right!=cur1)
-                {
-                    cur2=cur2.right;
-                }
-                if(cur2.right==null)
-                {
-                    cur2.right=cur1;
-                    cur1=cur1.left;
-                    continue;
-                }else{
-                    cur2.right=null;
-                    }
-            }
-            if(pre!=null && pre.value>cur1.value)
-                res=false;
-            pre=cur1;
-            cur1=cur1.right;
-        }
-        return res;
-    }
-
-    //判断你是否是完全二叉树
-    public static boolean isCBT(Node head)
-    {
-       if(head==null)
-           return true;
-        Queue<Node>queue=new LinkedList<>();
-        boolean leaf=false;////是否开启了叶节点的阶段，即：存在左孩子，但没有右孩子，开启叶节点的阶段。此时遍历遇到的结点应该都是叶节点，
-        queue.offer(head);
-        Node left=null;
-        Node right=null;
-        while(!queue.isEmpty())
-        {
-            head=queue.poll();
-            left=head.left;
-            right=head.right;
-            if((leaf && (left!=null || right!=null)) || (left==null && right!=null)) //左子节点不存在，右子节点存在，为false；开启叶子结点步骤后，还存在叶子结点，为false
-                return false;
-            if(left!=null)
-            {
-                queue.offer(left);
-            }
-            if(right!=null)
-                queue.offer(right);
-            // 即当两个节点不都存在的时候开启叶子结点步骤
-            if(left==null || right==null)
-                leaf=true;
-        }
-        return true;
-
-    }
-
-    // for test -- print tree
-    public static void printTree(Node head) {
-        System.out.println("Binary Tree:");
-        printInOrder(head, 0, "H", 17);
-        System.out.println();
-    }
-
-    public static void printInOrder(Node head, int height, String to, int len) {
-        if (head == null) {
-            return;
-        }
-        printInOrder(head.right, height + 1, "v", len);
-        String val = to + head.value + to;
-        int lenM = val.length();
-        int lenL = (len - lenM) / 2;
-        int lenR = len - lenM - lenL;
-        val = getSpace(lenL) + val + getSpace(lenR);
-        System.out.println(getSpace(height * len) + val);
-        printInOrder(head.left, height + 1, "^", len);
-    }
-
-    public static String getSpace(int num) {
-        String space = " ";
-        StringBuffer buf = new StringBuffer("");
-        for (int i = 0; i < num; i++) {
-            buf.append(space);
-        }
-        return buf.toString();
-    }
-
-    public static void main(String[] args) {
-        Node head = new Node(4);
-        head.left = new Node(2);
-        head.right = new Node(6);
-        head.left.left = new Node(1);
-        head.left.right = new Node(3);
-        head.right.left = new Node(5);
-
-        printTree(head);
-        System.out.println(isBST(head));
-        System.out.println(isCBT(head));
-
-    }
-}
Index: src/左神算法/进阶班一/树相关/IsCBT.java
===================================================================
diff --git a/src/左神算法/进阶班一/树相关/IsCBT.java b/src/左神算法/进阶班一/树相关/IsCBT.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/树相关/IsCBT.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,49 +0,0 @@
-package 左神算法.进阶班一.树相关;
-
-import java.util.LinkedList;
-import java.util.Queue;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:判断一颗树是否是完全二叉树
- * @date 2020/1/9 14:05
- */
-public class IsCBT {
-
-
-    public static class Node{
-        public int value;
-        public Node right;
-        public Node left;
-
-        public Node(int value) {
-            this.value = value;
-        }
-    }
-
-    public static boolean isCBT(Node node){
-           if(node==null)
-               return true;
-        Queue<Node> queue=new LinkedList<>();
-        boolean leaf=false; //是否开启剩下的结点需要全部是叶子结点的阶段
-        Node left=null;
-        Node right=null;
-        queue.add(node);
-        while(!queue.isEmpty()){
-            Node head=queue.poll();
-            left=head.left;
-            right=head.right;
-            if((leaf && (left!=null || right!=null)) || (left==null && right!=null)){
-                return false;
-            }
-            if(left!=null)
-                queue.add(left);
-            if(right!=null)
-                queue.add(right);
-            if(right==null || left==null)
-                leaf=true;
-        }
-        return true;
-    }
-}
Index: src/左神算法/基础班/并查集/Islands.java
===================================================================
diff --git a/src/左神算法/基础班/并查集/Islands.java b/src/左神算法/基础班/并查集/Islands.java
deleted file mode 100644
--- a/src/左神算法/基础班/并查集/Islands.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,83 +0,0 @@
-package 左神算法.基础班.并查集;
-
-/**
- * 岛问题
- */
-public class Islands {
-
-    //单cpu下解决岛问题
-//    public static int countIslands(int[][] m)
-//    {
-//        if(m == null || m[0]==null) //注意这里m[0]==null,
-//        {
-//            return 0;
-//        }
-//        int N=m.length;
-//        int M=m[0].length;
-//        int res=0;
-//        for(int i=0;i<N;i++)
-//        {
-//            for(int j=0;j<M;j++)
-//            {
-//                if(m[i][i]==1)
-//                {
-//                    res++;
-//                    infect(m,i,j,N,M);
-//                }
-//            }
-//        }
-//        return res;
-//    }
-//单cpu下的
-public static int countIslands(int[][] m) {
-    if (m == null || m[0] == null) {
-        return 0;
-    }
-    int N = m.length;
-    int M = m[0].length;
-    int res = 0;
-    for (int i = 0; i < N; i++) {
-        for (int j = 0; j < M; j++) {
-            if (m[i][j] == 1) {
-                res++;
-                infect(m, i, j, N, M);
-            }
-        }
-    }
-    return res;
-}
-    //判断是否是相同的岛，如果是，便感染这个元素。即：感染算法
-    public static void infect(int[][] m, int i, int j, int N, int M) {
-        if (i < 0 || i >= N || j < 0 || j >= M || m[i][j] != 1) {
-            return;
-        }
-        m[i][j] = 2;
-        infect(m, i + 1, j, N, M);
-        infect(m, i - 1, j, N, M);
-        infect(m, i, j + 1, N, M);
-        infect(m, i, j - 1, N, M);
-    }
-
-    public static void main(String[] args) {
-        int[][] m1 = {  { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
-                { 0, 1, 1, 1, 0, 1, 1, 1, 0 },
-                { 0, 1, 1, 1, 0, 0, 0, 1, 0 },
-                { 0, 1, 1, 0, 0, 0, 0, 0, 0 },
-                { 0, 0, 0, 0, 0, 1, 1, 0, 0 },
-                { 0, 0, 0, 0, 1, 1, 1, 0, 0 },
-                { 0, 0, 0, 0, 0, 0, 0, 0, 0 }, };
-        System.out.println(countIslands(m1));
-
-        int[][] m2 = {  { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
-                { 0, 1, 1, 1, 1, 1, 1, 1, 0 },
-                { 0, 1, 1, 1, 0, 0, 0, 1, 0 },
-                { 0, 1, 1, 0, 0, 0, 1, 1, 0 },
-                { 0, 0, 0, 0, 0, 1, 1, 0, 0 },
-                { 0, 0, 0, 0, 1, 1, 1, 0, 0 },
-                { 0, 0, 0, 0, 0, 0, 0, 0, 0 }, };
-        System.out.println(countIslands(m2));
-
-    }
-
-
-}
Index: src/左神算法/基础班/第四课/Islands.java
===================================================================
diff --git a/src/左神算法/基础班/第四课/Islands.java b/src/左神算法/基础班/第四课/Islands.java
deleted file mode 100644
--- a/src/左神算法/基础班/第四课/Islands.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,80 +0,0 @@
-package 左神算法.基础班.第四课;
-
-public class Islands {
-
-    //单cpu下解决岛问题
-//    public static int countIslands(int[][] m)
-//    {
-//        if(m == null || m[0]==null) //注意这里m[0]==null,
-//        {
-//            return 0;
-//        }
-//        int N=m.length;
-//        int M=m[0].length;
-//        int res=0;
-//        for(int i=0;i<N;i++)
-//        {
-//            for(int j=0;j<M;j++)
-//            {
-//                if(m[i][i]==1)
-//                {
-//                    res++;
-//                    infect(m,i,j,N,M);
-//                }
-//            }
-//        }
-//        return res;
-//    }
-//单cpu下的
-public static int countIslands(int[][] m) {
-    if (m == null || m[0] == null) {
-        return 0;
-    }
-    int N = m.length;
-    int M = m[0].length;
-    int res = 0;
-    for (int i = 0; i < N; i++) {
-        for (int j = 0; j < M; j++) {
-            if (m[i][j] == 1) {
-                res++;
-                infect(m, i, j, N, M);
-            }
-        }
-    }
-    return res;
-}
-    //判断是否是相同的岛，如果是，便感染这个元素。即：感染算法
-    public static void infect(int[][] m, int i, int j, int N, int M) {
-        if (i < 0 || i >= N || j < 0 || j >= M || m[i][j] != 1) {
-            return;
-        }
-        m[i][j] = 2;
-        infect(m, i + 1, j, N, M);
-        infect(m, i - 1, j, N, M);
-        infect(m, i, j + 1, N, M);
-        infect(m, i, j - 1, N, M);
-    }
-
-    public static void main(String[] args) {
-        int[][] m1 = {  { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
-                { 0, 1, 1, 1, 0, 1, 1, 1, 0 },
-                { 0, 1, 1, 1, 0, 0, 0, 1, 0 },
-                { 0, 1, 1, 0, 0, 0, 0, 0, 0 },
-                { 0, 0, 0, 0, 0, 1, 1, 0, 0 },
-                { 0, 0, 0, 0, 1, 1, 1, 0, 0 },
-                { 0, 0, 0, 0, 0, 0, 0, 0, 0 }, };
-        System.out.println(countIslands(m1));
-
-        int[][] m2 = {  { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
-                { 0, 1, 1, 1, 1, 1, 1, 1, 0 },
-                { 0, 1, 1, 1, 0, 0, 0, 1, 0 },
-                { 0, 1, 1, 0, 0, 0, 1, 1, 0 },
-                { 0, 0, 0, 0, 0, 1, 1, 0, 0 },
-                { 0, 0, 0, 0, 1, 1, 1, 0, 0 },
-                { 0, 0, 0, 0, 0, 0, 0, 0, 0 }, };
-        System.out.println(countIslands(m2));
-
-    }
-
-
-}
Index: src/左神算法/进阶班一/并查集/Islands.java
===================================================================
diff --git a/src/左神算法/进阶班一/并查集/Islands.java b/src/左神算法/进阶班一/并查集/Islands.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/并查集/Islands.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,83 +0,0 @@
-package 左神算法.进阶班一.并查集;
-
-/**
- * 岛问题
- */
-public class Islands {
-
-    //单cpu下解决岛问题
-//    public static int countIslands(int[][] m)
-//    {
-//        if(m == null || m[0]==null) //注意这里m[0]==null,
-//        {
-//            return 0;
-//        }
-//        int N=m.length;
-//        int M=m[0].length;
-//        int res=0;
-//        for(int i=0;i<N;i++)
-//        {
-//            for(int j=0;j<M;j++)
-//            {
-//                if(m[i][i]==1)
-//                {
-//                    res++;
-//                    infect(m,i,j,N,M);
-//                }
-//            }
-//        }
-//        return res;
-//    }
-//单cpu下的
-public static int countIslands(int[][] m) {
-    if (m == null || m[0] == null) {
-        return 0;
-    }
-    int N = m.length;
-    int M = m[0].length;
-    int res = 0;
-    for (int i = 0; i < N; i++) {
-        for (int j = 0; j < M; j++) {
-            if (m[i][j] == 1) {
-                res++;
-                infect(m, i, j, N, M);
-            }
-        }
-    }
-    return res;
-}
-    //判断是否是相同的岛，如果是，便感染这个元素。即：感染算法
-    public static void infect(int[][] m, int i, int j, int N, int M) {
-        if (i < 0 || i >= N || j < 0 || j >= M || m[i][j] != 1) {
-            return;
-        }
-        m[i][j] = 2;
-        infect(m, i + 1, j, N, M);
-        infect(m, i - 1, j, N, M);
-        infect(m, i, j + 1, N, M);
-        infect(m, i, j - 1, N, M);
-    }
-
-    public static void main(String[] args) {
-        int[][] m1 = {  { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
-                { 0, 1, 1, 1, 0, 1, 1, 1, 0 },
-                { 0, 1, 1, 1, 0, 0, 0, 1, 0 },
-                { 0, 1, 1, 0, 0, 0, 0, 0, 0 },
-                { 0, 0, 0, 0, 0, 1, 1, 0, 0 },
-                { 0, 0, 0, 0, 1, 1, 1, 0, 0 },
-                { 0, 0, 0, 0, 0, 0, 0, 0, 0 }, };
-        System.out.println(countIslands(m1));
-
-        int[][] m2 = {  { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
-                { 0, 1, 1, 1, 1, 1, 1, 1, 0 },
-                { 0, 1, 1, 1, 0, 0, 0, 1, 0 },
-                { 0, 1, 1, 0, 0, 0, 1, 1, 0 },
-                { 0, 0, 0, 0, 0, 1, 1, 0, 0 },
-                { 0, 0, 0, 0, 1, 1, 1, 0, 0 },
-                { 0, 0, 0, 0, 0, 0, 0, 0, 0 }, };
-        System.out.println(countIslands(m2));
-
-    }
-
-
-}
Index: src/左神算法/基础班/第三课/IsPalindromeList.java
===================================================================
diff --git a/src/左神算法/基础班/第三课/IsPalindromeList.java b/src/左神算法/基础班/第三课/IsPalindromeList.java
deleted file mode 100644
--- a/src/左神算法/基础班/第三课/IsPalindromeList.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,208 +0,0 @@
-package 左神算法.基础班.第三课;
-
-import java.util.Stack;
-
-public class IsPalindromeList {
-
-    public static class Node{
-        public int value;
-        public Node next;
-        public Node(int value)
-        {
-            this.value=value;
-        }
-
-    }
-
-    //need n extra space
-    public static boolean isPalindrome1(Node head) {
-        Stack<Node> stack = new Stack<Node>();
-        Node cur = head;
-        while (cur != null) {
-            stack.push(cur);
-            cur = cur.next;
-        }
-        while (head != null) {
-            if (head.value != stack.pop().value) {
-                return false;
-            }
-            head = head.next;
-        }
-        return true;
-    }
-
-    //need n/2 extra space
-    public static boolean isPalindrome2(Node head)
-    {
-        if(head==null || head.next==null)
-            return true;
-        Node fast=head;
-        Node cur=head.next;
-        while(fast.next!=null && fast.next.next!=null)
-        {
-            cur=cur.next;
-            fast=fast.next.next;
-        }
-        Stack<Node> stack=new Stack<>();
-        while(cur!=null)
-        {
-            stack.push(cur);
-            cur=cur.next;
-        }
-        while(!stack.isEmpty()){
-            if(head.value!=stack.pop().value)
-                return false;
-            head=head.next;
-        }
-        return true;
-    }
-
-
-    //need O(1) extra space
-    public static boolean isPalindrome3(Node head){
-        if(head==null || head.next==null)
-            return true;
-        Node n1=head;
-        Node n2=head;
-        while(n2.next!=null && n2.next.next!=null)
-        {
-            n1=n1.next; //n1->mid
-            n2=n2.next.next;//n2->end
-        }
-        n2=n1.next; //n2->right part first node
-        n1.next=null;//mid.next->null
-        Node n3=null;
-        while(n2!=null)  //right part convert
-        {
-            n3=n2.next;//save next part
-            n2.next=n1;//next of right node convert
-            n1=n2;//n1 move
-            n2=n3;//n2 move
-        }
-        n3=n1;//save the last node
-        n2=head;//left first node
-        boolean res=true;
-        while(n1!=null && n2!=null)//对于链表一共有奇数个元素和偶数个元素都适用
-        {
-            if(n1.value!=n2.value)
-            {
-                res=false;
-                break;
-            }
-            n1=n1.next;
-            n2=n2.next;
-        }
-        n1 = n3.next;
-        n3.next = null;
-        while (n1 != null) { // recover list
-            n2 = n1.next;
-            n1.next = n3;
-            n3 = n1;
-            n1 = n2;
-        }
-
-        return res;
-
-    }
-
-    public static void printLinkedList(Node node) {
-        System.out.print("Linked List: ");
-        while (node != null) {
-            System.out.print(node.value + " ");
-            node = node.next;
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-
-        Node head = null;
-        printLinkedList(head);
-        System.out.print(isPalindrome1(head) + " | ");
-        System.out.print(isPalindrome2(head) + " | ");
-        System.out.println(isPalindrome3(head) + " | ");
-        printLinkedList(head);
-        System.out.println("=========================");
-
-        head = new Node(1);
-        printLinkedList(head);
-        System.out.print(isPalindrome1(head) + " | ");
-        System.out.print(isPalindrome2(head) + " | ");
-        System.out.println(isPalindrome3(head) + " | ");
-        printLinkedList(head);
-        System.out.println("=========================");
-
-        head = new Node(1);
-        head.next = new Node(2);
-        printLinkedList(head);
-        System.out.print(isPalindrome1(head) + " | ");
-        System.out.print(isPalindrome2(head) + " | ");
-        System.out.println(isPalindrome3(head) + " | ");
-        printLinkedList(head);
-        System.out.println("=========================");
-
-        head = new Node(1);
-        head.next = new Node(1);
-        printLinkedList(head);
-        System.out.print(isPalindrome1(head) + " | ");
-        System.out.print(isPalindrome2(head) + " | ");
-        System.out.println(isPalindrome3(head) + " | ");
-        printLinkedList(head);
-        System.out.println("=========================");
-
-        head = new Node(1);
-        head.next = new Node(2);
-        head.next.next = new Node(3);
-        printLinkedList(head);
-        System.out.print(isPalindrome1(head) + " | ");
-        System.out.print(isPalindrome2(head) + " | ");
-        System.out.println(isPalindrome3(head) + " | ");
-        printLinkedList(head);
-        System.out.println("=========================");
-
-        head = new Node(1);
-        head.next = new Node(2);
-        head.next.next = new Node(1);
-        printLinkedList(head);
-        System.out.print(isPalindrome1(head) + " | ");
-        System.out.print(isPalindrome2(head) + " | ");
-        System.out.println(isPalindrome3(head) + " | ");
-        printLinkedList(head);
-        System.out.println("=========================");
-
-        head = new Node(1);
-        head.next = new Node(2);
-        head.next.next = new Node(3);
-        head.next.next.next = new Node(1);
-        printLinkedList(head);
-        System.out.print(isPalindrome1(head) + " | ");
-        System.out.print(isPalindrome2(head) + " | ");
-        System.out.println(isPalindrome3(head) + " | ");
-        printLinkedList(head);
-        System.out.println("=========================");
-
-        head = new Node(1);
-        head.next = new Node(2);
-        head.next.next = new Node(2);
-        head.next.next.next = new Node(1);
-        printLinkedList(head);
-        System.out.print(isPalindrome1(head) + " | ");
-        System.out.print(isPalindrome2(head) + " | ");
-        System.out.println(isPalindrome3(head) + " | ");
-        printLinkedList(head);
-        System.out.println("=========================");
-
-        head = new Node(1);
-        head.next = new Node(2);
-        head.next.next = new Node(3);
-        head.next.next.next = new Node(2);
-        head.next.next.next.next = new Node(1);
-        printLinkedList(head);
-        System.out.print(isPalindrome1(head) + " | ");
-        System.out.print(isPalindrome2(head) + " | ");
-        System.out.println(isPalindrome3(head) + " | ");
-        printLinkedList(head);
-        System.out.println("=========================");
-
-    }
-}
Index: src/面试相关/面试手撕代码/IsSymmetricTree.java
===================================================================
diff --git a/src/面试相关/面试手撕代码/IsSymmetricTree.java b/src/面试相关/面试手撕代码/IsSymmetricTree.java
deleted file mode 100644
--- a/src/面试相关/面试手撕代码/IsSymmetricTree.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,37 +0,0 @@
-package 面试相关.面试手撕代码;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 判断一颗树是否是镜像对称的
- * @date 2020/7/6 20:27
- */
-public class IsSymmetricTree {
-
-    class TreeNode{
-        int val;
-        TreeNode left;
-        TreeNode right;
-
-        public TreeNode(int val){
-            this.val=val;
-        }
-    }
-
-    public boolean process(TreeNode node){
-        if(node==null) return true;
-        if(node.left!=null && node.right!=null){
-            return help(node.left,node.right);
-        }
-        return false;
-    }
-    private boolean help(TreeNode left,TreeNode right){
-        if(left==null && right==null) return true;
-        if(left==null || right==null) return false;
-        if(left.val!=right.val) return false;
-        boolean leftResult=help(left.right,right.left);
-        boolean rightResult=help(left.left,right.right);
-        return leftResult && rightResult;
-    }
-}
Index: src/Gof/proxy/dynamicProxy/ITeacherDao.java
===================================================================
diff --git a/src/Gof/proxy/dynamicProxy/ITeacherDao.java b/src/Gof/proxy/dynamicProxy/ITeacherDao.java
deleted file mode 100644
--- a/src/Gof/proxy/dynamicProxy/ITeacherDao.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,7 +0,0 @@
-package Gof.proxy.dynamicProxy;
-
-public interface ITeacherDao {
-
-    void teach(String name);
-    void lesson(String name);
-}
Index: src/Gof/proxy/staticProxy/ITeacherDao.java
===================================================================
diff --git a/src/Gof/proxy/staticProxy/ITeacherDao.java b/src/Gof/proxy/staticProxy/ITeacherDao.java
deleted file mode 100644
--- a/src/Gof/proxy/staticProxy/ITeacherDao.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,6 +0,0 @@
-package Gof.proxy.staticProxy;
-
-public interface ITeacherDao {
-
-    void teach(String name);
-}
Index: src/Gof/iterator/Iterator.java
===================================================================
diff --git a/src/Gof/iterator/Iterator.java b/src/Gof/iterator/Iterator.java
deleted file mode 100644
--- a/src/Gof/iterator/Iterator.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package Gof.iterator;
-
-public interface Iterator {
-
-    public boolean hasNext();
-    public Object next();
-    public void remove();
-}
Index: src/Gof/Adapter/IVoltage5v.java
===================================================================
diff --git a/src/Gof/Adapter/IVoltage5v.java b/src/Gof/Adapter/IVoltage5v.java
deleted file mode 100644
--- a/src/Gof/Adapter/IVoltage5v.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,5 +0,0 @@
-package Gof.Adapter;
-
-public interface IVoltage5v {
-    public int output5v();
-}
Index: src/org/sd/javaMail/JavaMailDemo.java
===================================================================
diff --git a/src/org/sd/javaMail/JavaMailDemo.java b/src/org/sd/javaMail/JavaMailDemo.java
deleted file mode 100644
--- a/src/org/sd/javaMail/JavaMailDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,80 +0,0 @@
-package org.sd.javaMail;
-
-import javax.mail.Session;
-import javax.mail.Transport;
-import javax.mail.internet.InternetAddress;
-import javax.mail.internet.MimeMessage;
-import java.io.UnsupportedEncodingException;
-import java.util.Date;
-import java.util.Properties;
-
-public class JavaMailDemo {
-
-    public static String sendEmailAccount = "813321674@qq.com";
-    public static String sendEmailPwd = "pgbpbzdvghojbfee";
-    public static String receiveMailAccount = "3060346221@qq.com";
-    //发件人邮箱服务器地址
-    private static String emaiProtocolType="smtp";
-    private static String sendEmailSMTPHost="smtp.qq.com";
-    private static String smtpPort="465";
-    private static String sslSocketFactory="javax.net.ssl.SSLSocketFactory";
-
-    public static void main(String[] args) throws Exception {
-        //设置配置参数，用于连接邮箱服务器的配置参数
-        Properties pro=new Properties();
-        pro.setProperty("mail.transport.protocol",emaiProtocolType); //使用的协议
-        pro.setProperty("mail.smtp.host",sendEmailSMTPHost);//发件人的邮箱饿smtp服务器地址
-        pro.setProperty("mail.smtp.auth","true");//需要请求认证
-
-
-        //SSL安全认证
-        pro.setProperty("mail.smpt.port",smtpPort);
-        //设置socketFactory
-        pro.setProperty("mail.smtp.socketFactory",sslSocketFactory);
-
-        //只处理ssl的连接，对于非ssl的连接不做处理
-        pro.setProperty("mail.smtp.socketFactory.fallback","false");
-        pro.setProperty("mail.smtp.socketFactory.port",smtpPort);
-        //创建回话对象，用于和邮箱服务器交互
-        Session session=Session.getInstance(pro);
-        session.setDebug(true);//设置为debug模式，可以查看详细的发送log
-
-        //创建一封邮件
-        MimeMessage mimeMessage = createMimeMessage(session, sendEmailAccount, receiveMailAccount);
-        //根据session获取邮件传输对象
-        Transport transport=session.getTransport();
-        //使用邮箱账号，密码连接邮件服务器，这里认证的邮箱必须与message中的发件人的邮箱一直
-
-        transport.connect(sendEmailAccount,sendEmailPwd);
-        //发送邮件
-        transport.sendMessage(mimeMessage,mimeMessage.getAllRecipients());
-        //关闭连接
-        transport.close();
-
-
-
-
-    }
-    public static MimeMessage createMimeMessage(Session session,String sendMail,String receiveMail) throws Exception {
-        //创建一封邮件
-        MimeMessage message=new MimeMessage(session);
-        //设置发件人
-        message.setFrom(new InternetAddress(sendMail,"UTF-8"));
-        //设置收件人。可以增加多个收件人，抄送，密送
-        message.setRecipient(MimeMessage.RecipientType.TO,new InternetAddress(receiveMail,"xxxx用户", "UTF-8"));
-        message.setRecipient(MimeMessage.RecipientType.CC,new InternetAddress("3060346221@qq.com","xx用户","UTF-8"));
-
-        //设置邮件主题
-        message.setSubject("subject","UTF-8");
-        //设置正文
-        message.setContent("正文dddddd4444","text/html;charset=utf-8");
-
-        //设置发送事件
-        message.setSentDate(new Date());
-
-        //保存设置
-        message.saveChanges();
-        return message;
-
-    }
-}
Index: .idea/libraries/javax_mail.xml
===================================================================
diff --git a/.idea/libraries/javax_mail.xml b/.idea/libraries/javax_mail.xml
deleted file mode 100644
--- a/.idea/libraries/javax_mail.xml	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,9 +0,0 @@
-<component name="libraryTable">
-  <library name="javax.mail">
-    <CLASSES>
-      <root url="jar://$PROJECT_DIR$/src/lib/javax.mail.jar!/" />
-    </CLASSES>
-    <JAVADOC />
-    <SOURCES />
-  </library>
-</component>
\ No newline at end of file
Index: src/韩顺平算法与数据结构/datastructure/list/Josepfu.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/list/Josepfu.java b/src/韩顺平算法与数据结构/datastructure/list/Josepfu.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/list/Josepfu.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,133 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.list;
-
-public class Josepfu {
-    public static void main(String[] args) {
-        // 测试一把看看构建环形链表，和遍历是否ok
-        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
-        circleSingleLinkedList.addBoy(5);// 加入5个小孩节点
-        circleSingleLinkedList.showBoy();
-
-        //测试一把小孩出圈是否正确
-        circleSingleLinkedList.countBoy(1, 2, 5); // 2->4->1->5->3
-        //String str = "7*2*2-5+1-5+3-3";
-    }
-}
-
-class CircleSingleLinkedList{
-    private Boy first=null;
-    //添加小孩结点，创建环形链表
-    public void addBoy(int nums)
-    {
-        //数据校验
-        if(nums<1)
-        {
-            System.out.println("nums的值不正确！");
-            return;
-        }
-        Boy cur=null;//辅助指针，构建环形链表
-
-       for(int i=1;i<=nums;i++)
-       {
-           //根据编号，创建结点
-           Boy boy=new Boy(i);
-           if(i==1)
-           {
-               first=boy;
-               first.setNext(first);
-               cur=first;
-           }else{
-               cur.setNext(boy);
-               boy.setNext(first);
-               cur=boy;
-           }
-       }
-    }
-
-    //遍历当前的环形链表
-    public void showBoy()
-    {
-        if(first==null)
-        {
-            System.out.println("链表为空");
-            return;
-        }
-        Boy cur=first;
-        while(true)
-        {
-            System.out.println("小孩的编号为："+cur.getNo());
-            if(cur.getNext()==first)
-            {
-                break;
-            }
-            cur=cur.getNext();
-        }
-    }
-
-    //根据用户输入，计算出小孩的出圈顺序
-   public void countBoy(int startNo,int countNums,int nums)
-   {
-       if(first==null || startNo<=0 || startNo>nums)
-       {
-           System.out.println("参数输入不正确！！");
-           return;
-       }
-       Boy helper =first;//辅助指针，帮助完成小孩的出圈
-       //辅助指针指向最后一个结点
-       while (true)
-       {
-           if(helper.getNext()==first)
-           {
-               break;
-           }
-           helper=helper.getNext();
-       }
-       while(true) {
-           //小孩在报数前先移动startNo-1次
-           if(first==helper)
-           {  //说明只有一个小孩还在
-               break;
-           }
-           for (int i = 1; i <= startNo - 1; i++) {
-               first = first.getNext();
-               helper = helper.getNext();
-           }
-           //从开始报数小孩开始，移动countNums次，
-           for (int j = 1; j <= countNums - 1; j++) {
-               first = first.getNext();
-               helper = helper.getNext();
-           }
-           System.out.println("出圈小孩编号为：" + first.getNo());
-           first = first.getNext();
-           helper.setNext(first);
-       }
-       System.out.println("最后留下的小孩是："+first.getNo());
-
-
-   }
-
-}
-class Boy{
-    private int no;
-    private Boy next;
-
-   public Boy(int no)
-   {
-       this.no=no;
-   }
-
-    public int getNo() {
-        return no;
-    }
-
-    public void setNo(int no) {
-        this.no = no;
-    }
-
-    public Boy getNext() {
-        return next;
-    }
-
-    public void setNext(Boy next) {
-        this.next = next;
-    }
-}
\ No newline at end of file
Index: src/左神算法/高频面试题/十二十三/JosepheProblem.java
===================================================================
diff --git a/src/左神算法/高频面试题/十二十三/JosepheProblem.java b/src/左神算法/高频面试题/十二十三/JosepheProblem.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/十二十三/JosepheProblem.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,101 +0,0 @@
-package 左神算法.高频面试题.十二十三;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 约瑟夫环形链表问题。
- * @date 2020/2/5 16:20
- */
-public class JosepheProblem {
-
-    public static class Node {
-        public int value;
-        public Node next;
-
-        public Node(int data) {
-            this.value = data;
-        }
-    }
-
-    public static Node josephusKill1(Node head, int m) {
-        if (head == null || head.next == head || m < 1) {
-            return head;
-        }
-        Node last = head;
-        while (last.next != head) {
-            last = last.next;
-        }
-        int count = 0;
-        while (head != last) {
-            if (++count == m) {
-                last.next = head.next;
-                count = 0;
-            } else {
-                last = last.next;
-            }
-            head = last.next;
-        }
-        return head;
-    }
-    //O(n)
-    public static Node josephusKill2(Node head,int m){
-        if(head==null || head.next==head || m<1){
-            return head;
-        }
-        Node cur=head;
-        int temp=1; //记录总个数
-        while(cur.next!=head){
-            temp++;
-            cur=cur.next;
-        }
-        int live = getLive(temp, m);//存活下来的人最开始的编号
-        while(--live!=0){
-            head=head.next;
-
-        }
-        head.next=head;
-        return head;
-    }
-     //得到活下来的人的最初的编号
-    public static int getLive(int i,int m){ //i表示所有中最后一个人的编号，m:报数为m的人杀死
-        if(i==1)
-            return 1;
-        return (getLive(i-1,m)+m-1)%i+1;
-    }
-
-    public static void printCircularList(Node head) {
-        if (head == null) {
-            return;
-        }
-        System.out.print("Circular List: " + head.value + " ");
-        Node cur = head.next;
-        while (cur != head) {
-            System.out.print(cur.value + " ");
-            cur = cur.next;
-        }
-        System.out.println("-> " + head.value);
-    }
-
-    public static void main(String[] args) {
-        Node head1 = new Node(1);
-        head1.next = new Node(2);
-        head1.next.next = new Node(3);
-        head1.next.next.next = new Node(4);
-        head1.next.next.next.next = new Node(5);
-        head1.next.next.next.next.next = head1;
-        printCircularList(head1);
-        head1 = josephusKill1(head1, 3);
-        printCircularList(head1);
-
-        Node head2 = new Node(1);
-        head2.next = new Node(2);
-        head2.next.next = new Node(3);
-        head2.next.next.next = new Node(4);
-        head2.next.next.next.next = new Node(5);
-        head2.next.next.next.next.next = head2;
-        printCircularList(head2);
-        head2 = josephusKill2(head2, 3);
-        printCircularList(head2);
-
-    }
-}
Index: src/左神算法/进阶班一/进阶八/JosephusProblem.java
===================================================================
diff --git a/src/左神算法/进阶班一/进阶八/JosephusProblem.java b/src/左神算法/进阶班一/进阶八/JosephusProblem.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/进阶八/JosephusProblem.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,104 +0,0 @@
-package 左神算法.进阶班一.进阶八;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 环形单链表约瑟夫问题
- * @date 2020/1/28 16:52
- */
-public class JosephusProblem {
-
-    public static class Node{
-        public int value;
-        public Node next;
-
-        public Node(int data) {
-            this.value = data;
-        }
-
-    }
-
-    //O(M*N)
-    public static Node josephusKill1(Node head,int m){
-        if(head==null || head.next==null || m<1){
-            return head;
-        }
-        Node last=head;
-        while(last.next!=head){//使last到达环形链表的最后一个元素位置,即：last记录head前一个位置的元素
-            last=last.next;
-        }
-        int count=0;
-        while(head!=last){
-            if(++count==m){
-                last.next=head.next;
-                count=0;
-            }else{
-                last=last.next;
-            }
-            head=last.next;
-        }
-
-        return head;
-
-    }
-
-    public static Node josephusKill2(Node head, int m) {
-        if (head == null || head.next == head || m < 1) {
-            return head;
-        }
-        Node cur = head.next;
-        int tmp = 1; // tmp -> list size
-        while (cur != head) {
-            tmp++;
-            cur = cur.next;
-        }
-        tmp = getLive(tmp, m); // tmp -> service node position
-        while (--tmp != 0) {
-            head = head.next;
-        }
-        head.next = head;
-        return head;
-    }
-
-    public static int getLive(int i, int m) {
-        if (i == 1) {
-            return 1;
-        }
-        return (getLive(i - 1, m) + m - 1) % i + 1;
-    }
-
-    public static void printCircularList(Node head) {
-        if (head == null) {
-            return;
-        }
-        System.out.print("Circular List: " + head.value + " ");
-        Node cur = head.next;
-        while (cur != head) {
-            System.out.print(cur.value + " ");
-            cur = cur.next;
-        }
-        System.out.println("-> " + head.value);
-    }
-    public static void main(String[] args) {
-        Node head1 = new Node(1);
-        head1.next = new Node(2);
-        head1.next.next = new Node(3);
-        head1.next.next.next = new Node(4);
-        head1.next.next.next.next = new Node(5);
-        head1.next.next.next.next.next = head1;
-        printCircularList(head1);
-        head1 = josephusKill1(head1, 5);
-        printCircularList(head1);
-
-        Node head2 = new Node(1);
-        head2.next = new Node(2);
-        head2.next.next = new Node(3);
-        head2.next.next.next = new Node(4);
-        head2.next.next.next.next = new Node(5);
-        head2.next.next.next.next.next = head2;
-        printCircularList(head2);
-        head2 = josephusKill2(head2, 5);
-        printCircularList(head2);
-
-    }
-}
Index: src/左神算法/进阶班一/KMP/KMP.java
===================================================================
diff --git a/src/左神算法/进阶班一/KMP/KMP.java b/src/左神算法/进阶班一/KMP/KMP.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/KMP/KMP.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,63 +0,0 @@
-package 左神算法.进阶班一.KMP;
-
-/**
- * 返回str2在str1中首次出现的位置,不存在则返回-1。即：kmp算法实现过程
- */
-public class KMP {
-
-    public static int getIndexOf(String s,String m)
-    {
-        if(s==null || m==null || s.length()<m.length()||m.length()<1)
-            return -1;
-        char[] ss=s.toCharArray();
-        char[] ms=m.toCharArray();
-        int si=0;
-        int mi=0;
-        int []next=getNextArray(ms);
-        while(si<ss.length && mi<ms.length)
-        {
-            if(ss[si]==ms[mi])
-            {
-                si++;
-                mi++;
-            }else{
-                if(next[mi]==-1)
-                {
-                    si++;
-                }else{
-                    mi=next[mi];//next[i]表示i位置的字符的最大相同前后缀的下一个字符的位置
-                }
-            }
-
-        }
-        return mi==ms.length? si-mi: -1;
-    }
-
-    //next数组只与str2有关，与str1没有关系
-    public static int[] getNextArray(char[] ms) {
-        if (ms.length == 1) {
-            return new int[] { -1 };
-        }
-        int[] next = new int[ms.length];
-        next[0] = -1;
-        next[1] = 0;
-        int pos = 2;
-        int cn = 0;//cn表示跳到的位置,cn初始值=next[pos-1]==next[1]==0,同时cn的初始值也表示了pos-1位置的最长相同前后缀。
-        while (pos < next.length) {
-            if (ms[pos - 1] == ms[cn]) {
-                next[pos++] = ++cn;
-            } else if (cn > 0) {
-                cn = next[cn];//往前跳，跳到cn位置的前缀的下一个字符
-            } else {//也就是cn<=0,其实只存在可能是0的情况
-                next[pos++] = 0;
-            }
-        }
-        return next;
-    }
-    public static void main(String[] args) {
-        String str = "abcabcababaccc";
-        String match = "b";
-        System.out.println(getIndexOf(str, match));
-
-    }
-}
Index: src/韩顺平算法与数据结构/algorithm/kmp/KmpDemo.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/algorithm/kmp/KmpDemo.java b/src/韩顺平算法与数据结构/algorithm/kmp/KmpDemo.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/algorithm/kmp/KmpDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,84 +0,0 @@
-package 韩顺平算法与数据结构.algorithm.kmp;
-
-import java.rmi.UnexpectedException;
-
-public class KmpDemo {
-    public static void main(String[] args) {
-//        String str1 = "硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好";
-//        String str2 = "尚硅谷你尚硅你";
-//        int index = violenceMatch(str1, str2);
-//        System.out.println("index=" + index);
-        String str1 = "BBC ABCDAB ABCDABCDABDE";
-        String str2 = "ABCDABD";
-        int[] next = kmpNext("ABCDABD");
-        int index = kmpSearch(str1, str2, next);
-        System.out.println("index=" + index); // 15了
-    }
-
-    public static int violenceMatch(String str1,String str2)
-    {   char[]s1=str1.toCharArray();
-        char[]s2=str2.toCharArray();
-        int n=str1.length();
-        int m=str2.length();
-        int i=0,j=0;
-        while(i<n && j<m)
-        {
-            if(s1[i]==s2[j])
-            {
-                j++;
-                i++;
-            }else {
-
-                i=i-j+1;
-                j=0;
-            }
-        }
-        if(j==m)
-        {
-            return i-j;
-        }else {
-            return  -1;
-        }
-    }
-
-    public static int kmpSearch(String str1,String str2,int[]next)
-    {
-        //遍历
-        for(int i=0,j=0;i<str1.length();i++)
-        {
-            //需要处理str1.charAt(i)!= str2.charAt（j),去调整j的大小
-           while(j>0 && str1.charAt(i)!=str2.charAt(j))
-            {
-                j=next[j-1];
-            }
-            if(str1.charAt(i)==str2.charAt(j))
-            {
-                j++;
-            }
-            if(j==str2.length())
-            {
-                return i-j+1;
-            }
-        }
-        return -1;
-    }
-    public static int[] kmpNext(String dest)
-    {
-        int len=dest.length();
-        int[] next=new int[len];
-        next[0]=0;
-        for(int i=1,j=0;i<len;i++)
-        {    //j记录前缀位置，i记录后缀位置
-            while(j>0 && dest.charAt(i)!=dest.charAt(j))
-            {
-                j=next[j-1];
-            }
-            if(dest.charAt(i)==dest.charAt(j))
-            {
-                j++;
-            }
-            next[i]=j;
-        }
-        return next;
-    }
-}
Index: src/韩顺平算法与数据结构/algorithm/dynamic/KnapsackProblem.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/algorithm/dynamic/KnapsackProblem.java b/src/韩顺平算法与数据结构/algorithm/dynamic/KnapsackProblem.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/algorithm/dynamic/KnapsackProblem.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,47 +0,0 @@
-package 韩顺平算法与数据结构.algorithm.dynamic;
-
-public class KnapsackProblem {
-    public static void main(String[] args) {
-        int []w={1,4,3};//记录物品的重量
-        int []val={1500,3000,2000};//记录物品的价值
-        int m=4;//背包的容量
-        int n=val.length;//物品的个数
-
-
-        //v[i][j]表示来前i个物品中能够装入容量为j的背包中的最大价值
-        int[][]v=new int[n+1][m+1];
-        int[][]path=new int[n+1][m+1];//增加一个数组来记录放入物品的情况
-
-        for(int i=1;i<v.length;i++)
-        {
-            for(int j=1;j<v[0].length;j++)
-            {
-                if(w[i-1]>j)
-                {
-                    v[i][j]=v[i-1][j];
-                }else {
-                    if(v[i-1][j]<val[i-1]+v[i-1][j-w[i-1]])
-                    {
-                        v[i][j]=val[i-1]+v[i-1][j-w[i-1]];
-                        //把当前的情况记录到path。因为上式中出现了val，所以说明有物品加入背包
-                        path[i][j] = 1;
-                    }else {
-                        v[i][j]=v[i-1][j];
-
-                    }
-                }
-            }
-        }
-        //动脑筋
-        int i = path.length - 1; //行的最大下标
-        int j = path[0].length - 1;  //列的最大下标
-        while(i > 0 && j > 0 ) { //从path的最后开始找
-            if(path[i][j] == 1) {
-                System.out.printf("第%d个商品放入到背包\n", i);
-                j -= w[i-1]; //w[i-1]
-            }
-            i--;
-        }
-
-    }
-}
Index: src/左神算法/基础班/图/Kruskal.java
===================================================================
diff --git a/src/左神算法/基础班/图/Kruskal.java b/src/左神算法/基础班/图/Kruskal.java
deleted file mode 100644
--- a/src/左神算法/基础班/图/Kruskal.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,89 +0,0 @@
-package 左神算法.基础班.图;
-
-import java.util.*;
-
-public class Kruskal {
-
-    //通过并查集来实现
-    public static class UnionSet{
-        private HashMap<Node,Node> fatherMap;
-        private HashMap<Node,Integer>rankMap;
-        public UnionSet(){
-            this.fatherMap=new HashMap<>();
-            this.rankMap=new HashMap<>();
-        }
-        public void makeSet(Collection<Node> nodes)
-        {
-            fatherMap.clear();
-            rankMap.clear();
-            for(Node node:nodes)
-            {
-                fatherMap.put(node,node);
-                rankMap.put(node,1);
-            }
-        }
-
-        public Node findFather(Node node)
-        {
-            Node father=fatherMap.get(node);
-            if(node!=father)
-            {
-                father=findFather(father);
-            }
-            fatherMap.put(node,father);
-            return father;
-        }
-        public boolean isSameSet(Node node1,Node node2){
-            return findFather(node1)==findFather(node2);
-        }
-        public void unionSet(Node node1,Node node2)
-        {
-            if(node1==null || node2==null)
-                return;
-            Node father1=findFather(node1);
-            Node father2 = findFather(node2);
-            if(father1==father2)
-                return;
-            Integer n1=rankMap.get(node1);
-            Integer n2=rankMap.get(node2);
-            if(n1<=n2){
-                fatherMap.put(node1,father2);
-                rankMap.put(father2,n1+n2);
-            }else {
-                 fatherMap.put(node2,father1);
-                 rankMap.put(father1,n1+n2);
-            }
-        }
-    }
-
-    public static class EdgeComparator implements Comparator<Edge>{
-
-        @Override
-        public int compare(Edge o1, Edge o2) {
-            return o1.getWeight()-o2.getWeight();
-        }
-    }
-
-    public static Set<Edge> kruskalMST(Graph graph)
-    {
-        UnionSet unionSet=new UnionSet();
-        unionSet.makeSet(graph.nodes.values());
-        PriorityQueue<Edge> queue=new PriorityQueue<>(new EdgeComparator());
-        for(Edge edge:graph.edges)
-        {
-            queue.add(edge);
-        }
-        HashSet<Edge> result=new HashSet<>();
-        while(!queue.isEmpty())
-        {
-            Edge edge=queue.poll();
-            if(!unionSet.isSameSet(edge.getFrom(),edge.getTo()))//当边的两个结点不属于同一个集合时，引出这条边
-                                                                // 并且因为边的引入，使得这两个点所在的集合成为了同一个集合，因此将他们合并
-            {
-                result.add(edge);
-                unionSet.unionSet(edge.getFrom(),edge.getTo());
-            }
-        }
-        return result;
-    }
-}
Index: src/韩顺平算法与数据结构/algorithm/Kruskal/KruskalCase.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/algorithm/Kruskal/KruskalCase.java b/src/韩顺平算法与数据结构/algorithm/Kruskal/KruskalCase.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/algorithm/Kruskal/KruskalCase.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,193 +0,0 @@
-package 韩顺平算法与数据结构.algorithm.Kruskal;
-import java.util.Arrays;
-
-public class KruskalCase {
-
-    private int edgeNum; //边的个数
-    private char[] vertexs; //顶点数组
-    private int[][] matrix; //邻接矩阵
-    //使用 INF 表示两个顶点不能连通
-    private static final int INF = Integer.MAX_VALUE;
-
-    public static void main(String[] args) {
-        char[] vertexs = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
-        //克鲁斯卡尔算法的邻接矩阵
-        int matrix[][] = {
-                /*A*//*B*//*C*//*D*//*E*//*F*//*G*/
-                /*A*/ {   0,  12, INF, INF, INF,  16,  14},
-                /*B*/ {  12,   0,  10, INF, INF,   7, INF},
-                /*C*/ { INF,  10,   0,   3,   5,   6, INF},
-                /*D*/ { INF, INF,   3,   0,   4, INF, INF},
-                /*E*/ { INF, INF,   5,   4,   0,   2,   8},
-                /*F*/ {  16,   7,   6, INF,   2,   0,   9},
-                /*G*/ {  14, INF, INF, INF,   8,   9,   0}};
-        //大家可以在去测试其它的邻接矩阵，结果都可以得到最小生成树.
-
-        //创建KruskalCase 对象实例
-        KruskalCase kruskalCase = new KruskalCase(vertexs, matrix);
-        //输出构建的
-        kruskalCase.print();
-        kruskalCase.kruskal();
-
-    }
-
-    //构造器
-    public KruskalCase(char[] vertexs, int[][] matrix) {
-        //初始化顶点数和边的个数
-        int vlen = vertexs.length;
-
-        //初始化顶点, 复制拷贝的方式
-        this.vertexs = new char[vlen];
-        for(int i = 0; i < vertexs.length; i++) {
-            this.vertexs[i] = vertexs[i];
-        }
-
-        //初始化边, 使用的是复制拷贝的方式
-        this.matrix = new int[vlen][vlen];
-        for(int i = 0; i < vlen; i++) {
-            for(int j= 0; j < vlen; j++) {
-                this.matrix[i][j] = matrix[i][j];
-            }
-        }
-        //统计边的条数
-        for(int i =0; i < vlen; i++) {
-            for(int j = i+1; j < vlen; j++) {
-                if(this.matrix[i][j] != INF) {
-                    edgeNum++;
-                }
-            }
-        }
-
-    }
-    public void kruskal() {
-        int index = 0; //表示最后结果数组的索引
-        int[] ends = new int[edgeNum]; //用于保存"已有最小生成树" 中的每个顶点在最小生成树中的终点
-        //创建结果数组, 保存最后的最小生成树
-        EData[] rets = new EData[edgeNum];
-
-        //获取图中 所有的边的集合 ， 一共有12边
-        EData[] edges = getEdges();
-        System.out.println("图的边的集合=" + Arrays.toString(edges) + " 共"+ edges.length); //12
-
-        //按照边的权值大小进行排序(从小到大)
-        sortEdges(edges);
-
-        //遍历edges 数组，将边添加到最小生成树中时，判断是准备加入的边否形成了回路，如果没有，就加入 rets, 否则不能加入
-        for(int i=0; i < edgeNum; i++) {
-            //获取到第i条边的第一个顶点(起点)
-            int p1 = getPosition(edges[i].start); //p1=4
-            //获取到第i条边的第2个顶点
-            int p2 = getPosition(edges[i].end); //p2 = 5
-
-            //获取p1这个顶点在已有最小生成树中的终点
-            int m = getEnd(ends, p1); //m = 4
-            //获取p2这个顶点在已有最小生成树中的终点
-            int n = getEnd(ends, p2); // n = 5
-            //是否构成回路
-            if(m != n) { //没有构成回路
-                ends[m] = n; // 设置m 在"已有最小生成树"中的终点 <E,F> [0,0,0,0,5,0,0,0,0,0,0,0]，相当于查并集的合并过程
-                rets[index++] = edges[i]; //有一条边加入到rets数组
-            }
-        }
-        //<E,F> <C,D> <D,E> <B,F> <E,G> <A,B>。
-        //统计并打印 "最小生成树", 输出  rets
-        System.out.println("最小生成树为");
-        for(int i = 0; i < index; i++) {
-            System.out.println(rets[i]);
-        }
-
-
-    }
-
-    //打印邻接矩阵
-    public void print() {
-        System.out.println("邻接矩阵为: \n");
-        for(int i = 0; i < vertexs.length; i++) {
-            for(int j=0; j < vertexs.length; j++) {
-                System.out.printf("%12d", matrix[i][j]);
-            }
-            System.out.println();//换行
-        }
-    }
-
-    /**
-     * 功能：对边进行排序处理, 冒泡排序
-     * @param edges 边的集合
-     */
-    private void sortEdges(EData[] edges) {
-        for(int i = 0; i < edges.length - 1; i++) {
-            for(int j = 0; j < edges.length - 1 - i; j++) {
-                if(edges[j].weight > edges[j+1].weight) {//交换
-                    EData tmp = edges[j];
-                    edges[j] = edges[j+1];
-                    edges[j+1] = tmp;
-                }
-            }
-        }
-    }
-    /**
-     *
-     * @param ch 顶点的值，比如'A','B'
-     * @return 返回ch顶点对应的下标，如果找不到，返回-1
-     */
-    private int getPosition(char ch) {
-        for(int i = 0; i < vertexs.length; i++) {
-            if(vertexs[i] == ch) {//找到
-                return i;
-            }
-        }
-        //找不到,返回-1
-        return -1;
-    }
-    /**
-     * 功能: 获取图中边，放到EData[] 数组中，后面我们需要遍历该数组
-     * 是通过matrix 邻接矩阵来获取
-     * EData[] 形式 [['A','B', 12], ['B','F',7], .....]
-     * @return
-     */
-    private EData[] getEdges() {
-        int index = 0;
-        EData[] edges = new EData[edgeNum];
-        for(int i = 0; i < vertexs.length; i++) {
-            for(int j=i+1; j <vertexs.length; j++) {
-                if(matrix[i][j] != INF) {
-                    edges[index++] = new EData(vertexs[i], vertexs[j], matrix[i][j]);
-                }
-            }
-        }
-        return edges;
-    }
-    /**
-     * 功能: 获取下标为i的顶点的终点(), 用于后面判断两个顶点的终点是否相同
-     * @param ends ： 数组就是记录了各个顶点对应的终点是哪个,ends 数组是在遍历过程中，逐步形成
-     * @param i : 表示传入的顶点对应的下标
-     * @return 返回的就是 下标为i的这个顶点对应的终点的下标, 一会回头还有来理解
-     */
-    private int getEnd(int[] ends, int i) { // i = 4 [0,0,0,0,5,0,0,0,0,0,0,0]
-        while(ends[i] != 0) {//ends[i]<==>i结点在树中的父结点，如果ends[i]==0说明该结点就是父结点，
-            i = ends[i];//相当于并查集中在树中找该结点的父结点，一直往上递归，直到找到最终的根节点
-        }
-        return i;
-    }
-
-}
-
-//创建一个类EData ，它的对象实例就表示一条边
-class EData {
-    char start; //边的一个点
-    char end; //边的另外一个点
-    int weight; //边的权值
-    //构造器
-    public EData(char start, char end, int weight) {
-        this.start = start;
-        this.end = end;
-        this.weight = weight;
-    }
-    //重写toString, 便于输出边信息
-    @Override
-    public String toString() {
-        return "EData [<" + start + ", " + end + ">= " + weight + "]";
-    }
-
-
-}
Index: src/Leetcode/子序列问题/LCS.java
===================================================================
diff --git a/src/Leetcode/子序列问题/LCS.java b/src/Leetcode/子序列问题/LCS.java
deleted file mode 100644
--- a/src/Leetcode/子序列问题/LCS.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,72 +0,0 @@
-package Leetcode.子序列问题;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:要求：给定字符串1和字符串2，要求找出两个字符串的最长公共子序列。
- * 例如，字符串1=“helloworld”，字符串2=“hwewegallgeo”,那么两者的最长公共子序列为“hello”
- * @date 2020/9/18 21:37
- */
-public class LCS {
-
-
-    public static String getLCS(String str1,String str2){
-        if(str1==null || str1.length()==0 || str2==null || str2.length()==0)
-            return "";
-        int m=str1.length(),n=str2.length();
-        int[][] dp=new int[m+1][n+1];//str1的前i个字符跟str2的前j个字符的lcs的最大长度
-        String[][] paths=new String[m+1][n+1];//用来记录最大长度从前一步到这一步的路径
-        for(int i=1;i<=m;i++){
-            for(int j=1;j<=n;j++){
-                int lefttop=dp[i-1][j-1];
-                int left=dp[i][j-1];
-                int top=dp[i-1][j];
-                if(str1.charAt(i-1)==str2.charAt(j-1)){
-                    lefttop++;
-                }
-                int maxtmp=Math.max(left,lefttop);
-                dp[i][j]=Math.max(maxtmp,top);
-                //填写标记数组
-                if(dp[i][j]==lefttop){
-                    paths[i][j]="lefttop";
-                }else if(dp[i][j]==left){
-                    paths[i][j]="left";
-                }else{
-                    paths[i][j]="top";
-                }
-            }
-        }
-
-        StringBuilder sb=new StringBuilder();
-        int maxlen=dp[m][n];//表示公共的最长公共子序列的长度
-        int i=m,j=n;
-        String indexStr="";//记录paths中的转换方式
-        char currentCh=' ';//记录当前位置的字符
-        int currentlen=0;//记录前i,j个字符的最长公共子串
-        while(i>0 && j>0){
-            currentlen=dp[i][j];
-            indexStr=paths[i][j];
-            currentCh=str1.charAt(i-1);//这里必须是str1，即：行所在的字符串
-            if(indexStr.equals("lefttop")){
-                i--;
-                j--;
-            }else if(indexStr.equals("left")){
-                j--;
-            }else{
-                i--;
-            }
-            if(currentlen>dp[i][j]){//说明添加了一个字符
-                sb.insert(0,currentCh);
-            }
-        }
-        return sb.toString();
-
-    }
-
-    public static void main(String[] args) {
-        String str1 = "cbagaewagb";
-        String str2 = "cagewageba";
-        System.out.println(getLCS(str1,str2));
-    }
-
-}
Index: src/Gof/Factory/factorymethod/pizza/LDCheesePizza.java
===================================================================
diff --git a/src/Gof/Factory/factorymethod/pizza/LDCheesePizza.java b/src/Gof/Factory/factorymethod/pizza/LDCheesePizza.java
deleted file mode 100644
--- a/src/Gof/Factory/factorymethod/pizza/LDCheesePizza.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,9 +0,0 @@
-package Gof.Factory.factorymethod.pizza;
-
-public class LDCheesePizza extends Pizza{
-    @Override
-    public void prepare() {
-        setName("伦敦的奶酪pizza");
-        System.out.println(" 伦敦的奶酪pizza 准备原材料");
-    }
-}
Index: src/Gof/Factory/factorymethod/abstractFactoryOrder/LDFactory.java
===================================================================
diff --git a/src/Gof/Factory/factorymethod/abstractFactoryOrder/LDFactory.java b/src/Gof/Factory/factorymethod/abstractFactoryOrder/LDFactory.java
deleted file mode 100644
--- a/src/Gof/Factory/factorymethod/abstractFactoryOrder/LDFactory.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,19 +0,0 @@
-package Gof.Factory.factorymethod.abstractFactoryOrder;
-
-import Gof.Factory.factorymethod.pizza.LDCheesePizza;
-import Gof.Factory.factorymethod.pizza.LDPepperPizza;
-import Gof.Factory.factorymethod.pizza.Pizza;
-
-public class LDFactory implements AbsFactory {
-    @Override
-    public Pizza createPizze(String orderType) {
-        System.out.println("~使用的是抽象工厂模式~");
-        Pizza pizza = null;
-        if (orderType.equals("cheese")) {
-            pizza = new LDCheesePizza();
-        } else if (orderType.equals("pepper")) {
-            pizza = new LDPepperPizza();
-        }
-        return pizza;
-    }
-}
Index: src/Gof/Factory/factorymethod/order/LDOrderPizza.java
===================================================================
diff --git a/src/Gof/Factory/factorymethod/order/LDOrderPizza.java b/src/Gof/Factory/factorymethod/order/LDOrderPizza.java
deleted file mode 100644
--- a/src/Gof/Factory/factorymethod/order/LDOrderPizza.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,19 +0,0 @@
-package Gof.Factory.factorymethod.order;
-
-import Gof.Factory.factorymethod.pizza.LDCheesePizza;
-import Gof.Factory.factorymethod.pizza.LDPepperPizza;
-import Gof.Factory.factorymethod.pizza.Pizza;
-
-public class LDOrderPizza extends OrderPizza {
-    @Override
-    Pizza createPizza(String orderPizza) {
-        Pizza pizza = null;
-        if(orderPizza.equals("cheese")) {
-            pizza = new LDCheesePizza();
-        } else if (orderPizza.equals("pepper")) {
-            pizza = new LDPepperPizza();
-        }
-        // TODO Auto-generated method stub
-        return pizza;
-    }
-}
Index: src/Gof/Factory/factorymethod/pizza/LDPepperPizza.java
===================================================================
diff --git a/src/Gof/Factory/factorymethod/pizza/LDPepperPizza.java b/src/Gof/Factory/factorymethod/pizza/LDPepperPizza.java
deleted file mode 100644
--- a/src/Gof/Factory/factorymethod/pizza/LDPepperPizza.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,9 +0,0 @@
-package Gof.Factory.factorymethod.pizza;
-
-public class LDPepperPizza extends Pizza{
-    @Override
-    public void prepare() {
-        setName("伦敦的胡椒pizza");
-        System.out.println(" 伦敦的胡椒pizza 准备原材料");
-    }
-}
Index: src/org/sd/chainofR/Leader.java
===================================================================
diff --git a/src/org/sd/chainofR/Leader.java b/src/org/sd/chainofR/Leader.java
deleted file mode 100644
--- a/src/org/sd/chainofR/Leader.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,18 +0,0 @@
-package org.sd.chainofR;
-
-public abstract class Leader {
-    protected String name;
-    protected Leader nextLeader;
-
-    public Leader(String name) {
-        this.name = name;
-    }
-    //设置责任链上的后即对象
-    public void setNextLeader(Leader nextLeader)
-    {
-        this.nextLeader=nextLeader;
-    }
-
-    public abstract void handleRequest(LeaveRequest request);
-
-}
Index: src/org/sd/chainofR/LeaveRequest.java
===================================================================
diff --git a/src/org/sd/chainofR/LeaveRequest.java b/src/org/sd/chainofR/LeaveRequest.java
deleted file mode 100644
--- a/src/org/sd/chainofR/LeaveRequest.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,37 +0,0 @@
-package org.sd.chainofR;
-
-public class LeaveRequest {
-    private String empName;
-    private int leaveDays;
-    private String reason;
-
-    public LeaveRequest(String empName, int leaveDays, String reason) {
-        this.empName = empName;
-        this.leaveDays = leaveDays;
-        this.reason = reason;
-    }
-
-    public String getEmpName() {
-        return empName;
-    }
-
-    public void setEmpName(String empName) {
-        this.empName = empName;
-    }
-
-    public int getLeaveDays() {
-        return leaveDays;
-    }
-
-    public void setLeaveDays(int leaveDays) {
-        this.leaveDays = leaveDays;
-    }
-
-    public String getReason() {
-        return reason;
-    }
-
-    public void setReason(String reason) {
-        this.reason = reason;
-    }
-}
Index: src/codeTop/LeeCode1570.java
===================================================================
diff --git a/src/codeTop/LeeCode1570.java b/src/codeTop/LeeCode1570.java
deleted file mode 100644
--- a/src/codeTop/LeeCode1570.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,52 +0,0 @@
-package codeTop;
-
-import javafx.util.Pair;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Dot product of two sparse vectors(稀疏数组：指数组中有很多元素的值为0的数组)
- * Given two sparse vectors,compute their dot product
- * implement class SparseVector:
- * SparseVector(nums) initializes the object with vector nums
- * dotProduct(vec).compute the dot product of the two sparse vectors
- *
- */
-public class LeeCode1570 {
-
-
-    class SparseVector{
-        //auxiliary array,used to register the index and value of the sparse vector's element which is not zero
-        public List<Pair<Integer,Integer>> helpList;
-
-        //因为数组中大多数元素都是0，所以我们可以用一个辅助数组来记录非零元素的位置以及值，然后仅对这些非零元素进行dot product compute
-        public SparseVector(int[] nums){
-            this.helpList = new ArrayList<>();
-            for(int i = 0;i < nums.length;i++){
-                if(nums[i] != 0){
-                    Pair<Integer,Integer> pair = new Pair<>(i,nums[i]);
-                    helpList.add(pair);
-                }
-            }
-        }
-        int dotProduct(SparseVector vector){
-            int first = 0,second = 0;
-            int sum = 0;
-            while(first < this.helpList.size() && second < vector.helpList.size()){
-                if(this.helpList.get(first).getKey() < vector.helpList.get(second).getKey()){
-                    first++;
-                }else if(this.helpList.get(first).getKey() > vector.helpList.get(second).getKey()){
-                    second++;
-                }else{
-                    sum += this.helpList.get(first).getValue() * vector.helpList.get(second).getValue();
-                    first++;
-                    second++;
-                }
-            }
-            return sum;
-        }
-    }
-}
-
-
Index: src/LeetCodeHot100/LeetCode152.java
===================================================================
diff --git a/src/LeetCodeHot100/LeetCode152.java b/src/LeetCodeHot100/LeetCode152.java
deleted file mode 100644
--- a/src/LeetCodeHot100/LeetCode152.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,34 +0,0 @@
-package LeetCodeHot100;
-
-public class LeetCode152 {
-
-    public static int maxProduct(int[] nums) {
-        if(nums == null || nums.length == 0){
-            return 0;
-        }
-        int max = nums[0];
-        int min = nums[0];
-        int ans = max;
-        int tmpMax = max;
-        int tmpMin = min;
-        for(int i = 1;i < nums.length;i++){
-            tmpMax = max;
-            tmpMin = min;
-            if(nums[i] >= 0){
-                max = Math.max(nums[i],tmpMax * nums[i]);
-                min = Math.min(nums[i],tmpMin * nums[i]);
-            }else {
-                max = Math.max(nums[i],tmpMin * nums[i]);
-                min = Math.min(nums[i],tmpMax * nums[i]);
-            }
-            ans = Math.max(ans,max);
-        }
-        return ans;
-    }
-
-    public static void main(String[] args) {
-        int[] arr = new int[]{7,-2,-4};
-        System.out.println(maxProduct(arr));
-    }
-
-}
Index: src/codeTop/Leetcode224.java
===================================================================
diff --git a/src/codeTop/Leetcode224.java b/src/codeTop/Leetcode224.java
deleted file mode 100644
--- a/src/codeTop/Leetcode224.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,124 +0,0 @@
-package codeTop;
-
-import java.util.Stack;
-
-public class Leetcode224 {
-        public static int calculate(String s) {
-            if(s == null || s.length() == 0){
-                return 0;
-            }
-            int res = 0,idx = 0;
-            Stack<Integer> stack = new Stack<>();
-            s = s.trim();
-            int n = s.length();
-            while(idx < n){
-                char c = s.charAt(idx++);
-                if(c == ' '){
-                    continue;
-                }
-                if(Character.isDigit(c)){
-                    int tmp = c - '0';
-                    while(idx < n && Character.isDigit(s.charAt(idx))){
-                        tmp = tmp * 10 + s.charAt(idx++) - '0';
-                    }
-                    stack.push(tmp);
-                }else if(c == '+'){
-                    if(Character.isDigit(s.charAt(idx))){
-                        int tmp = s.charAt(idx++) - '0';
-                        while(idx < s.length() && Character.isDigit(s.charAt(idx))){
-                            tmp = tmp * 10 + s.charAt(idx++) - '0';
-                        }
-                        stack.push(tmp);
-                    }else {
-                        //碰到了(
-                        int[] ans = process(s,++idx);
-                        stack.push(ans[0]);
-                        idx = ans[1];
-                    }
-                }else if(c == '-'){
-                    if(Character.isDigit(s.charAt(idx))){
-                        int tmp = s.charAt(idx++) - '0';
-                        while(idx < s.length() && Character.isDigit(s.charAt(idx))){
-                            tmp = tmp * 10 + s.charAt(idx++) - '0';
-                        }
-                        stack.push(-tmp);
-                    }else {
-                        //碰到了(
-                        int[] ans = process(s,++idx);
-                        stack.push(-ans[0]);
-                        idx = ans[1];
-                    }
-                }else{
-                    int[] ans = process(s,idx);
-                    stack.push(ans[0]);
-                    idx = ans[1];
-                }
-            }
-            while(!stack.isEmpty()){
-                res += stack.pop();
-            }
-            return res;
-        }
-
-        /**
-         *碰到了(的处理
-         */
-        private static int[] process(String s,int idx){
-            int[] ans = new int[2];
-            Stack<Integer> stack = new Stack<>();
-            while(idx < s.length() && s.charAt(idx) != ')'){
-                char c = s.charAt(idx++);
-                if(c == ' '){
-                    continue;
-                }
-                if(Character.isDigit(c)){
-                    int tmp = c - '0';
-                    while(idx < s.length() && Character.isDigit(s.charAt(idx))){
-                        tmp = tmp * 10 + s.charAt(idx++) - '0';
-                    }
-                    stack.push(tmp);
-                }else if(c == '+'){
-                    if(Character.isDigit(s.charAt(idx))){
-                        int tmp = s.charAt(idx++) - '0';
-                        while(idx < s.length() && Character.isDigit(s.charAt(idx))){
-                            tmp = tmp * 10 + s.charAt(idx++) - '0';
-                        }
-                        stack.push(tmp);
-                    }else {
-                        //碰到了(
-                        int[] help = process(s,++idx);
-                        stack.push(help[0]);
-                        idx = help[1];
-                    }
-                }else if(c == '-'){
-                    if(Character.isDigit(s.charAt(idx))){
-                        int tmp = s.charAt(idx++) - '0';
-                        while(idx < s.length() && Character.isDigit(s.charAt(idx))){
-                            tmp = tmp * 10 + s.charAt(idx++) - '0';
-                        }
-                        stack.push(-tmp);
-                    }else {
-                        //碰到了(
-                        int[] help = process(s,++idx);
-                        stack.push(-help[0]);
-                        idx = help[1];
-                    }
-                }else if(c == '('){
-                    int[] help = process(s,idx);
-                    stack.push(help[0]);
-                    idx = help[1];
-                }
-            }
-
-            while(!stack.isEmpty()){
-                ans[0] += stack.pop();
-            }
-            ans[1] = ++idx;
-            return ans;
-        }
-
-    public static void main(String[] args) {
-        String s = "(1+(4+5+2)-3)+(6+8)";
-        System.out.println(calculate(s));
-    }
-}
Index: src/codeTop/hard/LeetCode305.java
===================================================================
diff --git a/src/codeTop/hard/LeetCode305.java b/src/codeTop/hard/LeetCode305.java
deleted file mode 100644
--- a/src/codeTop/hard/LeetCode305.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,134 +0,0 @@
-package codeTop.hard;
-
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-/**
- 假设你设计一个游戏，用一个 m 行 n 列的 2D 网格来存储你的游戏地图。
-
- 起始的时候，每个格子的地形都被默认标记为「水」。
- 我们可以通过使用 addLand 进行操作，将位置 (row, col) 的「水」变成「陆地」。
-
- 你将会被给定一个列表，来记录所有需要被操作的位置，然后你需要返回计算出来 每次 addLand 操作后岛屿的数量。
-
- 注意：一个岛的定义是被「水」包围的「陆地」，通过水平方向或者垂直方向上相邻的陆地连接而成。
- 你可以假设地图网格的四边均被无边无际的「水」所包围。
-
- 示例:
- 输入: m = 3, n = 3,
- positions = [[0,0], [0,1], [1,2], [2,1]]
- 输出: [1,1,2,3]
- 解析:
- 起初，二维网格 grid 被全部注入「水」。（0 代表「水」，1 代表「陆地」）
- 0 0 0
- 0 0 0
- 0 0 0
-
- 操作 #1：addLand(0, 0) 将 grid[0][0] 的水变为陆地。
- 1 0 0
- 0 0 0   Number of islands = 1
- 0 0 0
-
- 操作 #2：addLand(0, 1) 将 grid[0][1] 的水变为陆地。
- 1 1 0
- 0 0 0   岛屿的数量为 1
- 0 0 0
-
- 操作 #3：addLand(1, 2) 将 grid[1][2] 的水变为陆地。
- 1 1 0
- 0 0 1   岛屿的数量为 2
- 0 0 0
-
- 操作 #4：addLand(2, 1) 将 grid[2][1] 的水变为陆地。
- 1 1 0
- 0 0 1   岛屿的数量为 3
- 0 1 0
-
- 拓展：
- 你是否能在 O(k log mn) 的时间复杂度程度内完成每次的计算？
- （k 表示 positions 的长度）
-
- */
-public class LeetCode305 {
-
-    public static void main(String[] args) {
-        LeetCode305 leetCode305 = new LeetCode305();
-        int[] ans = leetCode305.numsIsland2(3, 3, new int[][]{{0, 0}, {0, 1}, {2, 1}, {1, 2}});
-        for(int i : ans){
-            System.out.println(i);
-        }
-
-
-    }
-
-
-    public  int[] numsIsland2(int m,int n,int[][] positions){
-        int len = positions.length;
-        int[] ans = new int[len];
-        int sum = m * n;
-        int[][] grid = new int[m][n];
-        int[][] directions = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
-        DisjionSet disjionSet = new LeetCode305().new DisjionSet(sum);
-        Set<Integer> set = new HashSet<>();//记录position中可能存在相同的元素
-        for(int i = 0;i < len;i++){
-            int pos = positions[i][0] * n + positions[i][1];
-            //先认为当前点构成的岛屿是独立的
-            ans[i] = i > 0 ? ans[i - 1] + 1 : 1;
-            //标记为岛屿
-            grid[positions[i][0]][positions[i][1]] = 1;
-            //如果已经存在过该节点
-            if(set.contains(pos)){
-                ans[i]--;
-                continue;
-            }
-            set.add(pos);
-            for(int[] direction : directions){
-                //当前节点相邻的节点
-                int row = positions[i][0] + direction[0];
-                int col = positions[i][1] + direction[1];
-                //临界点没有跑出边界范围，同时临界点是1，则合并
-                if(row >= 0 && row < m && col >= 0 && col < n && grid[row][col] == 1){
-                    if(disjionSet.isMerge(pos,row * n + col)){
-                        ans[i]--;
-                    }
-                }
-            }
-        }
-        return ans;
-    }
-
-    //定义并查集的结构
-     class DisjionSet{
-        private int[] fatherChildMap;
-
-        public DisjionSet(int n){
-            this.fatherChildMap = new int[n];
-            //初始化，第i个节点的父节点为i;
-            for(int i = 0; i < n;i++){
-                fatherChildMap[i] = i;
-            }
-        }
-
-        //找到a节点的父节点，同时直接将a挂在父节点下
-        public  int findFather(int a){
-            int father = fatherChildMap[a];
-            if(fatherChildMap[a] != a){
-               father = findFather(fatherChildMap[a]);
-            }
-            fatherChildMap[a] = father;
-            return father;
-        }
-        //节点a与节点b是否需要合并,其中节点a与节点b是临近节点
-        public boolean isMerge(int a,int b){
-            int fatherA = findFather(a);
-            int fatherB = findFather(b);
-            if(fatherB != fatherA){
-                fatherChildMap[fatherA] = fatherB;
-                return true;
-            }
-            return false;
-        }
-    }
-
-}
Index: src/codeTop/leetCode311.java
===================================================================
diff --git a/src/codeTop/leetCode311.java b/src/codeTop/leetCode311.java
deleted file mode 100644
--- a/src/codeTop/leetCode311.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,46 +0,0 @@
-package codeTop;
-
-/**
- * 给你两个 稀疏矩阵 A 和 B，请你返回 AB 的结果。
- * 你可以默认 A 的列数等于 B 的行数。
- *
- * 请仔细阅读下面的示例。
- *
- * 复制代码
- * 示例：
- * 输入：
- * A = [
- *   [ 1, 0, 0],
- *   [-1, 0, 3]
- * ]
- * B = [
- *   [ 7, 0, 0 ],
- *   [ 0, 0, 0 ],
- *   [ 0, 0, 1 ]
- * ]
- * 输出：
- *      |  1 0 0 |   | 7 0 0 |   |  7 0 0 |
- * AB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |
- *                   | 0 0 1 |
- * 复制代码
- */
-public class leetCode311 {
-
-    public static int[][] multiply(int[][] A,int[][] B){
-        int m = A.length;
-        int n = A[0].length;
-        int p = B[0].length;
-        int[][] ans = new int[m][p];
-        for(int i = 0;i < m;i++){
-            for(int j = 0;j < n;j++){
-                if(A[i][j] == 0){
-                    continue;
-                }
-                for(int h = 0; h < p;h++){
-                    ans[i][h] += A[i][j] * B[j][h]; // 只要A的纵坐标跟B的横坐标相等即可
-                }
-            }
-        }
-        return  ans;
-    }
-}
Index: src/codeTop/LeetCode487.java
===================================================================
diff --git a/src/codeTop/LeetCode487.java b/src/codeTop/LeetCode487.java
deleted file mode 100644
--- a/src/codeTop/LeetCode487.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,40 +0,0 @@
-package codeTop;
-
-/**
- * 给定一个二进制数组，你可以最多将 1 个 0 翻转为 1，找出其中最大连续 1 的个数。
- * 示例 1：
- * 输入：[1,0,1,1,0]
- * 输出：4
- * 解释：翻转第一个 0 可以得到最长的连续 1。
- *      当翻转以后，最大连续 1 的个数为 4。
- *
- * 注：
- * 输入数组只包含 0 和 1.
- * 输入数组的长度为正整数，且不超过 10,000
- */
-public class LeetCode487 {
-
-    public  static int findMaxConsecutiveOnes(int[] nums) {
-        int n = nums.length;
-        int left = 0,right = 0;
-        int count = 0,ans = 0;
-        while(right < n){
-            if(nums[right++] == 1){
-                count++;
-            }
-            if(right - left <= count + 1){
-                ans = Math.max(ans,right - left);
-            }else{
-                if(nums[left] == 1){
-                    --count;
-                }
-                left++;
-            }
-        }
-        return ans;
-    }
-
-    public static void main(String[] args) {
-        System.out.println(findMaxConsecutiveOnes(new int[]{1,0,1,1,0}));
-    }
-}
Index: src/LeetCodeHot100/LeetCode666.java
===================================================================
diff --git a/src/LeetCodeHot100/LeetCode666.java b/src/LeetCodeHot100/LeetCode666.java
deleted file mode 100644
--- a/src/LeetCodeHot100/LeetCode666.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,43 +0,0 @@
-package LeetCodeHot100;
-
-import java.util.HashMap;
-
-/**
- * leetCode 666 路径总和IV
- */
-public class LeetCode666 {
-    HashMap<Integer,Integer> map = new HashMap<>();
-    int ans = 0;
-    public int pathSum(int[] arr) {
-        if(arr == null || arr.length == 0) {
-            return 0;
-        }
-        for(int num : arr) {
-            map.put(num / 10,num % 10);
-        }
-        process(arr[0] / 10,0);
-        return ans;
-    }
-    private void process(int node ,int sum) {
-        if(!map.containsKey(node)){
-            return;
-        }
-        sum += map.get(node);
-        int level = node / 10; // 当前节点的深度
-        int pos = level % 10; // 当前节点在该层的编号
-        int nextlevel = level + 1;
-        int leftNode = nextlevel * 10 + 2 * pos - 1; // 左子节点的编号
-        int rightNode = nextlevel * 10 + 2 * pos + 1; // 右子节点的编号
-        if(!map.containsKey(leftNode) && !map.containsKey(rightNode)) {
-            ans += sum;
-        } else {
-            process(leftNode,sum);
-            process(rightNode,sum);
-        }
-    }
-
-    public static void main(String[] args) {
-        int[] arr = new int[] {113,215,221};
-        System.out.println(new LeetCode666().pathSum(arr));
-    }
-}
Index: src/codeTop/LeetCode880.java
===================================================================
diff --git a/src/codeTop/LeetCode880.java b/src/codeTop/LeetCode880.java
deleted file mode 100644
--- a/src/codeTop/LeetCode880.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,7 +0,0 @@
-package codeTop;
-
-public class LeetCode880 {
-
-
-
-}
Index: src/codeTop/LeetCode1060.java
===================================================================
diff --git a/src/codeTop/LeetCode1060.java b/src/codeTop/LeetCode1060.java
deleted file mode 100644
--- a/src/codeTop/LeetCode1060.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,42 +0,0 @@
-package codeTop;
-
-/**
- * 现有一个按 升序 排列的整数数组 nums ，其中每个数字都 互不相同 。
- *
- * 给你一个整数 k ，请你找出并返回从数组最左边开始的第 k 个缺失数字。
- * 例如：A[4,7,9,10],K = 1  ===> ans = 5
- */
-public class LeetCode1060 {
-
-    public  static int missingElement(int[] arr,int k){
-        int n = arr.length;
-        if(k > process(n - 1,arr)){
-            return arr[n - 1] + k - process(n - 1,arr);
-        }
-        int left = 0,right = n - 1;
-        while(left < right){
-            int mid = left + (right - left) / 2;
-            if(process(mid,arr) < k){
-                left = mid + 1;
-            }else {
-                //此时process(mid,arr) >= k,继续循环，则最终while结束的时候返回的是距离arr[0]丢失k个元素的最左边的元素
-                right = mid;
-            }
-        }
-        return arr[left - 1] + k - process(left - 1,arr);
-    }
-
-    /**
-     * 表示nums数组的第idx位到第0位丢失了几个数字
-     * @param idx
-     * @param nums
-     * @return
-     */
-    private static int process(int idx,int[] nums){
-        return nums[idx] - nums[0] - idx;
-    }
-
-    public static void main(String[] args) {
-        System.out.println(missingElement(new int[]{4,7,8,10},2));
-    }
-}
Index: src/codeTop/LeetCode1214.java
===================================================================
diff --git a/src/codeTop/LeetCode1214.java b/src/codeTop/LeetCode1214.java
deleted file mode 100644
--- a/src/codeTop/LeetCode1214.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,78 +0,0 @@
-package codeTop;
-
-import java.util.HashSet;
-
-/**
- * Given the roots of two binary tree,root1 and root2,return true if and only if there is a node in the first tree
- * and a node in the second tree whose value sum up to a given integer target
- */
-public class LeetCode1214 {
-
-    HashSet<Integer> set = new HashSet<>();
-
-    /**
-     * 时间负责度：O(N),空间复杂度：O(n)
-     * @param root1
-     * @param root2
-     * @param target
-     * @return
-     */
-    public boolean twoSumBSTS(TreeNode root1,TreeNode root2,Integer target){
-        if(root1 == null || root2 == null){
-            return false;
-        }
-        dfs(root1);
-        return process(root2,target);
-    }
-
-    //将TreeNode root的所有节点都放到set中
-    private void dfs(TreeNode root){
-        if(root != null){
-            set.add(root.value);
-            dfs(root.left);
-            dfs(root.right);
-        }
-    }
-    private boolean process(TreeNode root,Integer target){
-        if(root == null){
-            return false;
-        }
-        int diff = target - root.value;
-        if(set.contains(diff)){
-            return true;
-        }
-        return process(root.left,target) || process(root.right,target);
-    }
-    /**
-     * 方法二：O(nlogn),固定其中一个bst,二分查找另一个。
-     *
-     */
-    public boolean twoSumBSTS2(TreeNode root1,TreeNode root2,Integer target){
-        if(root1 == null) return false;
-        if(find(root2,target - root1.value)) return true;
-        return twoSumBSTS2(root1.left,root2,target) || twoSumBSTS2(root1.right,root2,target);
-    }
-
-    private boolean find(TreeNode root,Integer target){
-        if(root == null){
-            return false;
-        }
-        if(root.value == target){
-            return true;
-        }else if(root.value > target){
-            return find(root.left,target);
-        }else {
-            return find(root.right,target);
-        }
-    }
-}
-
-class TreeNode{
-    public Integer value;
-    public TreeNode left;
-    public TreeNode right;
-
-    public TreeNode(Integer value){
-        this.value = value;
-    }
-}
Index: src/codeTop/LeetCode1245.java
===================================================================
diff --git a/src/codeTop/LeetCode1245.java b/src/codeTop/LeetCode1245.java
deleted file mode 100644
--- a/src/codeTop/LeetCode1245.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,123 +0,0 @@
-package codeTop;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Given an undirected tree, return its diameter: the number of edges in a longest path in that tree.
- * <p>
- * The tree is given as an array of edges where edges[i] = [u, v] is a bidirectional edge between nodes u and v.
- * Each node has labels in the set {0, 1, ..., edges.length}.
- * <p>
- * Example 1:
- * <p>
- * <p>
- * <p>
- * Input: edges = [[0,1],[0,2]]
- * Output: 2
- * Explanation:
- * A longest path of the tree is the path 1 - 0 - 2.
- * Example 2:
- * <p>
- * <p>
- * <p>
- * Input: edges =
- * Output: 4
- * Explanation:[[0,1],[1,2],[2,3],[1,4],[4,5]]
- * A longest path of the tree is the path 3 - 2 - 1 - 4 - 5.
- * Constraints:
- * <p>
- * 0 <= edges.length < 10^4
- * edges[i][0] != edges[i][1]
- * 0 <= edges[i][j] <= edges.length
- * The given edges form an undirected tree.
- * 题解：
- * <p>
- * If it is a tree, then its nodes n = edges.length + 1.
- * <p>
- * Build the tree graph first. Then start DFS from node 0.
- * <p>
- * DFS returns the deepest depth. DFS state needs current node, tree graph, and parent.
- * <p>
- * For current node, for all its neighbors, as long as it is not parent, get the depth from it, pick 2 largest.
- * <p>
- * Use these 2 largest to update the diameter.
- * <p>
- * And returns the largest depth + 1.
- * <p>
- * Time Complexity: O(n). n = edges.length.
- * <p>
- * Space: O(n).
- */
-public class LeetCode1245 {
-
-    /**
-     * 1、遍历 edges 数组，把它转为邻接链表(或者邻接集合)表示的图。(因为这是一个无向图，所以需要分别以数组的两个值为开始节点进行存储)
-     *
-     * 2、定义一个全局变量 ans 表示最终返回的最长路径的边数；
-     *
-     * 3、遍历图，对每一个结点进行 DFS；
-     *
-     * DFS的实现：
-     *
-     * 1、遍历当前结点的所有子结点进行 DFS，找出长度最长的两个路径 max1 和 max2；
-     *
-     * 2、更新 ans = Math.max(ans, max1 + max2)，其中 max1 + max2 就好像是以当前点为圆心，加上两个半径，得到直径；
-     *
-     * 3、DFS 返回的是 Math.max(max1, max2)；
-     * @param edges
-     * @return
-     */
-    public static int ans = 0;
-    public static int treeDiameter(int[][] edges) {
-
-        int n = edges.length;
-        List<Integer> [] treeList = new List[n + 1];
-        for(int i = 0;i <= n;i++){
-            treeList[i] = new ArrayList<>();
-        }
-        //将数组表示的图转换成邻接矩阵表示的图
-        for(int[] arr :edges){
-            treeList[arr[0]].add(arr[1]);
-            treeList[arr[1]].add(arr[0]);
-        }
-        boolean[] visited = new boolean[n + 1];
-        process(treeList,0,visited);
-        return ans;
-    }
-
-    /**
-     * 返回以index为起点的经过的最大节点数量
-     * @param treeList
-     * @param index
-     * @param visited
-     * @return
-     */
-    private static int process(List<Integer>[] treeList,int index,boolean[] visited){
-        visited[index] = true;
-        List<Integer> list = treeList[index];
-        //相当于以index节点为圆心的的两个最大半径
-        int max1 = 0;
-        int max2 = 0;
-        for(int newIndex : list){
-            if(visited[newIndex]){
-                continue;
-            }
-            //返回以newIndex为起点可以经过的最大节点数量，即因为newIndex与index相连因此也等于以index为圆心的最大边长
-            int tmp = process(treeList,newIndex,visited);
-            if(tmp > max1){
-                max2 = max1;
-                max1 = tmp;
-            }else if(tmp > max2) {
-                max2 = tmp;
-            }
-        }
-        ans = Math.max(ans,max1 + max2);
-        return Math.max(max1,max2) + 1;
-    }
-
-    public static void main(String[] args) {
-        int[][] edges = new int[][] {{0,1},{1,2},{2,3},{1,4},{4,5}};
-        System.out.println(treeDiameter(edges));
-    }
-}
Index: src/codeTop/LeetCode1574.java
===================================================================
diff --git a/src/codeTop/LeetCode1574.java b/src/codeTop/LeetCode1574.java
deleted file mode 100644
--- a/src/codeTop/LeetCode1574.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,44 +0,0 @@
-package codeTop;
-
-public class LeetCode1574 {
-
-    public static int findLengthOfShortestSubarray(int[] arr) {
-        int len = arr.length;
-        int left = 0, right = len-1;
-        while(left < len - 1 && arr[left] <= arr[left + 1]){
-            left++;
-        }
-        while(right > 0 && arr[right] >= arr[right - 1]){
-            right--;
-        }
-        if(right <= left){
-            return 0;
-        }
-        //保留左边有序的或者右边有序的
-        int ans = Math.min(right,len - left - 1);
-        int l = right,r = len - 1;
-        for(int i = 0;i <= left;i++){
-            int target = arr[i];
-            r = len - 1;
-            l = Math.max(l,right);
-            //l - r范围内寻找第一个大于等于target的值得坐标，这样的值不一定存在
-            while(l < r){
-                int mid = l + (r - l) / 2;
-                if(arr[mid] < target){
-                    l = mid + 1;
-                }else{
-                    r = mid;
-                }
-            }
-            if(arr[l] >= target){
-                ans = Math.min(ans,r - i -1);
-            }
-        }
-        return ans;
-    }
-
-    public static void main(String[] args) {
-        int[] arr = new int[]{10,1,2,3,4,10,2};
-        System.out.println(findLengthOfShortestSubarray(arr));
-    }
-}
Index: src/左神算法/基础班/第四课/LessMoney.java
===================================================================
diff --git a/src/左神算法/基础班/第四课/LessMoney.java b/src/左神算法/基础班/第四课/LessMoney.java
deleted file mode 100644
--- a/src/左神算法/基础班/第四课/LessMoney.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,87 +0,0 @@
-package 左神算法.基础班.第四课;
-
-import java.util.Comparator;
-import java.util.PriorityQueue;
-
-/**
- * 地主打算切开一根金条，按照长工的工作量每人分一部分。只有金匠才能切开金条，每切一次，金匠要收金条长度个金币，比如长度为15的金条切开一次要收15个铜币
- * 地主希望找到一种切开的方法，使得完成切分后能给金匠最少的金币
- */
-public class LessMoney {
-
-    public static int lessMoney(int[] arr)
-    {
-        PriorityQueue<Integer> queue=new PriorityQueue<>();
-        for(int i=0;i<arr.length;i++)
-        {
-            queue.add(arr[i]);
-        }
-        int sum=0;
-        int cur=0;
-        while(queue.size()>1)
-        {
-            cur=queue.poll()+queue.poll();
-            sum+=cur;
-            queue.add(cur);
-        }
-        return sum;
-
-    }
-
-
-
-    public static class MinheapComparator implements Comparator<Integer> {
-
-        @Override
-        public int compare(Integer o1, Integer o2) {
-            return o1 - o2;
-        }
-
-    }
-
-    public static class MaxheapComparator implements Comparator<Integer> {
-
-        @Override
-        public int compare(Integer o1, Integer o2) {
-            return o2 - o1;
-        }
-
-    }
-    public static void main(String[] args) {
-        // solution
-        int[] arr = { 6, 7, 8, 9 };
-        System.out.println(lessMoney(arr));
-
-        int[] arrForHeap = { 3, 5, 2, 7, 0, 1, 6, 4 };
-
-        // min heap
-        PriorityQueue<Integer> minQ1 = new PriorityQueue<>();
-        for (int i = 0; i < arrForHeap.length; i++) {
-            minQ1.add(arrForHeap[i]);
-        }
-        while (!minQ1.isEmpty()) {
-            System.out.print(minQ1.poll() + " ");
-        }
-        System.out.println();
-
-        // min heap use Comparator
-        PriorityQueue<Integer> minQ2 = new PriorityQueue<>(new MinheapComparator());
-        for (int i = 0; i < arrForHeap.length; i++) {
-            minQ2.add(arrForHeap[i]);
-        }
-        while (!minQ2.isEmpty()) {
-            System.out.print(minQ2.poll() + " ");
-        }
-        System.out.println();
-
-        // max heap use Comparator
-        PriorityQueue<Integer> maxQ = new PriorityQueue<>(new MaxheapComparator());
-        for (int i = 0; i < arrForHeap.length; i++) {
-            maxQ.add(arrForHeap[i]);
-        }
-        while (!maxQ.isEmpty()) {
-            System.out.print(maxQ.poll() + " ");
-        }
-
-    }
-}
Index: src/左神算法/进阶班一/结构设计/LFU.java
===================================================================
diff --git a/src/左神算法/进阶班一/结构设计/LFU.java b/src/左神算法/进阶班一/结构设计/LFU.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/结构设计/LFU.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,202 +0,0 @@
-package 左神算法.进阶班一.结构设计;
-
-import java.util.HashMap;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: LFU算分的get,set操作实现，并且时间复杂度为O（1）
- * @date 2020/1/8 12:28
- */
-public class LFU {
-
-    public static class Node{
-        public Integer key;
-        public Integer value;
-        public Integer times;
-        public Node up;//利用up属性与down属性从而可以构建一个双端队列
-        public Node down;
-
-        public Node(int key, int value, int times) {
-            this.key = key;
-            this.value = value;
-            this.times = times;
-        }
-    }
-
-
-    public static class LFUCache{
-
-        //又一个双端队列，其中的每个元素又是一个双端对列，即上文中的Node
-        public static class NodeList{
-            public Node head;
-            public Node tail;//head与tail的times是相同的
-            public NodeList last;
-            public NodeList next;
-
-            public NodeList(Node node){
-                this.head=node;
-                this.tail=node;
-            }
-
-            //没对一个元素操作，将他对应的结点放在最前面
-            public void addNodeFromHead(Node newNode){
-                newNode.down=head;
-                head.up=newNode;
-                head=newNode;
-            }
-
-            public boolean isEmpty(){
-                return head==null;
-            }
-            public void deleteNode(Node node){
-                if(head==tail){
-                    head=null;
-                    tail=null;
-                }else{
-                    if(head==node){
-                        head=node.down;
-                        head.up=null;
-                    }else if(tail==node){
-                        tail=node.up;
-                        tail.down=null;
-                    }else{
-                        node.up.down=node.down;
-                        node.down.up=node.up;
-                    }
-                }
-                //与原链表断开
-                node.up=null;
-                node.down=null;
-            }
-        }
-
-        private int capacity;
-        private int size;
-        private HashMap<Integer,Node> records;
-        private HashMap<Node,NodeList> heads;
-        private NodeList headList;
-
-        public LFUCache(int capacity) {
-            this.capacity = capacity;
-            this.size=0;
-            this.records=new HashMap<>();
-            this.heads=new HashMap<>();
-            headList=null;
-        }
-
-
-        public void set(int key,int value){
-            if(records.containsKey(key)){
-                Node node = records.get(key);
-                node.times++;
-                node.value=value;
-                NodeList curList = heads.get(node);
-                move(node,curList);
-
-            }else{
-                if(size==capacity){
-                    Node node=headList.tail;
-                    headList.deleteNode(node);
-                    modifyHeadList(headList);
-                    records.remove(node.key);
-                    heads.remove(node);
-                    size--;
-                }
-                Node node=new Node(key,value,1); //该node一定位于headlist
-                if(headList==null){
-                    headList=new NodeList(node);
-                }else{
-                    if(headList.head.times.equals(node.times)){
-                        headList.addNodeFromHead(node);
-                    }else{
-                        NodeList newList=new NodeList(node);
-                        newList.next=headList;
-                        headList.last=newList;
-                        headList=newList;
-                    }
-                }
-                records.put(key,node);
-                heads.put(node,headList);
-                size++;
-            }
-        }
-
-        public void move(Node node,NodeList oldNodeList){
-            oldNodeList.deleteNode(node);//从当前nodelist删除该node
-            NodeList preList=modifyHeadList(oldNodeList) ? oldNodeList.last:oldNodeList;
-            NodeList nextList=oldNodeList.next;
-            if(nextList==null){
-                NodeList newList=new NodeList(node);
-                if(preList!=null){
-                    preList.next=nextList;
-                }
-                newList.last=preList;
-                if(headList==null){
-                    headList=newList;
-                }
-                heads.put(node,newList);
-
-            }else{
-                if(nextList.head.times.equals(node.times))
-                {
-                    nextList.addNodeFromHead(node);
-                    heads.put(node,nextList);
-                }else{
-                    NodeList newList=new NodeList(node);
-                    if(preList!=null){
-                        preList.next=nextList;
-                    }
-                    newList.last=preList;
-                    newList.next=nextList;
-                    nextList.last=newList;
-                    if(headList==nextList){
-                        headList=newList;
-                    }
-                    heads.put(node,newList);
-                }
-
-            }
-
-        }
-
-        //return whether delete this nodelist.当nodelist为空的时候，删除，否则不删。
-        private boolean modifyHeadList(NodeList nodeList){
-            if(nodeList.isEmpty()){
-                if(headList==nodeList)
-                {
-                    headList=headList.next;
-                    if(headList!=null){
-                        headList.last=null;
-                    }
-                }else{
-                    nodeList.last.next=nodeList.next;
-                    if(nodeList.next!=null){
-                        nodeList.next.last=nodeList.last;
-                    }
-                }
-                return true;
-
-            }
-            return false;
-        }
-
-        public int get(int key){
-            if(!records.containsKey(key))
-            {
-                return -1;
-            }
-            Node node = records.get(key);
-            node.times++;
-            NodeList nodeList = heads.get(node);
-            move(node,nodeList);
-            return node.value;
-
-
-        }
-
-
-
-    }
-
-}
Index: src/Gof/command/LightOffCommadn.java
===================================================================
diff --git a/src/Gof/command/LightOffCommadn.java b/src/Gof/command/LightOffCommadn.java
deleted file mode 100644
--- a/src/Gof/command/LightOffCommadn.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,20 +0,0 @@
-package Gof.command;
-
-public class LightOffCommadn implements Command {
-
-    private LightReceiver lightReceiver;
-
-    public  LightOffCommadn(LightReceiver lightReceiver) {
-        this.lightReceiver = lightReceiver;
-    }
-
-    @Override
-    public void execute() {
-        lightReceiver.off();
-    }
-
-    @Override
-    public void undo() {
-        lightReceiver.on();
-    }
-}
Index: src/Gof/command/LightOnCommand.java
===================================================================
diff --git a/src/Gof/command/LightOnCommand.java b/src/Gof/command/LightOnCommand.java
deleted file mode 100644
--- a/src/Gof/command/LightOnCommand.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,20 +0,0 @@
-package Gof.command;
-
-public class LightOnCommand implements Command{
-
-    private LightReceiver lightReceiver;
-
-    public LightOnCommand(LightReceiver lightReceiver) {
-        this.lightReceiver = lightReceiver;
-    }
-
-    @Override
-    public void execute() {
-       lightReceiver.on();
-    }
-
-    @Override
-    public void undo() {
-       lightReceiver.off();
-    }
-}
Index: src/Gof/command/LightReceiver.java
===================================================================
diff --git a/src/Gof/command/LightReceiver.java b/src/Gof/command/LightReceiver.java
deleted file mode 100644
--- a/src/Gof/command/LightReceiver.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,13 +0,0 @@
-package Gof.command;
-
-public class LightReceiver {
-
-    public void on()
-    {
-        System.out.println("电灯打开了。。。。");
-    }
-
-    public void off(){
-        System.out.println("电灯关闭了。。。");
-    }
-}
Index: src/韩顺平算法与数据结构/datastructure/list/LinkedListStackDemo.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/list/LinkedListStackDemo.java b/src/韩顺平算法与数据结构/datastructure/list/LinkedListStackDemo.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/list/LinkedListStackDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,7 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.list;
-
-public class LinkedListStackDemo {
-}
-class LinkedListStack{
-
-}
\ No newline at end of file
Index: src/左神算法/基础班/Sort/自己补充_链表排序/ListMergeSort.java
===================================================================
diff --git a/src/左神算法/基础班/Sort/自己补充_链表排序/ListMergeSort.java b/src/左神算法/基础班/Sort/自己补充_链表排序/ListMergeSort.java
deleted file mode 100644
--- a/src/左神算法/基础班/Sort/自己补充_链表排序/ListMergeSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,57 +0,0 @@
-package 左神算法.基础班.Sort.自己补充_链表排序;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:链表的归并排序 ：leetcode 148
- * @date 2020/8/6 17:56
- */
-public class ListMergeSort {
-
-     public static class ListNode {
-         int val;
-         ListNode next;
-         ListNode(int x) { val = x; }
-     }
-
-     public ListNode sortList(ListNode head){
-         if(head==null || head.next==null)
-             return head;
-         return mergeSort(head);
-     }
-
-     private static ListNode mergeSort(ListNode head){
-         if(head==null || head.next==null)
-             return head;
-         //通过快慢指针来找中点
-         ListNode slow=head,fast=head.next;//这样可以保证在偶数个结点的时候也能恰好均分，而不是造成分布不均匀
-         while(fast!=null && fast.next!=null){
-             fast=fast.next.next;
-             slow=slow.next;
-         }
-         ListNode rightStart=slow.next;
-         slow.next=null;//断开连接
-         ListNode left=mergeSort(head);
-         ListNode right=mergeSort(rightStart);
-         return merge(left,right);
-     }
-
-
-     private static ListNode merge(ListNode left,ListNode right){
-         ListNode dumpy=new ListNode(0);//哑结点
-         ListNode cur=dumpy;
-         while(left!=null && right!=null){
-             if(left.val<=right.val){
-                 cur.next=left;
-                 cur=left;
-                 left=left.next;
-             }else{
-                 cur.next=right;
-                 cur=right;
-                 right=right.next;
-             }
-         }
-         cur.next=left!=null ? left:right;
-         return dumpy.next;
-     }
-}
Index: src/左神算法/基础班/Sort/自己补充_链表排序/ListQuickSort.java
===================================================================
diff --git a/src/左神算法/基础班/Sort/自己补充_链表排序/ListQuickSort.java b/src/左神算法/基础班/Sort/自己补充_链表排序/ListQuickSort.java
deleted file mode 100644
--- a/src/左神算法/基础班/Sort/自己补充_链表排序/ListQuickSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,55 +0,0 @@
-package 左神算法.基础班.Sort.自己补充_链表排序;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:v 链表实现快排：也就是leetcode 第148题
- * @date 2020/8/6 15:23
- */
-public class ListQuickSort {
-
-    public static class Node{
-        int val;
-        Node next;
-        public Node(){}
-    }
-
-    /**
-     *
-     * 用三个指针来控制，模仿数组快排，数组中的交换结点在这里成了---》交换结点的值
-     */
-    public static Node sortList(Node head){
-        quickSort(head,null);
-        return head;
-    }
-    public static void quickSort(Node head,Node end){
-        if(head!=end){
-            Node node=partation(head,end);
-            quickSort(head,node);
-            quickSort(node.next,end);
-        }
-    }
-
-    private static Node partation(Node head,Node end){
-        Node left=head,right=head.next;//right用来遍历
-        //left左边是小于head值的结点，left-right之间是大于等于head值的点
-        while(right!=end){
-            if(right.val<head.val){//以head作为partation的base结点，当结
-                left=left.next;
-                int tmp=left.val;
-                left.val=right.val;
-                right.val=tmp;
-            }
-            right=right.next;
-        }
-        if(left!=head){
-            int tmp=left.val;
-            left.val=head.val;
-            head.val=tmp;
-        }
-        return left;//返回的是第一个等于head值的结点
-    }
-
-
-
-}
Index: src/韩顺平算法与数据结构/datastructure/stack/ListStackDemo.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/stack/ListStackDemo.java b/src/韩顺平算法与数据结构/datastructure/stack/ListStackDemo.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/stack/ListStackDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,23 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.stack;
-
-public class ListStackDemo {
-}
-class ListStack{
-    private int maxSize;
-
-}
-
-class Node{
-    public int data;
-    public Node next;
-
-    public Node(int data)
-    {
-       this.data=data;
-    }
-
-    public String toString(){
-
-        return "node.data= "+data;
-    }
-}
\ No newline at end of file
Index: src/重温设计模式/行为模式/观察者模式/示例/LogOpenListener.java
===================================================================
diff --git a/src/重温设计模式/行为模式/观察者模式/示例/LogOpenListener.java b/src/重温设计模式/行为模式/观察者模式/示例/LogOpenListener.java
deleted file mode 100644
--- a/src/重温设计模式/行为模式/观察者模式/示例/LogOpenListener.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,23 +0,0 @@
-package 重温设计模式.行为模式.观察者模式.示例;
-
-import java.io.File;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/8 16:41
- */
-public class LogOpenListener implements EventListener{
-    private File log;
-
-    public LogOpenListener(String fileName) {
-        this.log = new File(fileName);
-    }
-
-    @Override
-    public void update(String eventType, File file) {
-        System.out.println("Save to log " + log + ": Someone has performed " +
-                eventType + " operation with the following file: " + file.getName());
-    }
-}
Index: src/org/sd/Zxing/LogUtil.java
===================================================================
diff --git a/src/org/sd/Zxing/LogUtil.java b/src/org/sd/Zxing/LogUtil.java
deleted file mode 100644
--- a/src/org/sd/Zxing/LogUtil.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,54 +0,0 @@
-package org.sd.Zxing;
-
-import com.google.zxing.BarcodeFormat;
-import com.google.zxing.EncodeHintType;
-import com.google.zxing.MultiFormatWriter;
-import com.google.zxing.WriterException;
-import com.google.zxing.common.BitMatrix;
-import com.google.zxing.pdf417.decoder.ec.ErrorCorrection;
-import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;
-
-import javax.imageio.ImageIO;
-import java.awt.*;
-import java.awt.geom.RoundRectangle2D;
-import java.awt.image.BufferedImage;
-import java.awt.image.renderable.RenderableImage;
-import java.io.File;
-import java.io.IOException;
-import java.util.Hashtable;
-
-public class LogUtil {
-
-    public static BufferedImage logoMatrix(BufferedImage bufferedImage,String logo) throws IOException {
-        //在二维码上产生一个画板
-        Graphics2D g2 = bufferedImage.createGraphics();
-        //画logo：string--》bufferedImage
-        BufferedImage logoImage=ImageIO.read(new File(logo));
-        int height = bufferedImage.getHeight();
-        int width = bufferedImage.getWidth();
-        //
-        g2.drawImage(logoImage,width/5*2,height/5*2,width/5,height/5,null);
-        //产生一个画白色圆角正方形的画笔
-        BasicStroke stroke=new BasicStroke(5,BasicStroke.CAP_ROUND,BasicStroke.JOIN_ROUND);
-        //将画板与画笔绑定
-        g2.setStroke(stroke);
-        //创建一个正方形
-        RoundRectangle2D.Float round=new RoundRectangle2D.Float(width/5*2,height*2/5,width/5,height/5,BasicStroke.CAP_ROUND,BasicStroke.JOIN_ROUND);
-        g2.setColor(Color.WHITE);
-        g2.draw(round);
-
-        //灰色边框
-        BasicStroke stroke2=new BasicStroke(1,BasicStroke.CAP_ROUND,BasicStroke.JOIN_ROUND);
-        g2.setStroke(stroke2);
-        RoundRectangle2D.Float round2 = new RoundRectangle2D.Float(width*2/5+2,height* 2/5+2,    width*1/5-4,height* 1/5 -4, BasicStroke.CAP_ROUND ,BasicStroke.JOIN_ROUND);
-//		Color color = new Color(128,128,128) ;
-        g2.setColor(Color.GRAY);
-        g2.draw(round2);
-
-        g2.dispose();
-        bufferedImage.flush();
-        return bufferedImage;
-
-    }
-
-}
Index: src/Gof/decorator/LongBlack.java
===================================================================
diff --git a/src/Gof/decorator/LongBlack.java b/src/Gof/decorator/LongBlack.java
deleted file mode 100644
--- a/src/Gof/decorator/LongBlack.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,10 +0,0 @@
-package Gof.decorator;
-
-public class LongBlack extends Coffee {
-
-    public LongBlack()
-    {
-        setDes("longBlack");
-        setPrice(0.5f);
-    }
-}
Index: src/Leetcode/LongestCommonSubString/LongestCommonSubstring.java
===================================================================
diff --git a/src/Leetcode/LongestCommonSubString/LongestCommonSubstring.java b/src/Leetcode/LongestCommonSubString/LongestCommonSubstring.java
deleted file mode 100644
--- a/src/Leetcode/LongestCommonSubString/LongestCommonSubstring.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,44 +0,0 @@
-package Leetcode.LongestCommonSubString;
-
-public class LongestCommonSubstring {
-    public static void main(String[] args) {
-       String s="fgvb";
-       String t="vb";
-        String s1 = longestCommonSubstring(s, t);
-        System.out.println(s1);
-
-    }
-
-    public static String longestCommonSubstring(String s,String t)
-    {
-        int m=s.length();
-        int n=t.length();
-        int[][]arr=new int[m][n];
-        int len=0;
-        int maxEnd=0;
-        for(int i=0;i<m;i++)
-        {
-            for(int j=0;j<n;j++)
-            {
-                if(s.charAt(i)==t.charAt(j))
-                {
-                    if(i==0||j==0)
-                    {
-                        arr[i][j]=1;
-                    }
-                    else {
-                        arr[i][j]=arr[i-1][j-1]+1;//记录了公共子串的长度
-                    }
-                }
-
-                if(arr[i][j]>len)
-                {
-                    len=arr[i][j];
-                    maxEnd=i;//以i位置结尾的字符
-                }
-            }
-        }
-        return s.substring(maxEnd-len+1,maxEnd+1);
-
-    }
-}
Index: src/左神算法/高频面试题/八数组子序列问题/LongestIncrSubqueue.java
===================================================================
diff --git a/src/左神算法/高频面试题/八数组子序列问题/LongestIncrSubqueue.java b/src/左神算法/高频面试题/八数组子序列问题/LongestIncrSubqueue.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/八数组子序列问题/LongestIncrSubqueue.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,93 +0,0 @@
-package 左神算法.高频面试题.八数组子序列问题;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 求一个数组中的最长递增子序列
- * @date 2020/1/15 15:01
- */
-public class LongestIncrSubqueue {
-
-    //O(n^2)
-    public static int getLongestIncrSubqueue1(int[] arr){
-          if(arr==null || arr.length==0)
-              return 0;
-          int[]help=new int[arr.length];//help记录的是以每个元素结尾的最长递增子序列的长度
-          help[0]=1;
-          int temp=1;
-          for(int i=1;i<arr.length;i++){
-
-              if(arr[i]==arr[i-1])
-              {
-                  help[i]=help[i-1];
-              }else{
-                  temp=1;
-                  for(int j=i-1;j>-1;j--){
-                      if(arr[i]>arr[j])
-                      {
-                          temp=Math.max(temp,help[j]);
-                          help[i]=temp+1;
-                      }else if(arr[i]==arr[j]){
-                          if(help[i]<help[j])
-                          help[i]=help[j];
-                      }
-                  }
-
-              }
-          }
-          int res=Integer.MIN_VALUE;
-          for(int i=0;i<help.length;i++){
-              res=Math.max(res,help[i]);
-          }
-          return res;
-    }
-
-    //O(n)
-    public static int getLongestIncrSub(int[] arr){
-            if(arr==null || arr.length==0)
-                return 0;
-            int[] lens=new int[arr.length];//记录以每个元素结尾的最长递增子序列的长度
-            lens[0]=1;
-            int[] ends=new int[arr.length];//最小结尾子数组
-            ends[0]=arr[0];
-            int l=0;
-            int r=0;
-            int m=0;
-            int right=0;//right表示ends的有效长度，即非零元素的长度，最终后的right再加上1就是最大递增子序列的长度
-            for(int i=1;i<arr.length;i++){
-                l=0;
-                r=right;
-                //找到第一个大于等于arr[i]的值的下标，即循环退出时l的值
-                while(l<=r){
-                    m=(l+r)/2;
-                    if(arr[i]>ends[m])
-                    {
-                        l=m+1;
-                    }else{
-                        r=m-1;
-                    }
-                }
-                right=Math.max(right,l);
-                ends[l]=arr[i];//while循环一定是l>r退出的，根据l=m+1,r=m-1,得出，arr[i]的恰当位置就是ends[l]的位置
-                lens[i]=l+1;//如果仅仅是为了求最大递增子序列的长度，lens可以不需要，lens数组是辅助求出最大递增子序列有哪些元素。
-            }
-
-            return right+1;
-    }
-
-
-    public static int[] generateRandomArray(int size) {
-        int[] arr = new int[size];
-        for (int i = 0; i < size; i++) {
-            arr[i] = (int) (Math.random() * 1000);
-        }
-        return arr;
-    }
-
-    public static void main(String[] args) {
-
-    }
-
-
-
-}
Index: src/左神算法/高频面试题/数组问题/LongestSubarray2.java
===================================================================
diff --git a/src/左神算法/高频面试题/数组问题/LongestSubarray2.java b/src/左神算法/高频面试题/数组问题/LongestSubarray2.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/数组问题/LongestSubarray2.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,57 +0,0 @@
-package 左神算法.高频面试题.数组问题;
-
-import java.util.HashMap;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 给定一个数组，值可以是正数，负数，和0.请返回累加和为给定值k的最长子数组的长度
- * @date 2019/12/26 14:18
- */
-public class LongestSubarray2 {
-
-
-    public static int maxLength(int[] arr,int k){
-        if(arr==null || arr.length==0)
-            return 0;
-        HashMap<Integer,Integer>map=new HashMap<>();//记录前n个数的和，
-        map.put(0,-1);
-        int sum=0;
-        int len=0;
-        for(int i=0;i<arr.length;i++)
-        {
-            sum+=arr[i];
-            if(map.containsKey(sum-k))
-            {
-                len=Math.max(len,i-map.get(sum-k));
-            }
-            if(!map.containsKey(sum))
-                map.put(sum,i+1);
-        }
-        return len;
-
-    }
-
-    public static int[] generateArray(int size) {
-        int[] result = new int[size];
-        for (int i = 0; i != size; i++) {
-            result[i] = (int) (Math.random() * 11) - 5;
-        }
-        return result;
-    }
-
-    public static void printArray(int[] arr) {
-        for (int i = 0; i != arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-        int[] arr = generateArray(20);
-        printArray(arr);
-        System.out.println(maxLength(arr, 10));
-
-    }
-
-}
Index: src/左神算法/进阶班一/进阶八/LongestSubarrayLessSumSolution.java
===================================================================
diff --git a/src/左神算法/进阶班一/进阶八/LongestSubarrayLessSumSolution.java b/src/左神算法/进阶班一/进阶八/LongestSubarrayLessSumSolution.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/进阶八/LongestSubarrayLessSumSolution.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,119 +0,0 @@
-package 左神算法.进阶班一.进阶八;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 给定一个数组arr,值可正可负，可0；一个整数aim,求累加和小于等于aim的最长子数组
- * @date 2020/1/27 9:47
- */
-public class LongestSubarrayLessSumSolution {
-
-    //O(N）
-    public static int maxLengthAwesome(int[] arr,int aim){
-
-        if(arr==null || arr.length==0 )
-            return 0;
-        int[] sums=new int[arr.length];
-        int[] ends=new int[arr.length];
-        sums[arr.length-1]=arr[arr.length-1];
-        ends[arr.length-1]=arr.length-1;
-
-        for(int i=arr.length-2;i>=0;i--){
-            if(sums[i+1]<0){
-                sums[i]=arr[i]+sums[i+1];
-                ends[i]=ends[i+1];
-            }else{
-                sums[i]=arr[i];
-                ends[i]=i;
-            }
-        }
-        int end=0;
-        int sum=0;
-        int res=0;
-        for(int i=0;i<arr.length;i++){
-            while(end<arr.length && sums[end]+sum<=aim)
-            {
-               sum+=sums[end];
-               end=ends[end]+1;
-            }
-            sum-=end>i ? arr[i]:0; //不是再次从i+1位置重复判断，而是减去i位置的值，再次进行判断,如果减去i位置的值
-            //仍然不满足，则直接跳过i+1位置。
-            res=Math.max(res,end-i);
-            end=Math.max(end,i+1);
-        }
-        //这样做的话会重复计算，使时间复杂度成了O(n^2)
-//        for(int i=0;i<arr.length;i++){
-//
-//            while(end<arr.length && sums[end]+sum<=aim)
-//            {
-//                sum+=sums[end];
-//                end=ends[end]+1;
-//            }
-//            res=Math.max(res,end-i);
-//            end=i+1;
-//            sum=0;
-//        }
-        return res;
-
-    }
-
-    //O(NlogN)
-    public static int maxLength(int[] arr, int k) {
-        int[] h = new int[arr.length + 1];
-        int sum = 0;
-        h[0] = sum;
-        for (int i = 0; i != arr.length; i++) {
-            sum += arr[i];
-            h[i + 1] = Math.max(sum, h[i]);
-        }
-        sum = 0;
-        int res = 0;
-        int pre = 0;
-        int len = 0;
-        for (int i = 0; i != arr.length; i++) {
-            sum += arr[i];
-            pre = getLessIndex(h, sum - k);
-            len = pre == -1 ? 0 : i - pre + 1;
-            res = Math.max(res, len);
-        }
-        return res;
-    }
-
-    public static int getLessIndex(int[] arr, int num) {
-        int low = 0;
-        int high = arr.length - 1;
-        int mid = 0;
-        int res = -1;
-        while (low <= high) {
-            mid = (low + high) / 2;
-            if (arr[mid] >= num) {
-                res = mid;
-                high = mid - 1;
-            } else {
-                low = mid + 1;
-            }
-        }
-        return res;
-    }
-
-    // for test
-    public static int[] generateRandomArray(int len, int maxValue) {
-        int[] res = new int[len];
-        for (int i = 0; i != res.length; i++) {
-            res[i] = (int) (Math.random() * maxValue) - (maxValue / 3);
-        }
-        return res;
-    }
-
-    public static void main(String[] args) {
-        for (int i = 0; i < 1000000; i++) {
-            int[] arr = generateRandomArray(10, 20);
-            int k = (int) (Math.random() * 20) - 5;
-            if (maxLengthAwesome(arr, k) != maxLength(arr, k)) {
-                System.out.println("oops!");
-            }
-        }
-
-    }
-
-}
Index: src/左神算法/进阶班一/进阶八/LongestSubArraySolution.java
===================================================================
diff --git a/src/左神算法/进阶班一/进阶八/LongestSubArraySolution.java b/src/左神算法/进阶班一/进阶八/LongestSubArraySolution.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/进阶八/LongestSubArraySolution.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,90 +0,0 @@
-package 左神算法.进阶班一.进阶八;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 给定一个数组arr,全是正数；一个整数aim,求累加和等于aim的最长子数组，额外空间复杂度O(1),时间复杂度O（N)
- * @date 2020/1/23 20:45
- */
-public class LongestSubArraySolution {
-
-    public static int maxLength(int[] arr,int aim) {
-        if (arr == null || arr.length == 0 || aim < 0) {
-            return 0;
-        }
-        int res = 0;
-        int left = 0;
-        int right = 0;
-        int sum = arr[0];
-        while (right < arr.length) {
-            if(sum<aim){
-                right++;
-                if(right==arr.length){
-                    break;
-                }
-                sum+=arr[right];
-            }else if(sum==aim){
-                res=Math.max(res,right-left+1);
-                sum+=(++right==arr.length) ? 0:arr[right];
-            }else{
-                sum-=arr[left++];
-            }
-
-        }
-        return  res;
-    }
-
-
-    //相当于是使用了滑动窗口的方法
-    public static int maxLength2(int[] arr,int k){
-        if (arr == null || arr.length == 0 || k <= 0) {
-            return 0;
-        }
-        int left = 0;
-        int right = 0;
-        int sum = arr[0];
-        int len = 0;
-        while (right < arr.length) {
-            if (sum == k) {
-                len = Math.max(len, right - left + 1);
-                sum -= arr[left++];
-            } else if (sum < k) {
-                right++;
-                if (right == arr.length) {//边界判断
-                    break;
-                }
-                sum += arr[right];
-            } else {
-                sum -= arr[left++];
-            }
-        }
-        return len;
-
-    }
-
-    public static int[] generateArray(int size) {
-        int[] result = new int[size];
-        for (int i = 0; i != size; i++) {
-            result[i] = (int) (Math.random() * 10)+1 ;
-        }
-        return result;
-    }
-
-    public static void printArray(int[] arr) {
-        for (int i = 0; i != arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-        for(int i=0;i<100000;i++){
-            int[] arr = generateArray(20);
-            if(maxLength(arr, 20)!=maxLength2(arr,20))
-                System.out.println("error");
-        }
-
-
-    }
-
-}
Index: src/左神算法/高频面试题/数组问题/LongestSubarraySolution.java
===================================================================
diff --git a/src/左神算法/高频面试题/数组问题/LongestSubarraySolution.java b/src/左神算法/高频面试题/数组问题/LongestSubarraySolution.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/数组问题/LongestSubarraySolution.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,61 +0,0 @@
-package 左神算法.高频面试题.数组问题;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 给定义全是正数的数组，请返回累加和为给定值k的最长子数组的长度
- * @date 2019/12/26 12:45
- */
-public class LongestSubarraySolution {
-
-
-    //相当于是使用了滑动窗口的方法
-    public static int maxLength(int[] arr,int k){
-        if (arr == null || arr.length == 0 || k <= 0) {
-            return 0;
-        }
-        int left = 0;
-        int right = 0;
-        int sum = arr[0];
-        int len = 0;
-        while (right < arr.length) {
-            if (sum == k) {
-                len = Math.max(len, right - left + 1);
-                sum -= arr[left++];
-            } else if (sum < k) {
-                right++;
-                if (right == arr.length) {//边界判断
-                    break;
-                }
-                sum += arr[right];
-            } else {
-                sum -= arr[left++];
-            }
-        }
-        return len;
-
-    }
-    public static int[] generateArray(int size) {
-        int[] result = new int[size];
-        for (int i = 0; i != size; i++) {
-            result[i] = (int) (Math.random() * 10)+1 ;
-        }
-        return result;
-    }
-
-    public static void printArray(int[] arr) {
-        for (int i = 0; i != arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-        int[] arr = generateArray(20);
-        printArray(arr);
-        System.out.println(maxLength(arr, 15));
-
-    }
-
-}
-
Index: src/左神算法/高频面试题/数组问题/LongSubArray.java
===================================================================
diff --git a/src/左神算法/高频面试题/数组问题/LongSubArray.java b/src/左神算法/高频面试题/数组问题/LongSubArray.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/数组问题/LongSubArray.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,48 +0,0 @@
-package 左神算法.高频面试题.数组问题;
-
-import java.util.HashMap;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 一个数组由整数组成，求奇数与偶数数量相等的最大子数组的长度；
- * 一个数组由0和1组成，求0和1数量相等的最大子数组的长度；一个数组由0,1,2组成，求1和2数量相等的最大子数组的长度
- * @date 2020/1/4 12:29
- */
-public class LongSubArray {
-
-    public static int getLongSubArray(int[] arr){
-        //偶数全部标为-1，奇数全部变为1，也就是求累加和为0的最大子数组的长度
-        if(arr==null || arr.length==0)
-            return 0;
-        for(int i=0;i<arr.length;i++){
-            arr[i]=(arr[i] & 1)==1 ? 1:-1;//偶数全部标为-1，奇数全部变为1，
-        }
-        //System.out.println(Arrays.toString(arr));
-        int res=0;
-        int cur=0;
-
-        HashMap<Integer,Integer> map=new HashMap<>();//k:累加和，v：该累加和第一次出现的位置
-        map.put(0,-1);//代表0第一次出现的位置是-1.
-        //map.put(0,-1);
-        for(int i=0;i<arr.length;i++){
-            cur+=arr[i];
-            if(!map.containsKey(cur))
-            {
-                map.put(cur,i);
-            }else{
-                res=Math.max(res,i-map.get(cur));
-            }
-//            if(cur==0){
-//                res=Math.max(res,i+1);
-//            }
-        }
-        return res;
-    }
-
-    public static void main(String[] args) {
-        int[] arr={1,2,3,4,5,6,24,11,0,1};
-        System.out.println(getLongSubArray(arr));
-    }
-
-}
Index: src/左神算法/高频面试题/数组问题/LongSubarray3.java
===================================================================
diff --git a/src/左神算法/高频面试题/数组问题/LongSubarray3.java b/src/左神算法/高频面试题/数组问题/LongSubarray3.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/数组问题/LongSubarray3.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,52 +0,0 @@
-package 左神算法.高频面试题.数组问题;
-
-import java.util.HashMap;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一个数组，值可以是正数，负数，和0.请返回累加和小于等于k的最长子数组的长度
- * @date 2019/12/26 14:46
- */
-public class LongSubarray3 {
-
-    //时间复杂度O（N）
-    public static int maxLengthAwesome(int[] arr,int k)
-    {
-       if(arr==null || arr.length==0)
-           return 0;
-       int[] sums=new int[arr.length];
-       HashMap<Integer,Integer>ends=new HashMap<>();
-       sums[arr.length-1]=arr[arr.length-1];
-       ends.put(arr.length-1,arr.length-1);
-       for(int i=arr.length-2;i>=0;i--)
-       {
-           if(sums[i+1]<0)
-           {
-               sums[i]=arr[i]+sums[i+1];
-               ends.put(i,ends.get(i+1));
-           }else{
-               sums[i]=arr[i];
-               ends.put(i,i);
-           }
-       }
-       int sum=0;
-       int end=0;
-       int res=0;
-       for(int i=0;i<arr.length;i++)
-       {
-           while(end<arr.length && sum+sums[end]<=k)
-           {
-               sum+=sums[end];
-               end=ends.get(end)+1;
-           }
-           sum-=end>i?arr[i]:0;
-           res=Math.max(res,end-1);
-           end=Math.max(i+1,end);
-       }
-       return res;
-    }
-
-
-
-}
Index: src/左神算法/基础班/第四课/LowestString.java
===================================================================
diff --git a/src/左神算法/基础班/第四课/LowestString.java b/src/左神算法/基础班/第四课/LowestString.java
deleted file mode 100644
--- a/src/左神算法/基础班/第四课/LowestString.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,31 +0,0 @@
-package 左神算法.基础班.第四课;
-
-import java.util.Arrays;
-import java.util.Comparator;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 给定一个字符串类型的数组strs，请找到一种拼接顺序，使得将所有的字符串拼接起来组成的大写字符串是所有可能性字典序中最小的
- * 并并反复回这个大写字符串
- * @date 2020/3/24 9:57
- */
-public class LowestString {
-
-    public String lowestString(String[] strs){
-        if(strs==null || strs.length==0)
-            return "";
-        Arrays.sort(strs, new Comparator<String>() {
-            @Override
-            public int compare(String o1, String o2) {
-                return (o1+o2).compareTo(o2+o1);
-            }
-        });
-        String res="";
-        for(int i=0;i<strs.length;i++){
-            res+=strs[i];
-        }
-        return res;
-    }
-}
Index: src/左神算法/进阶班一/结构设计/LRU.java
===================================================================
diff --git a/src/左神算法/进阶班一/结构设计/LRU.java b/src/左神算法/进阶班一/结构设计/LRU.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/结构设计/LRU.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,146 +0,0 @@
-package 左神算法.进阶班一.结构设计;
-
-import java.util.HashMap;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 设计可变更的缓存结构LRU
- * @date 2020/1/7 11:28
- */
-public class LRU {
-
-    public static class Node<k,v>{
-        public k key;
-        public v value;
-        public Node last;
-        public Node next;
-
-        public Node(k key, v value) {
-            this.key = key;
-            this.value = value;
-        }
-    }
-
-    public static class NodeDoubleLinkedList<k,v>{
-        public Node<k,v>head;//头指针
-        public Node<k,v>tail;//尾指针
-
-        public NodeDoubleLinkedList() {
-            this.head =null;
-            this.tail =null;
-        }
-
-
-        public void addNode(Node node){
-            if(node==null)
-                return;
-            if(head==null){
-                this.head=node;
-                this.tail=node;
-            }else {
-                this.tail.next=node;
-                node.last=this.tail;
-                this.tail=node;
-            }
-        }
-
-        public  void moveNodeToTail(Node node){
-            if(this.tail==node){//说明没有元素
-                return;
-            }
-            if(this.head==node){
-                this.head=node.next;
-                this.head.last=null;
-            }else{
-                node.last.next=node.next;
-                node.next.last=node.last;
-            }
-            node.last=this.tail;
-            node.next=null;
-            this.tail.next=node;
-            this.tail=node;
-
-        }
-
-        public Node removeHead(){
-            if(this.head==null)
-                return null;
-            Node res=this.head;
-            if(this.head==this.tail){
-                this.head=null;
-                this.tail=null;
-            }else{
-                this.head=res.next;
-                this.head.last=null;
-                res.next=null;
-
-            }
-            return res;
-        }
-    }
-
-    public static class MyCache<k,v>{
-        private HashMap<k,Node<k,v>> keyNodeMap;
-        private int capicity;
-        private NodeDoubleLinkedList<k,v> nodeDoubleLinkedList;
-
-        public MyCache(int capicity) {
-            if(capicity<1){
-                throw new RuntimeException("should be more than 0");
-            }
-            this.keyNodeMap=new HashMap<>();
-            this.nodeDoubleLinkedList=new NodeDoubleLinkedList<>();
-            this.capicity=capicity;
-        }
-
-        public v get( k key){
-            if(this.keyNodeMap.containsKey(key))
-            {
-                Node<k, v> node= keyNodeMap.get(key);
-                this.nodeDoubleLinkedList.moveNodeToTail(node);
-                return node.value;
-            }
-            return null;
-        }
-
-        public void set(k k,v v){
-            //Node node=new Node(k,v);
-            if(this.keyNodeMap.containsKey(k))
-            {
-                Node<k, v> node = keyNodeMap.get(k);
-                node.value=v;
-                this.nodeDoubleLinkedList.moveNodeToTail(node);
-            }else{
-                Node node =new Node(k,v);
-                this.keyNodeMap.put(k,node);
-                this.nodeDoubleLinkedList.addNode(node);
-                if(this.keyNodeMap.size()==capicity+1)
-                {
-                   this.removeMostUnusedCache();
-                }
-            }
-
-        }
-
-        public void removeMostUnusedCache(){
-            Node node = this.nodeDoubleLinkedList.removeHead();
-            keyNodeMap.remove(node.key);
-
-        }
-    }
-
-    public static void main(String[] args) {
-        MyCache<String, Integer> testCache = new MyCache<String, Integer>(3);
-        testCache.set("A", 1);
-        testCache.set("B", 2);
-        testCache.set("C", 3);
-        System.out.println(testCache.get("B"));
-        System.out.println(testCache.get("A"));
-        testCache.set("D", 4);
-        System.out.println(testCache.get("D"));
-        System.out.println(testCache.get("C"));
-
-    }
-
-}
Index: src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/MacOSButton.java
===================================================================
diff --git a/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/MacOSButton.java b/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/MacOSButton.java
deleted file mode 100644
--- a/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/MacOSButton.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,14 +0,0 @@
-package 重温设计模式.创建型模式.工厂模式.抽象工厂模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/19 16:58
- */
-public class MacOSButton implements Button{
-    @Override
-    public void paint() {
-        System.out.println("You have created MacOSButton.");
-    }
-}
Index: src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/MacOSCheckBox.java
===================================================================
diff --git a/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/MacOSCheckBox.java b/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/MacOSCheckBox.java
deleted file mode 100644
--- a/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/MacOSCheckBox.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,14 +0,0 @@
-package 重温设计模式.创建型模式.工厂模式.抽象工厂模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/19 17:00
- */
-public class MacOSCheckBox implements CheckBox {
-    @Override
-    public void paint() {
-        System.out.println("You have created MacOSCheckbox.");
-    }
-}
Index: src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/MacOSFactory.java
===================================================================
diff --git a/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/MacOSFactory.java b/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/MacOSFactory.java
deleted file mode 100644
--- a/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/MacOSFactory.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,21 +0,0 @@
-package 重温设计模式.创建型模式.工厂模式.抽象工厂模式.示例;
-
-import java.awt.*;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/19 17:02
- */
-public class MacOSFactory implements GUIFactory {
-    @Override
-    public Button createButton() {
-        return new MacOSButton();
-    }
-
-    @Override
-    public CheckBox createCheckbox() {
-        return new MacOSCheckBox();
-    }
-}
Index: src/左神算法/基础班/第四课/MadianQuick.java
===================================================================
diff --git a/src/左神算法/基础班/第四课/MadianQuick.java b/src/左神算法/基础班/第四课/MadianQuick.java
deleted file mode 100644
--- a/src/左神算法/基础班/第四课/MadianQuick.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,133 +0,0 @@
-package 左神算法.基础班.第四课;
-
-import java.util.Arrays;
-import java.util.Comparator;
-import java.util.PriorityQueue;
-
-public class MadianQuick {
-
-    public static class MedianHolder{
-        private PriorityQueue<Integer>maxheap=new PriorityQueue<>(new MaxHeapComparator());
-        private PriorityQueue<Integer>minheap=new PriorityQueue<>(new MinHeapComparator());
-
-        public void modifyTwoHeapSize(){
-            if(this.maxheap.size()==this.minheap.size()+2)
-            {
-                this.minheap.add(this.maxheap.poll());
-            }
-            if(this.minheap.size()==this.maxheap.size()+2)
-            {
-                this.maxheap.add(this.minheap.poll());
-            }
-        }
-
-        public void addNumber(int num)
-        {
-            if(this.maxheap.isEmpty())
-            {
-                this.maxheap.add(num);
-                return;
-
-            }
-            if(this.maxheap.peek()>=num)
-            {
-                this.maxheap.add(num);
-            }else{
-                if(this.minheap.isEmpty())
-                {
-                    this.minheap.add(num);
-                    return;
-                }
-                if(this.minheap.peek()>=num)
-                    this.maxheap.add(num);
-                else{
-                    this.minheap.add(num);
-                }
-            }
-            modifyTwoHeapSize();
-        }
-
-        public Integer getMedian()
-        {
-            int maxHeapSize=maxheap.size();
-            int minHeapSize=minheap.size();
-
-            if(maxHeapSize+minHeapSize==0)
-                return null;
-            Integer maxHeapHead=this.maxheap.peek();
-            Integer minHeapHead=this.minheap.peek();
-            if(((maxHeapSize+minHeapSize)&1)==0)
-            {
-                return (maxHeapHead+minHeapHead)/2;
-            }
-            return maxHeapSize>minHeapSize ? maxHeapHead:minHeapHead;
-
-        }
-    }
-
-
-    public static class MaxHeapComparator implements Comparator<Integer>{
-
-        @Override
-        public int compare(Integer o1, Integer o2) {
-            return -(o1-o2);
-        }
-    }
-
-    public static class MinHeapComparator implements Comparator<Integer>{
-
-        @Override
-        public int compare(Integer o1, Integer o2) {
-            return (o1-o2);
-        }
-    }
-
-    // for test
-    public static int[] getRandomArray(int maxLen, int maxValue) {
-        int[] res = new int[(int) (Math.random() * maxLen) + 1];
-        for (int i = 0; i != res.length; i++) {
-            res[i] = (int) (Math.random() * maxValue);
-        }
-        return res;
-    }
-
-    // for test, this method is ineffective but absolutely right
-    public static int getMedianOfArray(int[] arr) {
-        int[] newArr = Arrays.copyOf(arr, arr.length);
-        Arrays.sort(newArr);
-        int mid = (newArr.length - 1) / 2;
-        if ((newArr.length & 1) == 0) {
-            return (newArr[mid] + newArr[mid + 1]) / 2;
-        } else {
-            return newArr[mid];
-        }
-    }
-
-    public static void printArray(int[] arr) {
-        for (int i = 0; i != arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-        boolean err = false;
-        int testTimes = 200000;
-        for (int i = 0; i != testTimes; i++) {
-            int len = 30;
-            int maxValue = 1000;
-            int[] arr = getRandomArray(len, maxValue);
-            MedianHolder medianHold = new MedianHolder();
-            for (int j = 0; j != arr.length; j++) {
-                medianHold.addNumber(arr[j]);
-            }
-            if (medianHold.getMedian() != getMedianOfArray(arr)) {
-                err = true;
-                printArray(arr);
-                break;
-            }
-        }
-        System.out.println(err ? "Oops..what a fuck!" : "today is a beautiful day^_^");
-
-    }
-}
Index: src/Gof/visitor/Man.java
===================================================================
diff --git a/src/Gof/visitor/Man.java b/src/Gof/visitor/Man.java
deleted file mode 100644
--- a/src/Gof/visitor/Man.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package Gof.visitor;
-
-public class Man extends Person {
-    @Override
-    public void accept(Action action) {
-        action.getManResult(this);
-    }
-}
Index: src/左神算法/进阶班一/Manacher/Manacher.java
===================================================================
diff --git a/src/左神算法/进阶班一/Manacher/Manacher.java b/src/左神算法/进阶班一/Manacher/Manacher.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/Manacher/Manacher.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,52 +0,0 @@
-package 左神算法.进阶班一.Manacher;
-
-/**
- * manacher算法实现过程
- */
-public class Manacher {
-
-    //构造manacher 字符数组
-    public static char[] manacherString(String str) {
-        char[] charArr = str.toCharArray();
-        char[] res = new char[str.length() * 2 + 1];
-        int index = 0;
-        for (int i = 0; i != res.length; i++) {
-            res[i] = (i & 1) == 0 ? '#' : charArr[index++];//即实现了在偶数下标位置插入#，奇数下标位置插入原来的字符数组的响
-        }
-        return res;
-    }
-
-    public static int maxLcpsLength(String str) {
-        if (str == null || str.length() == 0) {
-            return 0;
-        }
-        char[] charArr = manacherString(str);
-        int[] pArr = new int[charArr.length];//回文半径数组
-        int index = -1;//回文中心
-        int pR = -1;//最大回文右边界
-        int max = Integer.MIN_VALUE;
-        for (int i = 0; i != charArr.length; i++) {
-            pArr[i] = pR > i ? Math.min(pArr[2 * index - i], pR - i) : 1;
-            while (i + pArr[i] < charArr.length && i - pArr[i] > -1) {
-                if (charArr[i + pArr[i]] == charArr[i - pArr[i]])
-                    pArr[i]++;
-                else {
-                    break;
-                }
-            }
-            if (i + pArr[i] > pR) {
-                pR = i + pArr[i];
-                index = i;
-            }
-            max = Math.max(max, pArr[i]);//因为pArr[i]是manacher数组的回文半径，也就是原字符数组
-            // 的回文直径+1了..如果max的值发生了改变，原来string中最长回文串的起始坐标为：(i-max-1)/2;
-
-        }
-
-        return max - 1;//自己举个例子看看
-    }
-    public static void main(String[] args) {
-        String str1 = "bb";
-        System.out.println(maxLcpsLength(str1));
-    }
-}
Index: src/org/sd/chainofR/Manager.java
===================================================================
diff --git a/src/org/sd/chainofR/Manager.java b/src/org/sd/chainofR/Manager.java
deleted file mode 100644
--- a/src/org/sd/chainofR/Manager.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,20 +0,0 @@
-package org.sd.chainofR;
-
-public class Manager extends Leader {
-    public Manager(String name)
-    {
-        super(name);
-    }
-
-    public void handleRequest(LeaveRequest request)
-    {
-        if(request.getLeaveDays()<10){
-            System.out.println("员工："+request.getEmpName()+"请假，天数："+request.getLeaveDays()+",理由："+request.getReason());
-            System.out.println("经理："+this.name+",审批通过！");
-        }else
-        {
-            if(this.nextLeader!=null)
-                this.nextLeader.handleRequest(request);
-        }
-    }
-}
Index: src/org/sd/mediator/Market.java
===================================================================
diff --git a/src/org/sd/mediator/Market.java b/src/org/sd/mediator/Market.java
deleted file mode 100644
--- a/src/org/sd/mediator/Market.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,24 +0,0 @@
-package org.sd.mediator;
-
-public class Market implements Department {
-    private Mediator m;
-
-    public Market(Mediator m) {
-        super();
-        this.m = m;
-        m.register("market",this);
-    }
-
-    @Override
-    public void outAction() {
-        System.out.println("汇报工作！项目承接的进度，需要资金支持！");
-
-        m.command("finacial");
-
-    }
-
-    @Override
-    public void selfAction() {
-        System.out.println("跑去接项目！");
-    }
-}
Index: src/左神算法/进阶班一/前缀树应用/Max_EOR好题.java
===================================================================
diff --git a/src/左神算法/进阶班一/前缀树应用/Max_EOR好题.java b/src/左神算法/进阶班一/前缀树应用/Max_EOR好题.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/前缀树应用/Max_EOR好题.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,161 +0,0 @@
-package 左神算法.进阶班一.前缀树应用;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 给定一个数组，求子数组的最大异或和。一个数组的异或和为，数组中所有的数异或起来的结果
- * @date 2020/1/14 10:49
- */
-public class Max_EOR好题 {
-
-
-    //暴力解，以每一个位置结尾分别求异或和，O（n^3)
-    public static int getMaxE1(int [] arr){
-       if(arr==null || arr.length==0)
-       {
-           return 0;
-       }
-        int max=Integer.MIN_VALUE;
-        for(int i=0;i<arr.length;i++){
-            for(int start=0;start<=i;start++){
-                int res=0;
-                for(int k=start;k<=i;k++)
-                {
-                    res^=arr[k];
-                }
-                max=Math.max(res,max);
-            }
-        }
-        return max;
-    }
-
-    //使用一个数组记录0-i位置的异或和，使用到的结论：如果a^b=c，则：b=a^c,a=b^c.
-    public static int getMaxE2(int [] arr){
-        if(arr==null || arr.length==0)
-        {
-            return 0;
-        }
-        int max=Integer.MIN_VALUE;
-        int[] dp=new int[arr.length];//dp[i]表示0-i的异或和
-        int eor=0;
-        for(int i=0;i<arr.length;i++){
-            eor^=arr[i];//0...i的eor
-            max=Math.max(eor,max);
-            for(int start=1;start<=i;start++){
-                int startToIEor=eor^dp[start-1];//使用到的结论：如果a^b=c，则：b=a^c,a=b^c.
-                max=Math.max(max,startToIEor);
-            }
-            dp[i]=eor;
-        }
-        return max;
-    }
-
-    //使用trie Tree，将数组中的元素表示为二进制的形式.O(n)
-    public static int maxXorSubarray(int[] arr){
-        if(arr==null || arr.length==0)
-            return 0;
-        int max=Integer.MIN_VALUE;
-        int eor=0;
-        NumTrie numTrie=new NumTrie();
-        numTrie.add(0);//一开始传入0值，在不影响结果的前提下，使maxXor算法运行下去
-        for(int i=0;i<arr.length;i++){
-            eor^=arr[i];
-            max=Math.max(max,numTrie.maxXor(eor));//每次传入的是arr[0]-arr[i]的异或和，还是利用了a^b=c则a=b^c，b=a^c
-            numTrie.add(eor);//将arr中0-i的异或和放入numTrie中，
-        }
-        return max;
-    }
-
-
-    public static class Node{
-        public Node[] nexts=new Node[2];//只有0,1两条路走
-    }
-
-    public static class NumTrie{
-        public Node head=new Node();
-
-        //传入0-i的异或和。num：表示arr中0-i的异或和。这个函数的作用是将arr中0-i的异或和存入前缀树。
-        public void add(int num){
-            Node cur=head;
-            for(int move=31;move>=0;move--){
-                int path=(num>>move) & 1;//判断num每一位的值，0/1
-                cur.nexts[path]=cur.nexts[path]==null ? new Node():cur.nexts[path];//判断cur.nexts[i]是否有值。
-                cur=cur.nexts[path];
-            }
-        }
-           //传入的num是数组中arr[0]-arr[i]的异或和。
-        public int maxXor(int num){
-            Node cur=head;
-            int res=0;
-            for(int move=31;move>-1;move--){
-                int path=(num>>move) & 1; //求对应为的值
-                //best是指期望获得值，选择最优路径.move==31时，选择的是数子的符号位，此时希望选择路和符号位相同，不是符号位时，相反
-                int best=move==31 ? path:(path ^ 1);
-                //实际可以选择的值,看看有没有期望的值，best ^1相当于取反，相应的位置1变成0,0变成1
-                best=cur.nexts[best]!=null ? best:(best ^ 1);
-                res|=(path ^ best)<<move;//异或，设置答案的每一位
-                cur=cur.nexts[best];
-            }
-            return res;
-        }
-    }
-    // for test
-    public static int comparator(int[] arr) {
-        if (arr == null || arr.length == 0) {
-            return 0;
-        }
-        int max = Integer.MIN_VALUE;
-        for (int i = 0; i < arr.length; i++) {
-            int eor = 0;
-            for (int j = i; j < arr.length; j++) {
-                eor ^= arr[j];
-                max = Math.max(max, eor);
-            }
-        }
-        return max;
-    }
-    // for test
-    public static int[] generateRandomArray(int maxSize, int maxValue) {
-        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
-        for (int i = 0; i < arr.length; i++) {
-            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
-        }
-        return arr;
-    }
-
-    // for test
-    public static void printArray(int[] arr) {
-        if (arr == null) {
-            return;
-        }
-        for (int i = 0; i < arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    // for test
-    public static void main(String[] args) {
-        int testTime = 500000;
-        int maxSize = 30;
-        int maxValue = 50;
-        boolean succeed = true;
-        for (int i = 0; i < testTime; i++) {
-            int[] arr = generateRandomArray(maxSize, maxValue);
-            int res = maxXorSubarray(arr);
-            int comp = comparator(arr);
-            if (res != comp) {
-                succeed = false;
-                printArray(arr);
-                System.out.println(res);
-                System.out.println(comp);
-                break;
-            }
-        }
-        System.out.println(succeed ? "Nice!" : "Fucking fucked!");
-    }
-
-
-
-
-}
Index: src/左神算法/基础班/MaxABSBetweenLeftAndRight/MaxABSBetweenLeftAndRight.java
===================================================================
diff --git a/src/左神算法/基础班/MaxABSBetweenLeftAndRight/MaxABSBetweenLeftAndRight.java b/src/左神算法/基础班/MaxABSBetweenLeftAndRight/MaxABSBetweenLeftAndRight.java
deleted file mode 100644
--- a/src/左神算法/基础班/MaxABSBetweenLeftAndRight/MaxABSBetweenLeftAndRight.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,82 +0,0 @@
-package 左神算法.基础班.MaxABSBetweenLeftAndRight;
-
-import java.util.Random;
-
-/**
- * 已知一个整型数组arr，数组长度为size且size大于2，arr有size-1种 可以划分成左右两部分的方案。
- * 比如： arr = {3, 2, 3, 4, 1, 2} 第1种划分左部分为[3]，右部分为[2, 3, 4, 1, 2] 第2种划分左部分为[3, 2]，
- * 右部分为[3, 4, 1, 2] 第3种划分左部分为[3, 2, 3]，右部分为[4, 1, 2] 第4种划分左部分为[3, 2, 3, 4]，
- * 右部分为[1, 2] 第5种划分左部分为[3, 2, 3, 4, 1]，右部分为[2] 每一种划分下，左部分都有最大值记为max_left，
- * 右部分都有最大值记 为max_right。 求|max_left-max_right|(左部分最大值与左部分最大值之差的绝对值)，
- * 最大是多少？ 要求：时间复杂度为O(N)，额外空间复杂度O(1)。
- */
-
-public class MaxABSBetweenLeftAndRight {
-
-    public static int maxABS1(int[] array)
-    {
-        int res = Integer.MIN_VALUE;
-        int maxLeft = 0;
-        int maxRight = 0;
-        for (int i = 0; i != array.length - 1; i++) {
-            maxLeft = Integer.MIN_VALUE;
-            for (int j = 0; j != i + 1; j++) {
-                maxLeft = Math.max(array[j], maxLeft);
-            }
-            maxRight = Integer.MIN_VALUE;
-            for (int j = i + 1; j != array.length; j++) {
-                maxRight = Math.max(array[j], maxRight);
-            }
-            res = Math.max(Math.abs(maxLeft - maxRight), res);
-        }
-        return res;
-    }
-
-    public static int ABS2(int[] array){
-       int res=Integer.MIN_VALUE;
-       int n=array.length;
-       int[] leftmax=new int[n];//i以左部分的最大值
-       int[] rightmax=new int[n];//i以后的部分的最大值
-       leftmax[0]=array[0];
-       rightmax[n-1]=array[n-1];
-       for(int i=1;i<n;i++){
-           leftmax[i]=Math.max(array[i],leftmax[i-1]);
-       }
-       for(int i=array.length-2;i>=0;i--){
-           rightmax[i]=Math.max(array[i],rightmax[i+1]);
-       }
-       for(int i=0;i<n-1;i++){
-           res=Math.max(res,Math.abs(leftmax[i]-rightmax[i+1]));
-       }
-       return res;
-
-    }
-
-    //全局最大值一定在左半部分或者右半部分，左半部分的最大值一定>=arr[0],右半部分的最大值一定>=arr[n-1]
-    public static int ABS3(int[] arr)
-    {
-        int max=Integer.MIN_VALUE;
-        for(int i=0;i<arr.length;i++)
-        {
-            max=Math.max(max,arr[i]);
-        }
-
-        return arr[0]>arr[arr.length-1] ? (max-arr[arr.length-1]):(max-arr[0]);
-    }
-
-    public static int[] generateArray(int length)
-    {
-        int[] array=new int[length];
-        for(int i=0;i<length;i++)
-            array[i]=new Random().nextInt(100);
-        return array;
-    }
-    public static void main(String[] args){
-        int[] arr = generateArray(200);
-        System.out.println(maxABS1(arr));
-        System.out.println(ABS2(arr));
-        System.out.println(ABS3(arr));
-
-
-    }
-}
Index: src/左神算法/高频面试题/数组问题/MaxABSBetweenLeftAndRight.java
===================================================================
diff --git a/src/左神算法/高频面试题/数组问题/MaxABSBetweenLeftAndRight.java b/src/左神算法/高频面试题/数组问题/MaxABSBetweenLeftAndRight.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/数组问题/MaxABSBetweenLeftAndRight.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,66 +0,0 @@
-package 左神算法.高频面试题.数组问题;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一个长度为N（N>1)的整型数组arr,可以划分为左右两部分，左部分为arr[0,k],右部分为arr[k+1,N-1],k可以取值的范围为[0,N-2],求这么多划分案例中，作部分的最大值
- * 减去右部分的最大值的绝对值中，最大是多少？
- * @date 2020/1/3 10:45
- */
-public class MaxABSBetweenLeftAndRight {
-
-    //最终的结果一定是整个数组的最大值减去某一个数，当最大值在左半部分时，右半部分一定包括最右边的元素，所以右半部分的最大值>=arr[arr.length-1];
-    //同理当最大值在数组的右半部分时。所以只需要用最大值减去arr[0]与arr[arr.length-1]中的较小的那个。
-    public static int maxABS1(int[] arr){
-        int max=Integer.MIN_VALUE;
-        for(int i=0;i<arr.length;i++)
-        {
-            max=Math.max(max,arr[i]);
-        }
-        return max-Math.min(arr[0],arr[arr.length-1]);
-    }
-    //采用辅助数组的方式，记录以数组中每个位置为分点的左右两部分的最值，然后分别判断二者的差绝对值最大的。
-    public static int maxABS2(int[] arr){
-        if(arr==null || arr.length<2)
-            return 0;
-        int res=Integer.MIN_VALUE;
-        int[] rmax=new int[arr.length];
-        rmax[arr.length-1]=arr[arr.length-1];
-        int[] lmax=new int[arr.length];
-        lmax[0]=arr[0];
-        for(int i=arr.length-2;i>-1;i--){
-            rmax[i]=Math.max(arr[i],rmax[i+1]);
-        }
-        for(int i=1;i<arr.length;i++)
-        {
-            lmax[i]=Math.max(lmax[i-1],arr[i]);
-        }
-
-        for(int i=0;i<arr.length-1;i++){
-            res=Math.max(res,Math.abs(lmax[i]-rmax[i+1]));
-        }
-        return res;
-    }
-
-    public static int[] generateRandomArray(int length) {
-        int[] arr = new int[length];
-        for (int i = 0; i != arr.length; i++) {
-            arr[i] = (int) (Math.random() * 1000) - 499;
-        }
-        return arr;
-    }
-
-    public static void main(String[] args) {
-        for(int i=0;i<50000;i++){
-            int[] arr = generateRandomArray(200);
-            int i1 = maxABS1(arr);
-            int i2 = maxABS2(arr);
-            if(i1!=i2){
-                System.out.println("出错了！！！！");
-                return;
-            }
-        }
-        System.out.println("完全正确！！！！！");
-       // System.out.println(maxABS3(arr));
-    }
-}
Index: src/左神算法/进阶班一/树相关/高度套路题树形dp/MaxDistanceInTree.java
===================================================================
diff --git a/src/左神算法/进阶班一/树相关/高度套路题树形dp/MaxDistanceInTree.java b/src/左神算法/进阶班一/树相关/高度套路题树形dp/MaxDistanceInTree.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/树相关/高度套路题树形dp/MaxDistanceInTree.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,98 +0,0 @@
-package 左神算法.进阶班一.树相关.高度套路题树形dp;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:二叉树中，一个结点可以往上走和往下走，那么从结点A总能到达结点B。结点A到达结点B的距离为：A走到B的最短路径上的结点数
- *                   求一棵树上的最远距离
- * @date 2020/1/5 13:42
- */
-public class MaxDistanceInTree {
-
-    public static class Node {
-        public int value;
-        public Node left;
-        public Node right;
-
-        public Node(int data) {
-            this.value = data;
-        }
-    }
-
-    public static class ReturnType{
-       public int h;//树的高度
-       public int maxDistance;//最远距离
-
-        public ReturnType(int h, int maxDistance) {
-            this.h = h;
-            this.maxDistance = maxDistance;
-        }
-    }
-
-    public static int maxDistance(Node head) {
-        int[] record = new int[1];
-        return posOrder(head, record);
-    }
-    //方法一：
-    public static ReturnType process(Node head){
-            if(head==null){
-                return new ReturnType(0,0);
-            }
-
-            Node left=head.left;
-            ReturnType leftReturn=process(left);
-            Node right=head.right;
-            ReturnType rightReturn=process(right);
-            int includeItselves=leftReturn.h+1+rightReturn.h;//可能性3
-            int p1=leftReturn.maxDistance;//可能性1
-            int p2=rightReturn.maxDistance;//可能性2
-            int resultDistance=Math.max(Math.max(p1,p2),includeItselves);//找出最终答案
-            int hitselves=Math.max(leftReturn.h,rightReturn.h)+1;
-            return new ReturnType(hitselves,resultDistance);
-
-    }
-
-    //方法二：
-    public static int posOrder(Node head, int[] record) {
-        if (head == null) {
-            record[0] = 0;
-            return 0;
-        }
-        int lMax = posOrder(head.left, record);//返回左子树的结果
-        int maxfromLeft = record[0];//左子树树的高度
-        int rMax = posOrder(head.right, record);
-        int maxFromRight = record[0];//右子树的高度
-        int curNodeMax = maxfromLeft + maxFromRight + 1;
-        record[0] = Math.max(maxfromLeft, maxFromRight) + 1;//当前节点树的高度
-        return Math.max(Math.max(lMax, rMax), curNodeMax);
-    }
-
-    public static void main(String[] args) {
-        Node head1 = new Node(1);
-        head1.left = new Node(2);
-        head1.right = new Node(3);
-        head1.left.left = new Node(4);
-        head1.left.right = new Node(5);
-        head1.right.left = new Node(6);
-        head1.right.right = new Node(7);
-        head1.left.left.left = new Node(8);
-        head1.right.left.right = new Node(9);
-        System.out.println(maxDistance(head1));
-        System.out.println(process(head1).maxDistance);
-
-        Node head2 = new Node(1);
-        head2.left = new Node(2);
-        head2.right = new Node(3);
-        head2.right.left = new Node(4);
-        head2.right.right = new Node(5);
-        head2.right.left.left = new Node(6);
-        head2.right.right.right = new Node(7);
-        head2.right.left.left.left = new Node(8);
-        head2.right.right.right.right = new Node(9);
-        System.out.println(maxDistance(head2));
-        System.out.println(process(head2).maxDistance);
-
-    }
-
-
-}
Index: src/左神算法/基础班/Sort/maxGap.java
===================================================================
diff --git a/src/左神算法/基础班/Sort/maxGap.java b/src/左神算法/基础班/Sort/maxGap.java
deleted file mode 100644
--- a/src/左神算法/基础班/Sort/maxGap.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,101 +0,0 @@
-package 左神算法.基础班.Sort;
-
-import java.util.Arrays;
-
-public class maxGap {
-
-    public static int maxGap(int[] arr)
-    {
-        if(arr==null || arr.length<2)
-            return 0;
-        int max=Integer.MIN_VALUE;
-        int min=Integer.MAX_VALUE;
-        int len=arr.length;
-        for(int i=0;i<arr.length;i++)
-        {
-            max= Math.max(max,arr[i]);
-            min= Math.min(min,arr[i]);
-        }
-        if(max==min)
-            return 0;
-        boolean[] hasNum=new boolean[len+1];
-        int[] maxes=new int[len+1];//记录每一桶的最大值
-        int[] mins=new int[len+1];//记录每一个桶中的最小值
-        int bid=0;
-        for(int i=0;i<len;i++)
-        {
-          bid=bucket(arr[i],len,min,max);
-          maxes[bid]=hasNum[bid]?Math.max(arr[i],maxes[bid]):arr[i];
-          mins[bid]=hasNum[bid]?Math.min(arr[i],mins[bid]):arr[i];
-          hasNum[bid]=true;
-        }
-        int res=0;
-        int lastMax=maxes[0];//上一个桶的最大值，初始化为第一桶的最大值
-        int i=1;
-        for(;i<=len;i++)
-        {
-            if(hasNum[i])
-            {
-                res=Math.max(res,mins[i]-lastMax);
-                lastMax=maxes[i];
-            }
-        }
-        return res;
-    }
-
-    public static int  bucket(long num,long len,long min,long max)
-    {
-        return (int)((num-min)*len/(max-min));
-    }
-    // for test
-    public static int comparator(int[] nums) {
-        if (nums == null || nums.length < 2) {
-            return 0;
-        }
-        Arrays.sort(nums);
-        int gap = Integer.MIN_VALUE;
-        for (int i = 1; i < nums.length; i++) {
-            gap = Math.max(nums[i] - nums[i - 1], gap);
-        }
-        return gap;
-    }
-
-    // for test
-    public static int[] generateRandomArray(int maxSize, int maxValue) {
-        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
-        for (int i = 0; i < arr.length; i++) {
-            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
-        }
-        return arr;
-    }
-
-    // for test
-    public static int[] copyArray(int[] arr) {
-        if (arr == null) {
-            return null;
-        }
-        int[] res = new int[arr.length];
-        for (int i = 0; i < arr.length; i++) {
-            res[i] = arr[i];
-        }
-        return res;
-    }
-
-    // for test
-    public static void main(String[] args) {
-        int testTime = 500000;
-        int maxSize = 100;
-        int maxValue = 100;
-        boolean succeed = true;
-        for (int i = 0; i < testTime; i++) {
-            int[] arr1 = generateRandomArray(maxSize, maxValue);
-            int[] arr2 = copyArray(arr1);
-            if (maxGap(arr1) != comparator(arr2)) {
-                succeed = false;
-                break;
-            }
-        }
-        System.out.println(succeed ? "Nice!" : "Fucking fucked!");
-    }
-
-}
Index: src/左神算法/进阶班一/树相关/高度套路题树形dp/MaxHappy.java
===================================================================
diff --git a/src/左神算法/进阶班一/树相关/高度套路题树形dp/MaxHappy.java b/src/左神算法/进阶班一/树相关/高度套路题树形dp/MaxHappy.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/树相关/高度套路题树形dp/MaxHappy.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,85 +0,0 @@
-package 左神算法.进阶班一.树相关.高度套路题树形dp;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2020/1/6 12:51
- */
-public class MaxHappy {
-
-    public static class Node{
-        public int huo;
-        public List<Node> nexts;
-
-        public Node(int huo) {
-            this.huo = huo;
-            this.nexts=new ArrayList<>();
-        }
-    }
-
-    //构建成树形结构后，来的活跃度与不来的活跃度
-    public static class ReturnType{
-        public int lai_huo;
-        public int bu_lai_huo;
-
-        public ReturnType(int lai_huo, int bu_lai_huo) {
-            this.lai_huo = lai_huo;
-            this.bu_lai_huo = bu_lai_huo;
-        }
-    }
-    
-    public static int getMaxHappy(Node head){
-        ReturnType returnData = process(head);
-        return Math.max(returnData.bu_lai_huo,returnData.lai_huo);
-    }
-
-    public static ReturnType process(Node head){
-
-        List<Node> list=head.nexts;
-        int lai_huo=head.huo;
-        int bu_lai_huo=0;
-        for(int i=0;i<list.size();i++){
-            ReturnType process = process(list.get(i));
-            lai_huo+=process.bu_lai_huo;
-            bu_lai_huo+=Math.max(process.bu_lai_huo,process.lai_huo);
-        }
-        return new ReturnType(lai_huo,bu_lai_huo);
-
-    }
-
-    //改为动态规划
-    public static int maxHappy(int[][] matrix){
-        int[][] dp=new int[matrix.length][2];  //dp[i][0]:表示i来的欢乐度，dp[i][1]代表i不来的欢乐度
-        boolean [] visited=new boolean[matrix.length]; //visited[i]表示第i个人有没有已经计算过了
-        int root=0;
-        for(int i=0;i<matrix.length;i++){
-            if(i==matrix[i][0])
-                root=i;
-        }
-        process(matrix,dp,visited,root);
-
-        return Math.max(dp[root][0],dp[root][1]);
-    }
-
-    private static void process(int[][] matrix, int[][] dp, boolean[] visited, int root) {
-        visited[root]=true;
-        dp[root][0]=matrix[root][1];
-        for(int i=0;i<matrix.length;i++){
-            if(matrix[i][0]==root && !visited[i]){
-                process(matrix,dp,visited,i);
-                dp[root][0]+=dp[i][1];
-                dp[root][1]+=Math.max(dp[i][0],dp[i][1]);
-            }
-        }
-    }
-
-    public static void main(String[] args) {
-        int[][] matrix = { { 1, 8 }, { 1, 9 }, { 1, 10 } };
-        System.out.println(maxHappy(matrix));
-    }
-
-}
Index: src/左神算法/进阶班一/单调栈/MaximalRectange.java
===================================================================
diff --git a/src/左神算法/进阶班一/单调栈/MaximalRectange.java b/src/左神算法/进阶班一/单调栈/MaximalRectange.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/单调栈/MaximalRectange.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,63 +0,0 @@
-package 左神算法.进阶班一.单调栈;
-
-import java.util.Stack;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 求最大子矩阵的大小
- * 给定一个整型矩阵map,其中的值只有0和1两种，求其中全是1的所有矩形区域中，最大的矩形区域为1的数量
- * 例如：1 0 1 1
- *       1 1 1 1
- *       1 1 1 0
- *       其中最大的矩形区域有6个1，返回6
- * @date 2019/12/31 11:21
- */
-public class MaximalRectange {
-
-
-    public static int maxRecSize(int[][] map) {
-        if (map == null || map.length == 0 || map[0].length == 0) {
-            return 0;
-        }
-        int maxArea = 0;
-        int[] height = new int[map[0].length];
-        for (int i = 0; i < map.length; i++) {
-            for (int j = 0; j < map[0].length; j++) {
-                height[j] = map[i][j] == 0 ? 0 : height[j] + 1;
-            }
-            maxArea = Math.max(maxRecFromBottom(height), maxArea);
-        }
-        return maxArea;
-    }
-
-    //如果一个数组代表直方图，利用单调栈找到其中最大的矩形的过程
-    public static int maxRecFromBottom(int[] height) {
-        if (height == null || height.length == 0) {
-            return 0;
-        }
-        int maxArea = 0;
-        Stack<Integer> stack = new Stack<Integer>();
-        for (int i = 0; i < height.length; i++) {
-            while (!stack.isEmpty() && height[i] <=height[stack.peek()]) {
-                int j = stack.pop();//j位置的矩形
-                int k = stack.isEmpty() ? -1 : stack.peek();//弹出来的数的左边界
-                int curArea = (i - k - 1) * height[j];//一个数从栈中弹出，计算能组成的相应的矩形
-                maxArea = Math.max(maxArea, curArea);
-            }
-            stack.push(i);
-        }
-        while (!stack.isEmpty()) {//栈中剩余的元素结算
-            int j = stack.pop();
-            int k = stack.isEmpty() ? -1 : stack.peek();//左边界;
-            int curArea = (height.length - k - 1) * height[j];//栈中剩余元素的右边界，统一为数组的边界
-            maxArea = Math.max(maxArea, curArea);
-        }
-        return maxArea;
-    }
-
-    public static void main(String[] args) {
-        int[][] map = { { 1, 0, 1, 1 }, { 1, 1, 1, 1 }, { 1, 1, 1, 0 }, };
-        System.out.println(maxRecSize(map));
-    }
-}
Index: src/左神算法/高频面试题/MaxSum.java
===================================================================
diff --git a/src/左神算法/高频面试题/MaxSum.java b/src/左神算法/高频面试题/MaxSum.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/MaxSum.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,25 +0,0 @@
-package 左神算法.高频面试题;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 给定一个数组arr,返回子数组的最大累加和。例如：arr={1,-2,,3,5,-2,6,-1},所有子数组中，{3,5，-2.6}可以累积出最大的和12，所以返回12
- * @date 2019/12/28 11:16
- */
-public class MaxSum {
-
-    public static int getMaxSum(int[] arr)
-    {
-        if(arr==null || arr.length==0)
-            return 0;
-        int cur=0;
-        int max=Integer.MIN_VALUE;
-        for(int i=0;i<arr.length;i++)
-        {
-            cur+=arr[i];
-            max=Math.max(cur,max);
-            cur=cur>0?cur:0;
-        }
-        return max;
-    }
-}
Index: src/左神算法/进阶班一/单调栈/MaxTree.java
===================================================================
diff --git a/src/左神算法/进阶班一/单调栈/MaxTree.java b/src/左神算法/进阶班一/单调栈/MaxTree.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/单调栈/MaxTree.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,187 +0,0 @@
-package 左神算法.进阶班一.单调栈;
-
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.Queue;
-import java.util.Stack;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 一个数组的MaxTree定义如下，数组必须没有重复元素。MaxTree是一颗二叉树，数组的每一个值对应一个二叉树结点。包括MaxTree树在内且在其中的每一颗子树上
- * 值最大结点都是树的头。给定一个没有重复元素的数组arr,写出生成这个数组的MzxTree的函数，要求如果数组长度为N，则时间复杂度为O（N），额外空间复杂度为O(n)
- * @date 2019/12/31 11:25
- */
-public class MaxTree {
-
-    public static class Node{
-        public int value;
-        public Node right;
-        public Node left;
-        public Node(int value){
-            this.value=value;
-        }
-
-    }
-
-
-    //通过构建大根堆的方式实现
-    public static Node getMaxTree1(int[] arr){
-
-        if(arr==null || arr.length==0)
-        {
-            return null;
-        }
-        //将原数组构建成一个大根堆
-      for(int i=0;i<arr.length;i++)
-      {
-          heapInsert(arr,i);
-      }
-       Node [] nodes=new Node[arr.length];
-        for(int i=0;i<arr.length;i++){
-            nodes[i]=new Node(arr[i]);
-        }
-        int index=0;
-       Node head=nodes[index++];
-       Queue<Node> queue=new LinkedList<>();
-       queue.offer(head);
-       while(!queue.isEmpty()){
-           Node node=queue.poll();
-           node.left=index<arr.length ? nodes[index++]:null;
-           node.right=index<arr.length ? nodes[index++]:null;
-           if(node.left!=null)
-           {
-               queue.offer(node.left);
-           }
-           if(node.right!=null){
-               queue.offer(node.right);
-           }
-
-       }
-
-       return head;
-    }
-
-
-
-    public static void heapInsert(int[]arr,int index){
-
-        while(arr[index]>arr[(index-1)/2])
-        {
-            swap(arr,index,(index-1)/2);
-            index=(index-1)/2;
-        }
-    }
-    public static void swap(int[] arr,int i,int j){
-        int temp=arr[i];
-        arr[i]=arr[j];
-        arr[j]=temp;
-
-    }
-
-    public static void printPreOrder(Node head) {
-        if (head == null) {
-            return;
-        }
-        System.out.print(head.value + " ");
-        printPreOrder(head.left);
-        printPreOrder(head.right);
-    }
-   //这个中序遍历这样写有问题，对于用大根堆实现的不对
-    public static void printInOrder(Node head) {
-        if (head == null) {
-            return;
-        }
-        printPreOrder(head.left);
-        System.out.print(head.value + " ");
-        printPreOrder(head.right);
-    }
-    //单调栈实现
-    public static Node  getMaxTree(int[] arr){
-        Node[] nArr=new Node[arr.length];
-        for(int i=0;i<arr.length;i++){
-            nArr[i]=new Node(arr[i]);
-        }
-        Stack<Node> stack = new Stack<Node>();
-        HashMap<Node, Node> lBigMap = new HashMap<Node, Node>();//k:当前节点，v:左边第一个比他大的结点
-        HashMap<Node, Node> rBigMap = new HashMap<Node, Node>();//k:当前节点，v:右边第一个比他大的结点
-        //正着遍历数组，记录当前元素左边第一个比他大的值
-        for (int i = 0; i != nArr.length; i++) {
-            Node curNode = nArr[i];
-            while ((!stack.isEmpty()) && stack.peek().value < curNode.value) {
-                popStackSetMap(stack, lBigMap);
-            }
-            stack.push(curNode);
-        }
-        //最后栈中的元素不存在右边比他大的值
-
-        while (!stack.isEmpty()) {
-            popStackSetMap(stack, lBigMap);
-        }
-        //反着压入数组元素，记录下右边第一个比当前元素大的值
-        for (int i = nArr.length - 1; i != -1; i--) {
-            Node curNode = nArr[i];
-            while ((!stack.isEmpty()) && stack.peek().value < curNode.value) {
-                popStackSetMap(stack, rBigMap);
-            }
-            stack.push(curNode);
-        }
-        while (!stack.isEmpty()) {
-            popStackSetMap(stack, rBigMap);
-        }
-        Node head = null;
-        for (int i = 0; i != nArr.length; i++) {
-            Node curNode = nArr[i];
-            Node left =lBigMap.get(curNode);
-            Node right = rBigMap.get(curNode);
-            if (left == null && right == null) {
-                head = curNode;
-            } else if (left == null) {
-                if (right.left == null) {
-                    right.left = curNode;
-                } else {
-                    right.right = curNode;
-                }
-            } else if (right == null) {
-                if (left.left == null) {
-                    left.left = curNode;
-                } else {
-                    left.right = curNode;
-                }
-            } else {
-                Node parent = left.value < right.value ? left : right;
-                if (parent.left == null) {
-                    parent.left = curNode;
-                } else {
-                    parent.right = curNode;
-                }
-            }
-        }
-        return head;
-
-    }
-
-
-
-  public static void popStackSetMap(Stack<Node> stack,HashMap<Node,Node> map){
-        Node popNode=stack.pop();
-        if(stack.isEmpty()){
-            map.put(popNode,null);
-        }else {
-            map.put(popNode,stack.peek());
-        }
-  }
-
-    public static void main(String[] args) {
-        int[] uniqueArr = { 3, 4, 5, 1, 2,6,8 };
-
-        Node head = getMaxTree1(uniqueArr);
-        printPreOrder(head);
-        System.out.println();
-        printInOrder(head);
-        System.out.println("+==========");
-        Node maxTree = getMaxTree(uniqueArr);
-        printPreOrder(maxTree);
-
-    }
-}
Index: src/Gof/mediator/Mediator.java
===================================================================
diff --git a/src/Gof/mediator/Mediator.java b/src/Gof/mediator/Mediator.java
deleted file mode 100644
--- a/src/Gof/mediator/Mediator.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,10 +0,0 @@
-package Gof.mediator;
-
-public abstract class Mediator {
-
-    public abstract void register(String colleagueName,Colleague colleague);
-     //接受消息，具体的对象发出
-    public abstract void getMessage(String colleagueName,int stateChange);
-
-    public abstract void sendMessage();
-}
Index: src/org/sd/mediator/Mediator.java
===================================================================
diff --git a/src/org/sd/mediator/Mediator.java b/src/org/sd/mediator/Mediator.java
deleted file mode 100644
--- a/src/org/sd/mediator/Mediator.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,6 +0,0 @@
-package org.sd.mediator;
-
-public interface Mediator {
-    void register(String dname,Department p);
-    void command(String dname);
-}
Index: src/codeTop/MeetingRoom.java
===================================================================
diff --git a/src/codeTop/MeetingRoom.java b/src/codeTop/MeetingRoom.java
deleted file mode 100644
--- a/src/codeTop/MeetingRoom.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,83 +0,0 @@
-package codeTop;
-
-import java.util.Arrays;
-import java.util.PriorityQueue;
-
-/**
- * codeTop中的会议室题目，分为会议室I与会议室II两个题目
- * 一、会议室I:LeetCode 252
- * 给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],…] (si < ei)，请你判断一个人是否能够参加这里面的全部会议。
- *
- * 示例 1:
- * 输入: [[0,30],[5,10],[15,20]]
- * 输出: false
- *
- * 示例 2:
- * 输入: [[7,10],[2,4]]
- * 输出: true
- *
- * 二、会议室II:leetCode 253
- *给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],…] (si < ei)，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。
- *
- * 示例 1:
- * 输入: [[0, 30],[5, 10],[15, 20]]
- * 输出: 2
- *
- * 示例 2:
- * 输入: [[7,10],[2,4]]
- * 输出: 1
-
- */
-public class MeetingRoom {
-
-
-    public static void main(String[] args) {
-
-    }
-
-    /**
-     * 会议室I
-     * @param matrix
-     * @return
-     */
-    public static boolean meetingRoom1(int[][] matrix){
-        if(matrix == null || matrix.length < 2){
-            return true;
-        }
-        Arrays.sort(matrix,(a,b) ->{return a[0] - b[0];});
-        int last = matrix[0][1];
-        for(int i = 1;i < matrix.length;i++){
-            if(last > matrix[i][0]){
-                return false;
-            }
-            last = matrix[i][1];
-        }
-        return true;
-
-    }
-
-    /**
-     * 会议室II
-     * @param matrix
-     * @return
-     */
-    public static int meetingRoom(int[][] matrix){
-        if(matrix == null || matrix.length == 0){
-            return  0;
-        }
-        Arrays.sort(matrix,(a,b) ->{return a[0] - b[0];});
-        //保存当前正在开会的结束时间,queue中元素的个数即表示当前需要的会议室的数量
-        PriorityQueue<Integer> queue = new PriorityQueue<>();
-        int ans = 0;
-        for(int[] arr : matrix){
-            //当前要开的会是arr,如果当前要开的会的开始时间大于正在开的会的结束时间，则表示正在开的会已经结束，可以和将要开的会公用一个会议室
-            while(!queue.isEmpty() && queue.peek() <= arr[0]){
-              queue.poll();
-            }
-            queue.add(arr[1]);
-            ans = Math.max(ans,queue.size());
-        }
-        return ans;
-
-    }
-}
Index: src/Leetcode/Merge.java
===================================================================
diff --git a/src/Leetcode/Merge.java b/src/Leetcode/Merge.java
deleted file mode 100644
--- a/src/Leetcode/Merge.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,49 +0,0 @@
-package Leetcode;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 给出一个区间的集合，请合并所有重叠的区间。
-
-示例 1:
-
-输入: [[1,3],[2,6],[8,10],[15,18]]
-输出: [[1,6],[8,10],[15,18]]
-解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
-
-示例 2:
-
-输入: [[1,4],[4,5]]
-输出: [[1,5]]
-解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
-
- * @date 2020/4/17 20:08
- */
-public class Merge {
-    public int[][] merge(int[][] intervals) {
-        List<int[]> res = new ArrayList<>();
-        if (intervals.length == 0 || intervals == null) return res.toArray(new int[0][]);
-        // 对起点终点进行排序
-        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
-        int i = 0;
-        while (i < intervals.length) {
-            int left = intervals[i][0];
-            int right = intervals[i][1];
-            // 如果有重叠，循环判断哪个起点满足条件
-            while (i < intervals.length - 1 && intervals[i + 1][0] <= right) {
-                i++;
-                right = Math.max(right, intervals[i][1]);
-            }
-            // 将现在的区间放进res里面
-            res.add(new int[]{left, right});
-            // 接着判断下一个区间
-            i++;
-        }
-        return res.toArray(new int[0][]);
-    }
-}
Index: src/左神算法/基础班/Sort/MergeSort.java
===================================================================
diff --git a/src/左神算法/基础班/Sort/MergeSort.java b/src/左神算法/基础班/Sort/MergeSort.java
deleted file mode 100644
--- a/src/左神算法/基础班/Sort/MergeSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,125 +0,0 @@
-package 左神算法.基础班.Sort;
-
-import java.util.Arrays;
-
-public class MergeSort {
-
-    public static void mergeSort(int[] arr) {
-        if (arr == null || arr.length < 2) {
-            return;
-        }
-        mergeSort(arr, 0, arr.length - 1);
-    }
-
-    public static void mergeSort(int[] arr, int l, int r) {
-        if (l == r) {
-            return;
-        }
-        int mid = l + ((r - l) >> 1);
-        mergeSort(arr, l, mid);
-        mergeSort(arr, mid + 1, r);
-        merge(arr, l, mid, r);
-    }
-
-    public static void merge(int[] arr, int l, int m, int r) {
-        int[] help = new int[r - l + 1];
-        int i = 0;
-        int p1 = l;
-        int p2 = m + 1;
-        while (p1 <= m && p2 <= r) {
-            help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
-        }
-        while (p1 <= m) {
-            help[i++] = arr[p1++];
-        }
-        while (p2 <= r) {
-            help[i++] = arr[p2++];
-        }
-        for (i = 0; i < help.length; i++) {
-            arr[l + i] = help[i];
-        }
-    }
-
-    // for test
-    public static void comparator(int[] arr) {
-        Arrays.sort(arr);
-    }
-
-    // for test
-    public static int[] generateRandomArray(int maxSize, int maxValue) {
-        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
-        for (int i = 0; i < arr.length; i++) {
-            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
-        }
-        return arr;
-    }
-
-    // for test
-    public static int[] copyArray(int[] arr) {
-        if (arr == null) {
-            return null;
-        }
-        int[] res = new int[arr.length];
-        for (int i = 0; i < arr.length; i++) {
-            res[i] = arr[i];
-        }
-        return res;
-    }
-
-    // for test
-    public static boolean isEqual(int[] arr1, int[] arr2) {
-        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
-            return false;
-        }
-        if (arr1 == null && arr2 == null) {
-            return true;
-        }
-        if (arr1.length != arr2.length) {
-            return false;
-        }
-        for (int i = 0; i < arr1.length; i++) {
-            if (arr1[i] != arr2[i]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    // for test
-    public static void printArray(int[] arr) {
-        if (arr == null) {
-            return;
-        }
-        for (int i = 0; i < arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    // for test
-    public static void main(String[] args) {
-        int testTime = 500000;
-        int maxSize = 100;
-        int maxValue = 100;
-        boolean succeed = true;
-        for (int i = 0; i < testTime; i++) {
-            int[] arr1 = generateRandomArray(maxSize, maxValue);
-            int[] arr2 = copyArray(arr1);
-            mergeSort(arr1);
-            comparator(arr2);
-            if (!isEqual(arr1, arr2)) {
-                succeed = false;
-                printArray(arr1);
-                printArray(arr2);
-                break;
-            }
-        }
-        System.out.println(succeed ? "Nice!" : "Fucking fucked!");
-
-        int[] arr = generateRandomArray(maxSize, maxValue);
-        printArray(arr);
-        mergeSort(arr);
-        printArray(arr);
-
-    }
-}
Index: src/左神算法/面试重写与剑指offer/MergeSort.java
===================================================================
diff --git a/src/左神算法/面试重写与剑指offer/MergeSort.java b/src/左神算法/面试重写与剑指offer/MergeSort.java
deleted file mode 100644
--- a/src/左神算法/面试重写与剑指offer/MergeSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,129 +0,0 @@
-package 左神算法.面试重写与剑指offer;
-
-import java.util.Arrays;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 再次实现归并排序
- * @date 2020/3/19 20:44
- */
-public class MergeSort {
-
-    public static void mergeSort(int[] arr){
-        if(arr==null || arr.length<2)
-            return;
-        mergeSort(arr,0,arr.length-1);
-    }
-    private static void mergeSort(int[] arr,int start,int end){
-        if(start==end)
-            return;
-        int mid=start+((end-start)>>1); //注意这里运算符的优先级
-        mergeSort(arr,start,mid);
-        mergeSort(arr,mid+1,end);
-        merge(arr,start,end,mid);
-    }
-    private static void merge(int[]arr,int start,int end,int mid){
-        int[]help=new int[end-start+1];
-        int p1=start;
-        int p2=mid+1;
-        int index=0;
-        while(p1<=mid && p2<=end){
-            help[index++]=arr[p1]<=arr[p2] ? arr[p1++]:arr[p2++];
-        }
-        while(p1<=mid){
-            help[index++]=arr[p1++];
-        }
-        while(p2<=end){
-            help[index++]=arr[p2++];
-        }
-        for(int i=0;i<help.length;i++){
-            arr[start+i]=help[i];
-        }
-    }
-
-    // for test
-    public static void comparator(int[] arr) {
-        Arrays.sort(arr);
-    }
-
-    // for test
-    public static int[] generateRandomArray(int maxSize, int maxValue) {
-        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
-        for (int i = 0; i < arr.length; i++) {
-            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
-        }
-        return arr;
-    }
-
-    // for test
-    public static int[] copyArray(int[] arr) {
-        if (arr == null) {
-            return null;
-        }
-        int[] res = new int[arr.length];
-        for (int i = 0; i < arr.length; i++) {
-            res[i] = arr[i];
-        }
-        return res;
-    }
-
-    // for test
-    public static boolean isEqual(int[] arr1, int[] arr2) {
-        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
-            return false;
-        }
-        if (arr1 == null && arr2 == null) {
-            return true;
-        }
-        if (arr1.length != arr2.length) {
-            return false;
-        }
-        for (int i = 0; i < arr1.length; i++) {
-            if (arr1[i] != arr2[i]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    // for test
-    public static void printArray(int[] arr) {
-        if (arr == null) {
-            return;
-        }
-        for (int i = 0; i < arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    // for test
-    public static void main(String[] args) {
-        int testTime = 500000;
-        int maxSize = 100;
-        int maxValue = 100;
-        boolean succeed = true;
-        for (int i = 0; i < testTime; i++) {
-            int[] arr1 = generateRandomArray(maxSize, maxValue);
-            int[] arr2 = copyArray(arr1);
-            mergeSort(arr1);
-            comparator(arr2);
-            if (!isEqual(arr1, arr2)) {
-                succeed = false;
-                printArray(arr1);
-                printArray(arr2);
-                break;
-            }
-        }
-        System.out.println(succeed ? "Nice!" : "Fucking fucked!");
-
-        int[] arr = generateRandomArray(maxSize, maxValue);
-        printArray(arr);
-        mergeSort(arr);
-        printArray(arr);
-
-    }
-
-}
Index: src/算法重写练习/排序/MergeSort.java
===================================================================
diff --git a/src/算法重写练习/排序/MergeSort.java b/src/算法重写练习/排序/MergeSort.java
deleted file mode 100644
--- a/src/算法重写练习/排序/MergeSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,135 +0,0 @@
-package 算法重写练习.排序;
-
-import java.util.Arrays;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2020/6/28 23:34
- */
-public class MergeSort {
-
-    public static void mergeSort(int[] nums){
-        if(nums==null || nums.length<2)
-            return;
-        mergeSort(nums,0,nums.length-1);
-
-
-    }
-
-    private static void mergeSort(int[] nums,int left,int right){
-        if(left<right){
-            int mid=(left+right)>>>1;
-            mergeSort(nums,left,mid);
-            mergeSort(nums,mid+1,right);
-            merge(nums,left,right);
-        }
-    }
-
-    private static void merge(int[] nums,int left,int right){
-        int len=right-left+1;
-        int mid=(left+right)>>>1;
-        int [] help=new int[len];
-        int l=left,r=mid+1;
-        int index=0;
-        while(l<=mid && r<=right){
-            help[index++]=nums[l]<=nums[r] ? nums[l++] : nums[r++];
-
-        }
-        while(l<=mid){
-            help[index++]=nums[l++];
-        }
-        while(r<=right){
-            help[index++]=nums[r++];
-        }
-        index=0;
-        for(int i=0;i<len;i++){
-            nums[i+left]=help[i];
-        }
-    }
-
-
-    // for test
-    public static void comparator(int[] arr) {
-        Arrays.sort(arr);
-    }
-
-    // for test
-    public static int[] generateRandomArray(int maxSize, int maxValue) {
-        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
-        for (int i = 0; i < arr.length; i++) {
-            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
-        }
-        return arr;
-    }
-
-    // for test
-    public static int[] copyArray(int[] arr) {
-        if (arr == null) {
-            return null;
-        }
-        int[] res = new int[arr.length];
-        for (int i = 0; i < arr.length; i++) {
-            res[i] = arr[i];
-        }
-        return res;
-    }
-
-    // for test
-    public static boolean isEqual(int[] arr1, int[] arr2) {
-        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
-            return false;
-        }
-        if (arr1 == null && arr2 == null) {
-            return true;
-        }
-        if (arr1.length != arr2.length) {
-            return false;
-        }
-        for (int i = 0; i < arr1.length; i++) {
-            if (arr1[i] != arr2[i]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    // for test
-    public static void printArray(int[] arr) {
-        if (arr == null) {
-            return;
-        }
-        for (int i = 0; i < arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    // for test
-    public static void main(String[] args) {
-        int testTime = 500000;
-        int maxSize = 100;
-        int maxValue = 100;
-        boolean succeed = true;
-        for (int i = 0; i < testTime; i++) {
-            int[] arr1 = generateRandomArray(maxSize, maxValue);
-            int[] arr2 = copyArray(arr1);
-            mergeSort(arr1);
-            comparator(arr2);
-            if (!isEqual(arr1, arr2)) {
-                succeed = false;
-                printArray(arr1);
-                printArray(arr2);
-                break;
-            }
-        }
-        System.out.println(succeed ? "Nice!" : "Fucking fucked!");
-
-        int[] arr = generateRandomArray(maxSize, maxValue);
-        printArray(arr);
-        mergeSort(arr);
-        printArray(arr);
-
-    }
-}
Index: src/韩顺平算法与数据结构/datastructure/sort/MergeSort.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/sort/MergeSort.java b/src/韩顺平算法与数据结构/datastructure/sort/MergeSort.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/sort/MergeSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,108 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.sort;
-
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Date;
-
-public class MergeSort {
-    public static void main(String[] args) {
-//int arr[] = { 8, 4, 5, 7, 1, 3, 6, 2 }; //
-
-        //测试快排的执行速度
-        // 创建要给80000个的随机的数组
-        int[] arr = new int[80000000];
-        for (int i = 0; i < 80000000; i++) {
-            arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数
-        }
-        System.out.println("排序前");
-        Date data1 = new Date();
-        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
-        String date1Str = simpleDateFormat.format(data1);
-        System.out.println("排序前的时间是=" + date1Str);
-
-        int temp[] = new int[arr.length]; //归并排序需要一个额外空间
-        mergeSort(arr, 0, arr.length - 1, temp);
-
-        Date data2 = new Date();
-        String date2Str = simpleDateFormat.format(data2);
-      System.out.println("排序前的时间是=" + date2Str);
-
-       // System.out.println("归并排序后=" + Arrays.toString(arr));
-
-    }
-
-    /**
-     *
-     * @param arr:排序的原始数组
-     * @param left：左边有序序列的初始索引
-     * @param right
-     * @param temp
-     */
-    public static void mergeSort(int[] arr,int left,int right,int[] temp)
-    {
-        if(left<right)
-        {
-            int mid=(left+right)/2;//中间索引
-            //向左递归分解
-            mergeSort(arr,left,mid,temp);
-            //向右递归进行分解
-            mergeSort(arr,mid+1,right,temp);
-            //合并
-            merge(arr,left,mid,right,temp);
-
-        }
-    }
-    /**
-     *
-     * @param arr:排序的原始数组
-     * @param left：左边有序序列的初始索引
-     * @param mid：中间索引
-     *
-     * @param right 右边有序序列的最后索引
-     * @param temp:做中转的临时数组
-     */
-    public static void merge(int []arr,int left,int mid,int right,int[] temp)
-    {
-        int l=left;
-        int j=mid+1;
-        int t=0;
-        //把左右两边的数据按照规则填充到temp数组，直到左右两边的有序序列，有一边处理完毕为止
-        while(l<=mid && j<=right) {
-            if (arr[l] < arr[j]) {
-                temp[t] = arr[l];
-                t++;
-                l++;
-
-            } else {
-                temp[t] = arr[j];
-                t++;
-                j++;
-
-            }
-        }
-
-        //把后续的数据添加到数组后
-        while(l<=mid)
-        {
-            temp[t]=arr[l];
-            l++;
-            t++;
-        }
-        while(j<=right)
-        {
-            temp[t]=arr[j];
-            t++;
-            j++;
-        }
-        //将临时数组的内容拷贝到原来的数组中
-        t=0;
-        int tempLeft=left;
-        while(tempLeft<=right)
-        {
-            arr[tempLeft]=temp[t];
-            tempLeft++;
-            t++;
-        }
-
-    }
-}
Index: src/左神算法/高频面试题/动态规划与递归/MergeStones.java
===================================================================
diff --git a/src/左神算法/高频面试题/动态规划与递归/MergeStones.java b/src/左神算法/高频面试题/动态规划与递归/MergeStones.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/动态规划与递归/MergeStones.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,108 +0,0 @@
-package 左神算法.高频面试题.动态规划与递归;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。
-
-每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。
-
-找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。
-
-
-
-示例 1：
-
-输入：stones = [3,2,4,1], K = 2
-输出：20
-解释：
-从 [3, 2, 4, 1] 开始。
-合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。
-合并 [4, 1]，成本为 5，剩下 [5, 5]。
-合并 [5, 5]，成本为 10，剩下 [10]。
-总成本 20，这是可能的最小值。
-
-示例 2：
-
-输入：stones = [3,2,4,1], K = 3
-输出：-1
-解释：任何合并操作后，都会剩下 2 堆，我们无法再进行合并。所以这项任务是不可能完成的。.
-
-示例 3：
-
-输入：stones = [3,5,1,2,6], K = 3
-输出：25
-解释：
-从 [3, 5, 1, 2, 6] 开始。
-合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。
-合并 [3, 8, 6]，成本为 17，剩下 [17]。
-总成本 25，这是可能的最小值。
-
-
-
-提示：
-
-1 <= stones.length <= 30
-2 <= K <= 30
-1 <= stones[i] <= 100
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/minimum-cost-to-merge-stones
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/2/8 9:44
- */
-public class MergeStones {
-
-    public static int mergeStones(int[] stones, int K) {
-        if(K>stones.length)
-            return 0;
-        int len=stones.length;
-        while(len!=0 && len!=K && K!=2){
-            len-=(K-1);
-            if(len<K)
-                return -1;
-        }
-        return process(stones,K,stones.length-1);
-    }
-    //合并石头递归版本，超时了！！！
-    public static int process(int[] arr,int k,int end){//start,end表示数组饿开始和结束下标
-
-
-        if(k==end+1){
-            int res=0;
-
-            for(int i=0;i<=end;i++)
-                res+=arr[i];
-            return res;
-        }
-        int ans=Integer.MAX_VALUE;
-        for(int i=0;i<=end-k+1;i++){
-            int m=i;
-            int res=0;
-
-            for(int j=i;j<k+i;j++){
-                res+=arr[j];
-            }
-            int[] stones=new int[end-k+2];
-            for(int l=0;l<m;l++)
-            {
-                stones[l]=arr[l];
-            }
-            stones[m]=res;
-            for(int l=m+1;l<=end-k+1;l++){
-                stones[l]=arr[l+k-1];
-            }
-            ans=Math.min(ans,res+process(stones,k,end-k+1));
-
-        }
-        return ans;
-    }
-
-    public static void main(String[] args) {
-        int[] arr=new int[]{26,88,89,24,74,73,69,2,59,58,89,75,94
-
-};
-        System.out.println(mergeStones(arr,3));
-    }
-}
Index: src/JUC/MetaspaceOOM/MetaspaceOOMDemo.java
===================================================================
diff --git a/src/JUC/MetaspaceOOM/MetaspaceOOMDemo.java b/src/JUC/MetaspaceOOM/MetaspaceOOMDemo.java
deleted file mode 100644
--- a/src/JUC/MetaspaceOOM/MetaspaceOOMDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,37 +0,0 @@
-package JUC.MetaspaceOOM;
-
-import net.sf.cglib.proxy.Enhancer;
-import net.sf.cglib.proxy.MethodInterceptor;
-import net.sf.cglib.proxy.MethodProxy;
-
-import java.lang.reflect.Method;
-
-public class MetaspaceOOMDemo {
-
-    static class OOMTest{
-
-    }
-
-    public static void main(String[] args) {
-
-        int i=0;
-        try{
-            while(true){
-                Enhancer enhancer=new Enhancer();
-                enhancer.setSuperclass(OOMTest.class);
-                enhancer.setUseCache(false);
-                enhancer.setCallback(new MethodInterceptor() {
-                    @Override
-                    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
-                        return proxy.invokeSuper(obj,args);
-                    }
-                });
-                i++;
-            }
-        }catch (Exception e)
-        {
-            System.out.println("=-=============="+i);
-            e.printStackTrace();
-        }
-    }
-}
Index: src/重温设计模式/行为模式/责任链模式/示例/Middleware.java
===================================================================
diff --git a/src/重温设计模式/行为模式/责任链模式/示例/Middleware.java b/src/重温设计模式/行为模式/责任链模式/示例/Middleware.java
deleted file mode 100644
--- a/src/重温设计模式/行为模式/责任链模式/示例/Middleware.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,27 +0,0 @@
-package 重温设计模式.行为模式.责任链模式.示例;
-
-import javax.swing.*;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 基础验证接口
- * @date 2021/5/14 21:41
- */
-public abstract class Middleware {
-    private Middleware next;
-
-    public Middleware linkedWith(Middleware next){
-        this.next = next;
-        return next;
-    }
-
-    public abstract boolean check(String email,String password);
-
-    public boolean checkNext(String email,String password){
-        if(this.next == null){
-            return true;
-        }
-        return next.check(email,password);
-    }
-}
Index: src/韩顺平算法与数据结构/datastructure/recursion/MiGong.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/recursion/MiGong.java b/src/韩顺平算法与数据结构/datastructure/recursion/MiGong.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/recursion/MiGong.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,76 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.recursion;
-
-public class MiGong {
-    public static void main(String[] args) {
-        //设置迷宫局部
-        int[][] m=new int[8][7];
-
-        for(int i=0;i<7;i++)
-        {
-            m[0][i]=1;
-            m[7][i]=1;
-        }
-        for(int j=0;j<8;j++)
-        {
-            m[j][0]=1;
-            m[j][6]=1;
-        }
-        m[3][1]=m[3][2]=1;
-        System.out.println("地图的情况");
-        for (int i = 0; i < 8; i++) {
-            for (int j = 0; j < 7; j++) {
-                System.out.print(m[i][j] + " ");
-            }
-            System.out.println();
-        }
-
-        //使用递归回溯给小球找路
-        setWay(m, 1, 1);
-        //setWay2(map, 1, 1);
-
-        //输出新的地图, 小球走过，并标识过的递归
-        System.out.println("小球走过，并标识过的 地图的情况");
-        for (int i = 0; i < 8; i++) {
-            for (int j = 0; j < 7; j++) {
-                System.out.print(m[i][j] + " ");
-            }
-            System.out.println();
-        }
-
-    }
-
-
-    //设置小球的行走路线
-    //map:迷宫的路线，ij小球的初始位置
-    //int[][]=0:说明还没有该点还没有走；=1；说明是墙；in=2；说明通路可以走，3，表示该点已经走过，但是走不通
-    //int[6][5]==2;说明通路已经找到
-    //确定小球的行走路线：这个行走策略可以自己来安排。下-》右-》左-上的顺序
-    public static boolean setWay(int[][] map,int i,int j) {
-        if (map[6][5] == 2) {
-            return true;//通路已经找到
-        } else {
-            if (map[i][j] == 0) {//说明该点还没有走
-                map[i][j] = 2;//假设该点可以走的同
-                //继续往下走
-                if (setWay(map, i, j + 1)) {
-                    return true;
-                } else if (setWay(map, i + 1, j)) {
-                    return true;
-                } else if (setWay(map, i - 1, j)) {
-                    return true;
-                } else if (setWay(map, i, j - 1)) {
-                    return true;
-                } else {
-                    map[i][j] = 3;
-                    return false;
-                }
-
-            } else { //map[i][j]=1,2,3
-                return false;
-
-            }
-        }
-
-
-    }
-}
\ No newline at end of file
Index: src/Gof/decorator/MikeCoffee.java
===================================================================
diff --git a/src/Gof/decorator/MikeCoffee.java b/src/Gof/decorator/MikeCoffee.java
deleted file mode 100644
--- a/src/Gof/decorator/MikeCoffee.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,11 +0,0 @@
-package Gof.decorator;
-
-public class MikeCoffee extends Decorator{
-
-    public MikeCoffee(Drink drink)
-    {
-        super(drink);
-        setDes("加牛奶");
-        setPrice(3.0f);
-    }
-}
Index: src/左神算法/基础班/动态规划与递归/MinPath.java
===================================================================
diff --git a/src/左神算法/基础班/动态规划与递归/MinPath.java b/src/左神算法/基础班/动态规划与递归/MinPath.java
deleted file mode 100644
--- a/src/左神算法/基础班/动态规划与递归/MinPath.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,78 +0,0 @@
-package 左神算法.基础班.动态规划与递归;
-
-/**
- * 给你一个二维数组，二维数组中的每个数都是正数，要求从左上角走到右下角，每一步只能向下或者向右，沿途经过的数字要累加起来，返回最小的路径和。
- */
-public class MinPath {
-
-    public static int minPath1(int[][] matrix)
-    {
-        return walk(matrix,0,0);
-    }
-
-    //从（i,j)出发，到达最右下角位置，最短路径和（暴力枚举，存在重复计算）
-    public static int walk(int[][]matrix,int i,int j)
-    {
-        if(i==matrix.length-1 && j==matrix[0].length-1)
-            return matrix[i][j];
-        if(i==matrix.length-1)
-            return matrix[i][j]+walk(matrix,i,j+1);
-        if(j==matrix[0].length-1)
-            return matrix[i][j]+walk(matrix,i+1,j);
-        //一般情况：
-        int right=walk(matrix,i,j+1);//右边位置到最右下角的最短路径和
-        int down=walk(matrix,i+1,j);//下边位置到最右下角的最短路径和
-        return matrix[i][j]+Math.min(right,down);
-    }
-
-    //动态规划版本
-    public static int minPath2(int[][]matrix)
-    {
-        if(matrix==null || matrix.length==0 || matrix[0]==null || matrix[0].length==0)
-            return 0;
-        //根据可变参数构建dp数组
-        int row =matrix.length;
-        int col=matrix[0].length;
-        int [][] dp=new int[row][col];
-        dp[row-1][col-1]=matrix[row-1][col-1];
-        for(int i=row-1;i>=1;i--)
-        {
-            dp[i-1][col-1]=dp[i][col-1]+matrix[i-1][col-1];
-        }
-        for(int j=col-1;j>0;j--)
-        {
-            dp[row-1][j-1]=dp[row-1][j]+matrix[row-1][j-1];
-        }
-        for(int i=row-2;i>=0;i--)
-        {
-            for(int j=col-2;j>=0;j--)
-            {
-                dp[i][j]=Math.min(dp[i+1][j],dp[i][j+1])+matrix[i][j];
-            }
-        }
-        return dp[0][0];
-    }
-
-    // for test
-    public static int[][] generateRandomMatrix(int rowSize, int colSize) {
-        if (rowSize < 0 || colSize < 0) {
-            return null;
-        }
-        int[][] result = new int[rowSize][colSize];
-        for (int i = 0; i != result.length; i++) {
-            for (int j = 0; j != result[0].length; j++) {
-                result[i][j] = (int) (Math.random() * 10);
-            }
-        }
-        return result;
-    }
-    public static void main(String[] args) {
-        int[][] m = { { 1, 3, 5, 9 }, { 8, 1, 3, 4 }, { 5, 0, 6, 1 }, { 8, 8, 4, 0 } };
-        System.out.println(minPath1(m));
-        System.out.println(minPath2(m));
-
-        m = generateRandomMatrix(6, 7);
-        System.out.println(minPath1(m));
-        System.out.println(minPath2(m));
-    }
-}
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
deleted file mode 100644
--- a/.idea/misc.xml	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,19 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="MavenProjectsManager">
-    <option name="originalFiles">
-      <list>
-        <option value="$PROJECT_DIR$/sourceResearch/pom.xml" />
-        <option value="$PROJECT_DIR$/strategy/pom.xml" />
-      </list>
-    </option>
-    <option name="ignoredFiles">
-      <set>
-        <option value="$PROJECT_DIR$/strategyDemo/pom.xml" />
-      </set>
-    </option>
-  </component>
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" default="true" project-jdk-name="1.8" project-jdk-type="JavaSDK">
-    <output url="file://$PROJECT_DIR$/out" />
-  </component>
-</project>
\ No newline at end of file
Index: .idea/modules.xml
===================================================================
diff --git a/.idea/modules.xml b/.idea/modules.xml
deleted file mode 100644
--- a/.idea/modules.xml	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="ProjectModuleManager">
-    <modules>
-      <module fileurl="file://$PROJECT_DIR$/exercise2.iml" filepath="$PROJECT_DIR$/exercise2.iml" />
-      <module fileurl="file://$PROJECT_DIR$/sourceResearch/sourceResearch.iml" filepath="$PROJECT_DIR$/sourceResearch/sourceResearch.iml" />
-    </modules>
-  </component>
-</project>
\ No newline at end of file
Index: src/Gof/momentor/Momentor.java
===================================================================
diff --git a/src/Gof/momentor/Momentor.java b/src/Gof/momentor/Momentor.java
deleted file mode 100644
--- a/src/Gof/momentor/Momentor.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,18 +0,0 @@
-package Gof.momentor;
-
-public class Momentor {
-
-    private String state;
-
-    public Momentor(String state) {
-        this.state = state;
-    }
-
-    public String getState() {
-        return state;
-    }
-
-    public void setState(String state) {
-        this.state = state;
-    }
-}
Index: src/左神算法/基础班/动态规划与递归/MoneyProblem.java
===================================================================
diff --git a/src/左神算法/基础班/动态规划与递归/MoneyProblem.java b/src/左神算法/基础班/动态规划与递归/MoneyProblem.java
deleted file mode 100644
--- a/src/左神算法/基础班/动态规划与递归/MoneyProblem.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,75 +0,0 @@
-package 左神算法.基础班.动态规划与递归;
-
-/**
- * 题目描述：给你一个数组 arr,和一个整数aim,如果可以选择任意arr的数字，能不能累加得到aim,返回true or false
- */
-public class MoneyProblem {
-
-    //暴力递归版本,i表示当前数组的元素的位子，sum表示当前计算的和，
-    public static boolean process1(int[] arr,int i,int sum,int aim)
-    {
-        if(sum==aim)
-            return true;
-        if(i==arr.length)
-            return false;
-        return process1(arr,i+1,sum,aim) || process1(arr,i+1,sum+arr[i],aim);//和子序列问题类似，要或者不要当前的值，在不选择当前i位置的值时
-                                                                                          //sum不变，选择了当前i位置的值时，i+1位置的sum变为sum+arr[i]
-    }
-    public static boolean money1(int[] arr,int aim)
-    {
-        return process1(arr,0,0,aim);
-    }
-
-    //动态规划版本
-    public static boolean money2(int[] arr, int aim) {
-        boolean[][] dp = new boolean[arr.length + 1][aim + 1];
-        for (int i = 0; i < dp.length; i++) {
-            dp[i][aim] = true;
-        }
-        for (int i = arr.length - 1; i >= 0; i--) {
-            for (int j = aim - 1; j >= 0; j--) {
-                dp[i][j] = dp[i + 1][j];
-                if (j + arr[i] <= aim) {
-                    dp[i][j] = dp[i][j] || dp[i + 1][j + arr[i]];
-                }
-            }
-        }
-        return dp[0][0];
-    }
-
-    //动态规划2，假设只用正数
-    public static boolean money3(int[] arr,int aim)
-    {
-        int count=0;
-        for(int i=0;i<arr.length;i++)
-        {
-            count+=arr[i];
-        }
-        if(count<aim)
-            return false;
-        boolean[][] dp=new boolean[arr.length+1][count+1];
-        for(int i=0;i<=count;i++)
-        {
-            if(i!=aim)
-            dp[arr.length][i]=false;
-            else
-                dp[arr.length][i]=true;
-        }
-        for(int i=arr.length-1;i>=0;i--)
-        {
-            for(int j=0;j<=count;j++)
-            {
-                dp[i][j]=dp[i+1][j] || dp[i][j+arr[i]];
-            }
-        }
-        return dp[0][0];
-    }
-
-    public static void main(String[] args) {
-        int[] arr = { 1, 4, 8 ,2,3,4,54,5,3};
-        int aim = 65;
-        System.out.println(money1(arr, aim));
-        System.out.println(money2(arr, aim));
-    }
-
-}
Index: src/面试相关/面试之出奇制胜策略/MonitorDemo.java
===================================================================
diff --git a/src/面试相关/面试之出奇制胜策略/MonitorDemo.java b/src/面试相关/面试之出奇制胜策略/MonitorDemo.java
deleted file mode 100644
--- a/src/面试相关/面试之出奇制胜策略/MonitorDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,85 +0,0 @@
-package 面试相关.面试之出奇制胜策略;
-
-import com.google.common.util.concurrent.ListeningExecutorService;
-import com.google.common.util.concurrent.Monitor;
-import com.google.common.util.concurrent.MoreExecutors;
-
-import java.util.LinkedList;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 使用google .guava类库实现消费者，生产者问题
- * @date 2020/2/15 9:27
- */
-public class MonitorDemo {
-    private LinkedList<Integer> buffer = new LinkedList<>();
-    //最大容量
-    private static final int MAX = 10;
-    //记录生产的编号
-    private static AtomicInteger count = new AtomicInteger(0);
-
-    private Monitor monitor = new Monitor();
-
-    //生产者
-    public void produce(int value) {
-        try {
-            monitor.enterWhen(monitor.newGuard(() -> {
-                return buffer.size() < MAX;
-            }));
-            buffer.addLast(value);
-        } catch (InterruptedException e) {
-            e.printStackTrace();
-        } finally {
-            monitor.leave();
-            ;
-            System.out.println("生产完毕，缓冲区大小" + buffer.size());
-        }
-    }
-
-    //消费者
-    public int consume() {
-        try {
-            monitor.enterWhen(monitor.newGuard(() -> {
-                return buffer.size() > 0;
-            }));
-            return buffer.removeFirst();
-        } catch (InterruptedException e) {
-            e.printStackTrace();
-            throw new RuntimeException(e);
-
-        } finally {
-            monitor.leave();
-            System.out.println("消费完毕，缓冲区大小：" + buffer.size());
-        }
-    }
-
-    public static void main(String[] args) {
-        MonitorDemo monitorDemo = new MonitorDemo();
-        ExecutorService executorService = Executors.newFixedThreadPool(6);
-        //将线程池包装
-        ListeningExecutorService listeningExecutorService = MoreExecutors.listeningDecorator(executorService);
-        //向线程池中放入三个消费者
-        for(int i=0;i<3;i++){
-            listeningExecutorService.submit(()->{
-                while(true){
-                    int res = count.getAndAdd(1);
-                    monitorDemo.produce(res);
-                    System.out.println("生产："+res);
-                }
-            });
-        }
-        for(int i=0;i<3;i++){
-            listeningExecutorService.submit(()->{
-                while(true){
-
-                    int consume = monitorDemo.consume();
-                    System.out.println("消费："+consume);
-                }
-            });
-        }
-    }
-}
Index: src/左神算法/基础班/moris/MorisTraversal.java
===================================================================
diff --git a/src/左神算法/基础班/moris/MorisTraversal.java b/src/左神算法/基础班/moris/MorisTraversal.java
deleted file mode 100644
--- a/src/左神算法/基础班/moris/MorisTraversal.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,134 +0,0 @@
-package 左神算法.基础班.moris;
-
-/**
- * moris遍历的方式实现二叉树的前序，中序，后序遍历，空间复杂度可以控制在O(N)
- */
-public class MorisTraversal {
-
-    public static class Node{
-        public int value;
-        Node left;
-        Node right;
-
-        public Node(int value) {
-            this.value = value;
-        }
-    }
-
-    public static void morisPre(Node head)
-    {
-      if(head==null)
-          return;
-      Node cur1=head;
-      Node cur2=null;
-      while(cur1!=null)
-      {
-          cur2=cur1.left;
-          if(cur2!=null){
-              while(cur2.right!=null && cur2.right!=cur1)
-              {
-                  cur2=cur2.right;
-              }
-              if(cur2.right==null) {
-                  cur2.right = cur1;
-                  System.out.print(cur1.value+" ");//有左子树的的结点，第一次到达时便打印
-                  cur1 = cur1.left;
-                  continue;
-              }else{
-                  cur2.right=null;
-                  }
-          }else{
-              System.out.print(cur1.value+" ");//没有左子树的结点到到便打印
-          }
-          cur1=cur1.right;
-      }
-        System.out.println();
-    }
-
-    public static void morisIn(Node head)
-    {
-        if(head==null)
-            return;
-        Node cur1=head;
-        Node cur2=null;
-        while(cur1!=null)
-        {
-            cur2=cur1.left;
-            if(cur2!=null)
-            {
-                while(cur2.right!=null && cur2.right!=cur1)
-                {
-                    cur2=cur2.right;
-                }
-                if(cur2.right==null)
-                {
-                    cur2.right=cur1;
-                    cur1=cur1.left;
-                    continue;
-                }else {
-                    cur2.right=null;
-                }
-            }
-            System.out.print(cur1.value+" ");//没有加else实现了有左子树的结点第二次到达时打印，同时没有左子树的结点直接打印
-            cur1=cur1.right;
-        }
-        System.out.println();
-    }
-
-    public static void morisPos(Node head)
-    {
-      if(head==null)
-          return;
-      Node cur1=head;
-      Node cur2=null;
-      while(cur1!=null)
-      {
-          cur2=cur1.left;
-          if(cur2!=null)
-          {
-              while(cur2.right!=null && cur2.right!=cur1)
-                  cur2=cur2.right;
-              if(cur2.right==null)
-              {
-                  cur2.right=cur1;
-                  cur1=cur1.left;
-                  continue;
-              }else{
-                  cur2.right=null;
-                  printEdge(cur1.left);
-              }
-          }
-          cur1=cur1.right;
-      }
-      printEdge(head);
-      System.out.println();
-    }
-
-
-   public static void printEdge(Node node)
-   {
-       Node tail=reverse(node);
-       Node cur=tail;
-       while(cur!=null)
-       {
-           System.out.println(cur.value+" ");
-           cur=cur.right;
-       }
-       reverse(tail);//两次反转，不改变原来的结构
-   }
-    //反转右子树，---》在反转的时候通常需要两个额外的结点，一个用于保存下一个节点，一个用于表示上一个结点
-    public static Node reverse(Node from)
-    {
-        Node pre=null;
-        Node next=null;
-        while(from!=null)
-        {
-            next=from.right;//保存右节点
-            from.right=pre;
-            pre=from;
-            from=next;
-        }
-        return pre;
-    }
-
-}
Index: src/左神算法/进阶班一/moris/MorisTraversal.java
===================================================================
diff --git a/src/左神算法/进阶班一/moris/MorisTraversal.java b/src/左神算法/进阶班一/moris/MorisTraversal.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/moris/MorisTraversal.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,134 +0,0 @@
-package 左神算法.进阶班一.moris;
-
-/**
- * moris遍历的方式实现二叉树的前序，中序，后序遍历，空间复杂度可以控制在O(N)
- */
-public class MorisTraversal {
-
-    public static class Node{
-        public int value;
-        Node left;
-        Node right;
-
-        public Node(int value) {
-            this.value = value;
-        }
-    }
-
-    public static void morisPre(Node head)
-    {
-      if(head==null)
-          return;
-      Node cur1=head;
-      Node cur2=null;
-      while(cur1!=null)
-      {
-          cur2=cur1.left;
-          if(cur2!=null){
-              while(cur2.right!=null && cur2.right!=cur1)
-              {
-                  cur2=cur2.right;
-              }
-              if(cur2.right==null) {
-                  cur2.right = cur1;
-                  System.out.print(cur1.value+" ");//有左子树的的结点，第一次到达时便打印
-                  cur1 = cur1.left;
-                  continue;
-              }else{
-                  cur2.right=null;
-                  }
-          }else{
-              System.out.print(cur1.value+" ");//没有左子树的结点到到便打印
-          }
-          cur1=cur1.right;
-      }
-        System.out.println();
-    }
-
-    public static void morisIn(Node head)
-    {
-        if(head==null)
-            return;
-        Node cur1=head;
-        Node cur2=null;
-        while(cur1!=null)
-        {
-            cur2=cur1.left;
-            if(cur2!=null)
-            {
-                while(cur2.right!=null && cur2.right!=cur1)
-                {
-                    cur2=cur2.right;
-                }
-                if(cur2.right==null)
-                {
-                    cur2.right=cur1;
-                    cur1=cur1.left;
-                    continue;
-                }else {
-                    cur2.right=null;
-                }
-            }
-            System.out.print(cur1.value+" ");//没有加else实现了有左子树的结点第二次到达时打印，同时没有左子树的结点直接打印
-            cur1=cur1.right;
-        }
-        System.out.println();
-    }
-
-    public static void morisPos(Node head)
-    {
-      if(head==null)
-          return;
-      Node cur1=head;
-      Node cur2=null;
-      while(cur1!=null)
-      {
-          cur2=cur1.left;
-          if(cur2!=null)
-          {
-              while(cur2.right!=null && cur2.right!=cur1)
-                  cur2=cur2.right;
-              if(cur2.right==null)
-              {
-                  cur2.right=cur1;
-                  cur1=cur1.left;
-                  continue;
-              }else{
-                  cur2.right=null;
-                  printEdge(cur1.left);
-              }
-          }
-          cur1=cur1.right;
-      }
-      printEdge(head);
-      System.out.println();
-    }
-
-
-   public static void printEdge(Node node)
-   {
-       Node tail=reverse(node);
-       Node cur=tail;
-       while(cur!=null)
-       {
-           System.out.println(cur.value+" ");
-           cur=cur.right;
-       }
-       reverse(tail);//两次反转，不改变原来的结构
-   }
-    //反转右子树，---》在反转的时候通常需要两个额外的结点，一个用于保存下一个节点，一个用于表示上一个结点
-    public static Node reverse(Node from)
-    {
-        Node pre=null;
-        Node next=null;
-        while(from!=null)
-        {
-            next=from.right;//保存右节点
-            from.right=pre;
-            pre=from;
-            from=next;
-        }
-        return pre;
-    }
-
-}
Index: src/左神算法/高频面试题/数组问题/Most_EOR_没看懂.java
===================================================================
diff --git a/src/左神算法/高频面试题/数组问题/Most_EOR_没看懂.java b/src/左神算法/高频面试题/数组问题/Most_EOR_没看懂.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/数组问题/Most_EOR_没看懂.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,105 +0,0 @@
-package 左神算法.高频面试题.数组问题;
-
-import java.util.HashMap;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 定义数组的异或和的概念，数组所有的数异或起来，得到的结果叫做数组的异或和。比如数组[3,2,1]异或和是3^2^1=0;
- * 给定一个数组arr,你可以任意把arr分成很多不相容（也就是不相交）的子数组，你的目的是：分出来的子数组中，异或和为0的子数组最多，
- * 返回分出来的子数组中异或和为0的子数组最大是多少.（这是一个关于子数组问题的动态规划）
- * @date 2020/1/4 13:41
- */
-public class Most_EOR_没看懂 {
-
-    public static int mostEOR(int[] arr){
-        if(arr==null || arr.length==0){
-            return 0;
-        }
-        int res=0;
-        int[] dp=new int[arr.length];
-        HashMap<Integer,Integer> map=new HashMap<>();//记录以数组中每一个位置结尾的数组中异或和为0的子数组的个数
-        map.put(0,-1);
-        int xor=0;
-        for(int i=0;i<arr.length;i++){
-            xor^=arr[i];
-            if(map.containsKey(xor)){
-                int pre=map.get(xor);
-                dp[i]=pre==-1?1:(dp[pre]+1);
-
-            }
-            if(i>0){
-                dp[i]=Math.max(dp[i-1],dp[i]);
-            }
-            map.put(xor,i);
-            res=Math.max(res,dp[i]);
-        }
-        return res;
-    }
-     //一般做法
-    public static int comparator(int[] arr) {
-        if (arr == null || arr.length == 0) {
-            return 0;
-        }
-        int[] eors = new int[arr.length];
-        int eor = 0;
-        for (int i = 0; i < arr.length; i++) {
-            eor ^= arr[i];
-            eors[i] = eor;
-        }
-        int[] mosts = new int[arr.length];
-        mosts[0] = arr[0] == 0 ? 1 : 0;
-        for (int i = 1; i < arr.length; i++) {
-            mosts[i] = eors[i] == 0 ? 1 : 0;
-            for (int j = 0; j < i; j++) {
-                if ((eors[i] ^ eors[j]) == 0) {
-                    mosts[i] = Math.max(mosts[i], mosts[j] + 1);
-                }
-            }
-            mosts[i] = Math.max(mosts[i], mosts[i - 1]);
-        }
-        return mosts[mosts.length - 1];
-    }
-
-    // for test
-    public static int[] generateRandomArray(int maxSize, int maxValue) {
-        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
-        for (int i = 0; i < arr.length; i++) {
-            arr[i] = (int) ((maxValue + 1) * Math.random());
-        }
-        return arr;
-    }
-
-    // for test
-    public static void printArray(int[] arr) {
-        if (arr == null) {
-            return;
-        }
-        for (int i = 0; i < arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-        int testTime = 500000;
-        int maxSize = 300;
-        int maxValue = 100;
-        boolean succeed = true;
-        for (int i = 0; i < testTime; i++) {
-            int[] arr = generateRandomArray(maxSize, maxValue);
-            int res = mostEOR(arr);
-            int comp = comparator(arr);
-            if (res != comp) {
-                succeed = false;
-                printArray(arr);
-                System.out.println(res);
-                System.out.println(comp);
-                break;
-            }
-        }
-        System.out.println(succeed ? "Nice!" : "Fucking fucked!");
-    }
-
-
-}
Index: src/左神算法/高频面试题/十一/Most_XOR.java
===================================================================
diff --git a/src/左神算法/高频面试题/十一/Most_XOR.java b/src/左神算法/高频面试题/十一/Most_XOR.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/十一/Most_XOR.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,36 +0,0 @@
-package 左神算法.高频面试题.十一;
-
-import java.util.HashMap;
-
-/**
- * 给出n个数，问最多有多少个不重叠的非空区间，使得每个区间内数字的xor都等于0.
- */
-public class Most_XOR {
-
-    public static int maxXor(int[] arr){
-        if(arr==null || arr.length==0)
-            return 0;
-        int [] mosts=new int[arr.length];//记录以i位置结尾的情况下，能够划分的最大个数
-        int xor=0;
-        HashMap<Integer,Integer>map=new HashMap<>();
-        map.put(0,-1);//为了预防错过异或和本身就是0的情况，在map中提前塞一个记录（0，-1），表示异或和为0的点最近出现在-1位置，
-        int ans=0;
-        for(int i=0;i<arr.length;i++){
-            xor^=arr[i];
-            if(map.containsKey(xor)){
-                int pre=map.get(xor);
-                mosts[i]=pre==-1 ? 1:mosts[pre]+1;
-            }
-            if(i>0){
-                mosts[i]=Math.max(mosts[i],mosts[i-1]);//随着i的增大，mosts[i]只增不减，所以和mosts[i-1]取最大值
-            }
-            map.put(xor,i);
-            ans=Math.max(ans,mosts[i]);
-        }
-        return ans;
-    }
-    public static void main(String[] args) {
-        int[] test = { 3, 0, 2, 2,2,2,2,2,2,2,2,2,2,2,2 };
-        System.out.println(maxXor(test));
-    }
-}
Index: src/左神算法/进阶班一/单调栈/MountainsAndFlame.java
===================================================================
diff --git a/src/左神算法/进阶班一/单调栈/MountainsAndFlame.java b/src/左神算法/进阶班一/单调栈/MountainsAndFlame.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/单调栈/MountainsAndFlame.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,114 +0,0 @@
-package 左神算法.进阶班一.单调栈;
-
-import java.util.Scanner;
-import java.util.Stack;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 小B负责首都的防卫工作。
-首都处于一个四面环山的盆地中，周围的n个小山构成一个环，作为预警措施，小B计划在每个小山上设置一个观察哨，日夜不停的瞭望周围发生的情况。
-一旦发生外敌入侵事件，山顶上的岗哨将点燃烽烟。
-若两个岗哨所在的山峰之间的那些山峰，高度都不大于这两座山峰，且这两个山峰之间有相连通路，则岗哨可以观察到另一个山峰上的烽烟是否点燃。
-由于小山处于环上，任意两个小山之间存在两个不同的连接通路。满足上述不遮挡的条件下，一座山峰上岗哨点燃的烽烟至少可以通过一条通路被另一端观察到。
-对于任意相邻的岗哨，一端的岗哨一定可以发现一端点燃的烽烟。
-小B设计的这种保卫方案的一个重要特性是能够观测到对方烽烟的岗哨对的数量，她希望你能够帮她解决这个问题。
-输入
-输入中有多组测试数据。每组测试数据的第一行为一个整数n（3<=n<=10^6），为首都周围的小山数量，第二行为n个整数，依次表示小山的高度h，（1<=h<=10^9）。
-输出
-对每组测试数据，在单独的一行中输出能相互观察到的岗哨的对数。
-样例输入
-5
-1 2 4 5 3
-样例输出
-7
- * @date 2019/12/30 10:08
- */
-public class MountainsAndFlame {
-
-    /**
-    *@param：：：：：输入模版。
-    *@return
-    */
-    public static void main(String[] args) {
-        Scanner in = new Scanner(System.in);
-        System.out.println("输入样例：");
-        while (in.hasNextInt()) {
-            int size = in.nextInt();
-            int[] arr = new int[size];
-            for (int i = 0; i < size; i++) {
-                arr[i] = in.nextInt();
-            }
-            System.out.println("输出结果： ");
-            System.out.println(communications(arr));
-        }
-    }
-
-
-    //求当前元素的下一个元素
-    public static int nextIndex(int size ,int i)
-    {
-        return i<(size-1)? (i+1):0;
-    }
-
-    //求相同元素内部可以之间可以观察到的岗哨的数量
-    public static long getInternalSum(int n)
-    {
-        return n==1L ? 0L:(long)(n)*(long)(n-1)/2L;
-    }
-
-    public static class Pair{
-        public int value;
-        public int times;
-        public Pair(int value){
-            this.value=value;
-            this.times=1;
-        }
-
-    }
-
-    public static long communications(int[] arr){
-
-        if(arr==null || arr.length<2)
-            return 0;
-        //首先找到一个最大元素，将该最大元素首先压入栈
-        int maxIndex=0;
-        for(int i=0;i<arr.length;i++)
-        {
-            maxIndex=arr[maxIndex]<arr[i] ? i:maxIndex;
-        }
-        int value=arr[maxIndex];
-        Stack<Pair> stack=new Stack<>();
-        stack.push(new Pair(value));
-        long res=0L;
-        int index=nextIndex(arr.length,maxIndex);
-        while (index!=maxIndex){//说明还没有全部压入栈，计算有可能弹出栈的元素可以观察到的岗哨的数量
-            value=arr[index];
-            while(!stack.isEmpty() && value>stack.peek().value){
-                int times=stack.pop().times;
-                res+=getInternalSum(times)+times*2;
-            }
-            if(value==stack.peek().value)
-            {
-                stack.peek().times++;
-            }else {
-                stack.push(new Pair(value));
-            }
-            index=nextIndex(arr.length,index);
-        }
-        //压栈结束后，计算栈中剩余元素可以观察到的岗哨的数量
-        while(!stack.isEmpty()){
-            int times=stack.pop().times;
-            res+=getInternalSum(times);
-            if(!stack.isEmpty()){
-                res+=times;
-                if(stack.size()>1)
-                    res+=times;
-                else{
-                    res+=stack.peek().times>1 ? times:0;
-                }
-            }
-        }
-        return res;
-    }
-}
Index: src/左神算法/高频面试题/MountainsAndFlame.java
===================================================================
diff --git a/src/左神算法/高频面试题/MountainsAndFlame.java b/src/左神算法/高频面试题/MountainsAndFlame.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/MountainsAndFlame.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,114 +0,0 @@
-package 左神算法.高频面试题;
-
-import java.util.Scanner;
-import java.util.Stack;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 小B负责首都的防卫工作。
-首都处于一个四面环山的盆地中，周围的n个小山构成一个环，作为预警措施，小B计划在每个小山上设置一个观察哨，日夜不停的瞭望周围发生的情况。
-一旦发生外敌入侵事件，山顶上的岗哨将点燃烽烟。
-若两个岗哨所在的山峰之间的那些山峰，高度都不大于这两座山峰，且这两个山峰之间有相连通路，则岗哨可以观察到另一个山峰上的烽烟是否点燃。
-由于小山处于环上，任意两个小山之间存在两个不同的连接通路。满足上述不遮挡的条件下，一座山峰上岗哨点燃的烽烟至少可以通过一条通路被另一端观察到。
-对于任意相邻的岗哨，一端的岗哨一定可以发现一端点燃的烽烟。
-小B设计的这种保卫方案的一个重要特性是能够观测到对方烽烟的岗哨对的数量，她希望你能够帮她解决这个问题。
-输入
-输入中有多组测试数据。每组测试数据的第一行为一个整数n（3<=n<=10^6），为首都周围的小山数量，第二行为n个整数，依次表示小山的高度h，（1<=h<=10^9）。
-输出
-对每组测试数据，在单独的一行中输出能相互观察到的岗哨的对数。
-样例输入
-5
-1 2 4 5 3
-样例输出
-7
- * @date 2019/12/30 10:08
- */
-public class MountainsAndFlame {
-
-    /**
-    *@param：：：：：输入模版。
-    *@return
-    */
-    public static void main(String[] args) {
-        Scanner in = new Scanner(System.in);
-        System.out.println("输入样例：");
-        while (in.hasNextInt()) {
-            int size = in.nextInt();
-            int[] arr = new int[size];
-            for (int i = 0; i < size; i++) {
-                arr[i] = in.nextInt();
-            }
-            System.out.println("输出结果： ");
-            System.out.println(communications(arr));
-        }
-    }
-
-
-    //求当前元素的下一个元素
-    public static int nextIndex(int size ,int i)
-    {
-        return i<(size-1)? (i+1):0;
-    }
-
-    //求相同元素内部可以之间可以观察到的岗哨的数量
-    public static long getInternalSum(int n)
-    {
-        return n==1L ? 0L:(long)(n)*(long)(n-1)/2L;
-    }
-
-    public static class Pair{
-        public int value;
-        public int times;
-        public Pair(int value){
-            this.value=value;
-            this.times=1;
-        }
-
-    }
-
-    public static long communications(int[] arr){
-
-        if(arr==null || arr.length<2)
-            return 0;
-        //首先找到一个最大元素，将该最大元素首先压入栈
-        int maxIndex=0;
-        for(int i=0;i<arr.length;i++)
-        {
-            maxIndex=arr[maxIndex]<arr[i] ? i:maxIndex;
-        }
-        int value=arr[maxIndex];
-        Stack<Pair> stack=new Stack<>();
-        stack.push(new Pair(value));
-        long res=0L;
-        int index=nextIndex(arr.length,maxIndex);
-        while (index!=maxIndex){//说明还没有全部压入栈，计算有可能弹出栈的元素可以观察到的岗哨的数量
-            value=arr[index];
-            while(!stack.isEmpty() && value>stack.peek().value){
-                int times=stack.pop().times;
-                res+=getInternalSum(times)+times*2;
-            }
-            if(value==stack.peek().value)
-            {
-                stack.peek().times++;
-            }else {
-                stack.push(new Pair(value));
-            }
-            index=nextIndex(arr.length,index);
-        }
-        //压栈结束后，计算栈中剩余元素可以观察到的岗哨的数量
-        while(!stack.isEmpty()){
-            int times=stack.pop().times;
-            res+=getInternalSum(times);
-            if(!stack.isEmpty()){
-                res+=times;
-                if(stack.size()>1)
-                    res+=times;
-                else{
-                    res+=stack.peek().times>1 ? times:0;
-                }
-            }
-        }
-        return res;
-    }
-}
Index: src/左神算法/简单实现hash表/MyHashMap.java
===================================================================
diff --git a/src/左神算法/简单实现hash表/MyHashMap.java b/src/左神算法/简单实现hash表/MyHashMap.java
deleted file mode 100644
--- a/src/左神算法/简单实现hash表/MyHashMap.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,65 +0,0 @@
-package 左神算法.简单实现hash表;
-
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2020/8/24 16:30
- */
-public class MyHashMap<K,V> {
-
-    private static int default_length=16;
-    private MyEntry<K,V>[] entries;
-
-    public MyHashMap(){
-        entries=new MyEntry[default_length];
-    }
-    //头插法
-    public void put(K key, V val){
-        int index=key.hashCode() & default_length;
-        MyEntry<K,V> previous=entries[index];
-        for(MyEntry<K,V> entry=entries[index];entry!=null;entry=entry.next){
-            if(entry.key.equals(key)){
-                entry.val=val;
-                return;
-            }
-        }
-        MyEntry<K,V> entry=new MyEntry<>(key,val);//构建entry,使用头插法
-        entry.next=previous;
-        entries[index]=entry;
-    }
-
-    public V get(K key){
-        int index=key.hashCode()%default_length;
-        for(MyEntry<K,V> entry=entries[index];entry!=null;entry=entry.next){
-            if(entry.key.equals(key)){
-                return entry.val;
-            }
-        }
-        return null;
-    }
-
-
-
-    private final class MyEntry<K,V>{
-        public K key;
-        public V val;
-        public MyEntry next;
-
-        public MyEntry(){
-
-        }
-
-        public MyEntry(K key,V val){
-            this.key=key;
-            this.val=val;
-
-        }
-        public  MyEntry(K key,V val,MyEntry next){
-            this.key=key;
-            this.val=val;
-            this.next=next;
-        }
-    }
-}
Index: src/面试相关/手写HashMap/MyHashMap.java
===================================================================
diff --git a/src/面试相关/手写HashMap/MyHashMap.java b/src/面试相关/手写HashMap/MyHashMap.java
deleted file mode 100644
--- a/src/面试相关/手写HashMap/MyHashMap.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,110 +0,0 @@
-package 面试相关.手写HashMap;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2020/2/12 9:45
- */
-public class MyHashMap<K,V> {
-
-    private Entry<K,V>[] table;
-    private static final Integer CAPACITY=8;
-    private int size;
-
-    public void put(K k,V v){
-
-        if(table==null){
-            inflate();
-        }
-        //存entry
-
-        int hashCode=hash(k);
-        int index=indexFor(hashCode);
-        for(Entry<K,V> entry=table[index];entry!=null;entry=entry.next){
-            if(entry.key.equals(k)){
-                entry.value=v;
-                return;
-            }
-        }
-        addEntry(k,v,index);
-    }
-
-    public V get(K k){
-        int hashCode=hash(k);
-        int index=indexFor(hashCode);
-        for(Entry<K,V> entry=table[index];entry!=null;entry=entry.next){
-            if(entry.key.equals(k)){
-               return entry.value;
-            }
-        }
-        return null;
-    }
-
-    private void inflate(){
-        table=new Entry[CAPACITY];
-    }
-
-    public int size(){
-        return size;
-    }
-
-    private void addEntry(K k,V v,int index){
-        Entry entry=new Entry(k,v,table[index]);
-        table[index]=entry;
-        size++;
-    }
-
-    private int hash(K k){
-        return k.hashCode();
-    }
-    private int indexFor(int hashCode){
-        return hashCode % table.length;
-    }
-
-
-
-
-
-    class Entry<K,V>{
-        public K key;
-        public V value;
-        public Entry next;
-
-        public Entry(K key, V value) {
-            this.key = key;
-            this.value = value;
-        }
-        public Entry(K key, V value,Entry next) {
-            this.key = key;
-            this.value = value;
-            this.next=next;
-        }
-
-        public K getKey() {
-            return key;
-        }
-
-        public void setKey(K key) {
-            this.key = key;
-        }
-
-        public V getValue() {
-            return value;
-        }
-
-        public void setValue(V value) {
-            this.value = value;
-        }
-    }
-
-
-    public static void main(String[] args) {
-        MyHashMap<Integer,Integer> myHashMap=new MyHashMap<>();
-        myHashMap.put(1,2);
-        myHashMap.put(2,3);
-        System.out.println(myHashMap.get(1));;
-        myHashMap.put(1,4);
-        System.out.println(myHashMap.get(1));
-    }
-}
Index: src/JUC/MyThreadPool/MyThreadPool.java
===================================================================
diff --git a/src/JUC/MyThreadPool/MyThreadPool.java b/src/JUC/MyThreadPool/MyThreadPool.java
deleted file mode 100644
--- a/src/JUC/MyThreadPool/MyThreadPool.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,28 +0,0 @@
-package JUC.MyThreadPool;
-
-import java.util.concurrent.*;
-
-public class MyThreadPool {
-
-    public static void main(String[] args) {
-
-        ExecutorService threadPoolExecutor = new ThreadPoolExecutor(2, 5, 1L,
-                TimeUnit.SECONDS, new LinkedBlockingDeque<Runnable>(3),
-                Executors.defaultThreadFactory(), //new ThreadPoolExecutor.AbortPolicy()
-                new ThreadPoolExecutor.CallerRunsPolicy()
-        );
-
-        //模拟10个用户来办理业务
-        try{
-            for(int i=0;i<10;i++)
-            {
-                threadPoolExecutor.execute(()->{
-                    System.out.println(Thread.currentThread().getName()+"\t办理业务");
-                });
-            }
-            System.out.println(Runtime.getRuntime().availableProcessors());
-        }finally {
-            threadPoolExecutor.shutdown();
-        }
-    }
-}
Index: src/重温设计模式/行为模式/模版方法模式/示例/NetWork.java
===================================================================
diff --git a/src/重温设计模式/行为模式/模版方法模式/示例/NetWork.java b/src/重温设计模式/行为模式/模版方法模式/示例/NetWork.java
deleted file mode 100644
--- a/src/重温设计模式/行为模式/模版方法模式/示例/NetWork.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,37 +0,0 @@
-package 重温设计模式.行为模式.模版方法模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 基础社交网络类，定义了模版方法以及其中的步骤方法
- * @date 2021/5/11 15:04
- */
-public abstract class NetWork {
-
-    String userName;
-    String password;
-
-    /**
-     * 模版方法
-     * @param message
-     * @return
-     */
-    public boolean post(String message){
-        if(logIn(this.userName,this.password)){
-            boolean result = sendData(message.getBytes());
-            logOut();
-            return result;
-        }
-        return false;
-    }
-
-    /**
-     * 以下三个是步骤方法，具体子类中可以对这些步骤方法进行重写
-     * @param userName
-     * @param password
-     * @return
-     */
-    abstract boolean logIn(String userName,String password);
-    abstract boolean sendData(byte[] data);
-    abstract void logOut();
-}
Index: src/Gof/command/NoCommand.java
===================================================================
diff --git a/src/Gof/command/NoCommand.java b/src/Gof/command/NoCommand.java
deleted file mode 100644
--- a/src/Gof/command/NoCommand.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,14 +0,0 @@
-package Gof.command;
-
-public class NoCommand implements Command {
-
-    @Override
-    public void execute() {
-
-    }
-
-    @Override
-    public void undo() {
-
-    }
-}
Index: src/左神算法/基础班/图/Node.java
===================================================================
diff --git a/src/左神算法/基础班/图/Node.java b/src/左神算法/基础班/图/Node.java
deleted file mode 100644
--- a/src/左神算法/基础班/图/Node.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,20 +0,0 @@
-package 左神算法.基础班.图;
-
-import java.util.ArrayList;
-
-public class Node {
-    //图中的结点
-    public int value;
-    public int in;//该结点的入度数
-    public int out;//该结点的出度数
-    public ArrayList<Node> nexts; //该结点有多少个后序结点
-    public ArrayList<Edge>edges;//以该结点为出度的边
-
-    public Node(int value) {
-        this.value = value;
-        in=0;
-        out=0;
-        nexts=new ArrayList<>();
-        edges=new ArrayList<>();
-    }
-}
Index: src/Gof/Strategy/NoFlyBehavior.java
===================================================================
diff --git a/src/Gof/Strategy/NoFlyBehavior.java b/src/Gof/Strategy/NoFlyBehavior.java
deleted file mode 100644
--- a/src/Gof/Strategy/NoFlyBehavior.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package Gof.Strategy;
-
-public class NoFlyBehavior implements FlyBehavior {
-    @Override
-    public void fly() {
-        System.out.println("不会飞行");
-    }
-}
Index: src/Gof/Strategy/NoQuackBehavior.java
===================================================================
diff --git a/src/Gof/Strategy/NoQuackBehavior.java b/src/Gof/Strategy/NoQuackBehavior.java
deleted file mode 100644
--- a/src/Gof/Strategy/NoQuackBehavior.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package Gof.Strategy;
-
-public class NoQuackBehavior implements QuackBehavior{
-    @Override
-    public void quack() {
-        System.out.println("我根本不会叫啊");
-    }
-}
Index: src/Gof/state/NoRaffleState.java
===================================================================
diff --git a/src/Gof/state/NoRaffleState.java b/src/Gof/state/NoRaffleState.java
deleted file mode 100644
--- a/src/Gof/state/NoRaffleState.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,29 +0,0 @@
-package Gof.state;
-
-public class NoRaffleState implements State {
-
-    RaffleActivity activity;
-
-    public NoRaffleState(RaffleActivity activity)
-    {
-        this.activity=activity;
-    }
-
-
-    @Override
-    public void deductMoney() {
-        System.out.println("扣除50积分，可以抽奖了");
-        activity.setState(activity.getCanRaffleState());
-    }
-
-    @Override
-    public boolean raffle() {
-        System.out.println("当前状态不能抽奖。。");
-        return false;
-    }
-
-    @Override
-    public void dispensePrize() {
-        System.out.println("不能发放奖品");
-    }
-}
Index: src/面试相关/面试手撕代码/Num2Arab.java
===================================================================
diff --git a/src/面试相关/面试手撕代码/Num2Arab.java b/src/面试相关/面试手撕代码/Num2Arab.java
deleted file mode 100644
--- a/src/面试相关/面试手撕代码/Num2Arab.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,130 +0,0 @@
-package 面试相关.面试手撕代码;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:中文数字转阿拉伯数字，例如一千一百万零一百 -> 11000100
- * @date 2020/11/13 14:14
- */
-public class Num2Arab {
-
-    //单位
-    private static char[] units={'千','百','十'};
-    //中文数字
-    private static char[] numChars={'一','二','三','四','五','六','七','八','九'};
-
-    //单独的零
-    private static char numZero='零';
-
-    //将一位中文数字转化为一位数字
-    public static int oneCharCN2Arab(char chs){
-        if(numChars[0]==chs){
-            return 1;
-        }else if(numChars[1]==chs || chs=='两'){
-            return 2;
-        }else if(numChars[2]==chs){
-            return 3;
-        }else if(numChars[3]==chs){
-            return 4;
-        }else if(numChars[4]==chs){
-            return 5;
-        }else if(numChars[5]==chs){
-            return 6;
-        }else if(numChars[6]==chs){
-            return 7;
-        }else if(numChars[7]==chs){
-            return 8;
-        }else if(numChars[8]==chs){
-            return 9;
-        }
-        return 0;
-    }
-
-    //将中文数字转化为阿拉伯数字,在这里转化范围默认不超过int的范围
-    public static  int numberChar2Arab(String numStr){
-        if(numStr==null || numStr.length()==0) return 0;
-        //将numStr以亿，万，千为间隔划分
-        int[] idxes=new int[2];//分别存放亿，万，所在的位置所以
-        idxes[0]=numStr.indexOf('亿');
-        idxes[1]=numStr.indexOf('万');
-        String[] nums=new String[3];
-        if(idxes[0]!=-1){
-            nums[0]=numStr.substring(0,idxes[0]);
-        }
-        if(idxes[1]!=-1){
-            nums[1]=numStr.substring(idxes[0]+1,idxes[1]);
-        }
-
-        nums[2]=numStr.substring(idxes[1]+1);
-
-        StringBuilder sb=new StringBuilder();
-        for(int i=0;i<3;i++){
-            if(nums[i]=="" && sb.length()==0) continue;
-            String ans=help(nums[i]);
-            sb.append(ans);
-        }
-        return Integer.valueOf(sb.toString());//Integer.valueOf在转化时，会将开始的无意义的零自动清除
-
-    }
-
-    //将万以下的中文数字转化为阿拉伯数字
-    private static String help(String str){
-
-        if(str==null || str.length()==0) return "";
-        //if(str.length()==1) return "10";//就是只有一个数：十的情况
-        int[] idxes=new int[3];//存放千，百，十的位置
-        for(int i=0;i<3;i++){
-            idxes[i]=str.indexOf(units[i]);
-        }
-
-        StringBuilder sb=new StringBuilder();
-
-        if(idxes[0]!=-1){
-            char temp=str.substring(0,idxes[0]).charAt(0);
-            int tmp=oneCharCN2Arab(temp);
-            sb.append(tmp);
-        }else {
-            sb.append(0);
-        }
-
-        if(idxes[1]!=-1){
-            char temp=str.substring(idxes[1]-1,idxes[1]).charAt(0);
-            int tmp=oneCharCN2Arab(temp);
-            sb.append(tmp);
-        }else{
-            sb.append(0);
-        }
-
-        if(idxes[2]!=-1){
-            //当str是一个十几的数时
-            if(idxes[2]==0){
-                sb.append(1);
-            }else{
-                char temp=str.substring(idxes[2]-1,idxes[2]).charAt(0);
-                int tmp=oneCharCN2Arab(temp);
-                sb.append(tmp);
-            }
-
-        }else{
-            sb.append(0);
-        }
-
-        if(idxes[2]==str.length()-1){
-            sb.append(0);
-        }else {
-            sb.append(oneCharCN2Arab(str.charAt(str.length()-1)));
-        }
-
-        return sb.toString();
-
-    }
-
-    public static void main(String[] args) {
-        String str="十";
-        System.out.println(numberChar2Arab(str));
-
-    }
-
-
-
-}
Index: src/codeTop/NumDistinctIslands.java
===================================================================
diff --git a/src/codeTop/NumDistinctIslands.java b/src/codeTop/NumDistinctIslands.java
deleted file mode 100644
--- a/src/codeTop/NumDistinctIslands.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,71 +0,0 @@
-package codeTop;
-
-import java.util.HashSet;
-import java.util.Set;
-
-/**
- * 给定一个非空 01 二维数组表示的网格，一个岛屿由四连通（上、下、左、右四个方向）的 1 组成，你可以认为网格的四周被海水包围。
- *
- * 请你计算这个网格中共有多少个形状不同的岛屿。两个岛屿被认为是相同的，当且仅当一个岛屿可以通过平移变换（不可以旋转、翻转）和另一个岛屿重合。
- *
- * 示例 1：
- * 11000
- * 11000
- * 00011
- * 00011
- * 给定上图，返回结果 1 。
- *
- * 示例 2：
- * 11011
- * 10000
- * 00001
- * 11011
- * 给定上图，返回结果 3 。
- *
- * 注意：
- * 11
- * 1
- * 和
- * 1
- * 11
- * 是不同的岛屿，因为我们不考虑旋转、翻转操作。
- *
- */
-public class NumDistinctIslands {
-
-    public int numDistinctIsland(int[][] arr){
-        Set<String> set = new HashSet<>();
-        for(int i = 0;i < arr.length;i++){
-            for(int j = 0;j < arr[0].length;j++){
-                if(arr[i][j] == 0){
-                    continue;
-                }
-                //记录小岛的形状
-                StringBuilder sb = new StringBuilder();
-                process(arr,i,j,i,j,sb);
-                set.add(sb.toString());
-            }
-        }
-        return set.size();
-    }
-
-    private void process(int[][] arr,int row,int col,int oldRow,int oldCol,StringBuilder sb){
-        if(row >= arr.length || row < 0 || col < 0 || col >= arr[0].length || arr[row][col] == 0){
-            return;
-        }
-        int rowIdx = row - oldRow;
-        int colIdx = col - oldCol;
-        sb.append(rowIdx + "_"+colIdx);
-        arr[row][col] = 0;
-        //代表在1的位置
-        process(arr,row + 1,col,row,col,sb);
-        process(arr,row - 1,col,row,col,sb);
-        process(arr,row,col + 1,row,col,sb);
-        process(arr,row,col - 1,row,col,sb);
-    }
-
-    public static void main(String[] args) {
-        int[][] arr = {{1,1,0,1,1},{1,0,0,0,0},{0,0,0,0,1},{1,1,0,1,1}};
-        System.out.println(new NumDistinctIslands().numDistinctIsland(arr));
-    }
-}
Index: src/Gof/visitor/ObjectStructure.java
===================================================================
diff --git a/src/Gof/visitor/ObjectStructure.java b/src/Gof/visitor/ObjectStructure.java
deleted file mode 100644
--- a/src/Gof/visitor/ObjectStructure.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,29 +0,0 @@
-package Gof.visitor;
-
-import java.util.ArrayList;
-import java.util.List;
-
-//数据结构，用来管理很多的人
-public class ObjectStructure {
-
-    private List<Person> persons=new ArrayList<>();
-
-    //添加到list
-    public void attach(Person p){
-        persons.add(p);
-    }
-
-    //移除
-    public void detach(Person p)
-    {
-        persons.remove(p);
-    }
-
-    //显示评测请框
-    public void display(Action action)
-    {
-        for(Person p:persons)
-            p.accept(action);
-    }
-
-}
Index: src/Gof/observer/Observer.java
===================================================================
diff --git a/src/Gof/observer/Observer.java b/src/Gof/observer/Observer.java
deleted file mode 100644
--- a/src/Gof/observer/Observer.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,6 +0,0 @@
-package Gof.observer;
-
-public interface Observer {
-
-    public void update(float temperature,float pressure,float humidity);
-}
Index: src/Gof/Factory/factorymethod/abstractFactoryOrder/OrderPizza.java
===================================================================
diff --git a/src/Gof/Factory/factorymethod/abstractFactoryOrder/OrderPizza.java b/src/Gof/Factory/factorymethod/abstractFactoryOrder/OrderPizza.java
deleted file mode 100644
--- a/src/Gof/Factory/factorymethod/abstractFactoryOrder/OrderPizza.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,49 +0,0 @@
-package Gof.Factory.factorymethod.abstractFactoryOrder;
-
-import Gof.Factory.factorymethod.pizza.Pizza;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-
-public class OrderPizza {
-
-    AbsFactory absFactory;
-
-    public OrderPizza(AbsFactory absFactory)
-    {
-        setAbsFactory(absFactory);
-    }
-
-    private void setAbsFactory(AbsFactory absFactory)
-    {
-        String orderType="";
-        Pizza pizza=null;
-        this.absFactory=absFactory;
-        do{
-            orderType=getType();
-            pizza=absFactory.createPizze(orderType);
-            if(pizza!=null)
-            {
-                pizza.prepare();
-                pizza.bake();
-                pizza.cut();
-                pizza.box();
-            }else{
-                break;
-            }
-        }while(true);
-    }
-
-    private String getType() {
-        try {
-            BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
-            System.out.println("input pizza 种类:");
-            String str = strin.readLine();
-            return str;
-        } catch (IOException e) {
-            e.printStackTrace();
-            return "";
-        }
-    }
-}
Index: src/Gof/Factory/factorymethod/order/OrderPizza.java
===================================================================
diff --git a/src/Gof/Factory/factorymethod/order/OrderPizza.java b/src/Gof/Factory/factorymethod/order/OrderPizza.java
deleted file mode 100644
--- a/src/Gof/Factory/factorymethod/order/OrderPizza.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,39 +0,0 @@
-package Gof.Factory.factorymethod.order;
-
-import Gof.Factory.factorymethod.pizza.Pizza;
-
-import java.util.Scanner;
-
-public abstract class OrderPizza {
-
-    abstract Pizza createPizza(String orderPizza);
-
-    public OrderPizza()
-    {
-        Pizza pizza=null;
-        String orderType="";
-        do{
-            orderType=getOrderType();
-            pizza=createPizza(orderType);
-            if(pizza!=null)
-            {
-                pizza.prepare();
-                pizza.bake();
-                pizza.cut();
-                pizza.bake();
-            }else {
-                break;
-            }
-
-        }while(true);
-
-    }
-
-    public String getOrderType()
-    {
-        Scanner scanner=new Scanner(System.in);
-        System.out.println("请输入pizza的种类： ");
-        String str=scanner.next();
-        return str;
-    }
-}
Index: src/Gof/Factory/simpleFactory/OrderPizza.java
===================================================================
diff --git a/src/Gof/Factory/simpleFactory/OrderPizza.java b/src/Gof/Factory/simpleFactory/OrderPizza.java
deleted file mode 100644
--- a/src/Gof/Factory/simpleFactory/OrderPizza.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,50 +0,0 @@
-package Gof.Factory.simpleFactory;
-
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-
-public class OrderPizza {
-
-    Pizza pizza=null;
-    SimpleFatory simpleFatory;
-
-    public  OrderPizza(SimpleFatory simpleFatory)
-    {
-        setSimpleFatory(simpleFatory);
-    }
-    public void setSimpleFatory(SimpleFatory simpleFatory)
-    {
-        this.simpleFatory=simpleFatory;
-        String orderType="";//用户输入
-        do{
-            orderType=getOrderType();
-            Pizza pizza = simpleFatory.createPizza(orderType);
-            if(pizza!=null)
-            {
-                pizza.prepare();
-                pizza.bake();
-                pizza.cut();
-                pizza.bake();
-            }else{
-                break;
-            }
-        }while(true);
-    }
-
-
-
-
-
-    public  String getOrderType()
-    {
-        try{
-            BufferedReader strin=new BufferedReader(new InputStreamReader(System.in));
-            System.out.println("input pizza 种类：");
-            String str= strin.readLine();
-            return str;
-        }catch (Exception e)
-        {  e.printStackTrace();
-            return "";
-        }
-    }
-}
Index: src/Gof/composite/OrganizationComponent.java
===================================================================
diff --git a/src/Gof/composite/OrganizationComponent.java b/src/Gof/composite/OrganizationComponent.java
deleted file mode 100644
--- a/src/Gof/composite/OrganizationComponent.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,42 +0,0 @@
-package Gof.composite;
-
-public abstract  class OrganizationComponent {
-
-    private String name;//名字
-    private String des;//说明
-
-    protected void add(OrganizationComponent organizationComponent)
-    {    //默认实现
-        throw new UnsupportedOperationException();
-    }
-
-    protected void remove(OrganizationComponent organizationComponent)
-    {
-        throw new UnsupportedOperationException();
-    }
-    //构造器
-    public OrganizationComponent(String name,String des)
-    {
-        super();
-        this.name=name;
-        this.des=des;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    public String getDes() {
-        return des;
-    }
-
-    public void setDes(String des) {
-        this.des = des;
-    }
-
-    protected abstract void print();
-}
Index: src/Gof/momentor/Originator.java
===================================================================
diff --git a/src/Gof/momentor/Originator.java b/src/Gof/momentor/Originator.java
deleted file mode 100644
--- a/src/Gof/momentor/Originator.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,29 +0,0 @@
-package Gof.momentor;
-
-public class Originator {
-
-    private String state;
-
-    public Originator(String state) {
-        this.state = state;
-    }
-
-    public String getState() {
-        return state;
-    }
-
-    public void setState(String state) {
-        this.state = state;
-    }
-
-    public Momentor saveStateMomnentor()
-    {
-        return new Momentor(state);
-    }
-
-    public void getStateFromMomentor(Momentor momentor)
-    {
-        state=momentor.getState();
-    }
-
-}
Index: src/Gof/iterator/OutPutImpl.java
===================================================================
diff --git a/src/Gof/iterator/OutPutImpl.java b/src/Gof/iterator/OutPutImpl.java
deleted file mode 100644
--- a/src/Gof/iterator/OutPutImpl.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,35 +0,0 @@
-package Gof.iterator;
-
-import java.util.List;
-import java.util.Iterator;
-public class OutPutImpl {
-
-    List<College> collegeList;
-
-    public OutPutImpl(List<College> collegeList) {
-        this.collegeList = collegeList;
-    }
-
-    //遍历整个学校
-    public void printCollege()
-    {
-        Iterator<College> iterator = collegeList.iterator();
-
-        while(iterator.hasNext())
-        {
-            College college=iterator.next();
-            System.out.println("======"+college.getName()+"========");
-            printDepartment(college.createIterator());
-        }
-    }
-
-    public void printDepartment(Gof.iterator.Iterator iterator){
-
-        while(iterator.hasNext())
-        {
-            Department next = (Department)iterator.next();
-            System.out.println(next.getName());
-        }
-    }
-
-}
Index: src/左神算法/基础班/第四课/PageFolding.java
===================================================================
diff --git a/src/左神算法/基础班/第四课/PageFolding.java b/src/左神算法/基础班/第四课/PageFolding.java
deleted file mode 100644
--- a/src/左神算法/基础班/第四课/PageFolding.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,22 +0,0 @@
-package 左神算法.基础班.第四课;
-
-public class PageFolding {
-
-    public static void printAllFolds(int N){
-        printProcess(1,N,true);
-    }
-    //i表示是第几次打印，N表示是一共几次折，down表示是否是往下
-    public static void printProcess(int i,int N,boolean down)
-    {
-        if(i>N)
-            return;
-        printProcess(i+1,N,true);
-        System.out.println(down?"下":"上");
-        printProcess(i+1,N,false);
-    }
-    public static void main(String[] args) {
-        int N = 4;
-        printAllFolds(N);
-
-    }
-}
Index: src/左神算法/基础班/PaperFolding/PaperFolding.java
===================================================================
diff --git a/src/左神算法/基础班/PaperFolding/PaperFolding.java b/src/左神算法/基础班/PaperFolding/PaperFolding.java
deleted file mode 100644
--- a/src/左神算法/基础班/PaperFolding/PaperFolding.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,21 +0,0 @@
-package 左神算法.基础班.PaperFolding;
-
-public class PaperFolding {
-    public static void printAllFolds(int N) {
-        printProcess(1, N, true);
-    }
-
-    public static void printProcess(int i, int N, boolean down) {
-        if(i>N)
-            return;
-        printProcess(i+1,N,true);
-        System.out.println(down ? "down":"up");
-        printProcess(i+1,N,false);
-    }
-
-    public static void main(String[] args) {
-        int N = 4;
-        printAllFolds(N);
-    }
-
-}
Index: src/左神算法/高频面试题/十京东/Parentheses.java
===================================================================
diff --git a/src/左神算法/高频面试题/十京东/Parentheses.java b/src/左神算法/高频面试题/十京东/Parentheses.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/十京东/Parentheses.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,62 +0,0 @@
-package 左神算法.高频面试题.十京东;
-/*
- 四：合法的括号匹配序列被定义为：
- 1.空串“”是合法的括号序列
- 2.如果“x"和”y"是合法的序列，那么“xy"也是一个合法的括号序列
- 3.如果“x"是一个合法的序列，那么”(x)"也是一个合法的括号序列
- 4.每个括号序列都是由上面的规则生成
- 现在在有一个合法的括号序列s,一次移除操作分为两步：
- 1，移除序列s中第一个左括号
- 2 移除序列s中任意一个右括号，保证操作之后s还是一个合法的括号序列
- 现在想知道使用上述的移除操作有多少种方案可以把s变为空
- */
-public class Parentheses {
-
-    public static int possibilities(String str){
-        char[] chas=str.toCharArray();
-        int len=chas.length/2;
-        int [] rlen=new int[len];
-        int left=0;
-        int right=0;
-        int j=0;
-        for(int i=chas.length-1;i>-1;i--){
-            if(chas[i]==')')
-                right++;
-            if(chas[i]=='(')
-            {
-                rlen[j++]=right-left;
-                left++;
-            }
-        }
-        int res=1;
-        for(int i=0;i<len;i++){
-            res*=rlen[i];
-        }
-        return res;
-    }
-    public static int possibilities2(String parentheses) {
-        char[] chas = parentheses.toCharArray();
-        int cur = 0;
-        int ans = 1;
-        for (int i = chas.length - 1; i >= 0; i--) {
-            if (chas[i] == ')') {
-                cur++;
-            } else {
-                ans *= cur--;
-            }
-        }
-        return ans;
-    }
-
-    public static void main(String[] args) {
-        String test1 = "(((())))";
-        System.out.println(possibilities(test1));
-        System.out.println(possibilities2(test1));
-
-
-        String test2 = "()()()()()";
-        System.out.println(possibilities(test2));
-        System.out.println(possibilities2(test2));
-
-    }
-}
Index: src/左神算法/高频面试题/ParenthesesProblem.java
===================================================================
diff --git a/src/左神算法/高频面试题/ParenthesesProblem.java b/src/左神算法/高频面试题/ParenthesesProblem.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/ParenthesesProblem.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,74 +0,0 @@
-package 左神算法.高频面试题;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 已知一个字符串都是由左括号和后括号组成，判断该字符串是否是有效括号组合。
- * 进阶：已知一个字符串都是由左括号和右括号组成，返回最长有效括号子串的长度
- * @date 2019/12/26 11:20
- */
-public class ParenthesesProblem {
-
-    public static boolean isValid(String str)
-    {
-        if(str==null || str.equals(""))
-            return false;
-        char[] charArr=str.toCharArray();
-        int count=0;
-        for(int i=0;i<charArr.length;i++){
-            if(charArr[i]=='(')
-                count++;
-            if(charArr[i]==')'&& --count<0)
-                return false;
-
-        }
-        return count==0;
-
-    }
-
-    /**  进阶
-    *@param
-    *@return
-    */
-
-    public static int maxLength(String str){
-        if(str==null || str.equals(""))
-            return 0;
-        char[] charArr=str.toCharArray();
-        int[] dp=new int[charArr.length];//记录以对应位置字符结尾的子串的长度
-        int res=0;
-        int pre=0;//
-        dp[0]=0;
-        for(int i=1;i<charArr.length;i++)
-        {
-            if(charArr[i]=='(')
-                dp[i]=0;
-            else{
-               pre=i-dp[i-1]-1;
-               if(pre>=0 && charArr[pre]=='(')
-               {
-                   dp[i]=dp[i-1]+2+(pre-1>0 ? dp[pre-1]:0);
-               }
-
-            }
-            res=Math.max(dp[i],res);
-        }
-        return res;
-
-    }
-
-    public static void main(String[] args) {
-        String str1 = "((())())";
-        System.out.println(isValid(str1));
-        System.out.println(maxLength(str1));
-
-        String str2 = "(())(()(()))";
-        System.out.println(isValid(str2));
-        System.out.println(maxLength(str2));
-
-        String str3 = "()(()()(";
-        System.out.println(isValid(str3));
-        System.out.println(maxLength(str3));
-
-    }
-}
Index: src/Gof/Factory/simpleFactory/PepperPizza.java
===================================================================
diff --git a/src/Gof/Factory/simpleFactory/PepperPizza.java b/src/Gof/Factory/simpleFactory/PepperPizza.java
deleted file mode 100644
--- a/src/Gof/Factory/simpleFactory/PepperPizza.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,9 +0,0 @@
-package Gof.Factory.simpleFactory;
-
-
-public class PepperPizza extends Pizza {
-    @Override
-    public void prepare() {
-        System.out.println("给胡椒披散准备元才来");
-    }
-}
Index: src/Gof/visitor/Person.java
===================================================================
diff --git a/src/Gof/visitor/Person.java b/src/Gof/visitor/Person.java
deleted file mode 100644
--- a/src/Gof/visitor/Person.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,6 +0,0 @@
-package Gof.visitor;
-
-public abstract class Person {
-
-    public abstract void accept(Action action);
-}
Index: src/Gof/Adapter/Phone.java
===================================================================
diff --git a/src/Gof/Adapter/Phone.java b/src/Gof/Adapter/Phone.java
deleted file mode 100644
--- a/src/Gof/Adapter/Phone.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,14 +0,0 @@
-package Gof.Adapter;
-
-public class Phone {
-
-    public void charging(IVoltage5v iVoltage5v)
-    {
-        if(iVoltage5v.output5v()==5)
-        {
-            System.out.println("电压为5v,可以充电");
-        }else if(iVoltage5v.output5v()>5){
-            System.out.println("电压大于5v,不能充电。。");
-        }
-    }
-}
Index: src/Gof/bridge/Phone.java
===================================================================
diff --git a/src/Gof/bridge/Phone.java b/src/Gof/bridge/Phone.java
deleted file mode 100644
--- a/src/Gof/bridge/Phone.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,24 +0,0 @@
-package Gof.bridge;
-
-
-
-public abstract class Phone {
-    private Brand brand;
-
-    public Phone(Brand brand){
-        this.brand=brand;
-    }
-
-    public void open()
-    {
-        brand.open();
-    }
-    public void call()
-    {
-        brand.call();;
-    }
-    public void close()
-    {
-        brand.close();
-    }
-}
Index: src/Gof/Factory/factorymethod/pizza/Pizza.java
===================================================================
diff --git a/src/Gof/Factory/factorymethod/pizza/Pizza.java b/src/Gof/Factory/factorymethod/pizza/Pizza.java
deleted file mode 100644
--- a/src/Gof/Factory/factorymethod/pizza/Pizza.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,24 +0,0 @@
-package Gof.Factory.factorymethod.pizza;
-
-public abstract class Pizza {
-    private String name;
-
-    public abstract void prepare();
-
-    public void bake() {
-        System.out.println(name + " baking;");
-    }
-
-    public void cut() {
-        System.out.println(name + " cutting;");
-    }
-
-    //打包
-    public void box() {
-        System.out.println(name + " boxing;");
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-}
\ No newline at end of file
Index: src/Gof/Factory/simpleFactory/Pizza.java
===================================================================
diff --git a/src/Gof/Factory/simpleFactory/Pizza.java b/src/Gof/Factory/simpleFactory/Pizza.java
deleted file mode 100644
--- a/src/Gof/Factory/simpleFactory/Pizza.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,26 +0,0 @@
-package Gof.Factory.simpleFactory;
-
-public abstract class Pizza {
-    protected String name;
-
-    //原料不同，所以我们做成抽象方法
-    public abstract void prepare();
-
-    public void bake()
-    {
-        System.out.println(name+"  baking ");
-    }
-    public void cut()
-    {
-        System.out.println(name+" cut ");
-    }
-    public void box()
-    {
-        System.out.println(name +" box");
-    }
-
-    public void  setName(String name)
-    {
-        this.name=name;
-    }
-}
Index: src/Gof/Factory/factorymethod/abstractFactoryOrder/PizzaStore.java
===================================================================
diff --git a/src/Gof/Factory/factorymethod/abstractFactoryOrder/PizzaStore.java b/src/Gof/Factory/factorymethod/abstractFactoryOrder/PizzaStore.java
deleted file mode 100644
--- a/src/Gof/Factory/factorymethod/abstractFactoryOrder/PizzaStore.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,7 +0,0 @@
-package Gof.Factory.factorymethod.abstractFactoryOrder;
-
-public class PizzaStore {
-    public static void main(String[] args) {
-        new OrderPizza(new BJFactory());
-    }
-}
Index: src/Gof/Factory/factorymethod/order/PizzaStore.java
===================================================================
diff --git a/src/Gof/Factory/factorymethod/order/PizzaStore.java b/src/Gof/Factory/factorymethod/order/PizzaStore.java
deleted file mode 100644
--- a/src/Gof/Factory/factorymethod/order/PizzaStore.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package Gof.Factory.factorymethod.order;
-
-public class PizzaStore {
-    public static void main(String[] args) {
-        new BJOrderPizza();
-        
-    }
-}
Index: src/左神算法/高频面试题/十二十三/PointInRectangle.java
===================================================================
diff --git a/src/左神算法/高频面试题/十二十三/PointInRectangle.java b/src/左神算法/高频面试题/十二十三/PointInRectangle.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/十二十三/PointInRectangle.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,62 +0,0 @@
-package 左神算法.高频面试题.十二十三;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 判断一个点是否在矩形内部
- * @date 2020/2/4 17:08
- */
-public class PointInRectangle {
-
-    //矩形与坐标轴平行的情况
-    public static boolean isInside(double x1, double y1, double x4, double y4, double x, double y) {
-        if (x1 >= x)
-            return false;
-        if (x4 <= x)
-            return false;
-        if (y >= y1)
-            return false;
-        if (y <= y4)
-            return false;
-        return true;
-    }
-
-    //矩形与坐标轴不平行，先旋转矩形，使他平行
-    public static boolean isInside(double x1, double y1, double x2, double y2,
-                                    double x3, double y3, double x4, double y4, double x, double y) {
-        if(y1==y2){ //说明与坐标轴平行
-            return isInside(x1,y1,x4,y4,x,y);
-        }
-        //旋转
-        double l=Math.abs(y3-y4);
-        double k=Math.abs(x3-x4);
-        double s=Math.sqrt(l*l+k*k);
-        double sin=l/s;
-        double cos=k/s;
-        double x1R=cos*x1+sin*y1;
-        double y1R=-x1*sin+y1*cos;
-        double x4R = cos * x4 + sin * y4;
-        double y4R = -x4 * sin + y4 * cos;
-        double xR = cos * x + sin * y;
-        double yR = -x * sin + y * cos;
-        return isInside(x1R, y1R, x4R, y4R, xR, yR);
-
-        }
-
-    public static void main(String[] args) {
-        // (x1,y1),(x2,y2),(x3,y3),(x4,y4) stand for a Rectangle.
-        double x1 = 0;
-        double y1 = 3;// (x1,y1) should be the most left
-        double x2 = 3;
-        double y2 = 7;// (x2,y2) should be the most top.
-        double x3 = 4;
-        double y3 = 0;// (x3,y3) should be the most below.
-        double x4 = 7;
-        double y4 = 4;// (x4,y4) should be the most right.
-
-        double x = 4;
-        double y = 3;
-        System.out.print(isInside(x1, y1, x2, y2, x3, y3, x4, y4, x, y));
-
-    }
-}
Index: src/左神算法/高频面试题/十二十三/PointInTriangle.java
===================================================================
diff --git a/src/左神算法/高频面试题/十二十三/PointInTriangle.java b/src/左神算法/高频面试题/十二十三/PointInTriangle.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/十二十三/PointInTriangle.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,73 +0,0 @@
-package 左神算法.高频面试题.十二十三;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 判断一个点是否在三角形的内部
- * @date 2020/2/4 18:30
- */
-public class PointInTriangle {
-
-    public static boolean isInside1(double x1,double y1,double x2,double y2,double x3,double y3,double x,double y){
-      double area1=getArea(x1,y1,x2,y2,x,y);
-      double area2=getArea(x1,y1,x3,y3,x,y);
-      double area3=getArea(x2,y2,x3,y3,x,y);
-      double area4=getArea(x1,y1,x2,y2,x3,y3);
-      return area4>=(area1+area2+area3);
-    }
-    //海伦公式求三角形面积
-    public static double getArea(double x1,double y1,double x2,double y2,double x3,double y3){
-        double sidelen1=getSideLen(x1,y1,x2,y2);
-        double sidelen2=getSideLen(x1,y1,x3,y3);
-        double sidelen3=getSideLen(x2,y2,x3,y3);
-        double p=(sidelen1+sidelen2+sidelen3)/2;
-        return Math.sqrt(p*(p-sidelen1)*(p-sidelen2)*(p-sidelen3));
-    }
-    public static double getSideLen(double x1,double y1,double x2,double y2){
-        double a=Math.abs(x1-x2);
-        double b=Math.abs(y1-y2);
-        return Math.sqrt(a*a+b*b);
-    }
-
-    //通过向量叉乘来判断
-    public static boolean isInside2(double x1,double y1,double x2,double y2,double x3,double y3,double x,double y){
-
-        if(crossProduct(x2-x1,y2-y1,x3-x1,y3-y1)>=0){
-            double tmpx = x2;
-            double tmpy = y2;
-            x2 = x3;
-            y2 = y3;
-            x3 = tmpx;
-            y3 = tmpy;
-        }
-        if (crossProduct(x2 - x1, y2 - y1, x - x1, y - y1) < 0) {
-            return false;
-        }
-        if (crossProduct(x3 - x2, y3 - y2, x - x2, y - y2) < 0) {
-            return false;
-        }
-        if (crossProduct(x1 - x3, y1 - y3, x - x3, y - y3) < 0) {
-            return false;
-        }
-        return true;
-
-    }
-
-    public static  double crossProduct(double x1,double y1,double x2,double y2){
-        return x1*y2-x2*y1;
-    }
-
-    public static void main(String[] args) {
-        double x1 = -5;
-        double y1 = 0;
-        double x2 = 0;
-        double y2 = 8;
-        double x3 = 5;
-        double y3 = 0;
-        double x = 0;
-        double y = 5;
-        System.out.println(isInside1(x1, y1, x2, y2, x3, y3, x, y));
-        System.out.println(isInside2(x1, y1, x2, y2, x3, y3, x, y));
-
-    }
-}
Index: src/韩顺平算法与数据结构/datastructure/stack/PolandNotation.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/stack/PolandNotation.java b/src/韩顺平算法与数据结构/datastructure/stack/PolandNotation.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/stack/PolandNotation.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,208 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.stack;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Stack;
-
-public class PolandNotation {
-
-    public static void main(String[] args) {
-
-
-        //完成将一个中缀表达式转成后缀表达式的功能
-        //说明
-        //1. 1+((2+3)×4)-5 => 转成  1 2 3 + 4 × + 5 –
-        //2. 因为直接对str 进行操作，不方便，因此 先将  "1+((2+3)×4)-5" =》 中缀的表达式对应的List
-        //   即 "1+((2+3)×4)-5" => ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]
-        //3. 将得到的中缀表达式对应的List => 后缀表达式对应的List
-        //   即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]  =》 ArrayList [1,2,3,+,4,*,+,5,–]
-
-        String expression = "1+((2.6+3)*4.9)-5";//注意表达式
-        List<String> infixExpressionList = toInfixExpressionList(expression);
-        System.out.println("中缀表达式对应的List=" + infixExpressionList); // ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]
-        List<String> suffixExpreesionList = parseSuffixExpreesionList(infixExpressionList);
-        System.out.println("后缀表达式对应的List" + suffixExpreesionList); //ArrayList [1,2,3,+,4,*,+,5,–]
-
-        System.out.println(calculate(suffixExpreesionList)); // ?
-
-
-
-		/*
-
-		//先定义给逆波兰表达式
-		//(30+4)×5-6  => 30 4 + 5 × 6 - => 164
-		// 4 * 5 - 8 + 60 + 8 / 2 => 4 5 * 8 - 60 + 8 2 / +
-		//测试
-		//说明为了方便，逆波兰表达式 的数字和符号使用空格隔开
-		//String suffixExpression = "30 4 + 5 * 6 -";
-		String suffixExpression = "4 5 * 8 - 60 + 8 2 / +"; // 76
-		//思路
-		//1. 先将 "3 4 + 5 × 6 - " => 放到ArrayList中
-		//2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算
-
-		List<String> list = getListString(suffixExpression);
-		System.out.println("rpnList=" + list);
-		int res = calculate(list);
-		System.out.println("计算的结果是=" + res);
-
-		*/
-    }
-
-
-
-    //即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]  =》 ArrayList [1,2,3,+,4,*,+,5,–]
-    //方法：将得到的中缀表达式对应的List => 后缀表达式对应的List
-    public static List<String> parseSuffixExpreesionList(List<String> ls) {
-        //定义两个栈
-        Stack<String> s1 = new Stack<String>(); // 符号栈
-        //说明：因为s2 这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出
-        //因此比较麻烦，这里我们就不用 Stack<String> 直接使用 List<String> s2
-        //Stack<String> s2 = new Stack<String>(); // 储存中间结果的栈s2
-        List<String> s2 = new ArrayList<String>(); // 储存中间结果的Lists2
-
-        //遍历ls
-        for(String item: ls) {
-            //如果是一个数，加入s2
-            if(!(item.equals("+")|| item.equals("-")|| item.equals("*") || item.equals("/")|| item.equals("(") || item.equals(")"))) {
-                s2.add(item);
-            } else if (item.equals("(")) {
-                s1.push(item);
-            } else if (item.equals(")")) {
-                //如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
-                while(!s1.peek().equals("(")) {
-                    s2.add(s1.pop());
-                }
-                s1.pop();//!!! 将 ( 弹出 s1栈， 消除小括号
-            } else {
-                //当item的优先级小于等于s1栈顶运算符, 将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较
-                //问题：我们缺少一个比较优先级高低的方法
-                while(s1.size() != 0 && Operation.getValue(s1.peek()) >= Operation.getValue(item) ) {
-                    s2.add(s1.pop());
-                }
-                //还需要将item压入栈
-                s1.push(item);
-            }
-        }
-
-        //将s1中剩余的运算符依次弹出并加入s2
-        while(s1.size() != 0) {
-            s2.add(s1.pop());
-        }
-
-        return s2; //注意因为是存放到List, 因此按顺序输出就是对应的后缀表达式对应的List
-
-    }
-
-    //方法：将 中缀表达式转成对应的List
-    //  s="1+((2+3)×4)-5";
-    public static List<String> toInfixExpressionList(String s) {
-        //定义一个List,存放中缀表达式 对应的内容
-        List<String> ls = new ArrayList<String>();
-        int i = 0; //这时是一个指针，用于遍历 中缀表达式字符串
-        String str; // 对多位数的拼接
-        char c; // 每遍历到一个字符，就放入到c
-        do {
-            //如果c是一个非数字，我需要加入到ls
-            if(((c=s.charAt(i)) < 48 ||  (c=s.charAt(i)) > 57) && (!s.substring(i,i+1).equals("."))) {
-                ls.add("" + c);
-                i++; //i需要后移
-            } else { //如果是一个数，需要考虑多位数
-                str = ""; //先将str 置成"" '0'[48]->'9'[57]
-                while(i < s.length() &&(( (c=s.charAt(i)) >= 48 && (c=s.charAt(i)) <= 57) || s.substring(i,i+1).equals("."))) {
-                    str += c;//拼接s.charAt(i)
-                    i++;
-                }
-                ls.add(str);
-            }
-        }while(i < s.length());
-        return ls;//返回
-    }
-
-    //将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList中
-    public static List<String> getListString(String suffixExpression) {
-        //将 suffixExpression 分割
-        String[] split = suffixExpression.split(" ");
-        List<String> list = new ArrayList<String>();
-        for(String ele: split) {
-            list.add(ele);
-        }
-        return list;
-
-    }
-
-    //完成对逆波兰表达式的运算
-	/*
-	 * 1)从左至右扫描，将3和4压入堆栈；
-		2)遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
-		3)将5入栈；
-		4)接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
-		5)将6入栈；
-		6)最后是-运算符，计算出35-6的值，即29，由此得出最终结果
-	 */
-
-    public static double calculate(List<String> ls) {
-        // 创建给栈, 只需要一个栈即可
-        Stack<String> stack = new Stack<String>();
-        // 遍历 ls
-        for (String item : ls) {
-            // 这里使用正则表达式来取出数
-            if (!(item.equals("+")|| item.equals("-")|| item.equals("*") || item.equals("/"))) { // 匹配的是多位数
-                // 入栈
-                stack.push(item);
-            } else {
-                // pop出两个数，并运算， 再入栈
-                double num2 =Double.parseDouble(stack.pop());
-                double num1 =Double.parseDouble(stack.pop());
-                double res = 0;
-                if (item.equals("+")) {
-                    res = num1 + num2;
-                } else if (item.equals("-")) {
-                    res = num1 - num2;
-                } else if (item.equals("*")) {
-                    res = num1 * num2;
-                } else if (item.equals("/")) {
-                    res = num1 / num2;
-                } else {
-                    throw new RuntimeException("运算符有误");
-                }
-                //把res 入栈
-                stack.push("" + res);
-            }
-
-        }
-        //最后留在stack中的数据是运算结果
-        return Double.parseDouble(stack.pop());
-    }
-
-}
-
-//编写一个类 Operation 可以返回一个运算符 对应的优先级
-class Operation {
-    private static int ADD = 1;
-    private static int SUB = 1;
-    private static int MUL = 2;
-    private static int DIV = 2;
-
-    //写一个方法，返回对应的优先级数字
-    public static int getValue(String operation) {
-        int result = 0;
-        switch (operation) {
-            case "+":
-                result = ADD;
-                break;
-            case "-":
-                result = SUB;
-                break;
-            case "*":
-                result = MUL;
-                break;
-            case "/":
-                result = DIV;
-                break;
-            default:
-                break;
-        }
-        return result;
-    }
-
-}
Index: sourceResearch/pom.xml
===================================================================
diff --git a/sourceResearch/pom.xml b/sourceResearch/pom.xml
deleted file mode 100644
--- a/sourceResearch/pom.xml	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,19 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <modelVersion>4.0.0</modelVersion>
-
-    <groupId>com.source</groupId>
-    <artifactId>sourceResearch</artifactId>
-    <version>1.0-SNAPSHOT</version>
-
-    <dependencies>
-        <dependency>
-            <groupId>org.apache.rocketmq</groupId>
-            <artifactId>rocketmq-spring-boot-starter</artifactId>
-            <version>2.0.4</version>
-        </dependency>
-    </dependencies>
-    
-</project>
\ No newline at end of file
Index: src/左神算法/基础班/树/PreInPostTree.java
===================================================================
diff --git a/src/左神算法/基础班/树/PreInPostTree.java b/src/左神算法/基础班/树/PreInPostTree.java
deleted file mode 100644
--- a/src/左神算法/基础班/树/PreInPostTree.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,114 +0,0 @@
-package 左神算法.基础班.树;
-
-import java.util.Stack;
-
-/**
- * 树的前序，中序后序遍历的非递归实现
- */
-public class PreInPostTree {      //非递归的方式实现树的前序，中序，后序遍历
-
-
-    public static class Node {
-        public int value;
-        public Node left;
-        public Node right;
-
-        public Node(int data) {
-            this.value = data;
-        }
-    }
-
-
-    public static void preOrderRecur(Node head) {
-        System.out.println("pre-order: ");
-        if (head != null) {
-            Stack<Node> stack = new Stack<>();
-            stack.add(head);
-            while (!stack.isEmpty()) {
-                head = stack.pop();
-                System.out.print(head.value + "\t");
-                if (head.right != null)
-                    stack.add(head.right);
-                if (head.left != null)
-                    stack.add(head.left);
-            }
-        }
-        System.out.println();
-
-    }
-
-    public static void inOrderRecur(Node head) {
-        System.out.println("In-Order: ");
-        if (head != null) {
-            Stack<Node> stack = new Stack<>();
-            while (!stack.isEmpty() || head != null) {
-                if (head != null) {
-                    stack.add(head);
-                    head = head.left;
-                } else {
-                    head = stack.pop();
-                    System.out.print(head.value + "\t");
-                    head = head.right;
-                }
-            }
-        }
-        System.out.println();
-    }
-
-    public static void posOrderRecur(Node head) {
-        System.out.print("pos-order: ");
-        if (head != null) {
-            Stack<Node> s1 = new Stack<Node>();
-            Stack<Node> s2 = new Stack<Node>();
-            s1.push(head);
-            while (!s1.isEmpty()) {
-                head = s1.pop();
-                s2.push(head);
-                if (head.left != null) {
-                    s1.push(head.left);
-                }
-                if (head.right != null) {
-                    s1.push(head.right);
-                }
-            }
-            while (!s2.isEmpty()) {
-                System.out.print(s2.pop().value + " ");
-            }
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-        Node head = new Node(5);
-        head.left = new Node(3);
-        head.right = new Node(8);
-        head.left.left = new Node(2);
-        head.left.right = new Node(4);
-        head.left.left.left = new Node(1);
-        head.right.left = new Node(7);
-        head.right.left.left = new Node(6);
-        head.right.right = new Node(10);
-        head.right.right.left = new Node(9);
-        head.right.right.right = new Node(11);
-
-        // recursive
-        System.out.println("==============recursive==============");
-        System.out.print("pre-order: ");
-        preOrderRecur(head);
-        System.out.println();
-        System.out.print("in-order: ");
-        inOrderRecur(head);
-        System.out.println();
-        System.out.print("pos-order: ");
-        posOrderRecur(head);
-        System.out.println();
-
-        // unrecursive
-//        System.out.println("============unrecursive=============");
-//        preOrderUnRecur(head);
-//        inOrderUnRecur(head);
-//        posOrderUnRecur1(head);
-//        posOrderUnRecur2(head);
-
-    }
-}
Index: src/org/sd/mediator/President.java
===================================================================
diff --git a/src/org/sd/mediator/President.java b/src/org/sd/mediator/President.java
deleted file mode 100644
--- a/src/org/sd/mediator/President.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,20 +0,0 @@
-package org.sd.mediator;
-
-import java.util.HashMap;
-import java.util.Map;
-
-public class President implements Mediator {
-	
-	private Map<String,Department> map = new HashMap<>();
-	
-	@Override
-	public void command(String dname) {
-		map.get(dname).selfAction();
-	}
-
-	@Override
-	public void register(String dname, Department d) {
-		map.put(dname, d);
-	}
-
-}
Index: src/左神算法/基础班/图/Prim.java
===================================================================
diff --git a/src/左神算法/基础班/图/Prim.java b/src/左神算法/基础班/图/Prim.java
deleted file mode 100644
--- a/src/左神算法/基础班/图/Prim.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,44 +0,0 @@
-package 左神算法.基础班.图;
-
-import java.util.Comparator;
-import java.util.HashSet;
-import java.util.PriorityQueue;
-import java.util.Set;
-
-public class Prim {
-
-    public static class EdgeComparator implements Comparator<Edge> {
-
-        @Override
-        public int compare(Edge o1, Edge o2) {
-            return o1.getWeight() - o2.getWeight();
-        }
-
-    }
-    public static Set<Edge> primMST(Graph graph) {
-        PriorityQueue<Edge> priorityQueue = new PriorityQueue<>(new EdgeComparator());
-        HashSet<Node> set = new HashSet<>();
-        Set<Edge> result = new HashSet<>();
-        for (Node node : graph.nodes.values()) { //认为是一个森林，所以加入一个for循环,随便一个点开始
-            if (!set.contains(node)) {
-                set.add(node);
-                for (Edge edge : node.edges) {
-                    priorityQueue.add(edge);
-                }
-                while (!priorityQueue.isEmpty()) {
-                    Edge edge = priorityQueue.poll();
-                    Node toNode = edge.to;
-                    if (!set.contains(toNode)) {
-                        set.add(toNode);
-                        result.add(edge);
-                        for (Edge nextEdge : node.edges) { //将选择的边的另一个点的相应的边也加入到priorityqueue
-                            priorityQueue.add(nextEdge);
-                        }
-                    }
-                }
-            }
-        }
-        return result;
-    }
-
-}
Index: src/韩顺平算法与数据结构/algorithm/prim/PrimAlgorithm.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/algorithm/prim/PrimAlgorithm.java b/src/韩顺平算法与数据结构/algorithm/prim/PrimAlgorithm.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/algorithm/prim/PrimAlgorithm.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,97 +0,0 @@
-package 韩顺平算法与数据结构.algorithm.prim;
-
-import java.util.Arrays;
-
-public class PrimAlgorithm {
-    public static void main(String[] args) {
-    char[]data=new char[]{'A','B','C','D','E','F','G'};
-    int vexs=data.length;
-        int [][]weight=new int[][]{
-                {10000,5,7,10000,10000,10000,2},
-                {5,10000,10000,9,10000,10000,3},
-                {7,10000,10000,10000,8,10000,10000},
-                {10000,9,10000,10000,10000,4,10000},
-                {10000,10000,8,10000,10000,5,4},
-                {10000,10000,10000,4,5,10000,6},
-                {2,3,10000,10000,4,6,10000},};
-       MinGraph graph=new MinGraph(vexs);
-       MinTree minTree=new MinTree();
-       minTree.createMinTree(graph,vexs,data,weight);
-       minTree.prim(graph,0);
-    }
-}
-
-class MinTree {
-
-    /**
-     * @param minGraph：图对象
-     * @param vexs：图的顶点个数
-     * @param data：图中结点的数据
-     * @param weight：图的边的权重
-     */
-    public void createMinTree(MinGraph minGraph, int vexs, char[] data, int[][] weight) {
-        for (int i = 0; i < vexs; i++) {
-            minGraph.data[i] = data[i];
-            for (int j = 0; j < vexs; j++) {
-                minGraph.weight[i][j] = weight[i][j];
-            }
-        }
-    }
-
-    //显示图的邻接矩阵
-    public void showMinTree(MinGraph minGraph) {
-        for (int[] link : minGraph.weight) {
-            System.out.println(Arrays.toString(link));
-        }
-    }
-
-    /**
-     * @param minGraph:图
-     * @param v：表示从第几个结点开始生成
-     */
-    public void prim(MinGraph minGraph, int v) {
-
-        //用来记录图的结点是否已经访问过,访问过标注为1，未访问过标注为0
-        int[] visited = new int[minGraph.vexs];
-        visited[v] = 1;//从v结点开始，因此标注为已经访问
-        //用来记录两个顶点的下标
-        int h1 = -1;
-        int h2 = -1;
-        int minWeight = 10000;//将minWeight初始化成一个大数，后面在遍历过程中会被替代
-        for (int k = 1; k < minGraph.vexs; k++)//生成边的数量为minGraph.vexs-1
-        {
-            //这个是确定每一次生成的子图，和哪一个结点的距离最近
-            for (int i = 0; i < minGraph.vexs; i++) //i结点表示已经访问过的结点
-            {
-                for (int j = 0; j < minGraph.vexs; j++)//j结点表示还没有访问过的结点
-                {
-                    if (visited[i] == 1 && visited[j] == 0 && minGraph.weight[i][j] < minWeight) {
-                        h1 = i;
-                        h2 = j;
-                        minWeight = minGraph.weight[i][j];
-                    }
-                }
-            }
-            System.out.println("边<" + minGraph.data[h1] + "," + minGraph.data[h2] + ">权值：" + minGraph.weight[h1][h2]);
-            visited[h2] = 1;
-            minWeight = 10000;
-
-
-        }
-    }
-
-}
-
-
-class MinGraph{
-    int vexs;//表示图的结点的数量
-    char[] data;//存储图的结点
-    int[][] weight;//表示图的边
-
-    public MinGraph(int vexs)
-    {
-        this.vexs=vexs;
-        data=new char[vexs];
-        weight=new int[vexs][vexs];
-    }
-}
\ No newline at end of file
Index: src/左神算法/基础班/第三课/PrintMatrixSpiralOrder.java
===================================================================
diff --git a/src/左神算法/基础班/第三课/PrintMatrixSpiralOrder.java b/src/左神算法/基础班/第三课/PrintMatrixSpiralOrder.java
deleted file mode 100644
--- a/src/左神算法/基础班/第三课/PrintMatrixSpiralOrder.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,62 +0,0 @@
-package 左神算法.基础班.第三课;
-
-public class PrintMatrixSpiralOrder {
-
-    public static void spiralOrderPrint(int[][]arr)
-    {
-        int row1=0;
-        int col1=0;
-        int row2=arr.length-1;
-        int col2=arr[0].length-1;
-        while(row1<=row2 && col1<=col2)
-        {
-            printEdge(arr,row1++,col1++,row2--,col2--);
-        }
-    }
-
-    public static void printEdge(int[][]arr,int row1,int col1,int row2,int col2)
-    {
-        if(row1==row2)
-        {
-            for(int i=col1;i<=row2;i++)
-            {
-                System.out.println(arr[row1][i]+"\t");
-            }
-        }else if(col1==col2)
-        {
-            for(int i=row1;i<=row2;i++)
-            {
-                System.out.println(arr[i][row1]+"\t");
-            }
-        }else{
-            int curR=row1;
-            int curC=col1;
-            while (curC!=col2)   //注意这里的写法，如果是curC<=col2的话，终止的时候curC已经越界了。后序处理会麻烦。
-            {
-                System.out.println(arr[row1][curC]+"\t");
-                curC++;
-            }
-            while(curR!=row2)
-            {
-                System.out.println(arr[curR][curC]);
-                curR++;
-            }
-            while(curC!=col1)
-            {
-                System.out.println(arr[row2][curC]);
-                curC--;
-            }
-            while(curR!=row1)
-            {
-                System.out.println(arr[curR][col1]);
-                curR--;
-            }
-        }
-    }
-    public static void main(String[] args) {
-        int[][] matrix = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 },
-                { 13, 14, 15, 16 } };
-        spiralOrderPrint(matrix);
-
-    }
-}
Index: src/左神算法/基础班/动态规划与递归/PrintPermutation.java
===================================================================
diff --git a/src/左神算法/基础班/动态规划与递归/PrintPermutation.java b/src/左神算法/基础班/动态规划与递归/PrintPermutation.java
deleted file mode 100644
--- a/src/左神算法/基础班/动态规划与递归/PrintPermutation.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,48 +0,0 @@
-package 左神算法.基础班.动态规划与递归;
-
-/**
- * 打印一个字符串的全部排列（可以出现重复的排列）
- */
-public class PrintPermutation {
-
-    public static void printAllPermutations1(String str){
-        char[] chars = str.toCharArray();
-        process1(chars,0);
-    }
-
-    public static void process1(char[] str,int i)
-    {
-        if(i==str.length-1)
-        {
-            System.out.println(String.valueOf(str));
-            return;
-        }
-        for(int j=i;j<str.length;j++)
-        {
-            swap(str,i,j);
-            process1(str,i+1);
-            swap(str,i,j);
-        }
-    }
-
-    public static void swap(char[] str,int i,int j)
-    {
-        char temp=str[i];
-        str[i]=str[j];
-        str[j]=temp;
-    }
-
-    public static void main(String[] args) {
-        String test1 = "abc";
-        printAllPermutations1(test1);
-        System.out.println("======");
-        //printAllPermutations2(test1);
-        System.out.println("======");
-
-        String test2 = "acc";
-        printAllPermutations1(test2);
-        System.out.println("======");
-        //printAllPermutations2(test2);
-        System.out.println("======");
-    }
-}
Index: src/左神算法/基础班/动态规划与递归/PrintSub.java
===================================================================
diff --git a/src/左神算法/基础班/动态规划与递归/PrintSub.java b/src/左神算法/基础班/动态规划与递归/PrintSub.java
deleted file mode 100644
--- a/src/左神算法/基础班/动态规划与递归/PrintSub.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,37 +0,0 @@
-package 左神算法.基础班.动态规划与递归;
-
-/**
- * 打印一个字符串的去全部子序列，包括空字符串
- */
-public class PrintSub {
-
-    //i表示字符串中字符的位置
-    public static void printAllSub(char[] str,int i,String res)
-    {
-        if(i==str.length)
-        {
-            System.out.println(res);
-            return;
-        }
-        printAllSub(str,i+1,res+String.valueOf(str[i]));//包含当前字符
-        printAllSub(str,i+1,res);//不包含当前字符，当前字符为空
-    }
-    //法二
-    public static void process(char[] chs, int i) {
-        if (i == chs.length) {
-            System.out.println(String.valueOf(chs));
-            return;
-        }
-        process(chs, i + 1);//这里相当于上面的包含当前字符
-        char tmp = chs[i];
-        chs[i] = 0;//ascii中0表示空字符
-        process(chs, i + 1);//这里相当于上面的不包含当前字符
-        chs[i] = tmp;
-    }
-
-    public static void main(String[] args) {
-        String s="abc";
-        String res="";
-        process(s.toCharArray(),0);
-    }
-}
Index: src/左神算法/进阶班二/第一章/PrintUniquePair.java
===================================================================
diff --git a/src/左神算法/进阶班二/第一章/PrintUniquePair.java b/src/左神算法/进阶班二/第一章/PrintUniquePair.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第一章/PrintUniquePair.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,69 +0,0 @@
-package 左神算法.进阶班二.第一章;
-
-import java.util.Arrays;
-
-/**
- * 给定一个数组arr,和一个整数aim,返回所有满足两个数相加等于aim的不同整数对///找出所有三个数相加等于aim的所有不同整数对
- */
-public class PrintUniquePair {
-
-    public static void printUniquePair(int[] arr,int aim){
-        if(arr==null || arr.length<2){
-            return;
-        }
-        Arrays.sort(arr);
-        int left=0;
-        int right=arr.length-1;
-        int sum=0;
-        while(left<right){
-            sum=arr[left]+arr[right];
-            if(sum<aim){
-                left++;
-            }else if(sum>aim){
-                right--;
-            }else{
-                if(left==0 || arr[left]!=arr[left-1]){
-                    System.out.println(arr[left]+"  "+arr[right]);
-                }
-                left++;
-                right--;
-            }
-        }
-    }
-    //三个值得
-    public static void printUniqueTriad(int[] arr,int aim){
-        if(arr==null || arr.length<3)
-            return;
-        Arrays.sort(arr);
-        for(int i=0;i<arr.length;i++){
-            if(i==0 || arr[i]!=arr[i-1]){
-                printRest(arr,i,i+1,arr.length-1,aim-arr[i]);
-            }
-        }
-    }
-
-    public static void printRest(int[] arr,int f,int l,int r,int k){
-        int sum=0;
-        while(l<r){
-            sum=arr[l]+arr[r];
-            if(sum<k){
-                l++;
-            }else if(sum>k){
-                r--;
-            }else{
-                if(l==f+1 || arr[l]!=arr[l-1] ){
-                    System.out.println(arr[f]+" "+arr[l]+" "+arr[r]);
-                }
-                l++;
-                r--;
-            }
-        }
-    }
-
-
-    public static void main(String[] args) {
-        int[] arr=new int[]{1,1,4,1,2,2,3,4,5,5,5,5,6,6,6,7};
-        printUniquePair(arr,8);
-        printUniqueTriad(arr,10);
-    }
-}
Index: src/左神算法/高频面试题/五/Problem1.java
===================================================================
diff --git a/src/左神算法/高频面试题/五/Problem1.java b/src/左神算法/高频面试题/五/Problem1.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/五/Problem1.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,37 +0,0 @@
-package 左神算法.高频面试题.五;
-
-import java.util.HashSet;
-import java.util.Scanner;
-import java.util.Set;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2020/1/5 21:57
- */
-public class Problem1 {
-
-    public static void main(String[] args) {
-        Scanner sc=new Scanner(System.in);
-        String s=sc.nextLine();
-        Set<Character> set=new HashSet<>();
-        int count =0;
-        for(char c:s.toCharArray()){
-            if(!set.contains(c)){
-                count++;
-                set.add(c);
-            }
-        }
-        if(count>2){
-            System.out.println(0);
-        }else if(count==2){
-            System.out.println(2);
-        }else {
-            System.out.println(count);
-        }
-        sc.close();
-    }
-
-
-}
Index: src/左神算法/高频面试题/六大量运用优先级队列/Problem1.java
===================================================================
diff --git a/src/左神算法/高频面试题/六大量运用优先级队列/Problem1.java b/src/左神算法/高频面试题/六大量运用优先级队列/Problem1.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/六大量运用优先级队列/Problem1.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,33 +0,0 @@
-package 左神算法.高频面试题.六大量运用优先级队列;
-
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 很简单，不用看了
- * @date 2020/1/8 10:12
- */
-public class Problem1 {
-
-    public static void main(String[] args) {
-        Scanner sc=new Scanner(System.in);
-        while(sc.hasNext()){
-            int x=sc.nextInt();
-            int f=sc.nextInt();
-            int d=sc.nextInt();
-            int p=sc.nextInt();
-            System.out.println(liveDay(x,f,d,p));
-        }
-        sc.close();
-    }
-
-    public static int liveDay(int x,int f,int d,int p){
-        int p1=d/x;
-        if(p1<=f){
-            return p1;
-        }
-        int res=d-f*x;
-        return f+res/(p+x);
-    }
-}
Index: src/左神算法/高频面试题/十京东/Problem1.java
===================================================================
diff --git a/src/左神算法/高频面试题/十京东/Problem1.java b/src/左神算法/高频面试题/十京东/Problem1.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/十京东/Problem1.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,9 +0,0 @@
-package 左神算法.高频面试题.十京东;
-/*
- 有一个无限长的数字序列：1、2、2、3、3、3……(数字k在该序列中正好出现k次)，求这个数组序列的第n项是多少。
- */
-public class Problem1 {
-    public static int getNumber(long n){
-        return (int)Math.ceil((Math.sqrt(1+8*(double)n)-1)/2);
-    }
-}
Index: src/左神算法/进阶班二/第一章/Problem01_Palindrome_Number.java
===================================================================
diff --git a/src/左神算法/进阶班二/第一章/Problem01_Palindrome_Number.java b/src/左神算法/进阶班二/第一章/Problem01_Palindrome_Number.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第一章/Problem01_Palindrome_Number.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,31 +0,0 @@
-package 左神算法.进阶班二.第一章;
-
-/*
-  给定一个整数，判断该数是否是回文数
- */
-public class Problem01_Palindrome_Number {
-
-    public static boolean isPalindrome(int num){
-        if(num <0){
-            return false;
-        }
-        int help=1;
-        //下面的while如果写成如下可能会溢出
-        //while(help<=n){
-        //help*=10;
-        //}
-        //help/=10;
-        while(num/help>=10){
-            help*=10;
-        }
-        while(num>0){
-            if(num/help!=num%10){
-                return false;
-            }
-            num=(num%help)/10;//num%help去掉num的最高位，再/10去掉number的最低位
-            help/=100;//因为number缩小了100倍，所以help缩小100倍
-        }
-        return true;
-
-    }
-}
Index: src/左神算法/进阶班二/第二章/Problem01_Ugly_Number.java
===================================================================
diff --git a/src/左神算法/进阶班二/第二章/Problem01_Ugly_Number.java b/src/左神算法/进阶班二/第二章/Problem01_Ugly_Number.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第二章/Problem01_Ugly_Number.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,63 +0,0 @@
-package 左神算法.进阶班二.第二章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 求第n个丑数
- * @date 2020/2/15 19:30
- */
-public class Problem01_Ugly_Number {
-
-    public static int uglyNumber1(int index){
-        int num=0;
-        int count=0;
-        while(count<index){
-            num++;
-            if(isUgly(num)){
-                count++;
-            }
-        }
-        return num;
-    }
-
-    public static boolean isUgly(int num){
-        //消除num所有的因子2
-        while(num%2==0){
-            num/=2;
-        }
-        while(num%3==0){
-            num/=3;
-        }
-        while(num%5==0){
-            num/=5;
-        }
-        return num==1 ? true:false;
-    }
-
-    public static int uglyNumber2(int n) {
-        int[] help = new int[n];
-        help[0] = 1;
-        int i2 = 0;//表示可能*2的位置，一开始在最开始的位置
-        int i3 = 0;//表示可能*3的位置，一开始在最开始的位置
-        int i5 = 0;//表示可能*5的位置，一开始在最开始的位置
-        int index = 1;
-        while (index < n) {
-            help[index] = Math.min(2 * help[i2], Math.min(3 * help[i3], 5 * help[i5]));
-            if (help[index] == 2 * help[i2])//下一个数来自可能*2的位置，那么再下一个可能*2的位置就到下一个数的位置了
-                i2++;
-            if (help[index] == 3 * help[i3])
-                i3++;
-            if (help[index] == 5 * help[i5])
-                i5++;
-            index++;
-        }
-        return help[index - 1];
-    }
-
-    public static void main(String[] args) {
-        int test = 8;
-        System.out.println(uglyNumber1(test));
-        System.out.println(uglyNumber2(test));
-    }
-
-}
Index: src/左神算法/高频面试题/五/Problem2.java
===================================================================
diff --git a/src/左神算法/高频面试题/五/Problem2.java b/src/左神算法/高频面试题/五/Problem2.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/五/Problem2.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,46 +0,0 @@
-package 左神算法.高频面试题.五;
-
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2020/1/5 22:02
- */
-public class Problem2 {
-
-    public static void main(String[] args) {
-        Scanner sc=new Scanner(System.in);
-        System.out.println("请输入数组长度： ");
-        while(sc.hasNext()){
-
-            int n=sc.nextInt();
-            int[] arr=new int[n];
-            System.out.println("请输入数组元素： ");
-            for(int i=0;i<n;i++){
-                arr[i]=sc.nextInt();
-            }
-            if(isArithmeticSequeue(arr,n))
-            {
-                System.out.println("Possible");
-            }else {
-                System.out.println("Impossible");
-            }
-
-        }
-    }
-
-    public static boolean isArithmeticSequeue(int[] seq,int n){
-        int sum=0;
-        int min=Integer.MAX_VALUE;
-        for(int i=0;i<n;i++){
-            sum+=seq[i];
-            min=Math.min(min,seq[i]);
-        }
-        if ((2 * (sum - n * min)) % (n * (n - 1)) == 0)
-            return true;
-        else
-            return false;
-    }
-}
Index: src/左神算法/高频面试题/六大量运用优先级队列/Problem2.java
===================================================================
diff --git a/src/左神算法/高频面试题/六大量运用优先级队列/Problem2.java b/src/左神算法/高频面试题/六大量运用优先级队列/Problem2.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/六大量运用优先级队列/Problem2.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,64 +0,0 @@
-package 左神算法.高频面试题.六大量运用优先级队列;
-
-import java.util.PriorityQueue;
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 小易将n个棋子放在一张无限大的棋盘上。第i个棋子在在第x[i]行，y[i]列。同一个格子可以放置多个棋子。每一次操作小易可以把一个棋子拿起并移动到原来
- * 格子的上下左右的任意一个格子中，小易想知道要让棋盘上出现一个格子中至少有i(1<=i<=n)个棋子所需要的最少操作次数
- * @date 2020/1/8 10:17
- */
-public class Problem2 {
-
-    public static void main(String[] args) {
-        Scanner in = new Scanner(System.in);
-        while (in.hasNextInt()) {
-            int size = in.nextInt();
-            int[] x = new int[size];
-            int[] y = new int[size];
-            for (int i = 0; i < size; i++) {
-                x[i] = in.nextInt();
-            }
-            for (int i = 0; i < size; i++) {
-                y[i] = in.nextInt();
-            }
-            int[] res = minOPs(size, x, y);
-            StringBuilder result = new StringBuilder();
-            for (int i = 0; i < size; i++) {
-                result.append(String.valueOf(res[i]) + " ");
-            }
-            System.out.println(result.toString().trim());
-        }
-        in.close();
-    }
-
-    public static int[] minOPs(int size,int[] x,int[] y){
-        int[] res=new int[size];
-        for(int i=0;i<size;i++){
-            res[i]=Integer.MAX_VALUE;
-        }
-        PriorityQueue<Integer>pq=new PriorityQueue<>();
-
-        for(int i=0;i<size;i++){
-            for(int j=0;j<size;j++){//选中n^2个点，求棋子到选中的点的距离，从中选出距离最小的。
-
-                for(int k=0;k<size;k++){//求每一个点到选中的点的曼哈顿距离
-                    pq.add(Math.abs(x[k]-x[i])+Math.abs(y[k]-y[j]));
-
-                }
-
-                int sum=0;
-                int resI=0;
-                while(!pq.isEmpty()){
-                    sum+=pq.poll();
-                    res[resI]=Math.min(res[resI],sum);//选取所有距离中的最小的,res[i]代表使一个格子中有i+1个棋子的最小值
-                    resI++;
-                }
-            }
-        }
-        return res;
-    }
-
-}
Index: src/左神算法/进阶班二/第二章/Problem02_Palindrome_Pairs好难.java
===================================================================
diff --git a/src/左神算法/进阶班二/第二章/Problem02_Palindrome_Pairs好难.java b/src/左神算法/进阶班二/第二章/Problem02_Palindrome_Pairs好难.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第二章/Problem02_Palindrome_Pairs好难.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,118 +0,0 @@
-package 左神算法.进阶班二.第二章;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 链表words中都是不同的词，如果其中str1加str2之后是回文串，
-则str1的位置和str2的位置我们需要收集。
-比如
-words = ["bat", "tab", "cat"]
-返回[[0, 1], [1, 0]]
-words = ["abcd", "dcba", "lls", "s", "sssll"]
-返回[[0, 1], [1, 0], [3, 2], [2, 4]]
- * @date 2020/2/17 15:21
- */
-public class Problem02_Palindrome_Pairs好难 {
-
-    public static List<List<Integer>> palindromePairs(String[] words) {
-        HashMap<String, Integer> wordset = new HashMap<>();
-        for (int i = 0; i < words.length; i++) {
-            wordset.put(words[i], i);
-        }
-        List<List<Integer>> res = new ArrayList<>();
-        for (int i = 0; i < words.length; i++) {
-            res.addAll(findAll(words[i], i, wordset));
-        }
-        return res;
-    }
-
-    public static List<List<Integer>> findAll(String word, int index, HashMap<String, Integer> words) {
-        List<List<Integer>> res = new ArrayList<>();
-        int[] rs = manacherrs(word);
-        String reverse = reverse(word);
-        Integer rest = words.get("");
-        if (rest != null && rest != index && word.equals(reverse)) {
-            addRecord(res, rest, index);
-            addRecord(res, index, rest);
-        }
-        int mid = rs.length >> 1;
-        for (int i = 1; i < mid; i++) {
-            if (i - rs[i] == -1) {
-                rest = words.get(reverse.substring(0, mid - i));
-                if (rest != null && rest != index) {
-                    addRecord(res, rest, index);
-                }
-            }
-        }
-        for (int i = mid + 1; i < rs.length; i++) {
-            if (i + rs[i] == rs.length) {
-                rest = words.get(reverse.substring((mid << 1) - i));
-                if (rest != null && rest != index) {
-                    addRecord(res, index, rest);
-                }
-            }
-        }
-        return res;
-    }
-
-    public static void addRecord(List<List<Integer>> res, int left, int right) {
-        List<Integer> newr = new ArrayList<>();
-        newr.add(left);
-        newr.add(right);
-        res.add(newr);
-    }
-
-    public static int[] manacherrs(String word) {
-        char[] mchs = manachercs(word);
-        int[] rs = new int[mchs.length];
-        int center = -1;
-        int pr = -1;
-        for (int i = 0; i != mchs.length; i++) {
-            rs[i] = pr > i ? Math.min(rs[(center << 1) - i], pr - i) : 1;
-            while (i + rs[i] < mchs.length && i - rs[i] > -1) {
-                if (mchs[i + rs[i]] != mchs[i - rs[i]]) {
-                    break;
-                }
-                rs[i]++;
-            }
-            if (i + rs[i] > pr) {
-                pr = i + rs[i];
-                center = i;
-            }
-        }
-        return rs;
-    }
-
-    public static char[] manachercs(String word) {
-        char[] chs = word.toCharArray();
-        char[] mchs = new char[chs.length * 2 + 1];
-        int index = 0;
-        for (int i = 0; i != mchs.length; i++) {
-            mchs[i] = (i & 1) == 0 ? '#' : chs[index++];
-        }
-        return mchs;
-    }
-
-    public static String reverse(String str) {
-        char[] chs = str.toCharArray();
-        int l = 0;
-        int r = chs.length - 1;
-        while (l < r) {
-            chs[l] ^= chs[r];
-            chs[r] ^= chs[l];
-            chs[l++] ^= chs[r--];
-        }
-        return String.valueOf(chs);
-    }
-
-    public static void main(String[] args) {
-        String [] strs=new String[]{"bat", "tab", "cat"};
-        List<List<Integer>> lists = palindromePairs(strs);
-        System.out.println(lists.size());
-    }
-}
Index: src/左神算法/进阶班二/第一章/Problem02_TwoSum.java
===================================================================
diff --git a/src/左神算法/进阶班二/第一章/Problem02_TwoSum.java b/src/左神算法/进阶班二/第一章/Problem02_TwoSum.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第一章/Problem02_TwoSum.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,110 +0,0 @@
-package 左神算法.进阶班二.第一章;
-
-import java.util.Arrays;
-import java.util.HashMap;
-
-/*
-   给定一个数组arr,和一个整数aim，请返回哪两个位置的数可以加出aim来。
- */
-public class Problem02_TwoSum {
-
-     public static int[] twoSum1(int[] arr,int aim){
-         HashMap<Integer,Integer> map=new HashMap<>();
-         for(int i=0;i<arr.length;i++){
-             map.put(arr[i],i);
-         }
-         Arrays.sort(arr);
-         int left=0;
-         int right=arr.length-1;
-         while(left<right){
-             if(arr[left]+arr[right]<aim){
-                 left++;
-             }else if(arr[left]+arr[right]>aim){
-                 right--;
-             }else{
-                 return new int[]{map.get(arr[left]),map.get(arr[right])};
-
-             }
-         }
-         return new int[]{-1,-1};
-     }
-     //方法二：自定义堆排序的方式，然后左右指针移动
-     public static int[] twoSum2(int[] arr,int aim){
-         int [] indices=new int[arr.length];//用来记录数组中元素在数组中原来的位置，作用类似于上面方法的map
-         for(int i=0;i<arr.length;i++){
-             indices[i]=i;
-         }
-         sort(arr,indices);
-         int left=0;
-         int right=arr.length-1;
-         int sum=0;
-         while(left<right){
-             sum=arr[left]+arr[right];
-             if(sum<aim){
-                 left++;
-             }else if(sum>aim){
-                 right--;
-             }else {
-                 return new int[]{indices[left],indices[right]};
-             }
-         }
-         return new int[]{-1,-1};
-     }
-
-     public static void sort(int[] arr,int[] indices){
-       for(int i=0;i<arr.length;i++){
-           heapInsert(arr,indices,i);
-       }
-       int len=arr.length-1;
-       while(len>0){
-           swap(arr,indices,0,len);
-           heapify(arr,indices,--len);
-       }
-     }
-     //构造大根堆，
-     public static void heapInsert(int[] arr,int[] indices,int i){
-         while(i>0){
-             int p=(i-1)/2;
-             if(arr[p]<arr[i]){
-                 swap(arr,indices,i,p);
-                 i=p;
-             }else{
-                 break;
-             }
-         }
-     }
-     public static void heapify(int[] arr,int[] indices,int size){
-         int index=0;
-         int largest=1;
-         while(largest<size){
-             largest=(largest+1<size && arr[largest+1]>arr[largest])? largest+1:largest;
-             if(arr[index]>=arr[largest]){
-                 break;
-             }else{
-                 swap(arr,indices,index,largest);
-                 index=largest;
-                 largest=index*2+1;
-             }
-         }
-     }
-     //同时交换arr与indices相关联的元素
-     public static void swap(int[] arr,int[] indices,int i,int j){
-         int temp=arr[i];
-         arr[i]=arr[j];
-         arr[j]=temp;
-         temp=indices[i];
-         indices[i]=indices[j];
-         indices[j]=temp;
-     }
-
-    public static void main(String[] args) {
-        int[] arr=new int[]{1,24,3,4,5,8,10};
-        int[] res= twoSum2(arr, 8);
-        int[] arr1=new int[]{1,24,3,4,5,8,10};
-
-        int[] res2 = twoSum1(arr1, 8);
-        System.out.println(res[0]+" "+res[1]);
-        System.out.println(res2[0]+" "+res2[1]);
-
-    }
-}
Index: src/左神算法/高频面试题/五/Problem3.java
===================================================================
diff --git a/src/左神算法/高频面试题/五/Problem3.java b/src/左神算法/高频面试题/五/Problem3.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/五/Problem3.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,77 +0,0 @@
-package 左神算法.高频面试题.五;
-
-import java.util.HashMap;
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2020/1/5 22:10
- */
-public class Problem3 {
-
-    public static void main(String[] args) {
-        Scanner sc=new Scanner(System.in);
-        System.out.println("请输入字符串s ");
-        String str= sc.nextLine();
-        System.out.println("请输入字符串长度：");
-        int n=sc.nextInt();
-        System.out.println(maxSubString(str));
-        System.out.println(maxEqual0And1(str));
-        sc.close();
-
-    }
-
-    public static int maxSubString(String str){
-        if(str==null || str.length()==0)
-            return 0;
-        int cur=1;
-        int max=1;
-        char[] chas = str.toCharArray();
-        for(int i=1;i<chas.length;i++){
-            if(chas[i]!=chas[i-1])
-            {
-                cur++;
-                max=Math.max(cur,max);
-            }else{
-                cur=1;
-            }
-        }
-        return max;
-    }
-
-    public static int maxEqual0And1(String str){
-           if(str==null || str.length()<2)
-           {
-               return 0;
-           }
-           char[] chas=str.toCharArray();
-           //System.out.println(Arrays.toString(chas));
-           int[] arr=new int[chas.length];
-           for(int i=0;i<arr.length;i++){
-               if(chas[i]=='0')
-               {
-
-                   arr[i]=-1;
-               }else if(chas[i]=='1') {
-                   arr[i]=1;
-               }
-           }
-         // System.out.println(Arrays.toString(arr));
-           HashMap<Integer,Integer>map=new HashMap<>();
-           map.put(0,-1);
-           int cur=0;
-           int max=0;
-           for(int i=0;i<arr.length;i++){
-               cur+=arr[i];
-               if(!map.containsKey(cur))
-               {
-                   map.put(cur,i);
-               }else{
-                   max=Math.max(max,i-map.get(cur));
-               }
-           }
-           return max;
-    }
-}
Index: src/左神算法/高频面试题/六大量运用优先级队列/Problem3.java
===================================================================
diff --git a/src/左神算法/高频面试题/六大量运用优先级队列/Problem3.java b/src/左神算法/高频面试题/六大量运用优先级队列/Problem3.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/六大量运用优先级队列/Problem3.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,49 +0,0 @@
-package 左神算法.高频面试题.六大量运用优先级队列;
-
-import java.util.Arrays;
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 定义疯狂队列为每对相邻元素差的绝对值总和。给出n个元素，请你排序求出他们最大疯狂队列。
- * @date 2020/1/9 10:05
- */
-public class Problem3 {
-
-
-    public static void main(String[] args) {
-        Scanner in =new Scanner(System.in);
-        while(in.hasNext()){
-            int n=in.nextInt();
-            int [] arr=new int[n];
-            for(int i=0;i<n;i++){
-                arr[i]=in.nextInt();
-            }
-            System.out.println(maxMad(arr));
-        }
-        in.close();
-    }
-
-    public static int maxMad(int[] arr){
-
-        //先将数组进行从大到小的顺序排序
-        Arrays.sort(arr);
-        int res=arr[arr.length-1]-arr[0];
-        int maxI=arr.length-2;
-        int minI=1;
-        while(minI<maxI){
-            res+=arr[maxI+1]-arr[minI];
-            res+=arr[maxI]-arr[minI-1];
-            minI++;
-            maxI--;
-        }
-        //一共有奇数个元素的时候会发生以下过程
-        if(maxI==minI){
-            res+=Math.max(arr[maxI]-arr[maxI-1],arr[maxI+1]-arr[maxI]);
-        }
-
-        return res;
-
-    }
-}
Index: src/左神算法/进阶班二/第二章/Problem03_MaxTree.java
===================================================================
diff --git a/src/左神算法/进阶班二/第二章/Problem03_MaxTree.java b/src/左神算法/进阶班二/第二章/Problem03_MaxTree.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第二章/Problem03_MaxTree.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,25 +0,0 @@
-package 左神算法.进阶班二.第二章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 定义二叉树节点如下：
-public class Node {
-public int value;
-public Node left;
-public Node right;
-public Node(int data) {
-this.value = data;
-}
-}
-一个数组的MaxTree定义如下。
-数组必须没有重复元素。
-MaxTree是一棵二叉树，数组的每一个值对应一个二叉树节点。
-包括MaxTree树在内且在其中的每一棵子树上，值最大的节点都是树的头。
-给定一个没有重复元素的数组arr，写出生成这个数组的MaxTree的函数，要求如果数组长
-度为N，则时间复杂度为O(N)、额外空间复杂度为O(N)。
- * @date 2020/2/18 19:00
- */
-public class Problem03_MaxTree {
-}
Index: src/左神算法/进阶班二/第一章/Problem03_RelocateLinkedList.java
===================================================================
diff --git a/src/左神算法/进阶班二/第一章/Problem03_RelocateLinkedList.java b/src/左神算法/进阶班二/第一章/Problem03_RelocateLinkedList.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第一章/Problem03_RelocateLinkedList.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,160 +0,0 @@
-package 左神算法.进阶班二.第一章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 给定一个链表list，
-如果：
-list = 1 调整之后1。
-list = 1->2 调整之后1->2
-list = 1->2->3 调整之后1->2->3
-list = 1->2->3->4 调整之后1->3->2->4
-list = 1->2->3->4->5 调整之后1->3->2->4->5
-list = 1->2->3->4->5->6 调整之后1->4->2->5->3->6
-list = 1->2->3->4->5->6->7 调整之后1->4->2->5->3->6->7
-根据上面的规律，调整一个任意长度的链表。
- * @date 2020/2/11 17:34
- */
-public class Problem03_RelocateLinkedList {
-    public static class Node{
-        public int value;
-        public Node next;
-
-        public Node(int value) {
-            this.value = value;
-        }
-    }
-
-    //使用辅助数组的方式
-    public static void relocate1(Node head){
-
-        if(head==null || head.next==null || head.next.next==null){
-            return;
-        }
-        int len=0;
-        Node cur=head;
-        while(cur!=null){
-            len++;
-            cur=cur.next;
-        }
-        Node [] arr=new Node[(len & 1)==1 ?len-1:len];
-        cur=head;
-        for(int i=0;i<arr.length;i++)
-        {//最终cur会到达链表的最后位值
-            arr[i]=cur;
-            cur=cur.next;
-        }
-        Node[] help=new Node[arr.length];
-        for(int i=0;i<help.length;i++){
-            if(i<help.length/2){
-                help[2*i]=arr[i];
-            }else
-            {
-                help[(i-help.length/2)*2+1]=arr[i];
-            }
-        }
-        int j=1;
-        Node temp=head;
-        while(j<help.length){
-            temp.next=help[j];
-            j++;
-            temp=temp.next;
-        }
-        temp.next=cur;
-    }
-
-    //使用快慢指针的方式
-    public static void relocate(Node head){
-        if(head==null || head.next==null || head.next.next==null)
-            return;
-        Node left=head;
-        Node right=head.next;//为了使right走到最后的时候，left处在左半部分的最后一个结点
-        while(right.next!=null && right.next.next!=null){
-            right=right.next.next;
-            left=left.next;
-        }
-        right=left.next;//right指向右半部分的第一个节点
-        left.next=null;//断开左右两部分
-        mergeLR(head,right);
-
-    }
-
-    public static void mergeLR(Node left,Node right){
-       Node next=null;
-       while(left.next!=null){
-           next=right.next;
-           right.next=left.next;
-           left.next=right;
-           left=right.next;
-           right=next;
-       }
-       left.next=right;
-    }
-
-
-    public static void printLinkedList(Node head) {
-        System.out.print("Linked List: ");
-        while (head != null) {
-            System.out.print(head.value + " ");
-            head = head.next;
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-        Node head = null;
-        relocate(head);
-        printLinkedList(head);
-
-        head = new Node(1);
-        relocate(head);
-        printLinkedList(head);
-
-        head = new Node(1);
-        head.next = new Node(2);
-        relocate(head);
-        printLinkedList(head);
-
-        head = new Node(1);
-        head.next = new Node(2);
-        head.next.next = new Node(3);
-        relocate(head);
-        printLinkedList(head);
-
-        head = new Node(1);
-        head.next = new Node(2);
-        head.next.next = new Node(3);
-        head.next.next.next = new Node(4);
-        relocate(head);
-        printLinkedList(head);
-
-        head = new Node(1);
-        head.next = new Node(2);
-        head.next.next = new Node(3);
-        head.next.next.next = new Node(4);
-        head.next.next.next.next = new Node(5);
-        relocate(head);
-        printLinkedList(head);
-
-        head = new Node(1);
-        head.next = new Node(2);
-        head.next.next = new Node(3);
-        head.next.next.next = new Node(4);
-        head.next.next.next.next = new Node(5);
-        head.next.next.next.next.next = new Node(6);
-        relocate(head);
-        printLinkedList(head);
-
-        head = new Node(1);
-        head.next = new Node(2);
-        head.next.next = new Node(3);
-        head.next.next.next = new Node(4);
-        head.next.next.next.next = new Node(5);
-        head.next.next.next.next.next = new Node(6);
-        head.next.next.next.next.next.next = new Node(7);
-        relocate(head);
-        printLinkedList(head);
-    }
-
-}
Index: src/左神算法/高频面试题/五/Problem4.java
===================================================================
diff --git a/src/左神算法/高频面试题/五/Problem4.java b/src/左神算法/高频面试题/五/Problem4.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/五/Problem4.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,81 +0,0 @@
-package 左神算法.高频面试题.五;
-
-import java.util.Deque;
-import java.util.LinkedList;
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 小易有一个长度为n的整数序列，a1,a2 ......an，然后考虑在一个空序列b上进行n次以下操作：
- * 1.将ai放入b序列的末尾2.逆转b序列，小易需要你计算输出n次之后的b序列
- * @date 2020/1/6 11:09
- */
-public class Problem4 {
-
-    public static void main(String[] args) {
-        Scanner sc=new Scanner(System.in);
-        int num=sc.nextInt();
-        int[] arr=new int[num];
-        for(int i=0;i<num;i++){
-            arr[i]=sc.nextInt();
-        }
-        String str = reverse(arr, num);
-        char[] chas=str.toCharArray();
-        for(int i=0;i<chas.length;i++){
-            if(i!=chas.length-1){
-                System.out.print(chas[i]-'0'+" ");
-            }else {
-                System.out.print(chas[i]-'0');
-            }
-
-        }
-        sc.close();
-        //reverse2();
-
-    }
-
-    //方法一
-    public static String reverse(int[] arr,int num){
-        if(num==1){
-            return String.valueOf(arr[0]);
-        }
-         return arr[num-1]+new String(new StringBuffer(reverse(arr,num-1)).reverse());
-
-
-
-
-    }
-
-    //方法二，使用双端队列
-    public static void reverse2(){
-        Scanner in = new Scanner(System.in);
-        while (in.hasNextInt()) {
-            int n = in.nextInt();
-            Deque<Integer> deque = new LinkedList<Integer>();
-            boolean convert = false;
-            for (int i = 0; i < n; i++) {
-                if (convert) {
-                    deque.addLast(in.nextInt());
-                } else {
-                    deque.addFirst(in.nextInt());
-                }
-                convert = !convert;
-            }
-            if (convert) {
-                while (deque.size() != 1) {
-                    System.out.print(deque.pollFirst() + " ");
-                }
-                System.out.println(deque.pollFirst());
-            } else {
-                while (deque.size() != 1) {
-                    System.out.print(deque.pollLast() + " ");
-                }
-                System.out.println(deque.pollLast());
-            }
-        }
-        in.close();
-    }
-
-
-}
Index: src/左神算法/高频面试题/六大量运用优先级队列/Problem4.java
===================================================================
diff --git a/src/左神算法/高频面试题/六大量运用优先级队列/Problem4.java b/src/左神算法/高频面试题/六大量运用优先级队列/Problem4.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/六大量运用优先级队列/Problem4.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,146 +0,0 @@
-package 左神算法.高频面试题.六大量运用优先级队列;
-
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:小易非常喜欢拥有以下性质的数列：
- * 1.数列的长度为n,2.数列中每个元素的值在1到K之间（包括1和k)3.对于相邻的两个数A和B（A在B的前边），都满足A<=B,或者A mod B!=0，满足其一即可。
- * 给出n和K，求出有多少个他喜欢的队列。
- * @date 2020/1/9 10:18
- */
-public class Problem4 {
-
-    public static long number1(int n,int k){
-        return process(1,n,k);
-    }
-    //pre表示当前要放的元素的前一个元素是啥,n表示还有多少个元素要放，k,表示放得元素的最大值可以是啥
-    public static long process(int pre,int n,int k){
-        if(n==0){ //n=0说明没有需要填的数了，也就是已经得出答案了，所以返回1
-            return 1L;
-        }
-        long sum=0;
-        for(int cur=pre;cur<=k;cur++){
-            sum+=process(cur,n-1,k);
-        }
-        for(int cur=1;cur<pre;cur++){
-            sum+=(pre%cur)!=0 ? process(cur,n-1,k):0;
-        }
-
-        return sum;
-    }
-
-    public static long number2(int n,int k){
-        long[][]dp=new long[k+1][n];
-        for(int i=0;i<k+1;i++){
-            dp[i][0]=1L;
-        }
-        for(int col=1;col<n;col++){
-            for(int row= 1;row<k+1;row++){
-                long sum=0L;
-                for( int cur=row;cur<=k;cur++){
-                    sum+=dp[cur][col-1];
-                }
-                for(int cur=1;cur<row;cur++){
-                    sum+=(row%cur)!=0 ? dp[cur][col-1]:0;
-                }
-                dp[row][col] = sum % 1000000007L;
-            }
-        }
-        long res=0L;
-        for(int i=1;i<=k;i++){
-            res+=dp[i][n-1];//res即是dp[1][n]，而上面的循环仅仅求出到dp[i][n-1]
-            res %= 1000000007L; //为了防止越界
-        }
-        return res;
-
-    }
-
-
-    public static long number3(int n,int k){
-        long[][]dp=new long[k+1][n];
-        for(int i=0;i<k+1;i++){
-            dp[i][0]=1L;
-        }
-        for(int col=1;col<n;col++){
-            Long sum=0L;
-            for(int row=1;row<=k;row++)
-                sum+=dp[row][col-1];//求出上一列的总和
-                sum %= 1000000007L;
-            for(int row=1;row<=k;row++){
-                long noInclude=0L;
-                for(int cur=1;cur<row;cur++){//row之前不满足条件的总和
-                    if(row%cur==0){
-                    noInclude+=dp[cur][col-1];
-                    noInclude %= 1000000007L;
-                    }
-
-                }
-                dp[row][col] = (sum - noInclude) % 1000000007L;//用上一列的总和减去row之前不满足条件的。
-
-            }
-
-
-        }
-        long res=0L;
-        for(int i=1;i<=k;i++){
-            res+=dp[i][n-1];
-            res %= 1000000007L;
-
-        }
-        return res;
-
-    }
-    //用一维数组来实现
-    public static long number4(int n,int k){
-         long[] dp=new long[k+1];
-         for(int i=0;i<dp.length;i++){
-             dp[i]=1;
-         }
-         for(int col=1;col<n;col++){
-             long sum=0;
-             for(int row=1;row<=k;row++){
-                sum+=dp[row];//求出上一列的总和
-                sum %= 1000000007L;
-
-             }
-            for(int cur=k;cur>=1;cur--){ //从高的到低的倒着来计算，-
-                 long noInclude=0;
-                 for(int i=1;i<cur;i++){
-                     if(cur%i==0) {//cur之前不满足不满足条件的
-                     noInclude+=dp[i];
-                      noInclude %= 1000000007L;
-                     }
-                 }
-                dp[cur] = (sum - noInclude) % 1000000007L;
-            }
-
-         }
-
-         long res=0L;
-         for(int i=1;i<=k;i++){
-             res+=dp[i];
-             res %= 1000000007L;
-
-         }
-         return res;
-    }
-
-
-    public static void main(String[] args) {
-        System.out.println(number1(10, 9));
-        System.out.println(number2(10, 9));
-        System.out.println(number3(10, 9));
-        System.out.println(number4(10, 9));
-
-        Scanner in = new Scanner(System.in);
-
-        while (in.hasNextInt()) {
-            int n = in.nextInt();
-            int k = in.nextInt();
-            System.out.println(number2(n, k));
-        }
-        in.close();
-    }
-}
Index: src/左神算法/高频面试题/动态规划与递归/Problem4.java
===================================================================
diff --git a/src/左神算法/高频面试题/动态规划与递归/Problem4.java b/src/左神算法/高频面试题/动态规划与递归/Problem4.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/动态规划与递归/Problem4.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,146 +0,0 @@
-package 左神算法.高频面试题.动态规划与递归;
-
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:小易非常喜欢拥有以下性质的数列：
- * 1.数列的长度为n,2.数列中每个元素的值在1到K之间（包括1和k)3.对于相邻的两个数A和B（A在B的前边），都满足A<=B,或者A mod B!=0，满足其一即可。
- * 给出n和K，求出有多少个他喜欢的队列。
- * @date 2020/1/9 10:18
- */
-public class Problem4 {
-
-    public static long number1(int n,int k){
-        return process(1,n,k);
-    }
-    //pre表示当前要放的元素的前一个元素是啥,n表示还有多少个元素要放，k,表示放得元素的最大值可以是啥
-    public static long process(int pre,int n,int k){
-        if(n==0){ //n=0说明没有需要填的数了，也就是已经得出答案了，所以返回1
-            return 1L;
-        }
-        long sum=0;
-        for(int cur=pre;cur<=k;cur++){
-            sum+=process(cur,n-1,k);
-        }
-        for(int cur=1;cur<pre;cur++){
-            sum+=(pre%cur)!=0 ? process(cur,n-1,k):0;
-        }
-
-        return sum;
-    }
-
-    public static long number2(int n,int k){
-        long[][]dp=new long[k+1][n];
-        for(int i=0;i<k+1;i++){
-            dp[i][0]=1L;
-        }
-        for(int col=1;col<n;col++){
-            for(int row= 1;row<k+1;row++){
-                long sum=0L;
-                for( int cur=row;cur<=k;cur++){
-                    sum+=dp[cur][col-1];
-                }
-                for(int cur=1;cur<row;cur++){
-                    sum+=(row%cur)!=0 ? dp[cur][col-1]:0;
-                }
-                dp[row][col] = sum % 1000000007L;
-            }
-        }
-        long res=0L;
-        for(int i=1;i<=k;i++){
-            res+=dp[i][n-1];//res即是dp[1][n]，而上面的循环仅仅求出到dp[i][n-1]
-            res %= 1000000007L; //为了防止越界
-        }
-        return res;
-
-    }
-
-
-    public static long number3(int n,int k){
-        long[][]dp=new long[k+1][n];
-        for(int i=0;i<k+1;i++){
-            dp[i][0]=1L;
-        }
-        for(int col=1;col<n;col++){
-            Long sum=0L;
-            for(int row=1;row<=k;row++)
-                sum+=dp[row][col-1];//求出上一列的总和
-                sum %= 1000000007L;
-            for(int row=1;row<=k;row++){
-                long noInclude=0L;
-                for(int cur=1;cur<row;cur++){//row之前不满足条件的总和
-                    if(row%cur==0){
-                    noInclude+=dp[cur][col-1];
-                    noInclude %= 1000000007L;
-                    }
-
-                }
-                dp[row][col] = (sum - noInclude) % 1000000007L;//用上一列的总和减去row之前不满足条件的。
-
-            }
-
-
-        }
-        long res=0L;
-        for(int i=1;i<=k;i++){
-            res+=dp[i][n-1];
-            res %= 1000000007L;
-
-        }
-        return res;
-
-    }
-    //用一维数组来实现
-    public static long number4(int n,int k){
-         long[] dp=new long[k+1];
-         for(int i=0;i<dp.length;i++){
-             dp[i]=1;
-         }
-         for(int col=1;col<n;col++){
-             long sum=0;
-             for(int row=1;row<=k;row++){
-                sum+=dp[row];//求出上一列的总和
-                sum %= 1000000007L;
-
-             }
-            for(int cur=k;cur>=1;cur--){ //从高的到低的倒着来计算，-
-                 long noInclude=0;
-                 for(int i=1;i<cur;i++){
-                     if(cur%i==0) {//cur之前不满足不满足条件的
-                     noInclude+=dp[i];
-                      noInclude %= 1000000007L;
-                     }
-                 }
-                dp[cur] = (sum - noInclude) % 1000000007L;
-            }
-
-         }
-
-         long res=0L;
-         for(int i=1;i<=k;i++){
-             res+=dp[i];
-             res %= 1000000007L;
-
-         }
-         return res;
-    }
-
-
-    public static void main(String[] args) {
-        System.out.println(number1(10, 9));
-        System.out.println(number2(10, 9));
-        System.out.println(number3(10, 9));
-        System.out.println(number4(10, 9));
-
-        Scanner in = new Scanner(System.in);
-
-        while (in.hasNextInt()) {
-            int n = in.nextInt();
-            int k = in.nextInt();
-            System.out.println(number2(n, k));
-        }
-        in.close();
-    }
-}
Index: src/左神算法/进阶班二/第一章/Problem04_BSTtoDoubleLinkedList.java
===================================================================
diff --git a/src/左神算法/进阶班二/第一章/Problem04_BSTtoDoubleLinkedList.java b/src/左神算法/进阶班二/第一章/Problem04_BSTtoDoubleLinkedList.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第一章/Problem04_BSTtoDoubleLinkedList.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,210 +0,0 @@
-package 左神算法.进阶班二.第一章;
-
-import java.util.LinkedList;
-import java.util.Queue;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:把一棵搜索二叉树，转化成有序的双向链表。
- * @date 2020/2/17 15:42
- */
-public class Problem04_BSTtoDoubleLinkedList {
-
-    public static class Node{
-        public int value;
-        public Node left;
-        public Node right;
-
-        public Node(int value) {
-            this.value = value;
-        }
-    }
-    
-    public static Node bstToDoubleLinkedList(Node head){
-        if(head==null)
-            return head;
-        Node[] nodes=process1(head);
-        return nodes[0];
-    }
-
-    //方法一：返回以head为头结点的子树形成的双向链表的最左值与最右值
-    //node[0]:最左
-    //node[1]:最后
-    private static Node[] process1(Node head) {
-        if(head==null)
-            return new Node[]{null,null};
-        Node[] leftNodes = process1(head.left);
-        Node[] rightNodes = process1(head.right);
-        head.left=null;
-        head.right=null;
-        if(leftNodes[1]!=null){
-            head.left=leftNodes[1];
-            leftNodes[1].right=head;
-        }
-        if(rightNodes[0]!=null){
-            head.right=rightNodes[0];
-            rightNodes[0].left=head;
-        }
-        Node left=leftNodes[0]!=null ? leftNodes[0]:head;
-        Node right=rightNodes[1]!=null ? rightNodes[1]:head;
-        return new Node[]{left,right};
-
-
-    }
-
-    // 方法二：返回以head为头结点的子树形成的双向链表的最右值，同时最右结点的right指向头结点
-    public static Node process2(Node head){
-        if(head==null)
-            return head;
-       Node rightEnd= process2(head.right);
-       Node leftEnd=process2(head.left);
-       Node rights=rightEnd!=null ? rightEnd.right:null; //right start
-       Node lefts=leftEnd!=null ? leftEnd.right:null; //left start
-       if(rightEnd!=null && leftEnd!=null){
-           leftEnd.right=head;
-           head.left=leftEnd;
-           head.right=rights;
-           rights.left=head;
-           rightEnd.right=lefts;
-           return rightEnd;
-       }
-       if(leftEnd!=null){
-           leftEnd.right=head;
-           head.left=leftEnd;
-           head.right=lefts;
-           return head;
-       }
-       if(rightEnd!=null){
-           head.right=rights;
-           rights.left=head;
-           rightEnd.right=head;
-           return rightEnd;
-       }else{
-           head.right=head;
-           return head;
-       }
-
-    }
-
-    public static Node bstToDoubleLinkedList2(Node head){
-        if(head==null)
-            return null;
-        Node node = process2(head);
-        head=node.right;
-        node.right=null;
-        return head;
-    }
-
-
-    //方法三，将bst中序遍历的方式放入一个对列，然后将对列中的元素弹出，组成双向链表
-    public static Node bstToDoubleLinkedList3(Node head){
-        Queue<Node> queue=new LinkedList<>();
-        inOrderToQueue(head,queue);
-        if(queue.isEmpty()){
-            return null;
-        }
-        head=queue.poll();
-        Node pre=null;
-        Node cur=head;
-        cur.left=pre;
-        while(!queue.isEmpty()){
-            pre=cur;
-            cur=queue.poll();
-            pre.right=cur;
-            cur.left=pre;
-        }
-        return head;
-    }
-
-    public static void inOrderToQueue(Node head, Queue<Node> queue){
-        if(head==null)
-            return;
-        inOrderToQueue(head.left,queue);
-        queue.add(head);
-        inOrderToQueue(head.right,queue);
-    }
-    public static void printBSTInOrder(Node head) {
-        System.out.print("BST in-order: ");
-        if (head != null) {
-            inOrderPrint(head);
-        }
-        System.out.println();
-    }
-
-    public static void inOrderPrint(Node head) {
-        if (head == null) {
-            return;
-        }
-        inOrderPrint(head.left);
-        System.out.print(head.value + " ");
-        inOrderPrint(head.right);
-    }
-
-    public static void printDoubleLinkedList(Node head) {
-        System.out.print("Double Linked List: ");
-        Node end = null;
-        while (head != null) {
-            System.out.print(head.value + " ");
-            end = head;
-            head = head.right;
-        }
-        System.out.print("| ");
-        while (end != null) {
-            System.out.print(end.value + " ");
-            end = end.left;
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-        Node head = new Node(5);
-        head.left = new Node(2);
-        head.right = new Node(9);
-        head.left.left = new Node(1);
-        head.left.right = new Node(3);
-        head.left.right.right = new Node(4);
-        head.right.left = new Node(7);
-        head.right.right = new Node(10);
-        head.left.left = new Node(1);
-        head.right.left.left = new Node(6);
-        head.right.left.right = new Node(8);
-
-        printBSTInOrder(head);
-        head = bstToDoubleLinkedList3(head);
-        printDoubleLinkedList(head);
-
-        head = new Node(5);
-        head.left = new Node(2);
-        head.right = new Node(9);
-        head.left.left = new Node(1);
-        head.left.right = new Node(3);
-        head.left.right.right = new Node(4);
-        head.right.left = new Node(7);
-        head.right.right = new Node(10);
-        head.left.left = new Node(1);
-        head.right.left.left = new Node(6);
-        head.right.left.right = new Node(8);
-
-        printBSTInOrder(head);
-        head = bstToDoubleLinkedList2(head);
-        printDoubleLinkedList(head);
-
-        head = new Node(5);
-        head.left = new Node(2);
-        head.right = new Node(9);
-        head.left.left = new Node(1);
-        head.left.right = new Node(3);
-        head.left.right.right = new Node(4);
-        head.right.left = new Node(7);
-        head.right.right = new Node(10);
-        head.left.left = new Node(1);
-        head.right.left.left = new Node(6);
-        head.right.left.right = new Node(8);
-
-        printBSTInOrder(head);
-        head = bstToDoubleLinkedList(head);
-        printDoubleLinkedList(head);
-
-    }
-}
Index: src/左神算法/进阶班二/第二章/Problem04_Group_Anagrams.java
===================================================================
diff --git a/src/左神算法/进阶班二/第二章/Problem04_Group_Anagrams.java b/src/左神算法/进阶班二/第二章/Problem04_Group_Anagrams.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第二章/Problem04_Group_Anagrams.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,72 +0,0 @@
-package 左神算法.进阶班二.第二章;
-
-import java.util.*;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 如果str1和str2包含的字符种类一样，并且每种字符的个数也
-一样，那么str1和str2算作变形词。
-给定一个字符类型的数组，请把变形词分组。比如
-输入：
-["eat", "tea", "tan", "ate", "nat", "bat"]
-输出：
-[
-["ate", "eat","tea"],
-["nat","tan"],
-["bat"]
-]
-注意：所有的字符都是小写。
- * @date 2020/2/15 19:31
- */
-public class Problem04_Group_Anagrams {
-
-    //将字符串进行排序的方式
-    public static List<List<String>> groupAnagrams1(String[] strArr){
-        HashMap<String,List<String>> map=new HashMap<>();
-        for(int i=0;i<strArr.length;i++){
-            char[] chars = strArr[i].toCharArray();
-            Arrays.sort(chars);
-            if(!map.containsKey(chars.toString())){
-                ArrayList<String> arrayList=new ArrayList<>();
-                arrayList.add(strArr[i]);
-                map.put(chars.toString(),arrayList);
-            }else{
-                List<String> list= map.get(chars.toString());
-                list.add(strArr[i]);
-            }
-        }
-        ArrayList<List<String>> res=new ArrayList<>();
-        for(Map.Entry<String,List<String>> entry:map.entrySet()){
-            res.add(entry.getValue());
-        }
-        return res;
-    }
-
-    //使用有限穷举的方式
-    public static List<List<String>> groupAnagrams2(String[] strArr){
-        HashMap<String,List<String>> map=new HashMap<>();
-        for(int i=0;i<strArr.length;i++){
-            int[] arr=new int[26];
-            char[] chars = strArr[i].toCharArray();
-            for(int j=0;j<chars.length;i++){
-                arr[chars[j]-'a']++;
-            }
-            StringBuilder strB=new StringBuilder();
-            for(int value:arr){
-                strB.append(String.valueOf(value)).append("_");
-            }
-            String key=strB.toString();
-            if(!map.containsKey(key)){
-                map.put(key,new ArrayList<>());
-            }
-            map.get(key).add(strArr[i]);
-        }
-        ArrayList<List<String>> res=new ArrayList<>();
-        for(List<String> list:map.values()){
-            res.add(list);
-        }
-        return res;
-    }
-}
Index: src/左神算法/进阶班一/动态规划与递归/Problem5.java
===================================================================
diff --git a/src/左神算法/进阶班一/动态规划与递归/Problem5.java b/src/左神算法/进阶班一/动态规划与递归/Problem5.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/动态规划与递归/Problem5.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,83 +0,0 @@
-package 左神算法.进阶班一.动态规划与递归;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 机器人走路问题。一排有N个位置，一个机器人在最开始停留在P位置上，如果p==0位置，下一分钟机器人一定向左移动到1位置，如果p==N-1,
- * 下一分钟，机器人一定向左移动到p=N-2位置。如果p在0和N-1之间，下一分钟机器人一定会向左或者右移动。求k分钟的时候，机器人到达T位置有多少种走法。
- *
- * @date 2020/1/6 12:32
- */
-public class Problem5 {
-
-    public static int f1(int N, int p, int k, int t) {
-        if (N < 2 || k < 1 || p < 0 || t >= N || t < 0 || p >= N) {
-            return 0;
-        }
-        if (k == 1)
-            return p == t ? 1 : 0;
-        if (t == 0)
-
-            return f1(N, p, k - 1, 1);
-        if (t == N - 1)
-            return f1(N, p, k - 1, t - 1);
-
-        return f1(N, p, k - 1, t - 1) + f1(N, p, k - 1, t + 1);
-    }
-
-    //使用二维数组的动态规划
-    public static int f2(int N, int p, int k, int t) {
-        if (N < 2 || k < 1 || p < 0 || t >= N || t < 0 || p >= N) {
-            return 0;
-        }
-        int[][] dp = new int[k][N];
-        dp[0][p] = 1;
-        for (int i = 1; i < dp.length; i++) {
-            dp[i][0] = dp[i - 1][1];
-            dp[i][N - 1] = dp[i - 1][N - 2];
-            for (int j = 1; j < dp[0].length - 1; j++) {
-                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1];
-            }
-        }
-        return dp[k - 1][t];
-    }
-
-    //使用一个以为数组实现动态规化
-    public static int f3(int n, int p, int k, int t) {
-        if (n < 2 || k < 1 || p < 0 || t >= n || t < 0 || p >= n) {
-            return 0;
-        }
-        int[] dp = new int[n];
-        dp[p] = 1;
-        int temp = 0;
-        int pre = 0;
-        for (int i = 1; i < k; i++) {
-            pre = dp[0];
-            dp[0] = dp[1];
-            for (int j = 1; j < n - 1; j++) {
-                temp = dp[j];
-                dp[j] = pre + dp[j + 1];
-                pre = temp;
-            }
-            dp[n - 1] = pre;
-        }
-        return dp[t];
-    }
-
-    public static void main(String[] args) {
-        for (int i = 0; i < 3000000; i++) {
-            int N = (int) (Math.random() * 5) + 5;
-            int P = (int) (Math.random() * N);
-            int K = (int) (Math.random() * 10) + 2;
-            int T = (int) (Math.random() * N);
-            int res1 = f1(N, P, K, T);
-            int res2 = f2(N, P, K, T);
-            int res3 = f3(N, P, K, T);
-            if (res1 != res2 || res1 != res3) {
-                System.out.println("Fuck man!");
-                break;
-            }
-        }
-
-    }
-}
Index: src/左神算法/高频面试题/五/Problem5.java
===================================================================
diff --git a/src/左神算法/高频面试题/五/Problem5.java b/src/左神算法/高频面试题/五/Problem5.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/五/Problem5.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,83 +0,0 @@
-package 左神算法.高频面试题.五;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 机器人走路问题。一排有N个位置，一个机器人在最开始停留在P位置上，如果p==0位置，下一分钟机器人一定向左移动到1位置，如果p==N-1,
- * 下一分钟，机器人一定向左移动到p=N-2位置。如果p在0和N-1之间，下一分钟机器人一定会向左或者右移动。求k分钟的时候，机器人到达T位置有多少种走法。
- *
- * @date 2020/1/6 12:32
- */
-public class Problem5 {
-
-    public static int f1(int N, int p, int k, int t) {
-        if (N < 2 || k < 1 || p < 0 || t >= N || t < 0 || p >= N) {
-            return 0;
-        }
-        if (k == 1)
-            return p == t ? 1 : 0;
-        if (t == 0)
-
-            return f1(N, p, k - 1, 1);
-        if (t == N - 1)
-            return f1(N, p, k - 1, t - 1);
-
-        return f1(N, p, k - 1, t - 1) + f1(N, p, k - 1, t + 1);
-    }
-
-    //使用二维数组的动态规划
-    public static int f2(int N, int p, int k, int t) {
-        if (N < 2 || k < 1 || p < 0 || t >= N || t < 0 || p >= N) {
-            return 0;
-        }
-        int[][] dp = new int[k][N];
-        dp[0][p] = 1;
-        for (int i = 1; i < dp.length; i++) {
-            dp[i][0] = dp[i - 1][1];
-            dp[i][N - 1] = dp[i - 1][N - 2];
-            for (int j = 1; j < dp[0].length - 1; j++) {
-                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1];
-            }
-        }
-        return dp[k - 1][t];
-    }
-
-    //使用一个以为数组实现动态规化
-    public static int f3(int n, int p, int k, int t) {
-        if (n < 2 || k < 1 || p < 0 || t >= n || t < 0 || p >= n) {
-            return 0;
-        }
-        int[] dp = new int[n];
-        dp[p] = 1;
-        int temp = 0;
-        int pre = 0;
-        for (int i = 1; i < k; i++) {
-            pre = dp[0];
-            dp[0] = dp[1];
-            for (int j = 1; j < n - 1; j++) {
-                temp = dp[j];
-                dp[j] = pre + dp[j + 1];
-                pre = temp;
-            }
-            dp[n - 1] = pre;
-        }
-        return dp[t];
-    }
-
-    public static void main(String[] args) {
-        for (int i = 0; i < 3000000; i++) {
-            int N = (int) (Math.random() * 5) + 5;
-            int P = (int) (Math.random() * N);
-            int K = (int) (Math.random() * 10) + 2;
-            int T = (int) (Math.random() * N);
-            int res1 = f1(N, P, K, T);
-            int res2 = f2(N, P, K, T);
-            int res3 = f3(N, P, K, T);
-            if (res1 != res2 || res1 != res3) {
-                System.out.println("Fuck man!");
-                break;
-            }
-        }
-
-    }
-}
Index: src/左神算法/高频面试题/六大量运用优先级队列/Problem5.java
===================================================================
diff --git a/src/左神算法/高频面试题/六大量运用优先级队列/Problem5.java b/src/左神算法/高频面试题/六大量运用优先级队列/Problem5.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/六大量运用优先级队列/Problem5.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,33 +0,0 @@
-package 左神算法.高频面试题.六大量运用优先级队列;
-
-import java.util.PriorityQueue;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 地主打算切开一根金条，按照长工的工作量每人分一部分。只有金匠才能切开金条，每切一次，金匠要收金条长度个金币，比如长度为15的金条切开一次要收15个铜币
- * 地主希望找到一种切开的方法，使得完成切分后能给金匠最少的金币
- * @date 2020/1/9 22:21
- */
-public class Problem5 {
-
-    public static int lessMoney(int[] arr){
-        PriorityQueue<Integer> pQ = new PriorityQueue<>();
-        for (int i = 0; i < arr.length; i++) {
-            pQ.add(arr[i]);
-        }
-        int sum = 0;
-        int cur = 0;
-        while (pQ.size() > 1) {
-            cur = pQ.poll() + pQ.poll();
-            sum += cur;
-            pQ.add(cur);
-        }
-        return sum;
-    }
-
-    public static void main(String[] args) {
-        int[] arr = { 3,6, 7, 8, 9 };
-        System.out.println(lessMoney(arr));
-    }
-}
Index: src/左神算法/高频面试题/动态规划与递归/Problem5.java
===================================================================
diff --git a/src/左神算法/高频面试题/动态规划与递归/Problem5.java b/src/左神算法/高频面试题/动态规划与递归/Problem5.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/动态规划与递归/Problem5.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,83 +0,0 @@
-package 左神算法.高频面试题.动态规划与递归;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 机器人走路问题。一排有N个位置，一个机器人在最开始停留在P位置上，如果p==0位置，下一分钟机器人一定向左移动到1位置，如果p==N-1,
- * 下一分钟，机器人一定向左移动到p=N-2位置。如果p在0和N-1之间，下一分钟机器人一定会向左或者右移动。求k分钟的时候，机器人到达T位置有多少种走法。
- *
- * @date 2020/1/6 12:32
- */
-public class Problem5 {
-
-    public static int f1(int N, int p, int k, int t) {
-        if (N < 2 || k < 1 || p < 0 || t >= N || t < 0 || p >= N) {
-            return 0;
-        }
-        if (k == 1)
-            return p == t ? 1 : 0;
-        if (t == 0)
-
-            return f1(N, p, k - 1, 1);
-        if (t == N - 1)
-            return f1(N, p, k - 1, t - 1);
-
-        return f1(N, p, k - 1, t - 1) + f1(N, p, k - 1, t + 1);
-    }
-
-    //使用二维数组的动态规划
-    public static int f2(int N, int p, int k, int t) {
-        if (N < 2 || k < 1 || p < 0 || t >= N || t < 0 || p >= N) {
-            return 0;
-        }
-        int[][] dp = new int[k][N];
-        dp[0][p] = 1;
-        for (int i = 1; i < dp.length; i++) {
-            dp[i][0] = dp[i - 1][1];
-            dp[i][N - 1] = dp[i - 1][N - 2];
-            for (int j = 1; j < dp[0].length - 1; j++) {
-                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1];
-            }
-        }
-        return dp[k - 1][t];
-    }
-
-    //使用一个以为数组实现动态规化
-    public static int f3(int n, int p, int k, int t) {
-        if (n < 2 || k < 1 || p < 0 || t >= n || t < 0 || p >= n) {
-            return 0;
-        }
-        int[] dp = new int[n];
-        dp[p] = 1;
-        int temp = 0;
-        int pre = 0;
-        for (int i = 1; i < k; i++) {
-            pre = dp[0];
-            dp[0] = dp[1];
-            for (int j = 1; j < n - 1; j++) {
-                temp = dp[j];
-                dp[j] = pre + dp[j + 1];
-                pre = temp;
-            }
-            dp[n - 1] = pre;
-        }
-        return dp[t];
-    }
-
-    public static void main(String[] args) {
-        for (int i = 0; i < 3000000; i++) {
-            int N = (int) (Math.random() * 5) + 5;
-            int P = (int) (Math.random() * N);
-            int K = (int) (Math.random() * 10) + 2;
-            int T = (int) (Math.random() * N);
-            int res1 = f1(N, P, K, T);
-            int res2 = f2(N, P, K, T);
-            int res3 = f3(N, P, K, T);
-            if (res1 != res2 || res1 != res3) {
-                System.out.println("Fuck man!");
-                break;
-            }
-        }
-
-    }
-}
Index: src/左神算法/进阶班二/第一章/Problem05_AllLessNumSubArray.java
===================================================================
diff --git a/src/左神算法/进阶班二/第一章/Problem05_AllLessNumSubArray.java b/src/左神算法/进阶班二/第一章/Problem05_AllLessNumSubArray.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第一章/Problem05_AllLessNumSubArray.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,127 +0,0 @@
-package 左神算法.进阶班二.第一章;
-
-import java.util.LinkedList;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 给定数组arr和整数num，共返回有多少个子数组满足如下情况：
-max(arr[i..j]) - min(arr[i..j]) <= num
-max(arr[i..j])表示子数组arr[i..j]中的最大值，min(arr[i..j])表示子数组arr[i..中的最小值。
-【要求】
-如果数组长度为N，请实现时间复杂度为O(N)的解法。
- * @date 2020/2/17 15:40
- */
-public class Problem05_AllLessNumSubArray {
-
-    //左程云做法
-    public static int getNum1(int[] arr, int num) {
-        if (arr == null || arr.length == 0) {
-            return 0;
-        }
-        LinkedList<Integer> qmin = new LinkedList<Integer>();
-        LinkedList<Integer> qmax = new LinkedList<Integer>();
-        int i = 0;
-        int j = 0;
-        int res = 0;
-        while (i < arr.length) {
-            while (j < arr.length) {
-                while (!qmin.isEmpty() && arr[qmin.peekLast()] >= arr[j]) {
-                    qmin.pollLast();
-                }
-                qmin.addLast(j);
-                while (!qmax.isEmpty() && arr[qmax.peekLast()] <= arr[j]) {
-                    qmax.pollLast();
-                }
-                qmax.addLast(j);
-                if (arr[qmax.getFirst()] - arr[qmin.getFirst()] > num) {
-                    break;
-                }
-                j++;
-            }
-            if (qmin.peekFirst() == i) {
-                qmin.pollFirst();
-            }
-            if (qmax.peekFirst() == i) {
-                qmax.pollFirst();
-            }
-            res += j - i;
-            i++;
-        }
-        return res;
-    }
-
-    public static int getNum(int[] arr, int num) {
-        if(arr==null || arr.length==0){
-            return 0;
-        }
-        int l=0;
-        int r=0;
-        int len=arr.length;
-        int res=0;
-        LinkedList<Integer> qmin=new LinkedList<>();
-        LinkedList<Integer> qmax=new LinkedList<>();
-        while(l<len){
-            while(r<len){
-                while(!qmax.isEmpty() && arr[qmax.peekLast()]<=arr[r]){
-                    qmax.pollLast();
-                }
-                qmax.addLast(r);
-                while(!qmin.isEmpty() && arr[qmin.peekLast()]>=arr[r]){
-                    qmin.pollLast();
-                }
-                qmin.addLast(r);
-                if(arr[qmax.peekFirst()]-arr[qmin.peekFirst()]>num){
-                    break;
-                }
-                r++;
-            }
-            if(l==qmax.peekFirst()){
-                qmax.pollFirst();
-            }
-            if(l==qmin.peekFirst()){
-                qmin.pollFirst();
-            }
-            res+=r-l;
-            l++;
-
-
-        }
-        return res;
-    }
-
-    // for test
-    public static int[] getRandomArray(int len) {
-        if (len < 0) {
-            return null;
-        }
-        int[] arr = new int[len];
-        for (int i = 0; i < len; i++) {
-            arr[i] = (int) (Math.random() * 10);
-        }
-        return arr;
-    }
-
-    // for test
-    public static void printArray(int[] arr) {
-        if (arr != null) {
-            for (int i = 0; i < arr.length; i++) {
-                System.out.print(arr[i] + " ");
-            }
-            System.out.println();
-        }
-    }
-
-    public static void main(String[] args) {
-        int[] arr = getRandomArray(30);
-        int num = 5;
-        printArray(arr);
-        System.out.println(getNum1(arr, num));
-        printArray(arr);
-        System.out.println(getNum(arr,num));
-
-    }
-
-
-}
Index: src/左神算法/进阶班二/第二章/Problem05_Longest_Increasing_Path_in_a_Matrix.java
===================================================================
diff --git a/src/左神算法/进阶班二/第二章/Problem05_Longest_Increasing_Path_in_a_Matrix.java b/src/左神算法/进阶班二/第二章/Problem05_Longest_Increasing_Path_in_a_Matrix.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第二章/Problem05_Longest_Increasing_Path_in_a_Matrix.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,109 +0,0 @@
-package 左神算法.进阶班二.第二章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一个整数矩阵matrix，每个位置你可以向左、右、下、上移动，找到其中最长的递增路径。
-例如：
-matrix = [
-[9,9,4],
-[6,6,8],
-[2,1,1]
-]
-返回4
-最长路径是[1, 2, 6, 9].
-matrix = [
-[3,4,5],
-[3,2,6],
-[2,2,1]
-]
-返回4
-最长路径是[1, 2, 6, 9].
- * @date 2020/2/15 18:37
- */
-public class Problem05_Longest_Increasing_Path_in_a_Matrix {
-
-    //递归的方式
-    public static int longest(int[][] matrix){
-        int max=Integer.MIN_VALUE;
-        for(int i=0;i<matrix.length;i++)
-        {
-            for(int j=0;j<matrix[0].length;j++)
-                max=Math.max(max,process(matrix,i,j));
-        }
-        return max;
-    }
-    //i,j表示从matrix的i，j位置出发，返回从i,j位置出发的最长路径长度
-    private static int process(int[][] matrix, int i, int j) {
-        int path=1;//原地不动的长度
-        //判断是否可以往左走
-        if(j>0 && matrix[i][j-1]>matrix[i][j]){
-            path=Math.max(path,process(matrix,i,j-1)+1);
-        }
-        //判断是否可以往右走
-        if(j<matrix[0].length-1 && matrix[i][j]<matrix[i][j+1]){
-            path=Math.max(path,process(matrix,i,j+1)+1);
-        }
-
-        //判断是否可以往上走
-        if(i>0 && matrix[i-1][j]>matrix[i][j]){
-            path=Math.max(path,process(matrix,i-1,j)+1);
-        }
-
-        //判断是否可以往下走
-        if(i<matrix.length-1 && matrix[i+1][j]>matrix[i][j]){
-            path=Math.max(path,process(matrix,i+1,j)+1);
-        }
-        return path;
-
-    }
-
-    //改动态规划
-    public static int longestDP(int[][] matrix){
-        int max=Integer.MIN_VALUE;
-        int[][]dp=new int[matrix.length][matrix.length];
-        for(int i=0;i<matrix.length;i++)
-        {
-            for(int j=0;j<matrix[0].length;j++)
-                max=Math.max(max,processDP(matrix,dp,i,j));
-        }
-        return max;
-    }
-
-    //i,j表示从matrix的i，j位置出发，返回从i,j位置出发的最长路径长度
-    private static int processDP(int[][] matrix, int[][] dp,int i, int j) {
-
-        if(dp[i][j]==0) { //表示从来没有得到过该位置的值，需要进行计算，如果！=0说明前面已经计算过了，直接赋值即可，相当于加了个缓存。
-            dp[i][j] = 1;//原地不动的长度
-            //判断是否可以往左走
-            if (j > 0 && matrix[i][j - 1] > matrix[i][j]) {
-                dp[i][j] = Math.max(dp[i][j], processDP(matrix, dp, i, j - 1) + 1);
-            }
-            //判断是否可以往右走
-            if (j < matrix[0].length - 1 && matrix[i][j] < matrix[i][j + 1]) {
-                dp[i][j] = Math.max(dp[i][j], processDP(matrix, dp, i, j +1) + 1);
-            }
-
-            //判断是否可以往上走
-            if (i > 0 && matrix[i - 1][j] > matrix[i][j]) {
-                dp[i][j] = Math.max(dp[i][j], processDP(matrix, dp, i-1, j ) + 1);
-            }
-
-            //判断是否可以往下走
-            if (i < matrix.length - 1 && matrix[i + 1][j] > matrix[i][j]) {
-                dp[i][j] = Math.max(dp[i][j], processDP(matrix, dp, i+1, j ) + 1);
-            }
-        }
-        return dp[i][j];
-
-    }
-
-    public static void main(String[] args) {
-        int[][]arr=new int[][]{
-                {3,4,5},{3,2,6},{2,2,1}
-        };
-        System.out.println(longestDP(arr));
-        System.out.println(longestDP(arr));
-    }
-
-}
Index: src/左神算法/高频面试题/六大量运用优先级队列/Problem6.java
===================================================================
diff --git a/src/左神算法/高频面试题/六大量运用优先级队列/Problem6.java b/src/左神算法/高频面试题/六大量运用优先级队列/Problem6.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/六大量运用优先级队列/Problem6.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,78 +0,0 @@
-package 左神算法.高频面试题.六大量运用优先级队列;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:阿里题：有n个气球，编号为0到n-1,每个气球上都标有一个数字，这些数字存在数组nums中，现在要求你戳破所有的气球。每当你戳破一个气球i时，你可以获得
- * nums[left]*nums[i]*nums[right]个硬币。这里的left和right代表i相邻的两个气球的编号。注意当你戳破了气球i后，气球left和气球right就变成了相邻的气球了，求能获得最大的硬币数量
- * 你可以假设nums[-1]=nums[n]=1,但是他们不是真正存在的，所以不能被戳破
- * @date 2020/1/10 10:56
- */
-public class Problem6 {
-
-    public static int maxCoins1(int[] arr){
-        if(arr==null || arr.length==0)
-            return 0;
-        if(arr.length==1){
-            return arr[0];
-        }
-        int [] help=new int[arr.length+2];
-        help[0]=1;
-        help[help.length-1]=1;
-        for(int i=0;i<arr.length;i++){
-            help[i+1]=arr[i];
-        }
-        return process(help,1,help.length-2);
-    }
-
-    public static int process(int[] arr,int l,int r){//总有一个气球被最后打破，穷举所有的情况，找出其中最大的情况。l:表示最左边的气球的位置，r:表示最右边的气球的位置
-        if (l == r) {
-            return arr[l - 1] * arr[l] * arr[r + 1];
-        }
-
-        int res=Math.max(arr[l-1]*arr[l]*arr[r+1]+process(arr,l+1,r),
-                arr[l-1]*arr[r]*arr[r+1]+process(arr,l,r-1));//最后打l或者r的情况
-        for(int i=l+1;i<r;i++){
-            res=Math.max(res,process(arr,l,i-1)+process(arr,i+1,r)+arr[l-1]*arr[i]*arr[r+1]);
-        }
-        return res;//res即为动态规划中的dp[i][j]
-    }
-
-
-    //动态规划
-    public static int maxCoins2(int[] arr) {
-        if (arr == null || arr.length == 0) {
-            return 0;
-        }
-        int size = arr.length;
-        int[] all = new int[size + 2];
-        all[0] = 1;
-        all[size + 1] = 1;
-        for (int i = 0; i < size; i++) {
-            all[i + 1] = arr[i];
-        }
-        int[][] dp = new int[size][size];
-        for (int i = size - 1; i >= 0; i--) {
-            dp[i][i] = all[i] * all[i + 1] * all[i + 2];
-            for (int j = i + 1; j < size; j++) {
-                int coins = 0;
-                for (int k = i; k <= j; k++) {
-                    coins = all[i] * all[k + 1] * all[j + 2];
-                    coins += k != i ? dp[i][k - 1] : 0;
-                    coins += k != j ? dp[k + 1][j] : 0;
-                    dp[i][j] = Math.max(dp[i][j], coins);
-                }
-            }
-        }
-        return dp[0][size - 1];
-    }
-
-
-
-    public static void main(String[] args) {
-        int[] arr = { 3, 2, 6, 4, 2, 3, 4, 7, 9 };
-        System.out.println(maxCoins1(arr));
-        System.out.println(maxCoins2(arr));
-    }
-
-}
Index: src/左神算法/高频面试题/动态规划与递归/Problem6.java
===================================================================
diff --git a/src/左神算法/高频面试题/动态规划与递归/Problem6.java b/src/左神算法/高频面试题/动态规划与递归/Problem6.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/动态规划与递归/Problem6.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,78 +0,0 @@
-package 左神算法.高频面试题.动态规划与递归;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:阿里题：有n个气球，编号为0到n-1,每个气球上都标有一个数字，这些数字存在数组nums中，现在要求你戳破所有的气球。每当你戳破一个气球i时，你可以获得
- * nums[left]*nums[i]*nums[right]个硬币。这里的left和right代表i相邻的两个气球的编号。注意当你戳破了气球i后，气球left和气球right就变成了相邻的气球了，求能获得最大的硬币数量
- * 你可以假设nums[-1]=nums[n]=1,但是他们不是真正存在的，所以不能被戳破
- * @date 2020/1/10 10:56
- */
-public class Problem6 {
-
-    public static int maxCoins1(int[] arr){
-        if(arr==null || arr.length==0)
-            return 0;
-        if(arr.length==1){
-            return arr[0];
-        }
-        int [] help=new int[arr.length+2];
-        help[0]=1;
-        help[help.length-1]=1;
-        for(int i=0;i<arr.length;i++){
-            help[i+1]=arr[i];
-        }
-        return process(help,1,help.length-2);
-    }
-
-    public static int process(int[] arr,int l,int r){//总有一个气球被最后打破，穷举所有的情况，找出其中最大的情况。l:表示最左边的气球的位置，r:表示最右边的气球的位置
-        if (l == r) {
-            return arr[l - 1] * arr[l] * arr[r + 1];
-        }
-
-        int res=Math.max(arr[l-1]*arr[l]*arr[r+1]+process(arr,l+1,r),
-                arr[l-1]*arr[r]*arr[r+1]+process(arr,l,r-1));//最后打l或者r的情况
-        for(int i=l+1;i<r;i++){
-            res=Math.max(res,process(arr,l,i-1)+process(arr,i+1,r)+arr[l-1]*arr[i]*arr[r+1]);
-        }
-        return res;//res即为动态规划中的dp[i][j]
-    }
-
-
-    //动态规划
-    public static int maxCoins2(int[] arr) {
-        if (arr == null || arr.length == 0) {
-            return 0;
-        }
-        int size = arr.length;
-        int[] all = new int[size + 2];
-        all[0] = 1;
-        all[size + 1] = 1;
-        for (int i = 0; i < size; i++) {
-            all[i + 1] = arr[i];
-        }
-        int[][] dp = new int[size][size];
-        for (int i = size - 1; i >= 0; i--) {
-            dp[i][i] = all[i] * all[i + 1] * all[i + 2];
-            for (int j = i + 1; j < size; j++) {
-                int coins = 0;
-                for (int k = i; k <= j; k++) {
-                    coins = all[i] * all[k + 1] * all[j + 2];
-                    coins += k != i ? dp[i][k - 1] : 0;
-                    coins += k != j ? dp[k + 1][j] : 0;
-                    dp[i][j] = Math.max(dp[i][j], coins);
-                }
-            }
-        }
-        return dp[0][size - 1];
-    }
-
-
-
-    public static void main(String[] args) {
-        int[] arr = { 3, 2, 6, 4, 2, 3, 4, 7, 9 };
-        System.out.println(maxCoins1(arr));
-        System.out.println(maxCoins2(arr));
-    }
-
-}
Index: src/左神算法/进阶班二/第二章/Problem06_Self_Crossing.java
===================================================================
diff --git a/src/左神算法/进阶班二/第二章/Problem06_Self_Crossing.java b/src/左神算法/进阶班二/第二章/Problem06_Self_Crossing.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第二章/Problem06_Self_Crossing.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,64 +0,0 @@
-package 左神算法.进阶班二.第二章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 给定一个含有 n 个正数的数组 x。从点 (0,0) 开始，先向北移动 x[0] 米，然后向西移动 x[1] 米，向南移动 x[2] 米，向东移动 x[3] 米，持续移动。也就是说，每次移动后你的方位会发生逆时针变化。
-
-编写一个 O(1) 空间复杂度的一趟扫描算法，判断你所经过的路径是否相交。
-
-
-
-示例 1:
-
-┌───┐
-│   │
-└───┼──>
-│
-
-输入: [2,1,1,2]
-输出: true
-
-示例 2:
-
-┌──────┐
-│      │
-│
-│
-└────────────>
-
-输入: [1,2,3,4]
-输出: false
-
-示例 3:
-
-┌───┐
-│   │
-└───┼>
-
-输入: [1,1,1,1]
-输出: true
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/self-crossing
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/2/16 19:21
- */
-public class Problem06_Self_Crossing {
-
-    public static boolean isSelfCrossing(int[] x) {
-        if (x == null || x.length < 4) {
-            return false;
-        }
-        if ((x.length > 3 && x[2] <= x[0] && x[3] >= x[1]) || (x.length > 4 && ((x[3] <= x[1] && x[4] >= x[2]) || (x[3] == x[1] && x[0] + x[4] >= x[2])))) {
-            return true;
-        }
-        for (int i = 5; i < x.length; i++) { //考虑第i条边与第i条边之前的边有没有可能相交
-            if (x[i - 1] <= x[i - 3] && ((x[i] >= x[i - 2]) || (x[i - 2] >= x[i - 4] && x[i - 5] + x[i - 1] >= x[i - 3] && x[i - 4] + x[i] >= x[i - 2]))) {
-                return true;
-            }
-        }
-        return false;
-    }
-}
Index: src/左神算法/进阶班二/第一章/Problem06_Word_Ladder.java
===================================================================
diff --git a/src/左神算法/进阶班二/第一章/Problem06_Word_Ladder.java b/src/左神算法/进阶班二/第一章/Problem06_Word_Ladder.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第一章/Problem06_Word_Ladder.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,116 +0,0 @@
-package 左神算法.进阶班二.第一章;
-
-import java.util.*;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 给定两个单词beginWord和endWord，还有一本词典是list类型。
-找到所有从beginWord变到endWord的最短转换路径，变动的规则是：
-1，一次只能变一个位置的字符
-2，每一个转换后的word一定要在list中
-3，初始时list中没有beginWord这个词
-比如
-beginWord = "hit"
-endWord = "cog"
-wordList = ["hot","dot","dog","lot","log","cog"]
-返回：
-[
-["hit","hot","dot","dog","cog"],
-["hit","hot","lot","log","cog"]
-]
-注意：
-1，返回值的类型为List<List<String>>
-2，如果不存在转化路径请返回空链表（不是null）
-3，所有的词一定都是相同长度的
-4，所有词都是小写的a~z
-5，在list中没有重复的词
-6，beginWord和endWord都不是空字符串或者null
- * @date 2020/2/13 16:43
- */
-public class Problem06_Word_Ladder {
-
-
-    public static List<List<String>> findLadders(String beginWord,
-                                                 String endWord, List<String> wordList) {
-        wordList.add(beginWord);
-        HashMap<String, ArrayList<String>> nexts = getNexts(wordList);
-        HashMap<String, Integer> distances = getDistances(beginWord, nexts);
-        LinkedList<String> pathList = new LinkedList<>();
-        List<List<String>> res = new ArrayList<>();
-        getShortestPaths(beginWord, endWord, nexts, distances, pathList, res);
-        return res;
-    }
-    //返回每个单词的邻居
-    public static HashMap<String, ArrayList<String>> getNexts(List<String> words) {
-        Set<String> dict = new HashSet<>(words);
-        HashMap<String, ArrayList<String>> nexts = new HashMap<>();
-        for (int i = 0; i < words.size(); i++) {
-            nexts.put(words.get(i), new ArrayList<>());
-        }
-        for (int i = 0; i < words.size(); i++) {
-            nexts.put(words.get(i), getNext(words.get(i), dict));
-        }
-        return nexts;
-    }
-    //dict是将原来的list字典变换成set结构的，HashSet的增删改查都可以看做O(1);
-    //返回的是与word差别一个字母的单词的集合
-    private static ArrayList<String> getNext(String word, Set<String> dict) {
-        ArrayList<String> res = new ArrayList<String>();
-        char[] chs = word.toCharArray();
-        for (char cur = 'a'; cur <= 'z'; cur++) {//代价：26*chs.length
-            for (int i = 0; i < chs.length; i++) {
-                if (chs[i] != cur) {
-                    char tmp = chs[i];
-                    chs[i] = cur;
-                    if (dict.contains(String.valueOf(chs))) {
-                        res.add(String.valueOf(chs));
-                    }
-                    chs[i] = tmp;
-                }
-            }
-        }
-        return res;
-    }
-
-    public static HashMap<String, Integer> getDistances(String begin,
-                                                        HashMap<String, ArrayList<String>> nexts) {
-        HashMap<String, Integer> distances = new HashMap<>();
-        distances.put(begin, 0);
-        Queue<String> queue = new LinkedList<String>();
-        queue.add(begin);
-        HashSet<String> set = new HashSet<String>();//记录是否已经遍历过
-        set.add(begin);
-        while (!queue.isEmpty()) {//宽度优先遍历
-            String cur = queue.poll();
-            for (String str : nexts.get(cur)) {
-                if (!set.contains(str)) {
-                    distances.put(str, distances.get(cur) + 1);
-                    queue.add(str);
-                    set.add(str);
-                }
-            }
-        }
-        return distances;
-    }
-
-
-    //最终求解的答案在输入参数中的递归
-    private static void getShortestPaths(String cur, String end,
-                                         HashMap<String, ArrayList<String>> nexts,
-                                         HashMap<String, Integer> distances, LinkedList<String> solution,
-                                         List<List<String>> res) {
-        solution.add(cur);
-        if (end.equals(cur)) {
-            res.add(new LinkedList<String>(solution));
-        } else {
-            for (String next : nexts.get(cur)) {//cur的所有后代，搜索的过程又运用了深度优先遍历dfs
-                if (distances.get(next) == distances.get(cur) + 1) {
-                    getShortestPaths(next, end, nexts, distances, solution, res);
-                    solution.pollLast();//弹出solution最后的值，深度优先遍历dfs
-                }
-            }
-        }
-
-    }
-}
Index: src/左神算法/高频面试题/六大量运用优先级队列/Problem7.java
===================================================================
diff --git a/src/左神算法/高频面试题/六大量运用优先级队列/Problem7.java b/src/左神算法/高频面试题/六大量运用优先级队列/Problem7.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/六大量运用优先级队列/Problem7.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,90 +0,0 @@
-package 左神算法.高频面试题.六大量运用优先级队列;
-
-import java.util.Comparator;
-import java.util.PriorityQueue;
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 假设 力扣（LeetCode）即将开始其 IPO。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前
- * 完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。给定若干个项目。对于每个项目 i，它都有一个纯利润 Pi，并且需要最小的资本 Ci 来启动相应
- * 的项目。最初，你有 W 资本。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。总而言之，从给定项目中选择最多 k 个不同项目的列表，以最大化最终资本，并输出最
- * 终可获得的最多资本
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/ipo
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/1/10 13:00
- */
-public class Problem7 {
-    //因为一个cost对应着一个profit,所以我们可以将cost与之对应的profit封装在一个对象中
-    public static class Node{
-        int profit;
-        int cost;
-
-        public Node(int profit, int cost) {
-            this.profit = profit;
-            this.cost = cost;
-        }
-    }
-
-    public static class MinCostComparator implements Comparator<Node>{
-
-        @Override
-        public int compare(Node o1, Node o2) {
-            return o1.cost-o2.cost;
-        }
-    }
-
-    public static class MaxProfitComparator implements Comparator<Node>{
-
-        @Override
-        public int compare(Node o1, Node o2) {
-            return  -o1.profit+o2.profit;
-        }
-    }
-
-    public static int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) {
-        Node[] nodes = new Node[Profits.length];
-        for (int i = 0; i < Profits.length; i++) {
-            nodes[i] = new Node(Profits[i], Capital[i]);
-        }
-
-        PriorityQueue<Node> minCostQ = new PriorityQueue<>(new MinCostComparator());
-        PriorityQueue<Node> maxProfitQ = new PriorityQueue<>(new MaxProfitComparator());
-        for (int i = 0; i < nodes.length; i++) {
-            minCostQ.add(nodes[i]);
-        }
-       while(k>0) {
-            while (!minCostQ.isEmpty() && minCostQ.peek().cost <= W) {
-                maxProfitQ.add(minCostQ.poll());
-            }
-            if (maxProfitQ.isEmpty()) {
-                return W;
-            }
-            W += maxProfitQ.poll().profit;
-            k--;
-        }
-        return W;
-    }
-
-    public static void main(String[] args) {
-        Scanner in=new Scanner(System.in);
-        int[] cost=new int[4];
-        int[] profit=new int[4];
-        for(int i=0;i<4;i++)
-        {
-            cost[i]=in.nextInt();
-        }
-        for(int i=0;i<4;i++){
-            profit[i]=in.nextInt();
-        }
-
-        int k=in.nextInt();
-        int m=in.nextInt();
-        System.out.println(findMaximizedCapital(k,m,profit,cost));
-        in.close();
-
-    }
-}
Index: src/左神算法/高频面试题/十二十三/Problem07_CandyProblem.java
===================================================================
diff --git a/src/左神算法/高频面试题/十二十三/Problem07_CandyProblem.java b/src/左神算法/高频面试题/十二十三/Problem07_CandyProblem.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/十二十三/Problem07_CandyProblem.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,17 +0,0 @@
-package 左神算法.高频面试题.十二十三;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:一群孩子做游戏，现在请你根据游戏得分来分发糖果：
- * 1.每个孩子不管得分多少，起码分到一个糖果；
- * 2.任意两个相邻的孩子之间，得分较多的孩子必须拿多一些的糖果。
- * 给定一个数组arr代表得分数组，请返回最少需要多少糖果。
- * 进阶：
- * 原题目中再加一条规则：
- * 3.任意相邻的两个孩子之间，如果得分相同，糖果数必须相同
- * @date 2020/2/7 17:18
- */
-public class Problem07_CandyProblem {
-
-}
Index: src/左神算法/进阶班二/第一章/Problem07_FindTheClosestPalindrome.java
===================================================================
diff --git a/src/左神算法/进阶班二/第一章/Problem07_FindTheClosestPalindrome.java b/src/左神算法/进阶班二/第一章/Problem07_FindTheClosestPalindrome.java
deleted file mode 100644
--- a/src/左神算法/进阶班二/第一章/Problem07_FindTheClosestPalindrome.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,81 +0,0 @@
-
-package 左神算法.进阶班二.第一章;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给一个字符串str,代表一个整数，找到除了这个数之外，绝对值和这个数相差最小的回文数。假设字符串str
- * 一定能变成long类型。
- * @date 2020/2/13 16:44
- */
-public class Problem07_FindTheClosestPalindrome {
-
-
-    public static String nearestPalindromic(String n) {
-        Long num = Long.valueOf(n);
-        Long raw = getRawPalindrome(n);
-        Long big = raw > num ? raw : getBigPalindrome(raw);
-        Long small = raw < num ? raw : getSmallPalindrome(raw);
-        return String.valueOf(big - num >= num - small ? small : big);
-    }
-
-    public static Long getRawPalindrome(String n) {
-        char[] chs = n.toCharArray();
-        int len = chs.length;
-        for (int i = 0; i < len / 2; i++) {
-            chs[len - 1 - i] = chs[i];
-        }
-        return Long.valueOf(String.valueOf(chs));
-    }
-
-    public static Long getBigPalindrome(Long raw) {
-        char[] chs = String.valueOf(raw).toCharArray();
-        char[] res = new char[chs.length + 1];
-        res[0] = '0';
-        for (int i = 0; i < chs.length; i++) {
-            res[i + 1] = chs[i];
-        }
-        int size = chs.length;
-        for (int j = (size - 1) / 2 + 1; j >= 0; j--) {
-            if (++res[j] > '9') {
-                res[j] = '0';
-            } else {
-                break;
-            }
-        }
-        int offset = res[0] == '1' ? 1 : 0;
-        size = res.length;
-        for (int i = size - 1; i >= (size + offset) / 2; i--) {
-            res[i] = res[size - i - offset];
-        }
-        return Long.valueOf(String.valueOf(res));
-    }
-
-    public static Long getSmallPalindrome(Long raw) {
-        char[] chs = String.valueOf(raw).toCharArray();
-        char[] res = new char[chs.length];
-        int size = res.length;
-        for (int i = 0; i < size; i++) {
-            res[i] = chs[i];
-        }
-        for (int j = (size - 1) / 2; j >= 0; j--) {
-            if (--res[j] < '0') {
-                res[j] = '9';
-            } else {
-                break;
-            }
-        }
-        if (res[0] == '0') {
-            res = new char[size - 1];
-            for (int i = 0; i < res.length; i++) {
-                res[i] = '9';
-            }
-            return size == 1 ? 0 : Long.parseLong(String.valueOf(res));
-        }
-        for (int k = 0; k < size / 2; k++) {
-            res[size - 1 - k] = res[k];
-        }
-        return Long.valueOf(String.valueOf(res));
-    }
-
-}
Index: src/左神算法/高频面试题/十二十三/Problem08_ShuffleProblem.java
===================================================================
diff --git a/src/左神算法/高频面试题/十二十三/Problem08_ShuffleProblem.java b/src/左神算法/高频面试题/十二十三/Problem08_ShuffleProblem.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/十二十三/Problem08_ShuffleProblem.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,126 +0,0 @@
-package 左神算法.高频面试题.十二十三;
-
-import java.util.Arrays;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 完美洗牌问题
- * @date 2020/2/9 16:23
- */
-public class Problem08_ShuffleProblem {
-
-    public static void shuffle(int[] arr){
-        if(arr!=null && arr.length!=0 && (arr.length & 1)==0)
-            shuffle(arr,0,arr.length-1);
-    }
-    public static void shuffle(int[] arr, int l, int r) {
-        while (r - l + 1 > 0) {
-            int lenAndOne = r - l + 2;
-            int bloom = 3;
-            int k = 1;
-            while (bloom <= lenAndOne / 3) {
-                bloom *= 3;
-                k++;
-            }
-            int m = (bloom - 1) / 2;
-            int mid = (l + r) / 2;
-            rotate(arr, l + m, mid + m,mid );
-            cycles(arr, l - 1, bloom, k);
-            l = l + bloom - 1;
-        }
-    }
-
-    public static void cycles(int[] arr, int base, int bloom, int k) {
-        for (int i = 0, trigger = 1; i < k; i++, trigger *= 3) {
-            int next = (2 * trigger) % bloom; //下一个点与驱动点的关系
-            int cur = next;
-            int record = arr[next + base];
-            int tmp = 0;
-            arr[next + base] = arr[trigger + base];
-            while (cur != trigger) { //当再次回到驱动点的时候，该驱动点的任务完成
-                next = (2 * cur) % bloom;//下一个点与驱动点的关系
-                tmp = arr[next + base];
-                arr[next + base] = record;
-                cur = next;
-                record = tmp;
-            }
-        }
-    }
-
-    public static void rotate(int[] arr,int l,int r,int m){//三次反转
-        reverse(arr,l,m);
-        reverse(arr,m+1,r);
-        reverse(arr,l,r);
-    }
-   //反转数组
-    public static void reverse(int[] arr,int start,int end){
-       int temp=0;
-        while(start<end)
-       {
-           temp=arr[start];
-           arr[start++]=arr[end];
-           arr[end--]=temp;
-       }
-    }
-
-    // for test
-    public static void printArray(int[] arr) {
-        for (int i = 0; i < arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    // for test
-    public static int[] generateArray() {
-        int len = (int) (Math.random() * 10) * 2;
-        int[] arr = new int[len];
-        for (int i = 0; i < len; i++) {
-            arr[i] = (int) (Math.random() * 100);
-        }
-        return arr;
-    }
-
-    // for test
-    public static void shuffleTest(int[] arr) {
-        int[] tarr = new int[arr.length];
-        int bloom = arr.length + 1;
-        for (int i = 1; i <= arr.length; i++) {
-            tarr[((2 * i) % bloom) - 1] = arr[i - 1];
-        }
-        for (int i = 0; i < arr.length; i++) {
-            arr[i] = tarr[i];
-        }
-    }
-
-    // for test
-    public static boolean equalArrays(int[] arr1, int[] arr2) {
-        if (arr1 == null || arr2 == null || arr1.length != arr2.length) {
-            return false;
-        }
-        for (int i = 0; i < arr1.length; i++) {
-            if (arr1[i] != arr2[i]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    public static void main(String[] args) {
-        for (int i = 0; i < 5000000; i++) {
-            int[] arr = generateArray();
-            int[] arr1 = Arrays.copyOfRange(arr, 0, arr.length);
-            int[] arr2 = Arrays.copyOfRange(arr, 0, arr.length);
-            shuffle(arr1);
-            shuffleTest(arr2);
-            if (!equalArrays(arr1, arr2)) {
-                System.out.println("ooops!");
-                printArray(arr);
-                printArray(arr1);
-                printArray(arr2);
-                break;
-            }
-        }
-    }
-}
Index: src/左神算法/高频面试题/十二十三/Problem09_FindUpMedian.java
===================================================================
diff --git a/src/左神算法/高频面试题/十二十三/Problem09_FindUpMedian.java b/src/左神算法/高频面试题/十二十三/Problem09_FindUpMedian.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/十二十三/Problem09_FindUpMedian.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,90 +0,0 @@
-package 左神算法.高频面试题.十二十三;
-
-import java.util.Arrays;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 在两个长度相等的排序数组中找到上中位数。
- * 给定两个有序数组arr1和arr2，已知两个数组的长度都为N，求两个数组中所有数的上中位数。
- * 要求时间复杂度为O（logN),额外空间复杂度为O（1）
- * @date 2020/2/9 16:24
- */
-public class Problem09_FindUpMedian {
-
-    public static int getUpMedian(int[] arr1,int[] arr2){
-        if (arr1 == null || arr2 == null || arr1.length != arr2.length) {
-            throw new RuntimeException("Your arr is invalid!");
-        }
-        int start1=0;
-        int end1=arr1.length-1;
-        int start2=0;
-        int end2=arr2.length-1;
-        int mid1=0;
-        int mid2=0;
-        int offset=0;
-        while(start1<end1){
-            mid1=(end1+start1)/2;
-            mid2=(end2+start2)/2;
-            //偶数长度的数组offset=1,奇数长度的数组为0
-            offset=((end1-start1+1)&1)^1;
-            if(arr1[mid1]==arr2[mid2])
-                return arr1[mid1];
-            else if(arr1[mid1]>arr2[mid2])
-            {
-                end1=mid1;
-                start2=mid2+offset;
-            }
-            else{
-                start1=mid1+offset;
-                end2=mid2;
-            }
-        }
-        return Math.min(arr1[start1],arr2[start2]);
-    }
-
-    //for test
-    public static int findForTest(int[] arr1,int[] arr2){
-        if(arr1==null || arr2==null || arr1.length!=arr2.length){
-            return -1;
-        }
-        int[] all=new int[2*arr1.length];
-        for(int i=0;i!=arr1.length;i++){
-            all[2*i]=arr1[i];
-            all[2*i+1]=arr2[i];
-        }
-        Arrays.sort(all);
-        return all[all.length/2-1];
-    }
-
-    public static int[] generateSortedArray(int len,int maxValue){
-        int[] arr=new int[len];
-        for(int i=0;i<len;i++){
-            arr[i]=(int)(Math.random()*(maxValue+1));
-        }
-        Arrays.sort(arr);
-        return arr;
-    }
-
-
-    public static void printArray(int[] arr) {
-        for (int i = 0; i != arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-    public static void main(String[] args) {
-        int len = 10;
-        int maxValue1 = 20;
-        int maxValue2 = 50;
-        int[] arr1 = generateSortedArray(len, maxValue1);
-        int[] arr2 = generateSortedArray(len, maxValue2);
-        printArray(arr1);
-        printArray(arr2);
-        System.out.println(getUpMedian(arr1, arr2));
-        System.out.println(findForTest(arr1, arr2));
-
-    }
-
-
-}
Index: src/左神算法/高频面试题/十二十三/Problem10_FindKthMin.java
===================================================================
diff --git a/src/左神算法/高频面试题/十二十三/Problem10_FindKthMin.java b/src/左神算法/高频面试题/十二十三/Problem10_FindKthMin.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/十二十三/Problem10_FindKthMin.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,63 +0,0 @@
-package 左神算法.高频面试题.十二十三;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定两个有序数组arr1和arr2,再给定一个整数k,返回所有的数中第k小的数。
- * 要求：
- * 如果arr1长度为N，arr2的长度为M，时间复杂度要求O（log(min(M,N)),额外空间复杂度为O（1）
- * @date 2020/2/10 16:49
- */
-public class Problem10_FindKthMin {
-
-
-    public static int findKthMin(int[] arr1,int[] arr2,int k){
-        if(arr1==null || arr2==null){
-           throw new RuntimeException("Your arr is invalid");
-        }
-        if(k<1 || k>arr1.length+arr2.length){
-            throw new RuntimeException("K is invalid");
-        }
-        int[] longs=arr1.length>=arr2.length ? arr1:arr2;
-        int[] shorts=arr1.length<arr2.length ? arr1: arr2;
-        int l=longs.length;
-        int s=shorts.length;
-        if(k<=s){
-            return getUpMedian(longs,0,k-1,shorts,0,k-1);
-        }
-        if(k>l){
-            if(shorts[k-l-1]>=longs[l-1])
-                return shorts[k-l-1];
-            if(longs[k-s-1]>=shorts[s-1])
-                return longs[k-s-1];
-            return getUpMedian(longs,k-s,l-1,shorts,k-l,s-1);
-        }
-        if(longs[k-s]>=shorts[s-1])
-           return longs[k-s];
-        return getUpMedian(shorts,0,s-1,longs,k-s,k-1);
-
-
-    }
-
-    //当e1-s1==e2-s2时，才可用该方法
-    public static int getUpMedian(int[] arr1,int s1,int e1,int[] arr2,int s2,int e2){
-        int m1=0;
-        int m2=0;
-        int offset=0;
-        while(s1<e2){
-            m1=(s1+e1)/2;
-            m2=(s2+e2)/2;
-            offset=((e1-s1)&1)^1;
-            if(arr1[m1]==arr2[m2]){
-                return arr1[m1];
-            }else if(arr1[m1]>arr2[m2]){
-                e1=m1;
-                s2=m2+offset;
-            }else{
-               e2=m2;
-               s1=m1+offset;
-            }
-        }
-        return Math.min(arr1[s1],arr2[s2]);
-    }
-}
Index: src/左神算法/高频面试题/十二十三/Problem11MinWindowLength.java
===================================================================
diff --git a/src/左神算法/高频面试题/十二十三/Problem11MinWindowLength.java b/src/左神算法/高频面试题/十二十三/Problem11MinWindowLength.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/十二十三/Problem11MinWindowLength.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,101 +0,0 @@
-package 左神算法.高频面试题.十二十三;
-
-import java.util.HashMap;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 最小包含子串的长度
- * 给定一个字符串str1和str2,求str1的子串中含有str2所有子串的最小子串长度。不存在返回0
- * @date 2020/2/10 18:26
- */
-public class Problem11MinWindowLength {
-
-    public static int minLength(String str1,String str2){
-        if(str1==null || str2==null || str1.length()<str2.length())
-            return 0;
-        char[] chas1= str1.toCharArray();
-        char[] chas2= str2.toCharArray();
-        int all=chas2.length;
-        HashMap<Character,Integer> map=new HashMap<>();
-        for(int i=0;i<chas2.length;i++){
-            if(map.containsKey(chas2[i])){
-                map.put(chas2[i],map.get(chas2[i])+1);
-            }else {
-                map.put(chas2[i],1);
-            }
-
-        }
-        int l=0;
-        int r=0;
-        int res=Integer.MAX_VALUE;
-        while(r<chas1.length){
-            if(map.containsKey(chas1[r])){
-                map.put(chas1[r],map.get(chas1[r])-1);
-                if(map.get(chas1[r])>=0){
-                    all--;
-                }
-            }
-            if(all==0){
-                res=Math.min(res,r-l+1);
-                while(l<=r){
-                    if(map.containsKey(chas1[l])){
-                        map.put(chas1[l],map.get(chas1[l])+1);
-                        if(map.get(chas1[l++])>0){
-                            all++;
-                            break;
-                        }
-                        res=Math.min(res,r-l+1);
-                    }else{
-                        l++;
-                        res=Math.min(res,r-l+1);
-                    }
-
-                }
-            }
-            r++;
-        }
-        return res==Integer.MAX_VALUE ? 0:res;
-
-    }
-
-     //左神做法
-    public static int minLength2(String str1, String str2) {
-        if (str1 == null || str2 == null || str1.length() < str2.length()) {
-            return 0;
-        }
-        char[] chas1 = str1.toCharArray();
-        char[] chas2 = str2.toCharArray();
-        int[] map = new int[256];
-        for (int i = 0; i != chas2.length; i++) {
-            map[chas2[i]]++;
-        }
-        int left = 0;
-        int right = 0;
-        int match = chas2.length;
-        int minLen = Integer.MAX_VALUE;
-        while (right != chas1.length) {
-            map[chas1[right]]--;
-            if (map[chas1[right]] >= 0) {
-                match--;
-            }
-            if (match == 0) {
-                while (map[chas1[left]] < 0) {
-                    map[chas1[left++]]++;
-                }
-                minLen = Math.min(minLen, right - left + 1);
-                match++;
-                map[chas1[left++]]++;
-            }
-            right++;
-        }
-        return minLen == Integer.MAX_VALUE ? 0 : minLen;
-    }
-
-    public static void main(String[] args) {
-        String str1 = "adabbca";
-        String str2 = "abc";
-        System.out.println(minLength(str1, str2));
-
-    }
-}
Index: src/JUC/美团笔面试题/ProducerAndComsumer.java
===================================================================
diff --git a/src/JUC/美团笔面试题/ProducerAndComsumer.java b/src/JUC/美团笔面试题/ProducerAndComsumer.java
deleted file mode 100644
--- a/src/JUC/美团笔面试题/ProducerAndComsumer.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,90 +0,0 @@
-package JUC.美团笔面试题;
-
-import java.util.concurrent.locks.Condition;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:3个生产者生产包子，2个消费者消费包子，篮子的大小为10，生产者的生产速度为10s,消费者消费速度为2s.
-
- * @date 2020/4/16 12:31
- */
-public class ProducerAndComsumer {
-
-    public static void main(String[] args) {
-        MyResource myResource=new MyResource();
-        new Thread(()->{
-            while(true)
-            myResource.produce();
-        },"生产者1").start();
-        new Thread(()->{
-            while(true)
-            myResource.produce();
-        },"生产者2").start();
-        new Thread(()->{
-            while (true)
-            myResource.produce();
-        },"生产者3").start();
-        new Thread(()->{
-            while (true)
-            myResource.consume();
-        },"消费者1").start();
-        new Thread(()->{
-            while(true)
-            myResource.consume();
-        },"消费者2").start();
-
-    }
-}
-
-class MyResource{
-    Lock lock=new ReentrantLock();
-    Condition condition=lock.newCondition();
-    private int num=0;
-
-    //生产
-    public void produce(){
-        lock.lock();
-        try{
-            while(num==10){
-                condition.await();
-            }
-            //干活
-            num++;
-            Thread.sleep(2000);
-            System.out.println(Thread.currentThread().getName()+"生产了第"+num+"个馒头");
-            condition.signalAll();
-
-        }catch (Exception e){
-            e.printStackTrace();
-        }finally {
-            lock.unlock();
-        }
-    }
-
-    //消费
-    public void consume(){
-        lock.lock();
-        try{
-
-            while(num==0){
-                condition.await();
-            }
-
-            num--;
-            Thread.sleep(1000);
-            System.out.println(Thread.currentThread().getName()+"消费了第"+(num+1)+"个馒头");
-            condition.signalAll();
-
-        }catch (Exception e){
-            e.printStackTrace();
-        }finally {
-            lock.unlock();
-        }
-    }
-
-
-
-}
Index: src/JUC/美团笔面试题/ProducerConsumer.java
===================================================================
diff --git a/src/JUC/美团笔面试题/ProducerConsumer.java b/src/JUC/美团笔面试题/ProducerConsumer.java
deleted file mode 100644
--- a/src/JUC/美团笔面试题/ProducerConsumer.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,125 +0,0 @@
-package JUC.美团笔面试题;
-
-
-import jdk.nashorn.internal.ir.Block;
-
-import java.util.concurrent.ArrayBlockingQueue;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- * @author zbl
- * @version 1.0 Synchronized实现
- * @content:3个生产者生产包子，2个消费者消费包子，篮子的大小为10，生产者的生产速度为10s,消费者消费速度为2s.
- *
- * @date 2021/3/26 15:59
- */
-public class ProducerConsumer {
-
-
-    public static void main(String[] args) {
-
-        Shop shop = new Shop();
-        for (int i = 0; i < 3; i++) {
-            Producer producer = new Producer(shop);
-            producer.start();
-        }
-
-        for (int i = 0; i < 2; i++) {
-            Consumer consumer = new Consumer(shop);
-            consumer.start();
-        }
-    }
-
-}
-/**
- * 商店类（Shop）:定义一个成员变量，表示第几个面包，提供生产面包和消费面包的操作；
- */
-class Shop {
-    private int bread = 0;
-    /**
-     * 生产面包
-     */
-    public synchronized void produceBread() {
-        if (bread < 10) {
-            bread++;
-            System.out.println(Thread.currentThread().getName() + ":开始生产第" + bread + "个面包");
-            notify(); // 唤醒消费者线程
-        } else {
-            try {
-                wait(); // 告诉生产者等待一下
-            } catch (InterruptedException e) {
-                e.printStackTrace();
-            }
-        }
-    }
-
-    /**
-     * 消费面包
-     */
-    public synchronized void consumeBread() {
-        if (bread > 0) {
-            System.out.println(Thread.currentThread().getName() + ":开始消费第" + bread + "个面包");
-            bread--;
-            notify(); // 唤醒生产者线程
-        } else {
-            try {
-                wait(); // 告诉消费者等待一下
-            } catch (InterruptedException e) {
-                e.printStackTrace();
-            }
-        }
-    }
-}
-
-/**
- * 生产者类（Producer）：继承Thread类，重写run()方法，调用生产面包的操作
- */
-class Producer extends Thread {
-    private Shop shop;
-
-    public Producer(Shop shop) {
-        this.shop = shop;
-    }
-
-    @Override
-    public void run() {
-        System.out.println(getName() + ":开始生产面包.....");
-        while (true) {
-            try {
-                Thread.sleep(1000);
-            } catch (InterruptedException e) {
-                e.printStackTrace();
-            }
-            shop.produceBread() ;
-        }
-    }
-}
-
-/**
- * 消费者类（Consumer）：继承Thread类，重写run()方法，调用消费面包的操作
- */
-class Consumer extends Thread {
-    private Shop shop;
-    public Consumer(Shop shop) {
-        this.shop = shop;
-    }
-
-    @Override
-    public void run() {
-        System.out.println(getName() + ":开始消费面包.....");
-        while (true) {
-            try {
-                Thread.sleep(2000);
-            } catch (InterruptedException e) {
-                e.printStackTrace();
-            }
-            shop.consumeBread();
-        }
-    }
-}
-
-
-
-
-
Index: .idea/inspectionProfiles/Project_Default.xml
===================================================================
diff --git a/.idea/inspectionProfiles/Project_Default.xml b/.idea/inspectionProfiles/Project_Default.xml
deleted file mode 100644
--- a/.idea/inspectionProfiles/Project_Default.xml	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,36 +0,0 @@
-<component name="InspectionProjectProfileManager">
-  <profile version="1.0">
-    <option name="myName" value="Project Default" />
-    <inspection_tool class="JavaDoc" enabled="true" level="WARNING" enabled_by_default="true">
-      <option name="TOP_LEVEL_CLASS_OPTIONS">
-        <value>
-          <option name="ACCESS_JAVADOC_REQUIRED_FOR" value="none" />
-          <option name="REQUIRED_TAGS" value="" />
-        </value>
-      </option>
-      <option name="INNER_CLASS_OPTIONS">
-        <value>
-          <option name="ACCESS_JAVADOC_REQUIRED_FOR" value="none" />
-          <option name="REQUIRED_TAGS" value="" />
-        </value>
-      </option>
-      <option name="METHOD_OPTIONS">
-        <value>
-          <option name="ACCESS_JAVADOC_REQUIRED_FOR" value="none" />
-          <option name="REQUIRED_TAGS" value="@return@param@throws or @exception" />
-        </value>
-      </option>
-      <option name="FIELD_OPTIONS">
-        <value>
-          <option name="ACCESS_JAVADOC_REQUIRED_FOR" value="none" />
-          <option name="REQUIRED_TAGS" value="" />
-        </value>
-      </option>
-      <option name="IGNORE_DEPRECATED" value="false" />
-      <option name="IGNORE_JAVADOC_PERIOD" value="true" />
-      <option name="IGNORE_DUPLICATED_THROWS" value="false" />
-      <option name="IGNORE_POINT_TO_ITSELF" value="false" />
-      <option name="myAdditionalJavadocTags" value="date" />
-    </inspection_tool>
-  </profile>
-</component>
\ No newline at end of file
Index: src/Gof/proxy/CglibProxy/ProxyFactory.java
===================================================================
diff --git a/src/Gof/proxy/CglibProxy/ProxyFactory.java b/src/Gof/proxy/CglibProxy/ProxyFactory.java
deleted file mode 100644
--- a/src/Gof/proxy/CglibProxy/ProxyFactory.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,45 +0,0 @@
-package Gof.proxy.CglibProxy;
-
-import net.sf.cglib.proxy.Enhancer;
-import net.sf.cglib.proxy.MethodInterceptor;
-import net.sf.cglib.proxy.MethodProxy;
-
-import java.lang.reflect.Method;
-
-public class ProxyFactory implements MethodInterceptor {
-    //维护一个目标对象
-    private Object target;
-    public ProxyFactory(Object target) {
-        this.target=target;
-    }
-    //返回一个代理对象
-    public Object getProxyInstnce()
-    {
-        //创建一个工具类
-        Enhancer enhancer = new Enhancer();
-        //设置父类,即代理目标
-        enhancer.setSuperclass(target.getClass());
-        //设置单一回调对象，在调用中拦截目标方法的调用
-        enhancer.setCallback(this);
-        //创建子类对象，即代理对象
-        return enhancer.create();
-    }
-
-    /**
-     *
-     * @param o 代理对象
-     * @param method 拦截方法
-     *
-     * @param args 拦截方法的参数
-     * @param methodProxy 代理
-     * @return
-     * @throws Throwable
-     */
-    @Override
-    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
-        System.out.println("cglib代理模式。。。开始");
-        Object invoke = method.invoke(target, args);
-        System.out.println("cglib代理模式结束。。。。");
-        return invoke;
-    }
-}
Index: src/Gof/proxy/dynamicProxy/ProxyFactory.java
===================================================================
diff --git a/src/Gof/proxy/dynamicProxy/ProxyFactory.java b/src/Gof/proxy/dynamicProxy/ProxyFactory.java
deleted file mode 100644
--- a/src/Gof/proxy/dynamicProxy/ProxyFactory.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,36 +0,0 @@
-package Gof.proxy.dynamicProxy;
-
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
-
-//代理对象类
-public class ProxyFactory {
-
-    //维护一个目标对象
-    private Object target;
-
-    public ProxyFactory( Object target) {
-        this.target=target;
-    }
-//    public static Object newProxyInstance(ClassLoader loader,
-//                                          Class<?>[] interfaces,
-//                                          InvocationHandler h)
-
-    //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定
-    //2. Class<?>[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型
-    //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入
-    public Object getProxyInstance()
-    {
-        return Proxy.newProxyInstance(target.getClass().getClassLoader(),
-                target.getClass().getInterfaces(), new InvocationHandler() {
-            @Override
-            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-                System.out.println("jdk代理开始。。。");
-                Object returnVal = method.invoke(target, args);//args是传入的目标对象的参数，目标对象的方法如果没有返回值，则返回null
-                System.out.println("jdk代理结束");
-                return returnVal;
-            }
-        });
-    }
-}
Index: src/org/sd/dyanmicProxy/ProxyStar.java
===================================================================
diff --git a/src/org/sd/dyanmicProxy/ProxyStar.java b/src/org/sd/dyanmicProxy/ProxyStar.java
deleted file mode 100644
--- a/src/org/sd/dyanmicProxy/ProxyStar.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,53 +0,0 @@
-package org.sd.dyanmicProxy;
-
-public class ProxyStar implements Star {
-
-    StarHandler starHandler;
-    public ProxyStar(StarHandler starHandler) {
-        this.starHandler = starHandler;
-    }
-
-    /**
-     * 面谈
-     */
-    @Override
-    public void confer() throws Throwable {
-        starHandler.invoke(this,this.getClass().getDeclaredMethod("confer"),null);
-    }
-
-    /**
-     * 签合同
-     */
-    @Override
-    public void signContract() throws Throwable {
-    starHandler.invoke(this,this.getClass().getDeclaredMethod("signContract"),null);
-    }
-
-    /**
-     * 订票
-     */
-    @Override
-    public void bookTicket() throws Throwable {
-        starHandler.invoke(this,this.getClass().getDeclaredMethod("bookTicket"),null);
-    }
-
-    /**
-     * 唱歌
-     */
-    @Override
-    public void sing() throws Throwable {
-    starHandler.invoke(this,this.getClass().getDeclaredMethod("sing"),null);
-    }
-
-    /**
-     * 收钱
-     */
-    @Override
-    public void collectMoney() throws Throwable {
-    starHandler.invoke(this,this.getClass().getDeclaredMethod("collectMoney"),null);
-    }
-
-
-
-
-}
Index: src/org/sd/StaticProxy/ProxyStar.java
===================================================================
diff --git a/src/org/sd/StaticProxy/ProxyStar.java b/src/org/sd/StaticProxy/ProxyStar.java
deleted file mode 100644
--- a/src/org/sd/StaticProxy/ProxyStar.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,56 +0,0 @@
-package org.sd.StaticProxy;
-
-import org.sd.dyanmicProxy.Star;
-
-public class ProxyStar implements Star {
-    private Star star;
-
-    public ProxyStar(Star star) {
-        this.star = star;
-    }
-
-    /**
-     * 面谈
-     */
-    @Override
-
-    public void confer() {
-        System.out.println("ProxyStar.confer()");
-
-    }
-
-    /**
-     * 签合同
-     */
-    @Override
-    public void signContract() {
-        System.out.println("ProxyStar.signContract()");
-
-    }
-
-    /**
-     * 订票
-     */
-    @Override
-    public void bookTicket() {
-        System.out.println("ProxyStar.bookTicket()");
-
-    }
-
-    /**
-     * 唱歌
-     */
-    @Override
-    public void sing() throws Throwable {
-    this.star.sing();
-    }
-
-    /**
-     * 收钱
-     */
-    @Override
-    public void collectMoney() {
-        System.out.println("ProxyStar.collectMoney()");
-
-    }
-}
Index: src/Gof/responsibilityChain/PurchaseRequest.java
===================================================================
diff --git a/src/Gof/responsibilityChain/PurchaseRequest.java b/src/Gof/responsibilityChain/PurchaseRequest.java
deleted file mode 100644
--- a/src/Gof/responsibilityChain/PurchaseRequest.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,23 +0,0 @@
-package Gof.responsibilityChain;
-
-public class PurchaseRequest {
-
-    private int type = 0; //请求类型
-    private float price = 0.0f; //请求金额
-    private int id = 0;
-    //构造器
-    public PurchaseRequest(int type, float price, int id) {
-        this.type = type;
-        this.price = price;
-        this.id = id;
-    }
-    public int getType() {
-        return type;
-    }
-    public float getPrice() {
-        return price;
-    }
-    public int getId() {
-        return id;
-    }
-}
Index: src/Gof/template/PureSoyaMike.java
===================================================================
diff --git a/src/Gof/template/PureSoyaMike.java b/src/Gof/template/PureSoyaMike.java
deleted file mode 100644
--- a/src/Gof/template/PureSoyaMike.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,14 +0,0 @@
-package Gof.template;
-
-public class PureSoyaMike extends SoyaMilk {
-
-    @Override
-    void addCondiments() {
-
-    }
-
-    @Override
-    public boolean customerWantCondiments() {
-        return false;
-    }
-}
Index: .idea/libraries/QRCode.xml
===================================================================
diff --git a/.idea/libraries/QRCode.xml b/.idea/libraries/QRCode.xml
deleted file mode 100644
--- a/.idea/libraries/QRCode.xml	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,9 +0,0 @@
-<component name="libraryTable">
-  <library name="QRCode">
-    <CLASSES>
-      <root url="jar://$PROJECT_DIR$/src/lib/QRCode.jar!/" />
-    </CLASSES>
-    <JAVADOC />
-    <SOURCES />
-  </library>
-</component>
\ No newline at end of file
Index: src/org/sd/QRcode/QRCodeUtil.java
===================================================================
diff --git a/src/org/sd/QRcode/QRCodeUtil.java b/src/org/sd/QRcode/QRCodeUtil.java
deleted file mode 100644
--- a/src/org/sd/QRcode/QRCodeUtil.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,76 +0,0 @@
-package org.sd.QRcode;
-import com.swetake.util.Qrcode;
-import javax.imageio.ImageIO;
-import java.awt.*;
-import java.awt.image.BufferedImage;
-import java.io.File;
-
-public class QRCodeUtil {
-
-    //加密：文字信息---》二维码。png
-    /**
-     *   imgpath:src/二维码。png
-     *   content:helloworld
-     *   imgType:png
-     */
-    public void encoderQRCode(String content,String imgPath,String imgType,int size) throws Exception
-    {
-        BufferedImage bufferedImage=qRcodeCommon(content,imgType,size);
-        File file =new File(imgPath);
-        //生成图片
-        ImageIO.write(bufferedImage, imgType, file);
-    }
-
-    //产生一个二维码的BufferedImage
-    /**
-     *
-     */
-
-    public BufferedImage qRcodeCommon (String content,String imgType,int size)throws Exception
-    {
-        BufferedImage bufferedImage=null;
-        //QrCode对象：字符串--》boolean[][]
-        Qrcode qrcode=new Qrcode();
-        //设置二维码的排错率：7%<l<m<q<h<30%:排错率越高，可存储的信息越少：但是对二维码清晰度要求越高
-        qrcode.setQrcodeErrorCorrect('M');
-        //可存放的信息类型：N:数字，A；数字+字母：B：所有
-        qrcode.setQrcodeEncodeMode('B');
-
-        //尺寸：取值范围：1-40
-        qrcode.setQrcodeVersion(size);
-        byte[] contentType=content.getBytes("utf-8");
-        //转换为字节数组
-        boolean[][] codeOut=qrcode.calQrcode(contentType);
-
-        int imgSize=67+12*(size-1);
-        //bufferedImage:内存中的图片
-        bufferedImage=new BufferedImage(imgSize,imgSize,BufferedImage.TYPE_INT_BGR);
-
-        //创建一个画板
-        Graphics2D gs=bufferedImage.createGraphics();
-        gs.setBackground(Color.WHITE);//将画板的背景色设置为白色
-        gs.clearRect(0,0,imgSize,imgSize);//初始化
-        gs.setColor(Color.BLACK);//设置画板上图像的颜色（二维码颜色）
-        int pixoff=2;
-
-        for(int i=0;i<codeOut.length;i++)
-        {
-            for(int j=0;j<codeOut.length;j++)
-            {
-                if(codeOut[i][j])
-                    gs.fillRect(j*3+pixoff,i*3+pixoff,3,3);
-            }
-        }
-
-        //增加logo
-        //将硬盘中的图片转化为image对象
-        Image logo=ImageIO.read(new File("src/flower.jpg"));
-        int height=bufferedImage.getHeight();
-        int width=bufferedImage.getWidth();
-        gs.drawImage(logo,imgSize/3,imgSize/3,height/3,width/3,null);
-        gs.dispose();
-        bufferedImage.flush();
-
-        return bufferedImage;
-    }
-}
Index: src/Gof/Strategy/QuackBehavior.java
===================================================================
diff --git a/src/Gof/Strategy/QuackBehavior.java b/src/Gof/Strategy/QuackBehavior.java
deleted file mode 100644
--- a/src/Gof/Strategy/QuackBehavior.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,6 +0,0 @@
-package Gof.Strategy;
-
-public interface QuackBehavior {
-
-    void quack();
-}
Index: src/左神算法/面试重写与剑指offer/QuanPaiLie.java
===================================================================
diff --git a/src/左神算法/面试重写与剑指offer/QuanPaiLie.java b/src/左神算法/面试重写与剑指offer/QuanPaiLie.java
deleted file mode 100644
--- a/src/左神算法/面试重写与剑指offer/QuanPaiLie.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,48 +0,0 @@
-package 左神算法.面试重写与剑指offer;
-
-import java.util.Arrays;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 写个算法题，给一个数组输出它的全排列    (美团面试)
- * @date 2020/4/15 16:29
- */
-public class QuanPaiLie {
-
-    public static void main(String[] args) {
-       int[] arr={1,2,3};
-       dfs(arr);
-    }
-    public static void dfs(int[] arr){
-        if(arr==null)
-            return;
-        if(arr.length==1)
-        {
-            System.out.println();
-            return;
-        }
-        dfs(arr,0);
-    }
-
-    private static void dfs(int[] arr,int k){
-       if(k==arr.length-1){
-
-           System.out.println(Arrays.toString(arr));
-           return;
-       }
-       for(int i=k;i<arr.length;i++)
-       {
-           swap(arr,k,i);
-           dfs(arr,k+1);
-           swap(arr,k,i);
-       }
-
-    }
-
-    public static void swap(int[] arr,int a,int b){
-        int temp=arr[a];
-        arr[a]=arr[b];
-        arr[b]=temp;
-    }
-}
Index: src/韩顺平算法与数据结构/datastructure/recursion/Queen8.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/recursion/Queen8.java b/src/韩顺平算法与数据结构/datastructure/recursion/Queen8.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/recursion/Queen8.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,60 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.recursion;
-
-import javax.security.auth.login.AccountException;
-import java.util.Map;
-
-public class Queen8 {
-
-    //定义一个max表示共有多少个皇后
-    int max=8;
-    int [] arr=new int[max];
-    static int count=0;
-    static int judgecount=0;
-
-    public static void main(String[] args) {
-        Queen8 queen8=new Queen8();
-        queen8.check(0);
-        System.out.println(count);
-        System.out.println(judgecount);
-    }
-    //放置第n个皇后
-   public void check(int n)
-   {
-       if(n==max){
-           print();
-           return;
-       }
-       for(int i=0;i<max;i++)
-       {
-           arr[n]=i;
-           if(judge(n))
-           {
-               check(n+1);
-           }
-
-       }
-
-   }
-
-    //判断第n个皇后是否和前面n-1个皇后位置冲突
-    public boolean judge(int n)
-    {    judgecount++;
-        for(int i=0;i<n;i++)
-        {
-            if(arr[n]==arr[i] || Math.abs(arr[i]-arr[n])== Math.abs(i-n))
-                return false;
-        }
-        return true;
-    }
-
-    //输出皇后的摆放位置
-    public void print()
-    {
-        count++;
-        for(int i=0;i<8;i++)
-        {
-            System.out.print(arr[i]+" ");
-        }
-        System.out.println();
-    }
-}
Index: src/codeTop/QuickMulti.java
===================================================================
diff --git a/src/codeTop/QuickMulti.java b/src/codeTop/QuickMulti.java
deleted file mode 100644
--- a/src/codeTop/QuickMulti.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,36 +0,0 @@
-package codeTop;
-
-import java.util.HashMap;
-import java.util.Scanner;
-
-/**
- * 不使用乘法快速计算a * b的值
- */
-public class QuickMulti {
-
-    //模仿快速幂（LeetCode 50）的实现过程
-    public static int quickMultiImpl(int a,int b){
-        int ans = 0;
-        while(a != 0){
-            if((a & 1) != 0){
-                ans += b;
-            }
-            b += b;
-            a /= 2;
-        }
-        return ans;
-    }
-
-    public static void main(String[] args) {
-        Scanner scanner = new Scanner(System.in);
-        while(scanner.hasNext()){
-            int next = scanner.nextInt();
-            String[] arr = new String[next];
-            for(int i = 0;i < next;i++){
-                arr[i] = scanner.next();
-            }
-        }
-
-
-    }
-}
Index: src/左神算法/基础班/Sort/QuickSort.java
===================================================================
diff --git a/src/左神算法/基础班/Sort/QuickSort.java b/src/左神算法/基础班/Sort/QuickSort.java
deleted file mode 100644
--- a/src/左神算法/基础班/Sort/QuickSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,151 +0,0 @@
-package 左神算法.基础班.Sort;
-
-import java.util.Arrays;
-
-public class QuickSort {
-
-    public static void quickSort(int[] arr) {
-        if (arr == null || arr.length < 2) {
-            return;
-        }
-        quickSort(arr, 0, arr.length - 1);
-    }
-
-    public static void quickSort(int[] arr,int l,int r)
-     {
-
-         if(l<r)
-         {
-             swap(arr,l+(int)(Math.random()*(r-l+1)),r);//随机快速排序
-             int[] p=partition(arr,l,r);
-             quickSort(arr,l,p[0]-1);
-             quickSort(arr,p[1]+1,r);
-         }
-//         if (l < r) {
-//             swap(arr, l + (int) (Math.random() * (r - l + 1)), r);
-//             int[] p = partition(arr, l, r);
-//             quickSort(arr, l, p[0] - 1);
-//             quickSort(arr, p[1] + 1, r);
-//         }
-
-
-     }
-
-    //partition的过程，因为上面的方法中，以及进行了随机快排，这里选择最后元素的值作为划分依据
-    public static int [] partition(int[] arr ,int l,int r)
-    {
-      int less=l-1;
-      int more=r;
-
-      while(l<more)
-      {
-          if(arr[l]<arr[r])
-          {
-              swap(arr,++less,l++); //当前值小于最后的那个划分值
-
-          }else if(arr[l]>arr[r])
-          {
-              swap(arr,--more,l);//当前值大于最后的那个划分值
-          }else {
-              l++;//相等直接跳过
-          }
-      }
-      swap(arr,more,r);//将划分值提到大于区间的最前面
-      return new int[]{less+1,more};//返回划分值在数组中的第一次出现的位置以及最后一次出现的位置
-
-
-    }
-    //异或的方式实现两个变量值交换
-    public static void swap(int[]arr,int i,int j)
-    {
-        if(i!=j){ //只有当i!=j的时候才能使用
-            int tmp = arr[i];
-            arr[i] = arr[j];
-            arr[j] = tmp;
-        }
-
-    }
-
-    // for test
-    public static void comparator(int[] arr) {
-        Arrays.sort(arr);
-    }
-
-    // for test
-    public static int[] generateRandomArray(int maxSize, int maxValue) {
-        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
-        for (int i = 0; i < arr.length; i++) {
-            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
-        }
-        return arr;
-    }
-
-    // for test
-    public static int[] copyArray(int[] arr) {
-        if (arr == null) {
-            return null;
-        }
-        int[] res = new int[arr.length];
-        for (int i = 0; i < arr.length; i++) {
-            res[i] = arr[i];
-        }
-        return res;
-    }
-
-    // for test
-    public static boolean isEqual(int[] arr1, int[] arr2) {
-        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
-            return false;
-        }
-        if (arr1 == null && arr2 == null) {
-            return true;
-        }
-        if (arr1.length != arr2.length) {
-            return false;
-        }
-        for (int i = 0; i < arr1.length; i++) {
-            if (arr1[i] != arr2[i]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    // for test
-    public static void printArray(int[] arr) {
-        if (arr == null) {
-            return;
-        }
-        for (int i = 0; i < arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    // for test
-    public static void main(String[] args) {
-        int testTime = 500000;
-        int maxSize = 100;
-        int maxValue = 100;
-        boolean succeed = true;
-        for (int i = 0; i < testTime; i++) {
-            int[] arr1 = generateRandomArray(maxSize, maxValue);
-            int[] arr2 = copyArray(arr1);
-            quickSort(arr1,0,arr1.length-1);
-            comparator(arr2);
-            if (!isEqual(arr1, arr2)) {
-                succeed = false;
-                printArray(arr1);
-                printArray(arr2);
-                break;
-            }
-        }
-        System.out.println(succeed ? "Nice!" : "Fucking fucked!");
-
-        int[] arr = generateRandomArray(50, 100);
-        printArray(arr);
-        quickSort(arr);
-        printArray(arr);
-
-    }
-}
Index: src/左神算法/面试重写与剑指offer/QuickSort.java
===================================================================
diff --git a/src/左神算法/面试重写与剑指offer/QuickSort.java b/src/左神算法/面试重写与剑指offer/QuickSort.java
deleted file mode 100644
--- a/src/左神算法/面试重写与剑指offer/QuickSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,138 +0,0 @@
-package 左神算法.面试重写与剑指offer;
-
-import java.util.Arrays;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 重写quickSort,重点都是partation的过程
- * @date 2020/3/19 20:55
- */
-public class QuickSort {
-
-    public static void quickSort(int[] arr){
-        if(arr==null || arr.length<2)
-            return;
-        quickSort(arr,0,arr.length-1);
-    }
-
-    private static void quickSort(int[] arr,int left,int right){
-        if(left<right){
-            //随机快排
-            swap(arr,left+(int)(Math.random()*(right-left+1)),right);
-            int[] ans=partation(arr,left,right);
-            quickSort(arr,left,ans[0]-1);
-            quickSort(arr,ans[1]+1,right);
-
-        }
-    }
-    //以right位置的数为标准进行partation
-    private static int[] partation(int[] arr,int left,int right){
-        int less=left-1;
-        int more=right;
-        while(left<more){
-            if(arr[left]<arr[right]){
-                swap(arr,++less,left++);
-            }else if(arr[left]>arr[right]){
-                swap(arr,--more,left);
-            }else{
-                left++;
-            }
-        }
-        swap(arr,more,right);
-        return new int[]{less+1,more};
-    }
-
-
-    private static void swap(int[] arr,int left,int right){
-        int tmp=arr[left];
-        arr[left]=arr[right];
-        arr[right]=tmp;
-    }
-
-
-
-    // for test
-    public static void comparator(int[] arr) {
-        Arrays.sort(arr);
-    }
-
-    // for test
-    public static int[] generateRandomArray(int maxSize, int maxValue) {
-        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
-        for (int i = 0; i < arr.length; i++) {
-            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
-        }
-        return arr;
-    }
-
-    // for test
-    public static int[] copyArray(int[] arr) {
-        if (arr == null) {
-            return null;
-        }
-        int[] res = new int[arr.length];
-        for (int i = 0; i < arr.length; i++) {
-            res[i] = arr[i];
-        }
-        return res;
-    }
-
-    // for test
-    public static boolean isEqual(int[] arr1, int[] arr2) {
-        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
-            return false;
-        }
-        if (arr1 == null && arr2 == null) {
-            return true;
-        }
-        if (arr1.length != arr2.length) {
-            return false;
-        }
-        for (int i = 0; i < arr1.length; i++) {
-            if (arr1[i] != arr2[i]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    // for test
-    public static void printArray(int[] arr) {
-        if (arr == null) {
-            return;
-        }
-        for (int i = 0; i < arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    // for test
-    public static void main(String[] args) {
-//        int testTime = 500000;
-//        int maxSize = 100;
-//        int maxValue = 100;
-//        boolean succeed = true;
-//        for (int i = 0; i < testTime; i++) {
-//            int[] arr1 = generateRandomArray(maxSize, maxValue);
-//            int[] arr2 = copyArray(arr1);
-//            quickSort(arr1,0,arr1.length-1);
-//            comparator(arr2);
-//            if (!isEqual(arr1, arr2)) {
-//                succeed = false;
-//                printArray(arr1);
-//                printArray(arr2);
-//                break;
-//            }
-//        }
-//        System.out.println(succeed ? "Nice!" : "Fucking fucked!");
-//
-//        int[] arr = generateRandomArray(50, 100);
-//        printArray(arr);
-//        quickSort(arr);
-//        printArray(arr);
-
-    }
-}
Index: src/算法重写练习/排序/QuickSort.java
===================================================================
diff --git a/src/算法重写练习/排序/QuickSort.java b/src/算法重写练习/排序/QuickSort.java
deleted file mode 100644
--- a/src/算法重写练习/排序/QuickSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,138 +0,0 @@
-package 算法重写练习.排序;
-
-import java.util.Arrays;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2020/6/28 23:51
- */
-public class QuickSort {
-
-
-    public static void quickSort(int[] nums){
-         if(nums==null || nums.length==0)
-             return;
-         quickSort(nums,0,nums.length-1);
-    }
-
-
-    private static void quickSort(int[] nums,int left,int right){
-        if(left<right){
-            swap(nums,left+(int)(Math.random()*(right-left+1)),right);//随机快速排序
-            int[] res=partitation(nums,left,right);
-            quickSort(nums,left,res[0]-1);
-            quickSort(nums,res[1]+1,right);
-        }
-    }
-    //以right位置的值为标准进行大小比较
-    private static int[] partitation(int[] nums,int left,int right){
-        int l=left-1,r=right;
-        while(left<r){
-            if(nums[left]<nums[right]){
-               swap(nums,left++,++l);
-            }else if(nums[left]>nums[right]){
-                swap(nums,left,--r);
-            }else{
-                left++;
-            }
-        }
-        swap(nums,right,r);
-        return new int[]{l+1,r};//返回排序后nums中left-right范围中第一个等于最后一个数的索引以及最后一个等于等于最后一个数的索引
-
-    }
-
-    private static void swap(int[] nums,int l,int r){
-         int tmp=nums[l];
-         nums[l]=nums[r];
-         nums[r]=tmp;
-    }
-
-    // for test
-    public static void comparator(int[] arr) {
-        Arrays.sort(arr);
-    }
-
-    // for test
-    public static int[] generateRandomArray(int maxSize, int maxValue) {
-        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
-        for (int i = 0; i < arr.length; i++) {
-            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
-        }
-        return arr;
-    }
-
-    // for test
-    public static int[] copyArray(int[] arr) {
-        if (arr == null) {
-            return null;
-        }
-        int[] res = new int[arr.length];
-        for (int i = 0; i < arr.length; i++) {
-            res[i] = arr[i];
-        }
-        return res;
-    }
-
-    // for test
-    public static boolean isEqual(int[] arr1, int[] arr2) {
-        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
-            return false;
-        }
-        if (arr1 == null && arr2 == null) {
-            return true;
-        }
-        if (arr1.length != arr2.length) {
-            return false;
-        }
-        for (int i = 0; i < arr1.length; i++) {
-            if (arr1[i] != arr2[i]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    // for test
-    public static void printArray(int[] arr) {
-        if (arr == null) {
-            return;
-        }
-        for (int i = 0; i < arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    // for test
-    public static void main(String[] args) {
-        int testTime = 500000;
-        int maxSize = 100;
-        int maxValue = 100;
-        boolean succeed = true;
-        for (int i = 0; i < testTime; i++) {
-            int[] arr1 = generateRandomArray(maxSize, maxValue);
-            int[] arr2 = copyArray(arr1);
-            quickSort(arr1,0,arr1.length-1);
-            comparator(arr2);
-            if (!isEqual(arr1, arr2)) {
-                succeed = false;
-                printArray(arr1);
-                printArray(arr2);
-                break;
-            }
-        }
-        System.out.println(succeed ? "Nice!" : "Fucking fucked!");
-
-        int[] arr = generateRandomArray(50, 100);
-        printArray(arr);
-        quickSort(arr);
-        printArray(arr);
-
-
-
-    }
-
-
-}
Index: src/韩顺平算法与数据结构/datastructure/sort/QuickSort.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/sort/QuickSort.java b/src/韩顺平算法与数据结构/datastructure/sort/QuickSort.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/sort/QuickSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,87 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.sort;
-
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Date;
-
-public class QuickSort {
-
-    public static void main(String[] args) {
-        //int[] arr = {-9,78,0,23,-567,70, -1,900, 4561};
-
-        //测试快排的执行速度
-        // 创建要给80000个的随机的数组
-        int[] arr = new int[8000000];
-        for (int i = 0; i < 8000000; i++) {
-            arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数
-        }
-
-        System.out.println("排序前");
-        Date data1 = new Date();
-        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
-        String date1Str = simpleDateFormat.format(data1);
-        System.out.println("排序前的时间是=" + date1Str);
-
-        quickSort(arr, 0, arr.length-1);
-
-        Date data2 = new Date();
-        String date2Str = simpleDateFormat.format(data2);
-        System.out.println("排序前的时间是=" + date2Str);
-        //System.out.println("arr=" + Arrays.toString(arr));
-    }
-
-    public static void quickSort(int[] arr,int left, int right) {
-        int l = left; //左下标
-        int r = right; //右下标
-        //pivot 中轴值
-        int pivot = arr[(left + right) / 2];
-        int temp = 0; //临时变量，作为交换时使用
-        //while循环的目的是让比pivot 值小放到左边
-        //比pivot 值大放到右边
-        while( l < r) {
-            //在pivot的左边一直找,找到大于等于pivot值,才退出
-            while( arr[l] < pivot) {
-                l += 1;
-            }
-            //在pivot的右边一直找,找到小于等于pivot值,才退出
-            while(arr[r] > pivot) {
-                r -= 1;
-            }
-            //如果l >= r说明pivot 的左右两的值，已经按照左边全部是
-            //小于等于pivot值，右边全部是大于等于pivot值
-            if( l >= r) {
-                break;
-            }
-
-            //交换
-            temp = arr[l];
-            arr[l] = arr[r];
-            arr[r] = temp;
-
-            //如果交换完后，发现这个arr[l] == pivot值 相等 r--， 前移
-            if(arr[l] == pivot) {
-                r -= 1;
-            }
-            //如果交换完后，发现这个arr[r] == pivot值 相等 l++， 后移
-            if(arr[r] == pivot) {
-                l += 1;
-            }
-        }
-
-        // 如果 l == r, 必须l++, r--, 否则为出现栈溢出
-        if (l == r) {
-            l += 1;
-            r -= 1;
-        }
-        //向左递归
-        if(left < r) {
-            quickSort(arr, left, r);
-        }
-        //向右递归
-        if(right > l) {
-            quickSort(arr, l, right);
-        }
-
-
-    }
-}
Index: src/韩顺平算法与数据结构/datastructure/sort/RadixSort.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/sort/RadixSort.java b/src/韩顺平算法与数据结构/datastructure/sort/RadixSort.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/sort/RadixSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,176 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.sort;
-
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Date;
-
-public class RadixSort {
-
-    public static void main(String[] args) {
-        int arr[] = { 53, 3, 542, 748, 14, 214};
-
-        // 80000000 * 11 * 4 / 1024 / 1024 / 1024 =3.3G
-//		int[] arr = new int[8000000];
-//		for (int i = 0; i < 8000000; i++) {
-//			arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数
-//		}
-        System.out.println("排序前");
-        Date data1 = new Date();
-        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
-        String date1Str = simpleDateFormat.format(data1);
-        System.out.println("排序前的时间是=" + date1Str);
-
-        radixSort(arr);
-
-        Date data2 = new Date();
-        String date2Str = simpleDateFormat.format(data2);
-        System.out.println("排序前的时间是=" + date2Str);
-
-        System.out.println("基数排序后 " + Arrays.toString(arr));
-
-    }
-
-    //基数排序方法
-    public static void radixSort(int[] arr) {
-
-        //根据前面的推导过程，我们可以得到最终的基数排序代码
-
-        //1. 得到数组中最大的数的位数
-        int max = arr[0]; //假设第一数就是最大数
-        for(int i = 1; i < arr.length; i++) {
-            if (arr[i] > max) {
-                max = arr[i];
-            }
-        }
-        //得到最大数是几位数
-        int maxLength = (max + "").length();
-
-
-        //定义一个二维数组，表示10个桶, 每个桶就是一个一维数组
-        //说明
-        //1. 二维数组包含10个一维数组
-        //2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length
-        //3. 名明确，基数排序是使用空间换时间的经典算法
-        int[][] bucket = new int[10][arr.length];
-
-        //为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数
-        //可以这里理解
-        //比如：bucketElementCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数
-        int[] bucketElementCounts = new int[10];
-
-
-        //这里我们使用循环将代码处理
-
-        for(int i = 0 , n = 1; i < maxLength; i++, n *= 10) {
-            //(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..
-            for(int j = 0; j < arr.length; j++) {
-                //取出每个元素的对应位的值
-                int digitOfElement = arr[j] / n % 10;
-                //放入到对应的桶中
-                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
-                bucketElementCounts[digitOfElement]++;
-            }
-            //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)
-            int index = 0;
-            //遍历每一桶，并将桶中是数据，放入到原数组
-            for(int k = 0; k < bucketElementCounts.length; k++) {
-                //如果桶中，有数据，我们才放入到原数组
-                if(bucketElementCounts[k] != 0) {
-                    //循环该桶即第k个桶(即第k个一维数组), 放入
-                    for(int l = 0; l < bucketElementCounts[k]; l++) {
-                        //取出元素放入到arr
-                        arr[index++] = bucket[k][l];
-                    }
-                }
-                //第i+1轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！
-                bucketElementCounts[k] = 0;
-
-            }
-            //System.out.println("第"+(i+1)+"轮，对个位的排序处理 arr =" + Arrays.toString(arr));
-
-        }
-
-		/*
-
-		//第1轮(针对每个元素的个位进行排序处理)
-		for(int j = 0; j < arr.length; j++) {
-			//取出每个元素的个位的值
-			int digitOfElement = arr[j] / 1 % 10;
-			//放入到对应的桶中
-			bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
-			bucketElementCounts[digitOfElement]++;
-		}
-		//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)
-		int index = 0;
-		//遍历每一桶，并将桶中是数据，放入到原数组
-		for(int k = 0; k < bucketElementCounts.length; k++) {
-			//如果桶中，有数据，我们才放入到原数组
-			if(bucketElementCounts[k] != 0) {
-				//循环该桶即第k个桶(即第k个一维数组), 放入
-				for(int l = 0; l < bucketElementCounts[k]; l++) {
-					//取出元素放入到arr
-					arr[index++] = bucket[k][l];
-				}
-			}
-			//第l轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！
-			bucketElementCounts[k] = 0;
-
-		}
-		System.out.println("第1轮，对个位的排序处理 arr =" + Arrays.toString(arr));
-
-
-		//==========================================
-
-		//第2轮(针对每个元素的十位进行排序处理)
-		for (int j = 0; j < arr.length; j++) {
-			// 取出每个元素的十位的值
-			int digitOfElement = arr[j] / 10  % 10; //748 / 10 => 74 % 10 => 4
-			// 放入到对应的桶中
-			bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
-			bucketElementCounts[digitOfElement]++;
-		}
-		// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)
-		index = 0;
-		// 遍历每一桶，并将桶中是数据，放入到原数组
-		for (int k = 0; k < bucketElementCounts.length; k++) {
-			// 如果桶中，有数据，我们才放入到原数组
-			if (bucketElementCounts[k] != 0) {
-				// 循环该桶即第k个桶(即第k个一维数组), 放入
-				for (int l = 0; l < bucketElementCounts[k]; l++) {
-					// 取出元素放入到arr
-					arr[index++] = bucket[k][l];
-				}
-			}
-			//第2轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！
-			bucketElementCounts[k] = 0;
-		}
-		System.out.println("第2轮，对个位的排序处理 arr =" + Arrays.toString(arr));
-
-
-		//第3轮(针对每个元素的百位进行排序处理)
-		for (int j = 0; j < arr.length; j++) {
-			// 取出每个元素的百位的值
-			int digitOfElement = arr[j] / 100 % 10; // 748 / 100 => 7 % 10 = 7
-			// 放入到对应的桶中
-			bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
-			bucketElementCounts[digitOfElement]++;
-		}
-		// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)
-		index = 0;
-		// 遍历每一桶，并将桶中是数据，放入到原数组
-		for (int k = 0; k < bucketElementCounts.length; k++) {
-			// 如果桶中，有数据，我们才放入到原数组
-			if (bucketElementCounts[k] != 0) {
-				// 循环该桶即第k个桶(即第k个一维数组), 放入
-				for (int l = 0; l < bucketElementCounts[k]; l++) {
-					// 取出元素放入到arr
-					arr[index++] = bucket[k][l];
-				}
-			}
-			//第3轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！
-			bucketElementCounts[k] = 0;
-		}
-		System.out.println("第3轮，对个位的排序处理 arr =" + Arrays.toString(arr)); */
-
-    }
-}
Index: src/Gof/state/RaffleActivity.java
===================================================================
diff --git a/src/Gof/state/RaffleActivity.java b/src/Gof/state/RaffleActivity.java
deleted file mode 100644
--- a/src/Gof/state/RaffleActivity.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,78 +0,0 @@
-package Gof.state;
-
-public class RaffleActivity {
-
-    State state=null;//表示当前活动的状态
-    int count=0;//奖品数量
-
-    State noRaffleState=new NoRaffleState(this);
-    State canRaffleState=new CanRaffleState(this);
-    State dispenseState=new DispenseState(this);
-    State dispenseOutState=new DispenseOutState(this);
-
-    public RaffleActivity(int count) {
-        this.state=getNoRaffleState();
-        this.count = count;
-    }
-
-    //扣分
-    public void debuctMoney(){
-        state.deductMoney();
-    }
-    //抽奖
-    public void raffle()
-    {
-        if(state.raffle())
-            state.dispensePrize();
-    }
-
-    public State getState() {
-        return state;
-    }
-
-    public void setState(State state) {
-        this.state = state;
-    }
-
-    public int getCount() {
-        int curCount=count;
-        count--;
-        return curCount;
-    }
-
-    public void setCount(int count) {
-        this.count = count;
-    }
-
-    public State getNoRaffleState() {
-        return noRaffleState;
-    }
-
-    public void setNoRaffleState(State noRaffleState) {
-        this.noRaffleState = noRaffleState;
-    }
-
-    public State getCanRaffleState() {
-        return canRaffleState;
-    }
-
-    public void setCanRaffleState(State canRaffleState) {
-        this.canRaffleState = canRaffleState;
-    }
-
-    public State getDispenseState() {
-        return dispenseState;
-    }
-
-    public void setDispenseState(State dispenseState) {
-        this.dispenseState = dispenseState;
-    }
-
-    public State getDispenseOutState() {
-        return dispenseOutState;
-    }
-
-    public void setDispenseOutState(State dispenseOutState) {
-        this.dispenseOutState = dispenseOutState;
-    }
-}
Index: src/左神算法/基础班/第三课/RandomPool.java
===================================================================
diff --git a/src/左神算法/基础班/第三课/RandomPool.java b/src/左神算法/基础班/第三课/RandomPool.java
deleted file mode 100644
--- a/src/左神算法/基础班/第三课/RandomPool.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,66 +0,0 @@
-package 左神算法.基础班.第三课;
-
-import java.util.HashMap;
-
-public class RandomPool {
-
-    public static class Pool<K>{
-        private HashMap<K,Integer> keyIndexMap;
-        private HashMap<Integer,K> indexKeyMap;
-        private int size;
-
-        public Pool() {
-            this.keyIndexMap = new HashMap<>();
-            this.indexKeyMap = new HashMap<>();
-            this.size = 0;
-        }
-
-        public void insert(K key)
-        {
-            if(!this.keyIndexMap.containsKey(key))
-            {
-                this.keyIndexMap.put(key,size);
-                this.indexKeyMap.put(this.size++,key);
-            }
-        }
-
-        public K getRandom()
-        {
-            if(this.size==0)
-                return null;
-            int index=(int)(Math.random()*this.size);//0-size-1
-            return this.indexKeyMap.get(index);//真正的随机了
-
-        }
-
-
-        //!!!!!!!!!!!!!!!!!!!!!!!!!!
-        public void delete(K key)
-        {
-            if(!this.keyIndexMap.containsKey(key))
-                return;
-            int deleteIndex=keyIndexMap.get(key);
-            int lastIndex=--size;
-            K lastKey=indexKeyMap.get(lastIndex);
-            this.keyIndexMap.put(lastKey,deleteIndex);
-            this.indexKeyMap.put(deleteIndex,lastKey);
-            keyIndexMap.remove(key);
-            indexKeyMap.remove(lastIndex);
-
-        }
-
-    }
-    public static void main(String[] args) {
-        Pool<String> pool = new Pool<String>();
-        pool.insert("zuo");
-        pool.insert("cheng");
-        pool.insert("yun");
-        System.out.println(pool.getRandom());
-        System.out.println(pool.getRandom());
-        System.out.println(pool.getRandom());
-        System.out.println(pool.getRandom());
-        System.out.println(pool.getRandom());
-        System.out.println(pool.getRandom());
-
-    }
-}
Index: src/左神算法/高频面试题/十二十三/RandomPool.java
===================================================================
diff --git a/src/左神算法/高频面试题/十二十三/RandomPool.java b/src/左神算法/高频面试题/十二十三/RandomPool.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/十二十三/RandomPool.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,71 +0,0 @@
-package 左神算法.高频面试题.十二十三;
-
-import java.util.HashMap;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 设计RandomPool结构，设计一种结构，在该结构中有如下三个功能：
- * insert(key):将某个key加入到该结构，做到不重复
- * delete(key）：将原本在结构中的某个key移除
- * getRandom():等概率随机返回结构中的任何一个key.
- * 要求所有的操作的时间复杂度都是O（1）
- * @date 2020/2/6 17:27
- */
-public class RandomPool {
-
-    public static class Pool<K>{
-        public HashMap<K,Integer>keyIndexMap;
-        public HashMap<Integer,K>indexKeyMap;
-        public int size;
-
-        public Pool() {
-            this.keyIndexMap=new HashMap<>();
-            this.indexKeyMap=new HashMap<>();
-            this.size=0;
-        }
-
-        public void insert(K key){
-            if(!this.keyIndexMap.containsKey(key)){
-                this.keyIndexMap.put(key,this.size);
-                this.indexKeyMap.put(this.size,key);
-                size++;
-
-            }
-        }
-        public void delete(K key) {
-
-            if (this.keyIndexMap.containsKey(key)) {
-                int index = keyIndexMap.get(key);
-                int lastIndex = --this.size;
-                K lastKey = indexKeyMap.get(lastIndex);
-                keyIndexMap.put(lastKey, index);
-                indexKeyMap.put(index, lastKey);
-//              keyIndexMap.put(key, lastIndex);
-                keyIndexMap.remove(key);
-                indexKeyMap.remove(lastIndex);
-            }
-        }
-
-        public K getRandom(){
-            if(this.size==0)
-                return null;
-            int randomIndex=(int)(Math.random()*this.size);
-            return this.indexKeyMap.get(randomIndex);
-        }
-    }
-
-    public static void main(String[] args) {
-        Pool<String> pool = new Pool<String>();
-        pool.insert("zuo");
-        pool.insert("cheng");
-        pool.insert("yun");
-        System.out.println(pool.getRandom());
-        System.out.println(pool.getRandom());
-        System.out.println(pool.getRandom());
-        System.out.println(pool.getRandom());
-        System.out.println(pool.getRandom());
-        System.out.println(pool.getRandom());
-
-    }
-}
Index: src/重温设计模式/其他模式/Future模式/RealData.java
===================================================================
diff --git a/src/重温设计模式/其他模式/Future模式/RealData.java b/src/重温设计模式/其他模式/Future模式/RealData.java
deleted file mode 100644
--- a/src/重温设计模式/其他模式/Future模式/RealData.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,22 +0,0 @@
-package 重温设计模式.其他模式.Future模式;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/19 13:11
- */
-public class RealData implements Data {
-
-    protected final String result;
-    public RealData(String para) {
-        StringBuffer sb=new StringBuffer();
-        //假设这里很慢很慢，构造RealData不是一个容易的事
-        result =sb.toString();
-    }
-
-    @Override
-    public String getResult() {
-        return result;
-    }
-}
Index: src/org/sd/dyanmicProxy/RealStar.java
===================================================================
diff --git a/src/org/sd/dyanmicProxy/RealStar.java b/src/org/sd/dyanmicProxy/RealStar.java
deleted file mode 100644
--- a/src/org/sd/dyanmicProxy/RealStar.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,48 +0,0 @@
-package org.sd.dyanmicProxy;
-
-public class RealStar implements Star {
-
-    /**
-     * 面谈
-     */
-    @Override
-    public void confer() {
-        System.out.println("RealStar.confer()");
-    }
-
-    /**
-     * 签合同
-     */
-    @Override
-    public void signContract() {
-        System.out.println("RealStar.signContract()");
-
-    }
-
-    /**
-     * 订票
-     */
-    @Override
-    public void bookTicket() {
-        System.out.println("RealStar.bookTicket()");
-
-    }
-
-    /**
-     * 唱歌
-     */
-    @Override
-    public void sing() {
-        System.out.println("RealStar(周杰伦本人).sing()");
-
-    }
-
-    /**
-     * 收钱
-     */
-    @Override
-    public void collectMoney() {
-        System.out.println("RealStar.collectMoney()");
-
-    }
-}
Index: src/org/sd/StaticProxy/RealStar.java
===================================================================
diff --git a/src/org/sd/StaticProxy/RealStar.java b/src/org/sd/StaticProxy/RealStar.java
deleted file mode 100644
--- a/src/org/sd/StaticProxy/RealStar.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,50 +0,0 @@
-package org.sd.StaticProxy;
-
-import org.sd.dyanmicProxy.Star;
-
-public class RealStar implements Star {
-
-    /**
-     * 面谈
-     */
-    @Override
-    public void confer() {
-        System.out.println("RealStar.confer()");
-    }
-
-    /**
-     * 签合同
-     */
-    @Override
-    public void signContract() {
-        System.out.println("RealStar.signContract()");
-
-    }
-
-    /**
-     * 订票
-     */
-    @Override
-    public void bookTicket() {
-        System.out.println("RealStar.bookTicket()");
-
-    }
-
-    /**
-     * 唱歌
-     */
-    @Override
-    public void sing() {
-        System.out.println("RealStar(周杰伦本人).sing()");
-
-    }
-
-    /**
-     * 收钱
-     */
-    @Override
-    public void collectMoney() {
-        System.out.println("RealStar.collectMoney()");
-
-    }
-}
Index: src/左神算法/高频面试题/十二十三/ReceiveAndPrintOrderLine.java
===================================================================
diff --git a/src/左神算法/高频面试题/十二十三/ReceiveAndPrintOrderLine.java b/src/左神算法/高频面试题/十二十三/ReceiveAndPrintOrderLine.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/十二十三/ReceiveAndPrintOrderLine.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,97 +0,0 @@
-package 左神算法.高频面试题.十二十三;
-
-import java.util.HashMap;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 一种消息接收并打印的结构设计。
- * 已知一个消息流会不断的吐出整数1~N，但不一定按顺序吐出。如果上次打印的数为i,那么当i+1出现时，请打印i+1及
- * 其之后接受过的并且连续的所有数，知道1~N全部接受并打印完毕，请设计这种接受并打印的结构。
- *
- * @date 2020/2/6 18:11
- */
-public class ReceiveAndPrintOrderLine {
-
-     public static class Node{
-         public int num;
-         public Node next;
-
-         public Node(int num){
-             this.num=num;
-         }
-     }
-
-     public static class MessageBox{
-
-         public HashMap<Integer,Node> headMap;
-         public HashMap<Integer,Node> tailMap;
-         public int lastPrint;
-
-         public MessageBox() {
-             this.lastPrint =0;
-             headMap=new HashMap<>();
-             tailMap=new HashMap<>();
-         }
-
-         public  void receive(int num){
-             if(num<1)
-                 return;
-             Node cur=new Node(num);
-             headMap.put(num,cur);
-             tailMap.put(num,cur);
-             if(headMap.containsKey(num+1))
-             {
-                 cur.next=headMap.get(num+1);
-                 headMap.remove(num+1);
-                 tailMap.remove(num);
-             }
-             if(tailMap.containsKey(num-1))
-             {
-                 tailMap.get(num-1).next=cur;
-                 tailMap.remove(num-1);
-                 headMap.remove(num);
-             }
-             if(headMap.containsKey(lastPrint+1))
-                 print();
-         }
-
-         public void print(){
-             Node cur=headMap.get(++lastPrint);
-             headMap.remove(lastPrint);
-             while(cur!=null){
-                 System.out.print(cur.num+" ");
-                 cur=cur.next;
-                 lastPrint++;
-             }
-             tailMap.remove(--lastPrint);
-             System.out.println();
-
-         }
-     }
-
-    public static void main(String[] args) {
-        // MessageBox only receive 1~N
-        MessageBox box = new MessageBox();
-
-        box.receive(2); // - 2
-        box.receive(1); // 1 2 -> print, trigger is 1
-
-        box.receive(4); // - 4
-        box.receive(5); // - 4 5
-        box.receive(7); // - 4 5 - 7
-        box.receive(8); // - 4 5 - 7 8
-        box.receive(6); // - 4 5 6 7 8
-        box.receive(3); // 3 4 5 6 7 8 -> print, trigger is 3
-
-        box.receive(9); // 9 -> print, trigger is 9
-
-        box.receive(10); // 10 -> print, trigger is 10
-
-        box.receive(12); // - 12
-        box.receive(13); // - 12 13
-        box.receive(11); // 11 12 13 -> print, trigger is 11
-
-    }
-
-}
Index: src/Gof/template/RedBeanSoyaMilk.java
===================================================================
diff --git a/src/Gof/template/RedBeanSoyaMilk.java b/src/Gof/template/RedBeanSoyaMilk.java
deleted file mode 100644
--- a/src/Gof/template/RedBeanSoyaMilk.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package Gof.template;
-
-public class RedBeanSoyaMilk extends SoyaMilk {
-    @Override
-    void addCondiments() {
-        System.out.println("加入红豆配料。。。");
-    }
-}
Index: src/JUC/ReadWriteDemo/ReentrantReadWriteDemo.java
===================================================================
diff --git a/src/JUC/ReadWriteDemo/ReentrantReadWriteDemo.java b/src/JUC/ReadWriteDemo/ReentrantReadWriteDemo.java
deleted file mode 100644
--- a/src/JUC/ReadWriteDemo/ReentrantReadWriteDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,64 +0,0 @@
-package JUC.ReadWriteDemo;
-
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.locks.ReentrantReadWriteLock;
-
-//模仿内存的一个类
-class MyCache{
-
-    private volatile Map<String,Object> map=new HashMap<>();//在缓存中的变量一般都用volatile修饰
-    private ReentrantReadWriteLock reentrantReadWriteLock=new ReentrantReadWriteLock();
-    //写
-    public void put(String key,Object value)
-    {
-        reentrantReadWriteLock.writeLock().lock();
-        try{
-            System.out.println(Thread.currentThread().getName()+"\t正在写入。。"+key);
-            //模拟网路的延时
-            try{ TimeUnit.MICROSECONDS.sleep(300);}catch (Exception e){e.printStackTrace();}
-            map.put(key,value);
-            System.out.println(Thread.currentThread().getName()+"\t写入完成");
-
-
-        }finally {
-            reentrantReadWriteLock.writeLock().unlock();
-        }
-
-    }
-    //读
-    public void get(String key)
-    {
-        reentrantReadWriteLock.readLock().lock();
-        try{
-            System.out.println(Thread.currentThread().getName()+"\t 正在读取");
-            try{TimeUnit.MICROSECONDS.sleep(300);}catch (Exception e){e.printStackTrace();}
-           Object result= map.get(key);
-            System.out.println(Thread.currentThread().getName()+"\t读取完成了。。"+result);
-
-        }finally {
-            reentrantReadWriteLock.readLock().unlock();
-        }
-    }
-}
-public class ReentrantReadWriteDemo {
-
-    public static void main(String[] args) {
-      MyCache myCache=new MyCache();
-      for(int i=1;i<6;i++)
-      {   final int temp=i;
-          new Thread(()->{
-              myCache.put(temp+"",temp);
-          },String.valueOf(i)).start();
-      }
-
-        for(int i=1;i<6;i++)
-        {   final int temp=i;
-            new Thread(()->{
-                myCache.get(temp+"");
-            },String.valueOf(i)).start();
-        }
-    }
-}
Index: src/左神算法/进阶班一/进阶八/RegularExpressionMatch.java
===================================================================
diff --git a/src/左神算法/进阶班一/进阶八/RegularExpressionMatch.java b/src/左神算法/进阶班一/进阶八/RegularExpressionMatch.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/进阶八/RegularExpressionMatch.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,115 +0,0 @@
-package 左神算法.进阶班一.进阶八;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:字符串匹配问题：
- * 给定字符串str,其中不含'.'和'*'.再给定字符串exp,其中可以含有'.'和'*'，*字符不能是exp的首字符，并且任意两个*不能相邻
- * exp中的.代表人一个字符，*代表*前面的一个字符可以有0个或者多个。写一个函数，判断str能否用exp匹配
- * @date 2020/1/28 18:22
- */
-public class RegularExpressionMatch {
-
-    public static boolean isValid(char[] s, char[] e) {
-        for (int i = 0; i < s.length; i++) {
-            if (s[i] == '*' || s[i] == '.') {
-                return false;
-            }
-        }
-        for (int i = 0; i < e.length; i++) {
-            if (e[i] == '*' && (i == 0 || e[i - 1] == '*')) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    public static boolean isMatch(String str, String exp) {
-        if (str == null || exp == null) {
-            return false;
-        }
-        char[] s = str.toCharArray();
-        char[] e = exp.toCharArray();
-        return isValid(s, e) ? process(s, e, 0, 0) : false;
-    }
-    //str[i...一直到最后]这个字符串，能不能被exp[j..一直到最后]的字符串匹配出来
-    public static boolean process(char[] s, char[] e, int si, int ei) {
-        if (ei == e.length) {
-            return si == s.length;
-        }
-        //ei位置上还有字符，考察ei+1的情况
-        if (ei + 1 == e.length || e[ei + 1] != '*') {
-            return si != s.length && (e[ei] == s[si] || e[ei] == '.')
-                    && process(s, e, si + 1, ei + 1);
-        }
-        //exp的ei+1位置不仅有字符，并且字符是*
-        while (si != s.length && (e[ei] == s[si] || e[ei] == '.')) {
-            if (process(s, e, si, ei + 2)) {
-                return true;
-            }
-            si++;
-        }
-        return process(s, e, si, ei + 2);
-    }
-
-    public static boolean isMatchDP(String str, String exp) {
-        if (str == null || exp == null) {
-            return false;
-        }
-        char[] s = str.toCharArray();
-        char[] e = exp.toCharArray();
-        if (!isValid(s, e)) {
-            return false;
-        }
-        boolean[][] dp = initDPMap(s, e);
-        for (int i = s.length - 1; i > -1; i--) {
-            for (int j = e.length - 2; j > -1; j--) {
-                if (e[j + 1] != '*') {
-                    dp[i][j] = (s[i] == e[j] || e[j] == '.')
-                            && dp[i + 1][j + 1];
-                } else {
-                    int si = i;
-                    while (si != s.length && (s[si] == e[j] || e[j] == '.')) {
-                        if (dp[si][j + 2]) {
-                            dp[i][j] = true;
-                            break;
-                        }
-                        si++;
-                    }
-                    if (dp[i][j] != true) {
-                        dp[i][j] = dp[si][j + 2];
-                    }
-                }
-            }
-        }
-        return dp[0][0];
-    }
-    //单独填好最后一排和最后两列
-    public static boolean[][] initDPMap(char[] s, char[] e) {
-        int slen = s.length;
-        int elen = e.length;
-        boolean[][] dp = new boolean[slen + 1][elen + 1];
-        dp[slen][elen] = true;
-        for (int j = elen - 2; j > -1; j = j - 2) {
-            if (e[j] != '*' && e[j + 1] == '*') {
-                dp[slen][j] = true;
-            } else {
-                break;
-            }
-        }
-        if (slen > 0 && elen > 0) {
-            if ((e[elen - 1] == '.' || s[slen - 1] == e[elen - 1])) {
-                dp[slen - 1][elen - 1] = true;
-            }
-        }
-        return dp;
-    }
-
-    public static void main(String[] args) {
-        String str = "abcccdefg";
-        String exp = "ab.*d.*e.*";
-        System.out.println(isMatch(str, exp));
-        System.out.println(isMatchDP(str, exp));
-
-    }
-}
Index: src/Gof/command/RemoteController.java
===================================================================
diff --git a/src/Gof/command/RemoteController.java b/src/Gof/command/RemoteController.java
deleted file mode 100644
--- a/src/Gof/command/RemoteController.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,46 +0,0 @@
-package Gof.command;
-
-public class RemoteController {
-
-    Command[] onCommands;
-    Command[] offCommands;
-
-    //执行撤销的命令
-    Command undoCommand;
-
-    //n:指定了一共有几个命令按钮
-    public RemoteController(int n)
-    {
-        onCommands=new Command[n];
-        offCommands=new Command[n];
-        for(int i=0;i<n;i++)
-        {
-            onCommands[i]=new NoCommand();
-            offCommands[i]=new NoCommand();
-        }
-    }
-
-    //给我们的命令按钮设置我们的命令
-    public void setCommand(int no,Command OnCommand, Command OffCommand){
-        onCommands[no]=OnCommand;
-        offCommands[no]=OffCommand;
-    }
-
-    public void onButtonWasPush(int no)
-    {
-        onCommands[no].execute();
-        //记录按下的按钮，用于撤销
-        undoCommand=onCommands[no];
-    }
-
-    public void offButtonWasPush(int no){
-        offCommands[no].execute();
-        undoCommand=offCommands[no];
-    }
-
-    //执行撤销命名
-    public void undoButtonWasPush()
-    {
-        undoCommand.undo();
-    }
-}
Index: src/左神算法/基础班/第三课/ReverseList.java
===================================================================
diff --git a/src/左神算法/基础班/第三课/ReverseList.java b/src/左神算法/基础班/第三课/ReverseList.java
deleted file mode 100644
--- a/src/左神算法/基础班/第三课/ReverseList.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,99 +0,0 @@
-package 左神算法.基础班.第三课;
-
-public class ReverseList {
-
-    public static class Node {
-        public int value;
-        public Node next;
-
-        public Node(int data) {
-            this.value = data;
-        }
-    }
-
-    public static Node reverseList(Node head)
-    {
-        Node pre=null;
-        Node next=null;
-        while(head!=null)
-        {
-            next=head.next;
-            head.next=pre;
-            pre=head;
-            head=next;
-        }
-        return pre;
-
-    }
-
-
-    public static class DoubleNode {
-        public int value;
-        public DoubleNode last;
-        public DoubleNode next;
-
-        public DoubleNode(int data) {
-            this.value = data;
-        }
-    }
-
-    public static DoubleNode reverseList(DoubleNode head)
-    {
-        DoubleNode pre=null;
-        DoubleNode next=null;
-        while(head!=null)
-        {
-            next=head.next;
-            head.next=pre;
-            head.last=next;
-            pre=head;
-            head=next;
-        }
-        return pre;
-    }
-    public static void printLinkedList(Node head) {
-        System.out.print("Linked List: ");
-        while (head != null) {
-            System.out.print(head.value + " ");
-            head = head.next;
-        }
-        System.out.println();
-    }
-
-    public static void printDoubleLinkedList(DoubleNode head) {
-        System.out.print("Double Linked List: ");
-        DoubleNode end = null;
-        while (head != null) {
-            System.out.print(head.value + " ");
-            end = head;
-            head = head.next;
-        }
-        System.out.print("| ");
-        while (end != null) {
-            System.out.print(end.value + " ");
-            end = end.last;
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-        Node head1 = new Node(1);
-        head1.next = new Node(2);
-        head1.next.next = new Node(3);
-        printLinkedList(head1);
-        head1 = reverseList(head1);
-        printLinkedList(head1);
-
-        DoubleNode head2 = new DoubleNode(1);
-        head2.next = new DoubleNode(2);
-        head2.next.last = head2;
-        head2.next.next = new DoubleNode(3);
-        head2.next.next.last = head2.next;
-        head2.next.next.next = new DoubleNode(4);
-        head2.next.next.next.last = head2.next.next;
-        printDoubleLinkedList(head2);
-        printDoubleLinkedList(reverseList(head2));
-
-    }
-
-}
Index: src/左神算法/高频面试题/ReverseStackUsingRecursive.java
===================================================================
diff --git a/src/左神算法/高频面试题/ReverseStackUsingRecursive.java b/src/左神算法/高频面试题/ReverseStackUsingRecursive.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/ReverseStackUsingRecursive.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,39 +0,0 @@
-package 左神算法.高频面试题;
-
-import java.util.Stack;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 一个栈依次压入1,2,3,4,5，那么从栈顶到栈底分别为5,4,3,2,1.实现栈中元素的逆序，从栈顶到栈底为1,2,3,4,5，但是只能用递归函数实现，不能用其他数据结构
- * @date 2019/12/28 10:14
- */
-public class ReverseStackUsingRecursive {
-
-
-    //实现stack的逆序
-    public static void reverse(Stack<Integer> stack){
-
-        if(stack.isEmpty())
-        {
-            return;
-        }
-        int value=getAndRemoveLastElement(stack);
-        reverse(stack);
-        stack.push(value);
-    }
-
-    //获取栈中最后一个元素
-    public static int getAndRemoveLastElement(Stack<Integer>stack)
-    {
-        int num=stack.pop();
-        if(stack.isEmpty())
-        {
-            return num;
-        }else{
-            int last=getAndRemoveLastElement(stack);
-            stack.push(num);
-            return last;
-        }
-    }
-}
Index: src/左神算法/高频面试题/七_头条题/RightConner.java
===================================================================
diff --git a/src/左神算法/高频面试题/七_头条题/RightConner.java b/src/左神算法/高频面试题/七_头条题/RightConner.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/七_头条题/RightConner.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,147 +0,0 @@
-package 左神算法.高频面试题.七_头条题;
-
-import java.util.Arrays;
-import java.util.Comparator;
-import java.util.LinkedList;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:  p为给定的二维平面整数点集。定义p中某点x,如果x满足p中任意点都不在x的右上方区域内（横纵坐标都大于x）,则称其为最大的。求出所有最大点的集合。（所有点的横纵坐标都不重复）
- * @date 2020/1/12 13:34
- */
-public class RightConner {
-
-    //用一个类来封装x,y坐标
-    public static class Node{
-        public int x;
-        public int y;
-
-        public Node(int x, int y) {
-            this.x = x;
-            this.y = y;
-        }
-    }
-    //横纵坐标都不重复的情况
-    public static class MyComparator1 implements Comparator<Node>{
-
-        @Override
-        public int compare(Node o1, Node o2) {
-            return o1.x-o2.x;
-        }
-    }
-    //存在纵坐标相同的情况下，在横坐标相同的情况下，纵坐标按照从大到小排
-    public static class MyComparator2 implements Comparator<Node>{
-
-        @Override
-        public int compare(Node o1, Node o2) {
-            if(o1.x!=o2.x){
-                return o1.x-o2.x;
-            }else{
-                return o2.y-o1.y;
-            }
-
-        }
-    }
-    //在横坐标存在相同元素的情况下，只需要将比较器换成MyCompartor2
-    public static LinkedList<Node> getRightCornerNodes1(int[] x,int[] y){
-        int len=x.length;
-        Node[] nodes=new Node[len];
-        for(int i=0;i<len;i++){
-            nodes[i]=new Node(x[i],y[i]);
-        }
-        Arrays.sort(nodes,new MyComparator2());
-        LinkedList<Node>res=new LinkedList<>();
-        res.add(nodes[len-1]);
-        int temp=nodes[len-1].y;
-        for(int i=len-2;i>-1;i--){
-            if(nodes[i].y>=temp){
-                //temp=nodes[i].y;
-                res.addFirst(nodes[i]);
-            }
-            temp=Math.max(temp,nodes[i].y);
-        }
-
-        return res;
-    }
-    //暴力解
-    public static LinkedList<Node> getRightCornerNodes2(int[] x, int[] y) {
-        int size = x.length;
-        LinkedList<Node> res = new LinkedList<Node>();
-        Node[] nodes = new Node[size];
-        for (int i = 0; i < size; i++) {
-            nodes[i] = new Node(x[i], y[i]);
-        }
-        Arrays.sort(nodes, new MyComparator2());
-        for (int i = 0; i < size; i++) {
-            boolean insert = true;
-            for (int j = 0; j < size; j++) {
-                if ((nodes[i].x < nodes[j].x) && (nodes[i].y < nodes[j].y)) {
-                    insert = false;
-                }
-            }
-            if (insert) {
-                res.add(nodes[i]);
-            }
-        }
-        return res;
-    }
-
-
-
-
-    public static int[] generateRandomArray(int size) {
-        int[] arr = new int[size];
-        for (int i = 0; i < size; i++) {
-            arr[i] = (int) (Math.random() * 1000);
-        }
-        return arr;
-    }
-
-    public static boolean isEqual(LinkedList<Node> list1, LinkedList<Node> list2) {
-        if (list1.size() != list2.size()) {
-            return false;
-        }
-        while (!list1.isEmpty()) {
-            Node node1 = list1.pollFirst();
-            Node node2 = list2.pollFirst();
-            if (node1.x != node2.x || node1.y != node2.y) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    public static void printArray(int[] x, int[] y) {
-        for (int i = 0; i < x.length; i++) {
-            System.out.print("(" + x[i] + "," + y[i] + ") ");
-        }
-        System.out.println();
-    }
-
-    public static void printLinkedList(LinkedList<Node> list) {
-        for (Node node : list) {
-            System.out.print("(" + node.x + "," + node.y + ") ");
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-        int testTime = 3000000;
-        for (int i = 0; i < testTime; i++) {
-            int size = 3;
-            int[] x = generateRandomArray(size);
-            int[] y = generateRandomArray(size);
-            LinkedList<Node> res1 = getRightCornerNodes1(x, y);
-            LinkedList<Node> res2 = getRightCornerNodes2(x, y);
-            if (!isEqual(res1, res2)) {
-                printArray(x, y);
-                printLinkedList(res1);
-                printLinkedList(res2);
-                break;
-            }
-        }
-    }
-
-
-}
Index: src/Leetcode/RobII.java
===================================================================
diff --git a/src/Leetcode/RobII.java b/src/Leetcode/RobII.java
deleted file mode 100644
--- a/src/Leetcode/RobII.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,51 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
-
-给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
-
-示例 1:
-
-输入: [2,3,2]
-输出: 3
-解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
-
-示例 2:
-
-输入: [1,2,3,1]
-输出: 4
-解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
-偷窃到的最高金额 = 1 + 3 = 4 。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/house-robber-ii
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/4/4 21:16
- */
-public class RobII {
-    public int rob(int[] nums) {
-        if (nums == null || nums.length == 0)
-            return 0;
-        if (nums.length == 1)
-            return nums[0];
-        if (nums.length == 2)
-            return Math.max(nums[0], nums[1]);
-        return Math.max(process(nums, 0, nums.length - 2), process(nums, 1, nums.length - 1));
-    }
-
-    public int process(int[] nums, int start, int end) {
-        int pre1 = 0;
-        int pre2 = 0;
-        int cur = 0;
-        for (int i = start; i <= end; i++) {
-            cur = Math.max(pre1, pre2 + nums[i]);
-            pre2 = pre1;
-            pre1 = cur;
-        }
-        return cur;
-    }
-
-}
Index: src/重温设计模式/行为模式/责任链模式/示例/RoleCheckMiddleware.java
===================================================================
diff --git a/src/重温设计模式/行为模式/责任链模式/示例/RoleCheckMiddleware.java b/src/重温设计模式/行为模式/责任链模式/示例/RoleCheckMiddleware.java
deleted file mode 100644
--- a/src/重温设计模式/行为模式/责任链模式/示例/RoleCheckMiddleware.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,21 +0,0 @@
-package 重温设计模式.行为模式.责任链模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/14 21:42
- */
-public class RoleCheckMiddleware extends Middleware {
-
-    @Override
-    public boolean check(String email, String password) {
-        if (email.equals("admin@example.com")) {
-            System.out.println("Hello, admin!");
-            return true;
-        }
-        System.out.println("Hello, user!");
-        return checkNext(email, password);
-
-    }
-}
Index: src/重温设计模式/结构型设计模式/适配器模式/示例/RoundHole.java
===================================================================
diff --git a/src/重温设计模式/结构型设计模式/适配器模式/示例/RoundHole.java b/src/重温设计模式/结构型设计模式/适配器模式/示例/RoundHole.java
deleted file mode 100644
--- a/src/重温设计模式/结构型设计模式/适配器模式/示例/RoundHole.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,26 +0,0 @@
-package 重温设计模式.结构型设计模式.适配器模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/4/29 19:36
- */
-public class RoundHole {
-
-    private double radius;
-
-    public RoundHole(double radius){
-        this.radius = radius;
-    }
-
-    public double getRadius(){
-        return radius;
-    }
-
-    public boolean fits(RoundPeg peg){
-        return this.getRadius() >= peg.getRadius();
-    }
-
-
-}
Index: src/重温设计模式/结构型设计模式/适配器模式/示例/RoundPeg.java
===================================================================
diff --git a/src/重温设计模式/结构型设计模式/适配器模式/示例/RoundPeg.java b/src/重温设计模式/结构型设计模式/适配器模式/示例/RoundPeg.java
deleted file mode 100644
--- a/src/重温设计模式/结构型设计模式/适配器模式/示例/RoundPeg.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,25 +0,0 @@
-package 重温设计模式.结构型设计模式.适配器模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/4/29 19:38
- */
-public class RoundPeg {
-
-    private double radius;
-
-    public RoundPeg(){
-
-    }
-
-    public RoundPeg(double radius){
-
-        this.radius = radius;
-    }
-
-    public double getRadius() {
-        return radius;
-    }
-}
Index: src/左神算法/高频面试题/七_头条题/RussianDollEnvelopes.java
===================================================================
diff --git a/src/左神算法/高频面试题/七_头条题/RussianDollEnvelopes.java b/src/左神算法/高频面试题/七_头条题/RussianDollEnvelopes.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/七_头条题/RussianDollEnvelopes.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,77 +0,0 @@
-package 左神算法.高频面试题.七_头条题;
-
-import java.util.Arrays;
-import java.util.Comparator;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: You have a number of envelopes with widths and heights given as a pair of integers(w,h).One envelope can fit into another if and
- * only if both the width and height of one envelops is greater than the width and height of the other envelop.What is the maximum number of
- * envelopes can you Russian doll?(put one inside other)
- * @date 2020/1/16 11:30
- */
-public class RussianDollEnvelopes {
-
-    public  static class Node{
-        public int width;
-        public int height;
-
-        public Node(int width, int height) {
-            this.width = width;
-            this.height = height;
-        }
-    }
-     //排序后求最长递增子序列的长度，即是答案
-    public static class DotComparator implements Comparator<Node>{
-
-        @Override
-        public int compare(Node o1, Node o2) {
-            if(o1.width!=o2.width){
-                return o1.width-o2.width;
-            }else {
-                return o2.height-o1.height;
-            }
-        }
-    }
-    public static int maxEnvelopes(int[][]es){
-        if(es==null || es.length==0 || es[0]==null || es[0].length==0){
-            return 0;
-        }
-        Node[] dots=new Node[es.length];
-        for(int i=0;i<es.length;i++)
-        {
-            dots[i]=new Node(es[i][0],es[i][1]);
-        }
-
-        Arrays.sort(dots,new DotComparator());
-        int[] ends=new int[dots.length];//最小结尾子数组
-        ends[0]=dots[0].height;
-        int right=0;
-        int l=0;
-        int r=0;
-        int m=0;
-        for(int i=1;i<es.length;i++){
-            l=0;
-            r=right;
-            //找到第一个大于等于dots[i]的值
-            while(l<=r){
-                m=(l+r)/2;
-                if(dots[i].height>ends[m]){
-                    l=m+1;
-                }else{
-                    r=m-1;
-                }
-            }
-            right=Math.max(right,l);
-            ends[l]=dots[i].height;
-        }
-        return right+1;
-
-    }
-
-    public static void main(String[] args) {
-        int[][] test = { { 4, 3 }, { 1, 2 }, { 5, 7 }, { 5, 3 }, { 1, 1 }, { 4, 9 } };
-        System.out.println(maxEnvelopes(test));
-    }
-}
Index: src/org/sd/exercise/SaleTicketDemo.java
===================================================================
diff --git a/src/org/sd/exercise/SaleTicketDemo.java b/src/org/sd/exercise/SaleTicketDemo.java
deleted file mode 100644
--- a/src/org/sd/exercise/SaleTicketDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,38 +0,0 @@
-package org.sd.exercise;
-
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-
-class Ticket{
-
-    private int nums=30;
-
-    Lock lock=new ReentrantLock();
-    public void sale()
-    {
-        lock.lock();
-        try{
-            if(nums>0){
-                System.out.println(Thread.currentThread().getName()+"\t卖出第"+(nums--)+"\t 还剩下："+nums);
-            }
-        }finally {
-            lock.unlock();
-        }
-    }
-}
-
-public class SaleTicketDemo {
-    public static void main(String[] args) {
-
-        Ticket ticket=new Ticket();
-
-        new Thread(()->{for(int i=0;i<40;i++) ticket.sale();},"A").start();
-        new Thread(()->{for(int i=0;i<40;i++) ticket.sale();},"B").start();
-        new Thread(()->{for(int i=0;i<40;i++) ticket.sale();},"C").start();
-
-
-
-
-
-    }
-}
Index: src/Gof/responsibilityChain/SchoolMasterApprover.java
===================================================================
diff --git a/src/Gof/responsibilityChain/SchoolMasterApprover.java b/src/Gof/responsibilityChain/SchoolMasterApprover.java
deleted file mode 100644
--- a/src/Gof/responsibilityChain/SchoolMasterApprover.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,19 +0,0 @@
-package Gof.responsibilityChain;
-
-public class SchoolMasterApprover extends Approver{
-
-    public SchoolMasterApprover(String name) {
-        // TODO Auto-generated constructor stub
-        super(name);
-    }
-
-    @Override
-    public void processRequest(PurchaseRequest purchaseRequest) {
-        // TODO Auto-generated method stub
-        if(purchaseRequest.getPrice() > 30000) {
-            System.out.println(" 请求编号 id= " + purchaseRequest.getId() + " 被 " + this.name + " 处理");
-        }else {
-            approver.processRequest(purchaseRequest);
-        }
-    }
-}
Index: src/Gof/facade/Screen.java
===================================================================
diff --git a/src/Gof/facade/Screen.java b/src/Gof/facade/Screen.java
deleted file mode 100644
--- a/src/Gof/facade/Screen.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,23 +0,0 @@
-package Gof.facade;
-
-public class Screen {
-    private static final Screen instance=new Screen();
-    private Screen(){};
-    public static Screen getInstance()
-    {
-        return instance;
-    }
-
-    public void up()
-    {
-        System.out.println("screen up");
-    }
-
-    public void down()
-    {
-        System.out.println("screen down");
-    }
-
-
-
-}
Index: src/左神算法/高频面试题/七_头条题/SDEandPM.java
===================================================================
diff --git a/src/左神算法/高频面试题/七_头条题/SDEandPM.java b/src/左神算法/高频面试题/七_头条题/SDEandPM.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/七_头条题/SDEandPM.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,211 +0,0 @@
-package 左神算法.高频面试题.七_头条题;
-
-import java.util.ArrayList;
-import java.util.Comparator;
-import java.util.List;
-import java.util.PriorityQueue;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 产品经理有很多好的idea,而这些idea需要程序员实现。现有N个产品经理PM,在某个时间点会想出一个idea,每个idea有提出时间，所需时间和优先级。……
- * 视频：p12最后一个题
- * @date 2020/1/13 10:23
- */
-public class SDEandPM {
-
-
-    public static class Program {
-        public int index;
-        public int pm;
-        public int start;
-        public int rank;
-        public int cost;
-
-        public Program(int index, int pmNum, int begin, int rank, int cost) {
-            this.index = index;
-            this.pm = pmNum;
-            this.start = begin;
-            this.rank = rank;
-            this.cost = cost;
-        }
-    }
-
-    public static class PmLoveRule implements Comparator<Program> {
-
-        @Override
-        public int compare(Program o1, Program o2) {
-            if (o1.rank != o2.rank) {
-                return o1.rank - o2.rank;
-            } else if (o1.cost != o2.cost) {
-                return o1.cost - o2.cost;
-            } else {
-                return o1.start - o2.start;
-            }
-        }
-
-    }
-
-    public static class BigQueues {
-        private List<PriorityQueue<Program>> pmQueues; //有多少个pm就有多少个priorityqueue
-        private Program[] heap;//每个priorityqueue的堆顶组成的堆
-        private int[] indexes;
-        private int heapsize;
-
-        public BigQueues(int size) {
-            this.heapsize = 0;
-            heap = new Program[size];
-            indexes = new int[size + 1];
-            for (int i = 0; i <= size; i++) {
-                indexes[i] = -1;
-            }
-            pmQueues = new ArrayList<>();
-            for (int i = 0; i <= size; i++) {
-                pmQueues.add(new PriorityQueue<Program>(new PmLoveRule()));//没有0号pm,从1号开始，多加一个，0号不用。
-            }
-        }
-
-        public boolean isEmpty() {
-            return heapsize == 0;
-        }
-
-        public void add(Program program) {
-            PriorityQueue<Program> queue = pmQueues.get(program.pm);
-            queue.add(program);
-            Program head = queue.peek();
-            int heapindex = indexes[head.pm];
-            if (heapindex == -1) {
-                heap[heapsize] = head;
-                indexes[head.pm] = heapsize;
-                heapInsert(heapsize++);
-            } else {
-                heap[heapindex] = head;
-                heapInsert(heapindex);
-            }
-        }
-
-        public Program pop() {
-            Program head = heap[0];
-            PriorityQueue<Program> queue = pmQueues.get(head.pm);
-            queue.poll();
-            if (queue.isEmpty()) {
-                swap(0, heapsize - 1);
-                heap[--heapsize] = null;
-                indexes[head.pm] = -1;
-            } else {
-                heap[0] = queue.peek();
-            }
-            heapify(0);
-            return head;
-        }
-
-        private void heapInsert(int index) {
-            while (index != 0) {
-                int parent = (index - 1) / 2;
-                if (sdeLoveRule(heap[parent], heap[index]) > 0) {
-                    swap(parent, index);
-                    index = parent;
-                } else {
-                    break;
-                }
-            }
-        }
-
-        private void heapify(int index) {
-            int left = index * 2 + 1;
-            int right = index * 2 + 2;
-            int best = index;
-            while (left < heapsize) {
-                if (sdeLoveRule(heap[left], heap[index]) < 0) {
-                    best = left;
-                }
-                if (right < heapsize && sdeLoveRule(heap[right], heap[best]) < 0) {
-                    best = right;
-                }
-                if (best == index) {
-                    break;
-                }
-                swap(best, index);
-                index = best;
-                left = index * 2 + 1;
-                right = index * 2 + 2;
-            }
-        }
-
-        private void swap(int index1, int index2) {
-            Program p1 = heap[index1];
-            Program p2 = heap[index2];
-            heap[index1] = p2;
-            heap[index2] = p1;
-            indexes[p1.pm] = index2;
-            indexes[p2.pm] = index1;
-        }
-
-        private int sdeLoveRule(Program p1, Program p2) {
-            if (p1.cost != p2.cost) {
-                return p1.cost - p2.cost;
-            } else {
-                return p1.pm - p2.pm;
-            }
-        }
-
-    }
-
-    public static class StartRule implements Comparator<Program> {
-
-        @Override
-        public int compare(Program o1, Program o2) {
-            return o1.start - o2.start;
-        }
-
-    }
-
-    public static int[] workFinish(int pms, int sdes, int[][] programs) {
-        PriorityQueue<Program> programsQueue = new PriorityQueue<Program>(new StartRule());
-        for (int i = 0; i < programs.length; i++) {
-            Program program = new Program(i, programs[i][0], programs[i][1], programs[i][2], programs[i][3]);
-            programsQueue.add(program);
-        }
-        PriorityQueue<Integer> sdeWakeQueue = new PriorityQueue<Integer>();
-        for (int i = 0; i < sdes; i++) {
-            sdeWakeQueue.add(1);//所有程序员都认为是在第一时间醒来
-        }
-        BigQueues bigQueues = new BigQueues(pms);
-        int finish = 0;
-        int[] ans = new int[programs.length];
-        while (finish != ans.length) {
-            int sdeWakeTime = sdeWakeQueue.poll();
-            while (!programsQueue.isEmpty()) {
-                if (programsQueue.peek().start > sdeWakeTime) {
-                    break;
-                }
-                bigQueues.add(programsQueue.poll());//激活的项目直接进入bigQueue
-            }
-            if (bigQueues.isEmpty()) { //当前项目开始的时间大于程序员醒来的时间，就是当前醒来的程序员需要等待最早到来的项目时间
-                sdeWakeQueue.add(programsQueue.peek().start);
-            } else {
-                Program program = bigQueues.pop();
-                ans[program.index] = sdeWakeTime + program.cost;
-                sdeWakeQueue.add(ans[program.index]);//程序员下一次醒来的时机
-                finish++;
-            }
-        }
-        return ans;
-    }
-
-    public static void printArray(int[] arr) {
-        for (int i = 0; i < arr.length; i++) {
-            System.out.println(arr[i]);
-        }
-    }
-
-    public static void main(String[] args) {
-        int pms = 2;
-        int sde = 2;
-        int[][] programs = { { 1, 1, 1, 2 }, { 1, 2, 1, 1 }, { 1, 3, 2, 2 }, { 2, 1, 1, 2 }, { 2, 3, 5, 5 } };
-        int[] ans = workFinish(pms, sde, programs);
-        printArray(ans);
-    }
-
-
-}
Index: src/左神算法/基础班/Sort/SelectSort.java
===================================================================
diff --git a/src/左神算法/基础班/Sort/SelectSort.java b/src/左神算法/基础班/Sort/SelectSort.java
deleted file mode 100644
--- a/src/左神算法/基础班/Sort/SelectSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,27 +0,0 @@
-package 左神算法.基础班.Sort;
-
-public class SelectSort {
-
-    public static void selectSort(int[] arr)
-    {
-        if(arr==null || arr.length==0)
-            return;
-        for(int i=0;i<arr.length-1;i++)
-        {
-             int minIndex=i;
-            for(int j=i;j<arr.length;j++)
-            {
-                minIndex=arr[j]<arr[minIndex]?j:minIndex;
-            }
-            swap(arr,minIndex,i);
-        }
-    }
-
-    //异或的方式实现两个变量值交换
-    public static void swap(int[]array,int i,int j)
-    {
-        array[i]=array[i]^array[j];
-        array[j]=array[i]^array[j];
-        array[i]=array[i]^array[j];
-    }
-}
Index: src/韩顺平算法与数据结构/datastructure/sort/SelectSort.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/sort/SelectSort.java b/src/韩顺平算法与数据结构/datastructure/sort/SelectSort.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/sort/SelectSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,75 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.sort;
-
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Date;
-
-public class SelectSort {
-    public static void main(String[] args) {
-
-        int[] arr=new int[80000];
-        for(int i=0;i<80000;i++)
-        {
-            arr[i]=(int)(Math.random()*80000);
-        }
-        System.out.println("排序前");
-        //System.out.println(Arrays.toString(arr));
-
-        Date data1 = new Date();
-        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
-        String date1Str = simpleDateFormat.format(data1);
-        System.out.println("排序前的时间是=" + date1Str);
-
-        selectSort(arr);
-
-
-        Date data2 = new Date();
-        String date2Str = simpleDateFormat.format(data2);
-        System.out.println("排序前的时间是=" + date2Str);
-
-    }
-
-    public static void selectSort(int[] arr){
-        int maxValue=0;
-        int maxIndex=0;
-        for(int i=0;i<arr.length-1;i++)
-        {    maxIndex=i;
-             maxValue=arr[i];
-            for(int j=i+1;j<arr.length;j++)
-            {
-                if(maxValue<arr[j])
-                {
-                    maxValue=arr[j];
-                    maxIndex=j;
-
-                }
-            }
-            if(maxIndex!=i)
-            {   arr[maxIndex]=arr[i];
-                arr[i]=maxValue;
-
-            }
-//            System.out.println("第"+(i+1)+"轮后~~");
-//            System.out.println(Arrays.toString(arr));// 1, 34, 119, 101
-        }
-//        for (int i = 0; i < arr.length - 1; i++) {
-//            int minIndex = i;
-//            int min = arr[i];
-//            for (int j = i + 1; j < arr.length; j++) {
-//                if (min > arr[j]) { // 说明假定的最小值，并不是最小
-//                    min = arr[j]; // 重置min
-//                    minIndex = j; // 重置minIndex
-//                }
-//            }
-//
-//            // 将最小值，放在arr[0], 即交换
-//            if (minIndex != i) {
-//                arr[minIndex] = arr[i];
-//                arr[i] = min;
-//            }
-//
-//            System.out.println("第"+(i+1)+"轮后~~");
-//            System.out.println(Arrays.toString(arr));// 1, 34, 119, 101
-//        }
-    }
-}
Index: src/JUC/SemaphoreDemo/SemaphoreDemo.java
===================================================================
diff --git a/src/JUC/SemaphoreDemo/SemaphoreDemo.java b/src/JUC/SemaphoreDemo/SemaphoreDemo.java
deleted file mode 100644
--- a/src/JUC/SemaphoreDemo/SemaphoreDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,25 +0,0 @@
-package JUC.SemaphoreDemo;
-
-import java.util.concurrent.Semaphore;
-
-public class SemaphoreDemo {
-
-    public static void main(String[] args) {
-        Semaphore semaphore=new Semaphore(3);//模拟停车为的数量
-        for(int i=0;i<6;i++)//模拟车的数量
-        {
-            new Thread(()->{
-                try {
-                    System.out.println(Thread.currentThread().getName()+"\t 进入了一个停车位");
-                    semaphore.acquire();
-                    System.out.println(Thread.currentThread().getName()+"\t出去停车位");
-
-                } catch (InterruptedException e) {
-                    e.printStackTrace();
-                }finally {
-                    semaphore.release();
-                }
-            },String .valueOf(i)).start();
-        }
-    }
-}
Index: src/左神算法/基础班/树/SerializeAnDeserializeNTree.java
===================================================================
diff --git a/src/左神算法/基础班/树/SerializeAnDeserializeNTree.java b/src/左神算法/基础班/树/SerializeAnDeserializeNTree.java
deleted file mode 100644
--- a/src/左神算法/基础班/树/SerializeAnDeserializeNTree.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,78 +0,0 @@
-package 左神算法.基础班.树;
-
-import sun.awt.image.ImageWatched;
-
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Queue;
-
-public class SerializeAnDeserializeNTree {
-
-    /**
-     * 定义n叉树的节点
-     */
-    public static class Node{
-        int val;
-        List<Node> children;
-        Node(){}
-        Node(int val,List<Node> childern){
-            this.val = val;
-            this.children = childern;
-        }
-    }
-
-    /**
-     * 序列化操作，其实就是dfs的过程，并且记录每个节点孩子的数量
-     * @param root
-     * @return
-     */
-    public String serialize(Node root){
-        if(root == null){
-            return "";
-        }
-        List<String> list = new ArrayList<>();
-        process(root,list);
-        return String.join("#",list);
-    }
-    private void process(Node root,List<String>list){
-        if(root == null){
-            return;
-        }
-        String val = String.valueOf(root.val);
-        String childrendNum = String.valueOf(root.children.size());
-        list.add(val);
-        list.add(childrendNum);
-        for(Node node : root.children){
-            process(node,list);
-        }
-    }
-
-    /**
-     * 反序列化操作
-     * @param data
-     * @return
-     */
-    public Node deserialize(String data){
-        if(data == null || data.length() == 0){
-            return null;
-        }
-        String[] strs = data.split("#");
-        Queue<String> queue = new LinkedList<>();
-        for(String str : strs){
-            queue.add(str);
-        }
-        return doDeserialize(queue);
-    }
-    private Node doDeserialize(Queue<String> queue){
-       Node root = new Node();
-       int val = Integer.valueOf(queue.poll());
-       int size = Integer.valueOf(queue.poll());
-       root.val = val;
-       root.children = new ArrayList<>(size);
-       for(int i = 0;i < size;i++){
-           root.children.add(doDeserialize(queue));
-       }
-       return root;
-    }
-}
Index: src/左神算法/基础班/树/SerializeAndReconstructTree.java
===================================================================
diff --git a/src/左神算法/基础班/树/SerializeAndReconstructTree.java b/src/左神算法/基础班/树/SerializeAndReconstructTree.java
deleted file mode 100644
--- a/src/左神算法/基础班/树/SerializeAndReconstructTree.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,263 +0,0 @@
-package 左神算法.基础班.树;
-
-import java.util.LinkedList;
-import java.util.Queue;
-
-/**
- * 树的序列化与反序列化
- */
-public class SerializeAndReconstructTree {
-
-     public static class Node {
-         public int value;
-         public Node right;
-         public Node left;
-
-         public Node(int value) {
-             this.value = value;
-         }
-     }
-     //==============================================后序遍历的方式序列化与反序列化====================
-     public static String serialByPost(Node head){
-         StringBuilder sb = new StringBuilder();
-         if(head == null){
-             sb.append("#_");
-         }else{
-             sb.append(serialByPost(head.left));
-             sb.append(serialByPost(head.right));
-             sb.append(head.value + "_");
-         }
-         return sb.toString();
-     }
-    public Node deserialize(String data) {
-        String[] strs = data.split("_");
-        LinkedList<String> queue = new LinkedList<>();
-        for(String str : strs){
-            queue.add(str);
-        }
-        return postDeserial(queue);
-    }
-
-    private Node postDeserial(LinkedList<String> queue){
-        if(queue.isEmpty()){
-            return null;
-        }
-        //弹出最后一个节点
-        String str = queue.pollLast();
-        if(str.equals("#")){
-            return null;
-        }
-        Node root = new Node(Integer.valueOf(str));
-        //先右子节点，再左子节点
-        root.right = postDeserial(queue);
-        root.left = postDeserial(queue);
-        return root;
-    }
-    //==============================================后序遍历的方式序列化与反序列化====================
-     //以!来表示某个节点值的结尾，以#表示某个节点的孩子不存在
-     public static String serialByPre(Node head)
-     {
-         if(head==null)
-             return "#!";
-         String res=head.value+"!";
-         res+=serialByPre(head.left);
-         res+=serialByPre(head.right);
-         return res;
-     }
-
-     public static Node reconPreOrder(Queue<String> queue)
-     {
-         //前序遍历弹出最前端的节点值
-         String value=queue.poll();
-         if(value.equals("#"))
-             return null;
-         Node head=new Node(Integer.valueOf(value));
-         //先左孩子再右孩子
-         head.left=reconPreOrder(queue);
-         head.right=reconPreOrder(queue);
-         return head;
-     }
-
-     public static Node reconByPreString(String str)
-     {
-         String[] values = str.split("!");
-         Queue<String> queue = new LinkedList<String>();
-         for (int i = 0; i != values.length; i++) {
-             queue.offer(values[i]);
-         }
-         return reconPreOrder(queue);
-     }
-     //按层遍历的方式来序列化
-     public static String serialByLevel(Node head)
-     {
-          if(head==null)
-              return "#!";
-          String res=head.value+"!";
-          Queue<Node>queue=new LinkedList<>();
-          queue.offer(head);
-          while(!queue.isEmpty()){
-              head=queue.poll();
-              if(head.left!=null)
-              {
-                  res+=head.left.value+"!";
-                  queue.offer(head.left);
-              }else{
-                  res+="#!";
-              }
-              if(head.right!=null)
-              {
-                  res+=head.right.value+"!";
-                  queue.offer(head.right);
-              }else {
-                  res+="#!";
-              }
-          }
-          return res;
-     }
-
-     public static Node reconByLevelString(String str){
-         String[] values=str.split("!");
-         int index=0;
-         Node head=generateNodeByString(values[index++]);
-         Queue<Node>queue =new LinkedList<>();
-         if(head!=null)
-         {
-             queue.offer(head);
-         }
-         Node node=null;
-         while(!queue.isEmpty())
-         {
-             node=queue.poll();
-             node.left=generateNodeByString(values[index++]);
-             node.right=generateNodeByString(values[index++]);
-             if(node.left!=null)
-             {
-                 queue.offer(node.left);
-             }
-             if(node.right!=null)
-             {
-                 queue.offer(node.right);
-             }
-         }
-         return head;
-
-     }
-
-     public static Node generateNodeByString(String str)
-     {
-         if(str.equals("#"))
-             return null;
-         return new Node(Integer.parseInt(str));
-     }
-
-    // for test -- print tree
-    public static void printTree(Node head) {
-        System.out.println("Binary Tree:");
-        printInOrder(head, 0, "H", 17);
-        System.out.println();
-    }
-
-    public static void printInOrder(Node head, int height, String to, int len) {
-        if (head == null) {
-            return;
-        }
-        printInOrder(head.right, height + 1, "v", len);
-        String val = to + head.value + to;
-        int lenM = val.length();
-        int lenL = (len - lenM) / 2;
-        int lenR = len - lenM - lenL;
-        val = getSpace(lenL) + val + getSpace(lenR);
-        System.out.println(getSpace(height * len) + val);
-        printInOrder(head.left, height + 1, "^", len);
-    }
-
-    public static String getSpace(int num) {
-        String space = " ";
-        StringBuffer buf = new StringBuffer("");
-        for (int i = 0; i < num; i++) {
-            buf.append(space);
-        }
-        return buf.toString();
-    }
-
-    public static void main(String[] args) {
-        Node head = null;
-        printTree(head);
-
-        String pre = serialByPre(head);
-        System.out.println("serialize tree by pre-order: " + pre);
-        head = reconByPreString(pre);
-        System.out.print("reconstruct tree by pre-order, ");
-        printTree(head);
-
-        String level = serialByLevel(head);
-        System.out.println("serialize tree by level: " + level);
-        head = reconByLevelString(level);
-        System.out.print("reconstruct tree by level, ");
-        printTree(head);
-
-        System.out.println("====================================");
-
-        head = new Node(1);
-        printTree(head);
-
-        pre = serialByPre(head);
-        System.out.println("serialize tree by pre-order: " + pre);
-        head = reconByPreString(pre);
-        System.out.print("reconstruct tree by pre-order, ");
-        printTree(head);
-
-        level = serialByLevel(head);
-        System.out.println("serialize tree by level: " + level);
-        head = reconByLevelString(level);
-        System.out.print("reconstruct tree by level, ");
-        printTree(head);
-
-        System.out.println("====================================");
-
-        head = new Node(1);
-        head.left = new Node(2);
-        head.right = new Node(3);
-        head.left.left = new Node(4);
-        head.right.right = new Node(5);
-        printTree(head);
-
-        pre = serialByPre(head);
-        System.out.println("serialize tree by pre-order: " + pre);
-        head = reconByPreString(pre);
-        System.out.print("reconstruct tree by pre-order, ");
-        printTree(head);
-
-        level = serialByLevel(head);
-        System.out.println("serialize tree by level: " + level);
-        head = reconByLevelString(level);
-        System.out.print("reconstruct tree by level, ");
-        printTree(head);
-
-        System.out.println("====================================");
-
-        head = new Node(100);
-        head.left = new Node(21);
-        head.left.left = new Node(37);
-        head.right = new Node(-42);
-        head.right.left = new Node(0);
-        head.right.right = new Node(666);
-        printTree(head);
-
-        pre = serialByPre(head);
-        System.out.println("serialize tree by pre-order: " + pre);
-        head = reconByPreString(pre);
-        System.out.print("reconstruct tree by pre-order, ");
-        printTree(head);
-
-        level = serialByLevel(head);
-        System.out.println("serialize tree by level: " + level);
-        head = reconByLevelString(level);
-        System.out.print("reconstruct tree by level, ");
-        printTree(head);
-
-        System.out.println("====================================");
-
-    }
-
-}
Index: src/重温设计模式/行为模式/责任链模式/示例/Server.java
===================================================================
diff --git a/src/重温设计模式/行为模式/责任链模式/示例/Server.java b/src/重温设计模式/行为模式/责任链模式/示例/Server.java
deleted file mode 100644
--- a/src/重温设计模式/行为模式/责任链模式/示例/Server.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,44 +0,0 @@
-package 重温设计模式.行为模式.责任链模式.示例;
-
-import java.util.HashMap;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 授权目标
- * @date 2021/5/14 21:53
- */
-public class Server {
-
-    private HashMap<String,String> user = new HashMap<>();
-    private Middleware middleware;
-
-    public void setMiddleware(Middleware middleware){
-        this.middleware = middleware;
-    }
-
-    public boolean logIn(String email,String password){
-        if(middleware.check(email,password)){
-            System.out.println("Authorization have been successful!");
-
-            // Do something useful here for authorized users.
-
-            return true;
-        }
-        return false;
-    }
-
-    public void register(String email,String password){
-        user.put(email,password);
-    }
-
-    public boolean hasEmail(String email){
-        return user.containsKey(email);
-    }
-
-    public boolean isValidPassword(String email,String password){
-        return user.get(email).equals(password);
-    }
-
-
-}
Index: src/org/sd/prototype/Sheep.java
===================================================================
diff --git a/src/org/sd/prototype/Sheep.java b/src/org/sd/prototype/Sheep.java
deleted file mode 100644
--- a/src/org/sd/prototype/Sheep.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,43 +0,0 @@
-package org.sd.prototype;
-
-import java.io.Serializable;
-import java.util.Date;
-
-public class Sheep implements Cloneable, Serializable {
-    private String name;
-    private Date date;
-
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    public Date getDate() {
-        return date;
-    }
-
-    public void setDate(Date date) {
-        this.date = date;
-    }
-
-    protected Object clone() throws CloneNotSupportedException {
-      Object object=super.clone();
-
-     Sheep s=(Sheep)object;
-     s.date=(Date)this.date.clone();//把属性也进行克隆
-        return  object;
-    }
-
-    public Sheep(String name, Date date) {
-        this.name = name;
-        this.date = date;
-    }
-
-    public Sheep() {
-
-    }
-}
Index: src/韩顺平算法与数据结构/datastructure/sort/ShellSort.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/sort/ShellSort.java b/src/韩顺平算法与数据结构/datastructure/sort/ShellSort.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/sort/ShellSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,133 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.sort;
-
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Date;
-
-public class ShellSort {
-
-    public static void main(String[] args) {
-        //int[] arr = { 8, 9, 1, 7, 2, 3, 5, 4, 6, 0 };
-
-        // 创建要给80000个的随机的数组
-        int[] arr = new int[8000000];
-        for (int i = 0; i < 8000000; i++) {
-            arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数
-        }
-
-        System.out.println("排序前");
-        Date data1 = new Date();
-        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
-        String date1Str = simpleDateFormat.format(data1);
-        System.out.println("排序前的时间是=" + date1Str);
-
-        //shellSort(arr); //交换式
-        shellSort2(arr);//移位方式
-
-        Date data2 = new Date();
-        String date2Str = simpleDateFormat.format(data2);
-        System.out.println("排序前的时间是=" + date2Str);
-
-        //System.out.println(Arrays.toString(arr));
-    }
-
-    // 使用逐步推导的方式来编写希尔排序
-    // 希尔排序时， 对有序序列在插入时采用交换法,
-    // 思路(算法) ===> 代码
-    public static void shellSort(int[] arr) {
-
-        int temp = 0;
-        int count = 0;
-        // 根据前面的逐步分析，使用循环处理
-        for (int gap = arr.length / 2; gap > 0; gap /= 2) {
-            for (int i = gap; i < arr.length; i++) {
-                // 遍历各组中所有的元素(共gap组，每组有个元素), 步长gap
-                for (int j = i - gap; j >= 0; j -= gap) {
-                    // 如果当前元素大于加上步长后的那个元素，说明交换
-                    if (arr[j] > arr[j + gap]) {
-                        temp = arr[j];
-                        arr[j] = arr[j + gap];
-                        arr[j + gap] = temp;
-                    }
-                }
-            }
-            //System.out.println("希尔排序第" + (++count) + "轮 =" + Arrays.toString(arr));
-        }
-
-		/*
-
-		// 希尔排序的第1轮排序
-		// 因为第1轮排序，是将10个数据分成了 5组
-		for (int i = 5; i < arr.length; i++) {
-			// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5
-			for (int j = i - 5; j >= 0; j -= 5) {
-				// 如果当前元素大于加上步长后的那个元素，说明交换
-				if (arr[j] > arr[j + 5]) {
-					temp = arr[j];
-					arr[j] = arr[j + 5];
-					arr[j + 5] = temp;
-				}
-			}
-		}
-
-		System.out.println("希尔排序1轮后=" + Arrays.toString(arr));//
-
-
-		// 希尔排序的第2轮排序
-		// 因为第2轮排序，是将10个数据分成了 5/2 = 2组
-		for (int i = 2; i < arr.length; i++) {
-			// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5
-			for (int j = i - 2; j >= 0; j -= 2) {
-				// 如果当前元素大于加上步长后的那个元素，说明交换
-				if (arr[j] > arr[j + 2]) {
-					temp = arr[j];
-					arr[j] = arr[j + 2];
-					arr[j + 2] = temp;
-				}
-			}
-		}
-
-		System.out.println("希尔排序2轮后=" + Arrays.toString(arr));//
-
-		// 希尔排序的第3轮排序
-		// 因为第3轮排序，是将10个数据分成了 2/2 = 1组
-		for (int i = 1; i < arr.length; i++) {
-			// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5
-			for (int j = i - 1; j >= 0; j -= 1) {
-				// 如果当前元素大于加上步长后的那个元素，说明交换
-				if (arr[j] > arr[j + 1]) {
-					temp = arr[j];
-					arr[j] = arr[j + 1];
-					arr[j + 1] = temp;
-				}
-			}
-		}
-
-		System.out.println("希尔排序3轮后=" + Arrays.toString(arr));//
-		*/
-    }
-
-    //对交换式的希尔排序进行优化->移位法
-    public static void shellSort2(int[] arr) {
-
-        // 增量gap, 并逐步的缩小增量
-        for (int gap = arr.length / 2; gap > 0; gap /= 2) {
-            // 从第gap个元素，逐个对其所在的组进行直接插入排序
-            for (int i = gap; i < arr.length; i++) {
-                int j = i;
-                int temp = arr[j];
-                if (arr[j] < arr[j - gap]) {
-                    while (j - gap >= 0 && temp < arr[j - gap]) {
-                        //移动
-                        arr[j] = arr[j-gap];
-                        j -= gap;
-                    }
-                    //当退出while后，就给temp找到插入的位置
-                    arr[j] = temp;
-                }
-
-            }
-        }
-    }
-
-}
Index: src/左神算法/进阶班一/Manacher/ShortestEnd.java
===================================================================
diff --git a/src/左神算法/进阶班一/Manacher/ShortestEnd.java b/src/左神算法/进阶班一/Manacher/ShortestEnd.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/Manacher/ShortestEnd.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,101 +0,0 @@
-package 左神算法.进阶班一.Manacher;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 如果只能向字符串的后面添加字符，如何使整个字符串成为回文串，求需要添加的最短字符串
- * @date 2019/12/27 11:14
- */
-public class ShortestEnd {
-
-    //找到包含原来字符串最后一个字符的回文串，将原字符串中剩余位置的字符反过来添加到字符串的后面即可，
-
-    public static char[] manacherString(String str){
-        char[] strArr=str.toCharArray();
-        char[] chas=new char[2*strArr.length+1];
-        int index=0;
-        for(int i=0;i<chas.length;i++){
-            chas[i]=(i&1)==1?strArr[index++]:'#';
-        }
-        return chas;
-    }
-
-    public static String shortestEnd(String str){
-        if(str==null || str.length()==0)
-            return null;
-        char[] chars = manacherString(str);
-        int[] pArr=new int[chars.length];
-        int index=-1;//回文中心
-        int pR=-1;//最后回文右边界
-        int maxContainedEnd=-1;
-        for(int i=0;i<chars.length;i++)
-        {
-//            pArr[i]=pR>i ? Math.min(pArr[2*index-i],pR-i):1;//在最右回文右边界之外，先暂定pArr[i]=1,即当前元素自己;
-//            while(i+pArr[i]<chars.length && i-pArr[i]>=0)
-//            {
-//                if(chars[i+pArr[i]]==chars[i-pArr[i]])
-//                    pArr[i]++;
-//                else
-//                    break;
-//            }
-//            if(i+pArr[i]>pR)
-//            {
-//                pR=i+pArr[i];
-//                index=i;
-//            }
-
-            //i在回文边界内和上面实现的功能一样,代码中相应位置全部换为注释部分也可以，这样的话，最右右边界就是不包含的一个位置了
-             if(pR>i)
-             {
-                 if(2*index-i-pArr[2*index-i]>index-pArr[index])
-                 {
-                     pArr[i]=pArr[2*index-i];
-                 }else if(2*index-i-pArr[2*index-i]<index-pArr[index])
-                 {
-                     pArr[i]=pR-i+1; //pArr[i]=pR-i;
-                 }else {
-                     pArr[i]=pArr[2*index-i];
-                     while(i+pArr[i]<chars.length && i-pArr[i]>-1)
-                     {
-                         if(chars[i+pArr[i]]==chars[i-pArr[i]])
-                             pArr[i]++;
-                         else
-                             break;
-                     }
-                 }
-             }else{
-                 pArr[i]=1;
-                 while(i+pArr[i]<chars.length && i-pArr[i]>=0)
-                 {
-                     if(chars[i+pArr[i]]==chars[i-pArr[i]])
-                         pArr[i]++;
-                     else
-                         break;
-                 }
-             }
-             if(i+pArr[i]-1>pR){ //或者是这样i+pArr[i]>pR
-                 pR=i+pArr[i]-1; //pR=i+pArr[i]
-                 index=i;
-             }
-            if(pR==chars.length-1) //pR=chars.length;
-            {
-                maxContainedEnd=pArr[i];
-                break;
-            }
-
-
-
-        }
-        char[] res=new char[str.length()-maxContainedEnd+1];
-        for(int i=0;i<res.length;i++)
-        {
-            res[res.length-1-i]=chars[i*2+1];
-        }
-        return String.valueOf(res);
-    }
-    public static void main(String[] args) {
-        String str2 = "123abba";
-        System.out.println(shortestEnd(str2));
-
-    }
-}
Index: src/左神算法/进阶班一/KMP/ShortestHaveTwice.java
===================================================================
diff --git a/src/左神算法/进阶班一/KMP/ShortestHaveTwice.java b/src/左神算法/进阶班一/KMP/ShortestHaveTwice.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/KMP/ShortestHaveTwice.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,66 +0,0 @@
-package 左神算法.进阶班一.KMP;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:有一个字符串str，请在字符串末尾添加相应的字符，使得形成的新字符串包含连个原来的字符串，并且要求包含的两个原来的字符串的开始位置不同，求
- *                   最短的新字符串。(京东)
- * @date 2019/12/25 14:33
- */
-public class ShortestHaveTwice {
-
-
-    public static String answer(String str)
-    {
-        if(str==null || str.length()==0)
-            return null;
-        char[] chas=str.toCharArray();
-        if(chas.length==1)
-            return str+str;
-        if(chas.length==2)
-        {
-            return chas[0]==chas[1]?(str+String.valueOf(chas[0])):str+str;
-        }
-
-        int endNext=endNextLength(chas);
-        return str+str.substring(endNext);
-    }
-     //next数组多算一位
-    public static int endNextLength(char[] chas){
-
-      int[] next=new int[chas.length+1];
-      next[0]=-1;
-      next[1]=0;
-      int pos=2;
-      int cn=0;//下一跳的位置
-      while(pos<next.length){
-          if(chas[pos-1]==chas[cn])
-          {
-              next[pos++]=++cn;
-          }else if(cn>0){
-              cn=next[cn];
-          }else{
-              next[pos++]=0;
-          }
-      }
-      return next[next.length-1];
-    }
-
-    public static void main(String[] args) {
-        String test1 = "a";
-        System.out.println(answer(test1));
-
-        String test2 = "aa";
-        System.out.println(answer(test2));
-
-        String test3 = "ab";
-        System.out.println(answer(test3));
-
-        String test4 = "abcdabcd";
-        System.out.println(answer(test4));
-
-        String test5 = "abracadabra";
-        System.out.println(answer(test5));
-
-    }
-}
Index: src/左神算法/高频面试题/十京东/ShortestHaveTwice.java
===================================================================
diff --git a/src/左神算法/高频面试题/十京东/ShortestHaveTwice.java b/src/左神算法/高频面试题/十京东/ShortestHaveTwice.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/十京东/ShortestHaveTwice.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,80 +0,0 @@
-package 左神算法.高频面试题.十京东;
-/*
-   给定一个字符串s，请计算输出含有连续两个s作为 子串的最短字符串。注意两个s可能有重叠的部分，例如：ababa含有连个aba
- */
-public class ShortestHaveTwice {
-
-    public static String answer(String str){
-        if(str==null || str.length()==0)
-            return "";
-        if(str.length()==1){
-            return str+str;
-        }
-        char[] chas=str.toCharArray();
-        if(str.length()==2){
-            return chas[0]==chas[1] ? str+String.valueOf(chas[0]): str+str;
-        }
-        int endNext=endNextLength(chas);
-        return str+str.substring(endNext);
-    }
-
-    private static int endNextLength(char[] chas) {
-        int [] next=new int[chas.length+1];
-        next[0]=-1;
-        next[1]=0;
-        int pos=2;
-        int cn=0;
-        //与下面的等价
-//        while(pos<next.length){
-//            cn=next[pos-1];
-//            if(chas[cn]==chas[pos-1]){
-//                next[pos]=next[pos-1]+1;
-//            }else{
-//                while(cn>0) {
-//                    cn = next[cn];
-//                    if (cn <= 0){
-//                        next[pos]=0;
-//                        break;
-//                    }
-//                     else if(chas[cn] == chas[pos - 1]) {
-//                        next[pos] = next[cn] + 1;
-//                        break;
-//                    }
-//                }
-//            }
-//            pos++;
-//
-//        }
-
-        while (pos < next.length) {
-            if (chas[pos - 1] == chas[cn]) {
-                next[pos++] = ++cn;
-            } else if (cn > 0) {
-                cn = next[cn];
-            } else {
-                next[pos++] = 0;
-            }
-        }
-        return next[chas.length];
-    }
-
-    public static void main(String[] args) {
-        String test1 = "a";
-        System.out.println(answer(test1));
-
-        String test2 = "aa";
-        System.out.println(answer(test2));
-
-        String test3 = "ab";
-        System.out.println(answer(test3));
-
-        String test4 = "abcdabcd";
-        System.out.println(answer(test4));
-
-        String test5 = "abracadabra";
-        System.out.println(answer(test5));
-        String test6 = "abracadabraca";
-        System.out.println(answer(test6));
-
-    }
-}
Index: src/左神算法/高频面试题/十京东/ShortestMakePalindrome.java
===================================================================
diff --git a/src/左神算法/高频面试题/十京东/ShortestMakePalindrome.java b/src/左神算法/高频面试题/十京东/ShortestMakePalindrome.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/十京东/ShortestMakePalindrome.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,51 +0,0 @@
-package 左神算法.高频面试题.十京东;
-
-/*
-  回文是指从前往后读和从后往前读是一样的词语，给定一个字符串s,然后在后面附加0个或更多个字母形成回文。希望这个回文
-  越短越好，求能够得到的最短回文串
- */
-public class ShortestMakePalindrome {
-
-    //将原来的数组变成manacher数组，保证数组应用是奇数的长度
-    public static char[] manacherString(String str){
-        char[] charArr=str.toCharArray();
-        char[] res=new char[charArr.length*2+1];
-        int index=0;
-        for(int i=0;i<res.length;i++){
-            res[i]=(i&1)==0 ? '#':charArr[index++];
-        }
-        return res;
-    }
-
-    public static int shortestEnd(String str){
-        if(str==null || str.length()==0)
-            return 0;
-        char[] charArr=manacherString(str);
-        int[] pArr=new int [charArr.length];//回文半径数组
-        int index=-1;//回文中心
-        int pR=-1;//回文最右边界
-        int maxContainsEnd=0;
-        for(int i=0;i<charArr.length;i++) {
-            pArr[i] = pR > i ? Math.min(pArr[2 * index - i], pR - i) : 1;
-            while (i + pArr[i] < charArr.length && i - pArr[i] > -1) {//进行左右两边扩
-                if (charArr[i + pArr[i]] == charArr[i - pArr[i]])
-                    pArr[i]++;
-                else
-                    break;
-            }
-            if (index + pArr[i] > pR) {
-                index = i;
-                pR = i + pArr[i];
-            }
-            if (pR == charArr.length) {
-                maxContainsEnd = pArr[i];//这里maxContainsEnd的值是在manacher的情况下求出的。所以相当于原数组的回文直径
-                break;
-            }
-        }
-        return 2*str.length()-maxContainsEnd+1;
-    }
-    public static void main(String[] args) {
-        String test = "abcd1234321";
-        System.out.println(shortestEnd(test));
-    }
-}
Index: src/Gof/Factory/simpleFactory/SimpleFatory.java
===================================================================
diff --git a/src/Gof/Factory/simpleFactory/SimpleFatory.java b/src/Gof/Factory/simpleFactory/SimpleFatory.java
deleted file mode 100644
--- a/src/Gof/Factory/simpleFactory/SimpleFatory.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,25 +0,0 @@
-package Gof.Factory.simpleFactory;
-
-public class SimpleFatory {
-
-    String orderType="";
-
-    public Pizza createPizza(String orderType)
-    {
-        Pizza pizza=null;
-        if(orderType.equals("cheese"))
-        {
-            pizza=new CheesePizza();
-            pizza.setName("奶酪披萨");
-        }else if(orderType.equals("greek"))
-        {
-            pizza=new GreekPizza();
-            pizza.setName("希腊披萨");
-        }else if(orderType.equals("pepper"))
-        {
-            pizza=new PepperPizza();
-            pizza.setName("胡椒披萨");
-        }
-        return pizza;
-    }
-}
Index: src/韩顺平算法与数据结构/datastructure/list/SingleLinkedListDemo.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/list/SingleLinkedListDemo.java b/src/韩顺平算法与数据结构/datastructure/list/SingleLinkedListDemo.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/list/SingleLinkedListDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,367 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.list;
-
-import java.util.Stack;
-
-public class SingleLinkedListDemo {
-    public static void main(String[] args) {
-        HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
-        HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟");
-        HeroNode hero3 = new HeroNode(3, "吴用", "智多星");
-        HeroNode hero4 = new HeroNode(4, "林冲", "豹子头");
-        HeroNode hero5= new HeroNode(6, "林冲111", "豹子111");
-        HeroNode hero6= new HeroNode(7, "林冲54", "豹子55");
-        HeroNode hero7= new HeroNode(5, "林冲23", "豹子67");
-        //创建要给链表
-        SingleLinkedList singleLinkedList1 = new SingleLinkedList();
-        SingleLinkedList singleLinkedList2= new SingleLinkedList();
-
-        //加入
-        singleLinkedList1.addByOrder(hero1);
-        singleLinkedList1.addByOrder(hero4);
-        singleLinkedList1.addByOrder(hero3);
-        singleLinkedList1.addByOrder(hero5);
-        singleLinkedList2.addByOrder(hero2);
-        singleLinkedList2.addByOrder(hero7);
-        singleLinkedList2.addByOrder(hero6);
-        //singleLinkedList.updata(hero5);
-       // singleLinkedList.delete(4);
-        HeroNode heroNode1=singleLinkedList1.getHead();
-        HeroNode heroNode2=singleLinkedList2.getHead();
-        HeroNode heroNode = mergeList(heroNode1, heroNode2);
-        singleLinkedList1.list();
-        System.out.println("======================");
-        singleLinkedList2.list();
-//        singleLinkedList1.list();
-//        reversePrint(heroNode1);
-//        System.out.println(findLastIndexNode(singleLinkedList.getHead(),2));
-//
-//        reverseList(heroNode);
-//        singleLinkedList.list();
-   }
-
-    //获取单链表的结点的个数，不加头结点
-    public static int getLength(HeroNode head)
-    {
-        if(head.next==null)
-        {
-            return 0;
-        }
-        int count=0;
-        HeroNode temp=head.next;
-        while(temp!=null)
-        { count++;
-        temp=temp.next;
-
-        }
-        return count;
-    }
-
-    //查找单链表的倒数第k个结点
-    public static HeroNode findLastIndexNode(HeroNode head,int index)
-    {
-        //检查是否为空
-        if(head.next==null)
-        {
-            System.out.println("链表为空");
-            return null;
-        }
-        //第一遍遍历，得到链表的有效长度
-        int size=getLength(head);
-        //判断选取的结点是否合理
-        if(index<=0 || index>size)
-        {
-            return null;
-        }
-        HeroNode temp=head.next;
-        for(int i=0;i<size-index;i++)
-        {
-            temp=temp.next;
-        }
-        return temp;
-    }
-       //单链表的翻转
-    public static  void reverseList(HeroNode head){
-        if(head.next==null || head.next.next==null)
-        {
-            return;
-        }
-
-        //辅助接点，一个替代head，来遍历，另一个记住当前遍历的位置的下一各节点
-        HeroNode cur=head.next;
-        HeroNode next=null;
-        //定义一个新的头结点
-        HeroNode reverseNode=new HeroNode(0," "," ");
-        while(cur!=null)
-        {
-            next=cur.next;//记住下一个位置
-            cur.next=reverseNode.next;
-            reverseNode.next=cur;
-            cur=next;//后移一个位置
-
-        }
-         head.next=reverseNode.next;
-    }
-
-    //从头到尾打印单链表(利用栈）
-    public static void reversePrint(HeroNode head)
-    {
-        if(head.next==null)
-        {
-            return;
-        }
-        HeroNode temp=head.next;
-        Stack<HeroNode> stack=new Stack<>();
-        while(temp!=null)
-        {
-            stack.push(temp);
-            temp=temp.next;
-        }
-        while(stack.size()>0)
-        {
-            System.out.println(stack.pop());
-        }
-    }
-
-    //合并两个有序链表，合并之后仍然要有序
-    public static HeroNode  mergeList(HeroNode head1,HeroNode head2)
-    {
-        HeroNode cur1=head1.next;
-        HeroNode cur2=head2.next;
-        HeroNode result=new HeroNode(0," "," ");//合并产生的新的链表头结点
-        HeroNode tail=null;//新链表的尾结点，便于直接插入
-        HeroNode temp;//记住当前遍历的位置
-        while(cur1==null || cur2==null)
-        {
-            if(cur1.no<=cur2.no)
-            {
-                if(result.next!=null)
-                {   temp=cur1.next;
-                    //插入过程
-                    tail.next=cur1;
-                    cur1.next=null;
-                    //保存新的最后的结点
-                    tail=cur1;
-                    cur1=temp;
-                }else {
-                    temp = cur1.next;
-                    result.next = cur1;
-                    cur1.next = null;
-                    tail = cur1;
-                    cur1 = temp;
-                }
-
-            }else{
-                if(result.next!=null)
-                {
-                    temp=cur2.next;
-                    tail.next=cur2;
-                    cur2.next=null;
-                    tail=cur2;
-                    cur2=temp;
-                }else{
-                    temp=cur2.next;
-                    result.next=cur2;
-                    cur2.next=null;
-                    tail=cur2;
-                    cur2=temp;
-
-                }
-            }
-        }
-        if(cur1==null)
-        {
-            tail.next=cur2;
-        }
-        if(cur2==null)
-        {
-            tail.next=cur1;
-        }
-     return result;
-    }
-       //递归方式实现：head1,head2为链表的第一个有效结点
-    public static HeroNode merge(HeroNode head1,HeroNode head2)
-    {
-
-        if(head1==null)
-        {
-            return head2;
-        }
-        if(head2==null)
-        {
-            return head1;
-        }
-        HeroNode result=null;
-        if(head1.no<head2.no)
-        {
-            result=head1;
-            result.next=merge(head1.next,head2);
-        }else{
-            result=head2;
-            result.next=merge(head1,head2.next);
-        }
-        return result;
-    }
-
-
-
-}
-
-class SingleLinkedList{
-    //先初始化一个头结点，头结点不要动，不存放具体的数据
-    private HeroNode head=new HeroNode(0, " "," ");
-
-    //获取头结点
-    public HeroNode getHead()
-    {
-        return head;
-    }
-
-    //依次添加新的结点
-
-    public void add(HeroNode heroNode)
-    {
-        HeroNode temp=head;
-        while(true)
-        {
-            if(temp.next==null)
-            {
-                break;
-            }else{
-                temp=temp.next;
-            }
-        }
-        temp.next=heroNode;
-    }
-
-    //插入指定位置,找到插入结点的后一个结点
-    public void addByOrder(HeroNode heroNode)
-    {
-
-        HeroNode temp=head;
-        boolean flag=false;//flag标志添加的编号是否存在，默认为false
-        while(true)
-        {
-            if(temp.next==null)
-            {
-                break;
-            }
-            if(temp.next.no>heroNode.no) //找到插入的位置，
-            {
-                break;
-            }else if(temp.next.no==heroNode.no)
-            {
-                flag=true;
-                break;
-            }
-            temp=temp.next;
-        }
-        if(flag)
-        {
-            System.out.println("准备插入的结点已经存在");
-
-        }else {
-            heroNode.next=temp.next;
-            temp.next=heroNode;
-        }
-    }
-
-    //根据no来修改结点，即，结点的no值不能修改
-    public void updata(HeroNode heroNode)
-    {
-        //判断是否为空
-        if(head.next==null)
-        {
-            System.out.println("链表为空");
-            return;
-        }
-        HeroNode temp=head.next;
-        boolean flag=false;//用来判断是否找到了要修改的结点
-        while(true)
-        {
-            if(temp==null)//说明要修改的结点不存在
-            {
-                break;
-            }if(temp.no==heroNode.no)//已经找到了
-            {
-              flag=true;
-              break;
-            }
-            temp=temp.next;
-        }
-        if(flag)
-        {
-            temp.name=heroNode.name;
-            temp.nickName=heroNode.nickName;
-        }else{
-            System.out.println("没有找到要修改的结点！！！");
-        }
-    }
-
-    //根据指定的no值，删除指定的结点,并且需要找到要删除的结点的前一个结点
-    public void delete(int no){
-        HeroNode temp=head;
-        boolean flag=false;//标志着我们是否找到要删除的结点
-        while(true)
-        {
-            if(temp.next==null)
-            {break;}
-            if(temp.next.no==no)
-            {
-                flag=true;
-                break;
-            }
-            temp=temp.next;
-
-        }
-        //判断flag
-        if(flag)
-        {
-            temp.next=temp.next.next;
-        }else {
-            System.out.println("要删除的结点不存在");
-        }
-    }
-
-    //显示链表的内容，遍历
-    public  void list()
-    {
-        //先判断链表是否为空
-        if(head.next==null)
-        {
-            System.out.println("链表为空");
-            return;
-        }
-        //因为头结点不能动，因此我们需要一个辅助变量来遍历
-        HeroNode temp=head.next;
-        while(true)
-        {
-            System.out.println(temp);
-            temp=temp.next;
-            if(temp==null)
-            {
-                break;
-            }
-        }
-    }
-
-
-
-}
-class HeroNode{
-    public int no;
-    public String name;
-    public String nickName;
-    public HeroNode next;
-
-    public HeroNode(int no,String name,String nickName)
-    {
-        this.no=no;
-        this.name=name;
-        this.nickName=nickName;
-    }
-
-    public String toString()
-    {
-        return "HeroNode [no=" + no + ", name=" + name + ", nickname=" + nickName + "]";
-    }
-}
\ No newline at end of file
Index: src/org/sd/singleton/SingletonDemo1.java
===================================================================
diff --git a/src/org/sd/singleton/SingletonDemo1.java b/src/org/sd/singleton/SingletonDemo1.java
deleted file mode 100644
--- a/src/org/sd/singleton/SingletonDemo1.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,13 +0,0 @@
-package org.sd.singleton;
-
-import java.io.Serializable;
-
-public class SingletonDemo1 implements Serializable {
-    //类初始时，立即加载这个对象，（没有延迟加载），加载类时，天然的是线程安全的。
-    private static final SingletonDemo1 s=new SingletonDemo1();
-    private SingletonDemo1(){}//私有化构造器
-    //方法没有同步，调用效率高
-    public static SingletonDemo1 getInstance()
-    {return s;}
-
-}
Index: src/org/sd/singleton/SingletonDemo2.java
===================================================================
diff --git a/src/org/sd/singleton/SingletonDemo2.java b/src/org/sd/singleton/SingletonDemo2.java
deleted file mode 100644
--- a/src/org/sd/singleton/SingletonDemo2.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,15 +0,0 @@
-package org.sd.singleton;
-
-public class SingletonDemo2 {
-    private static SingletonDemo2 instance;
-    private SingletonDemo2(){}
-    public static synchronized SingletonDemo2 getInstance()
-    {
-        if(instance==null)
-        {
-            instance=new SingletonDemo2();
-        }
-        return  instance;
-    }
-
-}
Index: src/org/sd/singleton/SingletonDemo3.java
===================================================================
diff --git a/src/org/sd/singleton/SingletonDemo3.java b/src/org/sd/singleton/SingletonDemo3.java
deleted file mode 100644
--- a/src/org/sd/singleton/SingletonDemo3.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,10 +0,0 @@
-package org.sd.singleton;
-
-public class SingletonDemo3 {
-    private static class SingletonClassInstance{
-        private static final SingletonDemo3 instance=new SingletonDemo3();
-    }
-    private SingletonDemo3(){}
-    public static SingletonDemo3 getInstance()
-    {return SingletonClassInstance.instance;}
-}
Index: src/org/sd/singleton/SingletonDemo4.java
===================================================================
diff --git a/src/org/sd/singleton/SingletonDemo4.java b/src/org/sd/singleton/SingletonDemo4.java
deleted file mode 100644
--- a/src/org/sd/singleton/SingletonDemo4.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,11 +0,0 @@
-package org.sd.singleton;
-
-public enum SingletonDemo4 {
-    INSTANCE;//定义了一个枚举元素，本身就是一个枚举对象
-    //添加自己的操作
-    public void singletonOperation()
-    {
-        //功能处理
-    }
-
-}
Index: src/Gof/Singleton/SingletonTest.java
===================================================================
diff --git a/src/Gof/Singleton/SingletonTest.java b/src/Gof/Singleton/SingletonTest.java
deleted file mode 100644
--- a/src/Gof/Singleton/SingletonTest.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,141 +0,0 @@
-package Gof.Singleton;
-
-public class SingletonTest {
-    public static void main(String[] args) {
-
-        Singleton7 instance1= Singleton7.getInstance();
-        Singleton7 instance2=Singleton7.getInstance();
-        System.out.println(instance1.hashCode());
-        System.out.println(instance2.hashCode());
-        Singleton8 s1=Singleton8.INSTACNE;
-        Singleton8 s2=Singleton8.INSTACNE;
-        System.out.println(s1==s2);
-    }
-}
-
-//饿汉式（静态常量）
-class SingleTon1{
-
-    private SingleTon1()
-    {
-
-    }
-
-    private final static SingleTon1 instance=new SingleTon1();
-
-    public static SingleTon1 getInstance()
-    {
-        return instance;
-    }
-}
-//饿汉式（静态代码块）
-class SingleTon2{
-
-    private SingleTon2(){}
-
-    private static  SingleTon2 instance;
-
-      static {
-        instance=new SingleTon2();
-      }
-    public static SingleTon2 getInstance()
-    {
-        return instance;
-    }
-}
-
-//懒汉式（线程不安全）
-class Singleton3
-{
-    private static Singleton3 instance;
-    private Singleton3(){}
-    public static Singleton3 getInstance()
-    {
-        if(instance==null)
-        {
-            instance=new Singleton3();
-        }
-        return instance;
-    }
-}
-
-//懒汉式（线程安全，同步方法）
-class Singleton4
-{
-    private static Singleton4 instance;
-    private Singleton4(){}
-    public static synchronized Singleton4 getInstance()
-    {
-        if(instance==null)
-            instance=new Singleton4();
-        return instance;
-    }
-
-}
-
-//懒汉式（同步代码块，不推荐）
-class Singleton5
-{
-    private static Singleton5 instance;
-    private Singleton5(){}
-    public static Singleton5 getInstance()
-    {
-        if(instance==null)
-            synchronized (Singleton5.class) {
-                instance = new Singleton5();
-            }
-        return instance;
-    }
-}
-
-//双重检查，同步代码块，线程安全
-class Singleton6
-{
-    private static volatile Singleton6 instance;
-    private Singleton6(){
-
-    }
-    //提供了一个静态的共有方法，加入了双重检查，解决了线程安全问题，同时解决了懒加载问题，保证了效率，推荐
-    public static Singleton6 getInstance(){
-    if(instance==null)
-    {
-        synchronized (Singleton6.class)
-        {
-            if(instance==null)
-                instance=new Singleton6();
-        }
-    }
-    return instance;
-}
-
-
-
-}
-
-
-//静态内部类
-class Singleton7 {
-    private Singleton7() {
-
-    }
-
-    private static class SingletonInstance {
-
-        private static final Singleton7 INSTANCE = new Singleton7();//final可以不加
-
-    }
-
-    public static Singleton7 getInstance() {
-        return SingletonInstance.INSTANCE;
-    }
-
-}
-
-//枚举
-enum Singleton8{
-    INSTACNE;//属性
-    public void sayOK()
-    {
-        System.out.println("ok");
-    }
-}
Index: src/Leetcode/字符串/Siolution49.java
===================================================================
diff --git a/src/Leetcode/字符串/Siolution49.java b/src/Leetcode/字符串/Siolution49.java
deleted file mode 100644
--- a/src/Leetcode/字符串/Siolution49.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,78 +0,0 @@
-package Leetcode.字符串;
-
-import java.util.*;
-
-/**
- * @Author zbl
- * @Date 2020/12/14 17:51
- * @Content
- * 49. 字母异位词分组
- * 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。
- *
- * 示例:
- *
- * 输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
- * 输出:
- * [
- *   ["ate","eat","tea"],
- *   ["nat","tan"],
- *   ["bat"]
- * ]
- * 说明：
- *
- * 所有输入均为小写字母。
- * 不考虑答案输出的顺序。
- * 通过次数142,212提交次数219,031
- * @Version 1.0
- */
-public class Siolution49 {
-
-    /**
-     * 方法一：计数法
-     * @param strs
-     * @return
-     */
-    public static List<List<String>> groupAnagrams(String[] strs) {
-        //当且仅当他们的字符计数相等时，两个字符串是字母异位词
-        if(strs.length==0)return new ArrayList();
-        int[] count=new int[26];
-        Map<String,List> temp=new HashMap<>();
-        for(String str:strs){
-            String s=str;
-            Arrays.fill(count,0);
-            for(char c:str.toCharArray()) count[c-'a']++;
-            StringBuilder sb=new StringBuilder();
-            for(int i=0;i<26;i++)
-            {
-                sb.append(count[i]+"#");//这里要加上一个#，用来区分不同的字母的个数统计
-            }
-            String key=sb.toString();
-            if(!temp.containsKey(key)) temp.put(key,new ArrayList<String>());
-            temp.get(key).add(s);
-        }
-        return new ArrayList(temp.values());
-    }
-
-    /**
-     * 方法二：排序法
-     * @param strs
-     */
-    public static List<List<String>> groupAnagrams2(String[] strs) {
-        Map<String,List<String>> map=new HashMap<>();
-        for(int i=0;i<strs.length;i++){
-            char[]  chs=strs[i].toCharArray();
-            Arrays.sort(chs);
-            String key=new String(chs);//将每个字符串排序后形成的字符串作为key
-            List<String> tmp= map.getOrDefault(key, new ArrayList<>());
-            tmp.add(strs[i]);
-            map.put(key,tmp);
-        }
-        return new ArrayList<>(map.values());
-    }
-
-    public static void main(String[] args) {
-        String[] strs=new String[]{"bdddddddddd", "bbbbbbbbbbc"};
-        List<List<String>> res= groupAnagrams(strs);
-
-    }
-}
Index: src/左神算法/进阶班一/滑动窗口/SlidingWindowMaxArray.java
===================================================================
diff --git a/src/左神算法/进阶班一/滑动窗口/SlidingWindowMaxArray.java b/src/左神算法/进阶班一/滑动窗口/SlidingWindowMaxArray.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/滑动窗口/SlidingWindowMaxArray.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,57 +0,0 @@
-package 左神算法.进阶班一.滑动窗口;
-
-import java.util.LinkedList;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 生成窗口最大值
- * @date 2019/12/28 13:52
- */
-public class SlidingWindowMaxArray {
-
-    /**
-    *@param :arr是输入的数组，w是窗口的大小，
-    *@return：窗口在各个位置时的最大值
-    */
-    public static int[] getMaxWindow(int[] arr,int w)
-    {
-        if(arr==null || arr.length<w || w<1)
-            return null;
-        int[] res=new int[arr.length-w+1];
-        LinkedList<Integer> list=new LinkedList<>();//使用双端队列来模拟数字进入/出去窗口,队列中存的是数组中对应元素的下标
-        int index=0;
-        for(int i=0;i<arr.length;i++){
-            while(!list.isEmpty() && arr[list.peekLast()]<arr[i])
-            {
-                list.pollLast();
-            }
-            list.addLast(i);
-            if(list.peekFirst()==i-w) //窗口右移，判断窗口中保存的元素是否过期了
-            {
-                list.pollFirst();
-            }
-            if(i>=w-1)
-            {
-                res[index++]=arr[list.peekFirst()];
-            }
-        }
-        return res;
-
-    }
-
-    public static void printArray(int[] arr) {
-        for (int i = 0; i != arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-        int[] arr = { 4, 3, 5, 4, 3, 3, 6, 7 };
-        int w = 3;
-        printArray(getMaxWindow(arr, w));
-
-    }
-
-}
Index: src/左神算法/基础班/第三课/SmallerEqualBigger.java
===================================================================
diff --git a/src/左神算法/基础班/第三课/SmallerEqualBigger.java b/src/左神算法/基础班/第三课/SmallerEqualBigger.java
deleted file mode 100644
--- a/src/左神算法/基础班/第三课/SmallerEqualBigger.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,150 +0,0 @@
-package 左神算法.基础班.第三课;
-
-public class SmallerEqualBigger {
-
-    public static class Node {
-        public int value;
-        public Node next;
-
-        public Node(int data) {
-            this.value = data;
-        }
-    }
-
-    public static Node listPartition1(Node head,int pivot)
-    {
-        if(head==null)
-            return head;
-        Node cur=head;
-        int count=0;
-        while(cur!=null)
-        {
-            count++;
-            cur=cur.next;
-        }
-        Node[] nodeArr=new Node[count];
-        cur=head;
-        for(int i=0;i<count;i++)
-        {
-            nodeArr[i]=cur;
-            cur=cur.next;
-        }
-        arrPartition(nodeArr,pivot);
-        for(int i=1;i<count;i++)
-        {
-            nodeArr[i-1].next=nodeArr[i];
-        }
-        nodeArr[count-1].next=null;
-        return nodeArr[0];
-    }
-    public static void arrPartition(Node[]arr,int pivot)
-    {
-        int small=-1;
-        int big=arr.length;
-        int index=0;
-        while(index!=big)
-        {
-            if(arr[index].value<pivot)
-            {
-                swap(arr,index++,++small);
-            }else if(arr[index].value>pivot)
-            {
-                swap(arr,--big,index);
-            }else {
-                index++;
-            }
-        }
-
-    }
-    public static void swap(Node[]arr,int a,int b)
-    {
-        Node temp=arr[a];
-        arr[a]=arr[b];
-        arr[b]=temp;
-    }
-    //定义6个Node,分别用来指向小于，等于，大于pivot的结点的头和尾
-    public static Node listPartition2(Node head,int pivot)
-    {
-        if(head==null)
-            return head;
-        Node sh=null;
-        Node st=null;
-        Node eh=null;
-        Node et=null;
-        Node bh=null;
-        Node bt=null;
-        Node next=null;
-
-        while(head!=null)
-        {
-            next=head.next;//保留下一个节点
-            head.next=null;//将当前遍历的结点单独拿出来
-            if(head.value<pivot)
-            {
-                if(sh==null)
-                {
-                    sh=head;
-                    st=head;
-                }else {
-                    st.next=head;
-                    st=st.next;
-                }
-            }else if(head.value==pivot){
-                if(eh==null)
-                {
-                    eh=head;
-                    et=head;
-                }else {
-                    et.next=head;
-                    et=et.next;
-                }
-            }else {
-                if(bh==null)
-                {
-                    bh=head;
-                    bt=head;
-                }else {
-                    bt.next=head;
-                    bt=head;
-                }
-            }
-            head=next;
-        }
-        if(st!=null)
-        {
-            st.next=eh;
-            et=et==null?st:et;
-        }
-        if(et!=null)
-        {
-            et.next=bh;
-
-        }
-        return sh!=null?sh:eh!=null?eh:bh;
-
-    }
-    public static void printLinkedList(Node node) {
-        System.out.print("Linked List: ");
-        while (node != null) {
-            System.out.print(node.value + " ");
-            node = node.next;
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-        Node head1 = new Node(7);
-        head1.next = new Node(9);
-        head1.next.next = new Node(1);
-        head1.next.next.next = new Node(8);
-        head1.next.next.next.next = new Node(5);
-        head1.next.next.next.next.next = new Node(2);
-        head1.next.next.next.next.next.next = new Node(5);
-        printLinkedList(head1);
-        // head1 = listPartition1(head1, 4);
-        head1 = listPartition2(head1, 5);
-        printLinkedList(head1);
-
-    }
-
-}
Index: src/左神算法/高频面试题/九TOP_K问题/SmallestUnFormedSum.java
===================================================================
diff --git a/src/左神算法/高频面试题/九TOP_K问题/SmallestUnFormedSum.java b/src/左神算法/高频面试题/九TOP_K问题/SmallestUnFormedSum.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/九TOP_K问题/SmallestUnFormedSum.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,110 +0,0 @@
-package 左神算法.高频面试题.九TOP_K问题;
-
-import java.util.HashSet;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 求正数数组的最小不可组成和
- * @date 2020/1/21 19:22
- */
-public class SmallestUnFormedSum {
-
-    public static int unformedSum1(int[] arr) {
-        if (arr == null || arr.length == 0) {
-            return 1;
-        }
-        HashSet<Integer> set = new HashSet<Integer>();
-        process(arr, 0, 0, set);
-
-        int min = Integer.MAX_VALUE;
-        for (int i = 0; i != arr.length; i++) {
-            min = Math.min(min, arr[i]);
-
-        }
-
-        for (int i = min + 1; i != Integer.MIN_VALUE; i++) {
-            if (!set.contains(i)) {
-                return i;
-            }
-        }
-        return 0;
-    }
-    /*使用递归的方式求出数组所有的子集的和
-         index:使用数组下标index及以后的元素
-         sum:当前的和
-        */
-    public static void process(int[] arr, int i, int sum, HashSet<Integer> set) {
-        if (i == arr.length) {
-            set.add(sum);
-            return;
-        }
-        process(arr, i + 1, sum, set);
-        process(arr, i + 1, sum + arr[i], set);
-    }
-
-
-
-    public static int unformedSum2(int [] arr){
-        if(arr==null || arr.length==0)
-            return 1;
-        int sum=0;
-        int min=Integer.MAX_VALUE;
-        for(int i=0;i<arr.length;i++){
-            sum+=arr[i];
-            min=Math.min(min,arr[i]);
-        }
-        boolean[][] dp=new boolean[arr.length][sum+1];
-        for(int i=0;i<arr.length;i++){
-            dp[i][arr[i]]=true;
-
-        }
-        for(int i=1;i<arr.length;i++){
-            for(int j=0;j<dp[0].length;j++){
-                dp[i][arr[i-1]]=true;
-
-            }
-        }
-        for(int j=min+1;j<sum+1;j++){
-            for(int i=0;i<arr.length;i++){
-                if(!dp[i][j])
-                    return j;
-            }
-        }
-        return sum+1;
-
-    }
-
-    public static int[] generateArray(int len, int maxValue) {
-        int[] res = new int[len];
-        for (int i = 0; i != res.length; i++) {
-            res[i] = (int) (Math.random() * maxValue) + 1;
-        }
-        return res;
-    }
-
-    public static void printArray(int[] arr) {
-        for (int i = 0; i != arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-        int len = 27;
-        int max = 30;
-        int[] arr = generateArray(len, max);
-        printArray(arr);
-        long start = System.currentTimeMillis();
-        System.out.println(unformedSum1(arr));
-        long end = System.currentTimeMillis();
-        System.out.println("cost time: " + (end - start) + " ms");
-        System.out.println("======================================");
-        start = System.currentTimeMillis();
-        System.out.println(unformedSum2(arr));
-        end = System.currentTimeMillis();
-        System.out.println("cost time: " + (end - start) + " ms");
-        System.out.println("======================================");
-
-    }
-}
Index: src/左神算法/高频面试题/SmallSum.java
===================================================================
diff --git a/src/左神算法/高频面试题/SmallSum.java b/src/左神算法/高频面试题/SmallSum.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/SmallSum.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,51 +0,0 @@
-package 左神算法.高频面试题;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:数组小和的定义如下：
- * 例如：数组s=[1,3,5,2,4,6],在s[0]的左边小于等于s[0]的数的和为0.在s[1]的左边小于等于s[1]的数的和为1，在s[2]的左边小于等于s[2]的数的和为1+3=4……
- * s的小和等于各个位置的小和的和。给定一个数组s,实现函数返回s的小和。
- * @date 2019/12/28 10:42
- */
-public class SmallSum {
-
-    public static  int getSmallSum(int[] arr)
-    {
-        if(arr==null || arr.length==0)
-            return 0;
-        return func(arr,0,arr.length-1);
-    }
-    public static int func(int[] arr,int l,int r){
-        if(l==r)
-            return 0;
-        int mid=(l+r)/2;
-        return func(arr,l,mid)+func(arr,mid+1,r)+merge(arr,l,r,mid);
-    }
-
-    public static int merge(int[] arr,int left,int right,int mid){
-        int[] help=new int[right-left+1];
-        int h=0;
-        int i=left;
-        int j=mid+1;
-        int smallSum=0;
-        while(i<=mid && j<=right)
-        {
-            if(arr[i]<=arr[j])
-            {   /**仅仅比归并排序多了这一步
-                 */
-                smallSum+=arr[i]*(right-j+1);
-                help[h++]=arr[i++];
-            }else{
-                help[h++]=arr[j++];
-            }
-        }
-        for(;(j<=right)||(i<=mid);j++,i++){
-            help[h++]=i>mid? arr[j]:arr[i];
-        }
-        for(int m=0;i<help.length;m++){
-            arr[left++]=help[i];
-        }
-        return smallSum;
-    }
-}
Index: src/Leetcode/Solution.java
===================================================================
diff --git a/src/Leetcode/Solution.java b/src/Leetcode/Solution.java
deleted file mode 100644
--- a/src/Leetcode/Solution.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,79 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一个非负整数数组，你最初位于数组的第一个位置。
-
-数组中的每个元素代表你在该位置可以跳跃的最大长度。
-
-判断你是否能够到达最后一个位置。
-
-示例 1:
-
-输入: [2,3,1,1,4]
-输出: true
-解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
-
-示例 2:
-
-输入: [3,2,1,0,4]
-输出: false
-解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/jump-game
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/4/21 18:14
- */
-public class Solution {
-
-    public static boolean canJump(int[] nums) {
-        if(nums==null || nums.length==0) {
-            return true;
-        }
-        int len=nums.length;
-        boolean[] dp=new boolean[len];
-        dp[0]=true;
-        //dp[1]=true;
-        for(int i=0;i<len && dp[i]==true;i++){
-            for(int j=1;j<=nums[i];j++){
-                if(dp[len-1]==true) {
-                    return true;
-                }
-                if(i+j>len-1) {
-                    continue;
-                }
-                dp[i+j]=true;
-            }
-
-
-        }
-        
-        return dp[len-1];
-    }
-
-    //贪心
-    public static boolean solution2(int[] nums){
-        if(nums==null || nums.length==0) {
-            return true;
-        }
-        int len=nums.length;
-        int mostRight=0;
-        for(int i=0;i<len;i++){
-            if(i<=mostRight){
-                mostRight=Math.max(mostRight,nums[i]+i);
-            }
-            if(mostRight>=len-1) {
-                return true;
-            }
-
-        }
-        return false;
-    }
-
-    public static void main(String[] args) {
-        int [] arr=new int[]{3,2,1,0,4};
-        System.out.println(canJump(arr));
-    }
-}
Index: src/后端进阶小专栏/Solution.java
===================================================================
diff --git a/src/后端进阶小专栏/Solution.java b/src/后端进阶小专栏/Solution.java
deleted file mode 100644
--- a/src/后端进阶小专栏/Solution.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,12 +0,0 @@
-package 后端进阶小专栏;
-
-/**
- * @Author zbl
- * @Date 2020/11/17 16:52
- * @Content
- * @Version 1.0
- */
-public class Solution {
-    
-
-}
Index: src/Leetcode/Solution1.java
===================================================================
diff --git a/src/Leetcode/Solution1.java b/src/Leetcode/Solution1.java
deleted file mode 100644
--- a/src/Leetcode/Solution1.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,36 +0,0 @@
-package Leetcode;
-
-import java.util.HashMap;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2020/5/21 11:52
- */
-public class Solution1 {
-
-    public static int[] twoSum(int[] nums, int target) {
-        int len=nums.length;
-        int[] res=new int[2];
-        HashMap<Integer,Integer> map = new HashMap<>();
-        for(int i=0;i<len;i++){
-            map.put(nums[i],i);
-
-        }
-        for(int i=0;i<len;i++){
-            if(map.containsKey(target-nums[i]) && map.get(target-nums[i])!=i){
-                res[0]=i;
-                res[1]=map.get(target-nums[i]);
-                break;
-            }
-        }
-        return res;
-    }
-
-    public static void main(String[] args) {
-        int[] arr={3,2,4};
-        int[] res=twoSum(arr,6);
-        System.out.println(res[0]+" "+res[1]);
-    }
-}
Index: src/公司笔面试真题/微软/Solution1.java
===================================================================
diff --git a/src/公司笔面试真题/微软/Solution1.java b/src/公司笔面试真题/微软/Solution1.java
deleted file mode 100644
--- a/src/公司笔面试真题/微软/Solution1.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,53 +0,0 @@
-package 公司笔面试真题.微软;
-
-/**
- * @Author zbl
- * @Date 2020/11/22 14:54
- * @Content:  给定两个已经排序好的数组，找到两者所有元素中第k大的元素
- * @Version 1.0
- */
-public class Solution1 {
-
-    public int getKth(int[] arr1,int [] arr2,int k){
-        int len1=arr1.length;
-        int len2=arr2.length;
-        return process(arr1,0,len1-1,arr2,0,len2-1,k);
-    }
-
-    //二分法,取中间位置的二分
-    public int process(int[] arr1,int start1,int end1,int [] arr2,int start2,int end2,int k){
-        if(end1<start1){
-           return arr2[start2+k-1];
-        }
-        if(end2<start2) return arr1[start1+k-1];
-        //取中间位置：因为无论数组的长度为啥，一定右中间位置
-        int mid1=start1+(end1-start1)/2;
-        int mid2=start2+(end2-start2)/2;
-        //从arr1开始位置到mid位置以及从arr2开始位置到mid位置的总个数
-        int halflen=mid1+mid2-start1-start2+2;
-        if(arr1[mid1]<arr2[mid2]){
-            if(halflen>k){
-                //此时第k个元素一定在arr2[mid]的左边
-                return process(arr1,start1,end1,arr2,start2,mid2-1,k);
-            }else{
-                //此时arr1中的前mid1个元素一定包含在前k个元素中
-                return process(arr1,mid1+1,end1,arr2,start2,end2,k-(mid1-start1+1));
-            }
-        }else{
-            if(halflen>k){
-                //此时第k个元素一定在arr1[mid]的左边
-                return process(arr1,start1,mid1-1,arr2,start2,end2,k);
-            }else{
-                //此时arr2中的前mid1个元素一定包含在前k个元素中
-                return process(arr1,start1,end1,arr2,mid2+1,end2,k-(mid2-start2+1));
-            }
-        }
-    }
-
-    public static void main(String[] args) {
-        String str = "a_b_c_c_d_";
-        String[] s = str.split("_");
-
-    }
-
-}
Index: src/挑战程序设计竞赛/第二章/Solution1.java
===================================================================
diff --git a/src/挑战程序设计竞赛/第二章/Solution1.java b/src/挑战程序设计竞赛/第二章/Solution1.java
deleted file mode 100644
--- a/src/挑战程序设计竞赛/第二章/Solution1.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,52 +0,0 @@
-package 挑战程序设计竞赛.第二章;
-
-/**
- * @Author zbl
- * @Date 2020/12/1 19:15
- * @Content 给定长度为n的字符串S，要构建一个长度为n的字符串T。起初，T是一个空串，随后反复进行下列任意操作：
- * 从S的头部删除一个字符，加到T的尾部
- * 从S的尾部删除一个字符，加到T的尾部
- * 目标：构造字段序尽可能小的字符串T
- * 限制条件：1<=N<=2000;字符串S只包含大写英文字母
- * @Version 1.0
- */
-public class Solution1 {
-    /**
-     * 字典序比较类的问题上经常能用上贪心算法
-     * @param s
-     * @return
-     */
-    public String getResult(String s){
-        if(s==null || s.length()<2) return  s;
-        int n=s.length();
-        StringBuilder sb=new StringBuilder();
-        int left=0,right=n-1;
-
-        while(left<=right){
-            boolean flag=false;//表示是否从s的开头拿一个元素加入到t中
-            //贪心法的思想：找出左右端点尽可能小的元素
-            for(int i=0;left+i<=right;i++){
-                if(s.charAt(left+i)<s.charAt(right-i)){
-                    flag=true;
-                    break;
-                }else if(s.charAt(left+i)>s.charAt(right-i)) {
-                    flag=false;
-                    break;
-                }else{
-                    //当相等的时候就继续找下去，看一下左右相等位置的下一个位置哪个更小，将更小的提前暴露出来
-                    continue;
-                }
-
-            }
-            if(flag) sb.append(s.charAt(left++));
-            else sb.append(s.charAt(right--));
-        }
-        return sb.toString();
-    }
-
-    public static void main(String[] args) {
-        String str="abcabcaba";
-        System.out.println(new Solution1().getResult(str));
-    }
-
-}
Index: src/面试相关/公司笔面试真题/微软/Solution1.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/微软/Solution1.java b/src/面试相关/公司笔面试真题/微软/Solution1.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/微软/Solution1.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,53 +0,0 @@
-package 面试相关.公司笔面试真题.微软;
-
-/**
- * @Author zbl
- * @Date 2020/11/22 14:54
- * @Content:  给定两个已经排序好的数组，找到两者所有元素中第k大的元素
- * @Version 1.0
- */
-public class Solution1 {
-
-    public int getKth(int[] arr1,int [] arr2,int k){
-        int len1=arr1.length;
-        int len2=arr2.length;
-        return process(arr1,0,len1-1,arr2,0,len2-1,k);
-    }
-
-    //二分法,取中间位置的二分
-    public int process(int[] arr1,int start1,int end1,int [] arr2,int start2,int end2,int k){
-        if(end1<start1){
-           return arr2[start2+k-1];
-        }
-        if(end2<start2) return arr1[start1+k-1];
-        //取中间位置：因为无论数组的长度为啥，一定右中间位置
-        int mid1=start1+(end1-start1)/2;
-        int mid2=start2+(end2-start2)/2;
-        //从arr1开始位置到mid位置以及从arr2开始位置到mid位置的总个数
-        int halflen=mid1+mid2-start1-start2+2;
-        if(arr1[mid1]<arr2[mid2]){
-            if(halflen>k){
-                //此时第k个元素一定在arr2[mid]的左边
-                return process(arr1,start1,end1,arr2,start2,mid2-1,k);
-            }else{
-                //此时arr1中的前mid1个元素一定包含在前k个元素中
-                return process(arr1,mid1+1,end1,arr2,start2,end2,k-(mid1-start1+1));
-            }
-        }else{
-            if(halflen>k){
-                //此时第k个元素一定在arr1[mid]的左边
-                return process(arr1,start1,mid1-1,arr2,start2,end2,k);
-            }else{
-                //此时arr2中的前mid1个元素一定包含在前k个元素中
-                return process(arr1,start1,end1,arr2,mid2+1,end2,k-(mid2-start2+1));
-            }
-        }
-    }
-
-    public static void main(String[] args) {
-        int[] arr1={1,2,3,4};
-        int[] arr2={2,4,5,6};
-        System.out.println(new Solution1().getKth(arr1,arr2,5));
-    }
-
-}
Index: src/面试相关/公司笔面试真题/拼多多/Solution1.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/拼多多/Solution1.java b/src/面试相关/公司笔面试真题/拼多多/Solution1.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/拼多多/Solution1.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,58 +0,0 @@
-package 面试相关.公司笔面试真题.拼多多;
-
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:多多鸡有N个魔术盒子（编号1～N），其中编号为i的盒子里有i个球。
-多多鸡让皮皮虾每次选择一个数字X（1 <= X <= N），多多鸡就会把球数量大于等于X个的盒子里的球减少X个。
-通过观察，皮皮虾已经掌握了其中的奥秘，并且发现只要通过一定的操作顺序，可以用最少的次数将所有盒子里的球变没。
-那么请问聪明的你，是否已经知道了应该如何操作呢？
-
-
-
-输入描述:
-第一行，有1个整数T，表示测试用例的组数。
-（1 <= T <= 100）
-接下来T行，每行1个整数N，表示有N个魔术盒子。
-（1 <= N <= 1,000,000,000）
-
-输出描述:
-共T行，每行1个整数，表示要将所有盒子的球变没，最少需要进行多少次操作。
-
-输入例子1:
-3
-1
-2
-5
-
-输出例子1:
-1
-2
-3
- * @date 2020/7/28 18:54
- */
-public class Solution1 {
-
-
-    public static void main(String[] args) {
-        Scanner sc=new Scanner(System.in);
-        int t=sc.nextInt();
-        int[] nums=new int[t];
-        for(int i=0;i<t;i++){
-            nums[i]=sc.nextInt();
-        }
-        for(int i=0;i<t;i++){
-            System.out.println(process(nums[i]));
-        }
-
-    }
-
-    public static int process(int n){
-        if(n==1) return 1;
-        if(n==2) return 2;
-
-        return 1+process(n/2);
-    }
-}
Index: src/面试相关/公司笔面试真题/猿辅导/二一_1/Solution1.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/猿辅导/二一_1/Solution1.java b/src/面试相关/公司笔面试真题/猿辅导/二一_1/Solution1.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/猿辅导/二一_1/Solution1.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,47 +0,0 @@
-package 面试相关.公司笔面试真题.猿辅导.二一_1;
-
-import java.util.Arrays;
-import java.util.PriorityQueue;
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:小明选了 n 门在线课程，每门课程的开始和结束时间为 (s[i], e[i])，小明可以一心多用，
- * 问小明最多需要同时打开多少个播放器窗口才能顺利地上完这些课程。
-
-这个问题的本质是：给定了 n 个区间，问重合的区间的最大数量是多少。
- * @date 2020/8/1 22:32
- */
-public class Solution1{
-
-    public static void main(String[] args) {
-        Scanner sc=new Scanner(System.in);
-        int n=sc.nextInt();
-        int[][] arr=new int[n][2];
-        for(int i=0;i<n;i++){
-            arr[i][0]=sc.nextInt();
-            arr[i][1]=sc.nextInt();
-        }
-
-        Arrays.sort(arr,(a,b)->{
-            if(a[0]!=b[0]){
-                return a[0]-b[0];
-            }else{
-                return b[1]-a[1];
-            }
-        });
-
-        PriorityQueue<Integer> priorityQueue=new PriorityQueue<>();
-        int max=0;
-        for(int i=0;i<n;i++){
-            while(!priorityQueue.isEmpty() && priorityQueue.peek()<=arr[i][0]){
-                priorityQueue.peek();
-            }
-            priorityQueue.add(arr[i][1]);
-            max=Math.max(max,priorityQueue.size());
-        }
-        System.out.println(max);
-
-    }
-}
Index: src/面试相关/公司笔面试真题/猿辅导/二零_1/Solution1.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/猿辅导/二零_1/Solution1.java b/src/面试相关/公司笔面试真题/猿辅导/二零_1/Solution1.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/猿辅导/二零_1/Solution1.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,59 +0,0 @@
-package 面试相关.公司笔面试真题.猿辅导.二零_1;
-
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:K(K>=3)个猿辅导的老师们在玩一个击鼓传花的小游戏。每击一次鼓，拿着花的老师要将花交给别人，不能留在自己手中。游戏开始前花在小猿手中，求击了N次鼓后，这朵花又回到小猿手中的方案数，请输出这个数模1000000007后的结果。
-
-输入描述:
-输入两个数N，K。
-
-20%的数据：(3<=K<=10, 1<= N<=10)
-
-70%的数据：(3<=K<=1000, 1<= N<=1000)
-
-100%的数据：(3<=K<=10^9, 1<= N<=10^9)
-
-输出描述:
-输出方案数模1000000007后的结果
-
-输入例子1:
-3 3
-
-输出例子1:
-2
- * @date 2020/7/26 11:15
- */
-public class Solution1 {
-
-
-
-    private static final int M=1000000007;
-    public static void main(String[] args) {
-        Scanner sc=new Scanner(System.in);
-        int k=sc.nextInt();
-        int n=sc.nextInt();
-        System.out.println(process(k,n));
-    }
-
-    /**
-     * 以下做法超时，应该使用矩阵快速幂来解决
-     * @param k
-     * @param n
-     * @return
-     */
-    public static long  process(int k,int n){
-        if(k<3) return 0;
-        long[][] dp=new long[n+1][2];//dp[i][1]:表示传了i次在小猿手里，dp[i][0]：表示不在小猿手里
-        dp[0][1]=1;
-        dp[0][0]=0;
-        for(int i=1;i<=n;i++){
-            dp[i][1]=dp[i-1][0]%M;
-            dp[i][0]=(((k-1)*dp[i-1][1]) %M+(dp[i-1][0]*(k-2))%M)%M;
-        }
-        return dp[n][1];
-
-    }
-}
Index: src/面试相关/公司笔面试真题/猿辅导/二零_2/Solution1.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/猿辅导/二零_2/Solution1.java b/src/面试相关/公司笔面试真题/猿辅导/二零_2/Solution1.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/猿辅导/二零_2/Solution1.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,67 +0,0 @@
-package 面试相关.公司笔面试真题.猿辅导.二零_2;
-
-import java.util.*;
-
-/**
- * @author zbl
- * @version 2020 校招笔试2
- * @content:猿辅导老师在直播课上和同学们做游戏，让同学们在聊天区报自己的学号，每报一次可以获得一个礼物。但是老师不给报数次数超过了一定的次数的同学发礼物。
-现在请你来帮助老师把聊天区的报数数列处理一下。
-规定，当发现某个数大于 m 次时，则认定为报数过多，我们需要得到去除这些学生的报数后的报数数列。
-
-输入描述:
-第一行：两个数，学生报数总个数n，和允许的最大重复次数 m，以空格分隔
-第二行：n个整数，表示学生所有报数数列，以空格分隔，范围是-2147483648~2147483647
-
-输出描述:
-只有一行，去除超出m次的报数数字后的报数数列，该数列不改变原报数顺序，数列以空格分隔
-
-输入例子1:
-7 2
-4 3 3 3 1 5 5
-
-输出例子1:
-4 1 5 5
-
-输入例子2:
-6 3
-1 2 2 2 2 2
-
-输出例子2:
-1
- * @date 2020/7/25 16:21
- */
-public class Solution1 {
-
-
-    public static void main(String[] args) {
-        Scanner sc=new Scanner(System.in);
-        int n=sc.nextInt();
-        int m=sc.nextInt();
-        int[] arr=new int[n];
-        for(int i=0;i<n;i++){
-            arr[i]=sc.nextInt();
-        }
-
-        List<Integer> list = process(n, m, arr);
-        for(int i=0;i< list.size();i++){
-            System.out.print(list.get(i)+" ");
-        }
-    }
-    private static List<Integer> process(int n, int m, int[] arr){
-        HashMap<Integer,Integer> map=new HashMap<>();
-        List<Integer> list=new ArrayList<>();
-        for(int i=0;i<n;i++){
-            map.put(arr[i],map.getOrDefault(arr[i],0)+1);
-        }
-        for(int i=0;i<n;i++){
-            if(map.get(arr[i])<=m){
-                if(!list.contains(arr[i]))
-                list.add(arr[i]);
-            }
-        }
-        return list;
-    }
-
-
-}
Index: src/面试相关/公司笔面试真题/猿辅导/二零_3/Solution1.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/猿辅导/二零_3/Solution1.java b/src/面试相关/公司笔面试真题/猿辅导/二零_3/Solution1.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/猿辅导/二零_3/Solution1.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,168 +0,0 @@
-package 面试相关.公司笔面试真题.猿辅导.二零_3;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:中午是猿辅导水果时间，小猿会给每个同学发水果。猿辅导有一个矩形的办公区域，共有N 排，每排M个工位。平时小猿按照从第一排到最后一排的顺序发水果，某一天小猿突然发现似乎旋转着发水果是一种更有趣的方式，所以决定试试按照逆时针方向螺旋发水果。
-已知每个工位有一个数字，表示该工位员工的工号，每个员工的工号不同。已知小猿从（0, 0）位置开始，按照逆时针螺旋的顺序发水果，请输出收到水果的员工工号序列。
-
-输入描述:
-第一行 两个数， 数组行列 N，M
-接下来 N 行，每行 M 个正整数，表示每个位置的员工工号
-1 ≤ N ≤ 1000
-1 ≤ M ≤ 1000
-
-输出描述:
-发放水果工号序列
-
-输入例子1:
-3 3
-1 2 3
-4 5 6
-7 8 9
-
-输出例子1:
-1 4 7 8 9 6 3 2 5
- * @date 2020/7/25 21:15
- */
-public class Solution1 {
-
-    public static void main(String[] args) {
-        Scanner sc=new Scanner(System.in);
-        int n=sc.nextInt();
-        int m=sc.nextInt();
-        int[][] matrix=new int[n][m];
-        for(int i=0;i<n;i++){
-            for(int j=0;j<m;j++){
-                matrix[i][j]=sc.nextInt();
-            }
-        }
-
-        List<Integer> list=process(matrix,n,m);
-        for(Integer num:list){
-            System.out.print(num+" ");
-        }
-    }
-
-    private static List<Integer> process(int[][] matrix, int n, int m){
-       List<Integer>list=new ArrayList<>();
-       int rs=0,cs=0,re=n-1,ce=m-1;
-       while(rs<=re && cs<=ce){
-           if(rs==re){
-               for(int i=cs;i<=ce;i++){
-                   list.add(matrix[rs][i]);
-               }
-           }else if(cs==ce){
-               for(int i=rs;i<=re;i++){
-                   list.add(matrix[i][ce]);
-               }
-           }else{
-               for(int i=rs;i<=re;i++){
-                   list.add(matrix[i][cs]);
-               }
-
-               list.remove(list.size()-1);
-
-               for(int i=cs;i<=ce;i++){
-                   list.add(matrix[re][i]);
-               }
-               list.remove(list.size()-1);
-               for(int i=re;i>=rs;i--){
-                   list.add(matrix[i][ce]);
-               }
-               list.remove(list.size()-1);
-               for(int i=ce;i>=cs;i--){
-                   list.add(matrix[rs][i]);
-               }
-               list.remove(list.size()-1);
-           }
-           rs++;
-           cs++;
-           re--;
-           ce--;
-       }
-       return list;
-    }
-
-    /**
-     * 或者如下写法
-     */
-//public static void main(String[] args){
-//
-//    Scanner sc = new Scanner(System.in);
-//    int N = sc.nextInt();
-//    int M = sc.nextInt();
-//    int[][] matrix = new int[N][M];
-//    for(int i = 0;i < N; i++){
-//        for(int j=  0;j < M;j++){
-//            matrix[i][j] = sc.nextInt();
-//            //    System.out.print(matrix[i][j]+" ");
-//        }
-//        //  System.out.println();
-//    }
-//
-//    int[] res = fruits(matrix);
-//    for(int i = 0 ; i< res.length - 1;i++){
-//        System.out.print(res[i] + " ");
-//    }
-//    System.out.print(res[res.length - 1]);
-//
-//}
-//
-//    public static int[] fruits(int[][] matrix){
-//        //1 <= m , n <= 1000
-//        //不需要特点判断
-//        int m = matrix.length;
-//        int n = matrix[0].length;
-//        if(m == 1 && n==1){
-//            int[] res = new int[]{matrix[0][0]};
-//            return res;
-//        }
-//        int[] res = new int[m * n];
-//        int index = 0;
-//        int up = 0 ;
-//        int down = m -1;
-//        int left = 0;
-//        int right = n -1;
-//        while(index < m * n){
-//
-//            for(int i = up;i <= down;i++)
-//            {
-//                res[index++] = matrix[i][left];
-//            }
-//            left++;
-//            if(left > right){
-//                break;
-//            }
-//            for(int j = left;j <= right;j++){
-//                res[index++] = matrix[down][j];
-//            }
-//            down--;
-//            if(down < up){
-//                break;
-//            }
-//            for(int i = down;i >= up;i--){
-//                res[index++] = matrix[i][right];
-//            }
-//            right--;
-//            if(right < left){
-//                break;
-//            }
-//            for(int j = right;j >= left;j--){
-//                res[index++] = matrix[up][j];
-//            }
-//            up++;
-//            if(up > down){
-//                break;
-//            }
-//        }
-//
-//        return res;
-//    }
-
-
-}
Index: src/面试相关/公司笔面试真题/猿辅导/Solution1.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/猿辅导/Solution1.java b/src/面试相关/公司笔面试真题/猿辅导/Solution1.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/猿辅导/Solution1.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,44 +0,0 @@
-package 面试相关.公司笔面试真题.猿辅导;
-
-import java.util.Stack;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一个二叉搜索树，并给出他的前序序列，输出中序序列，时间复杂度O(n)
- * @date 2020/8/24 20:49
- */
-public class Solution1 {
-
-    //利用单调栈，栈中元素从大到小排列
-
-    public static int[] process(int[] arr){
-        if(arr==null || arr.length==0)
-            return new int[0];
-        if(arr.length==1) return arr;
-        int n=arr.length;
-        int[] res=new int[n];
-        Stack<Integer> stack=new Stack<>();
-        int index=0;
-        for(int i=0;i<n;i++){
-            while(!stack.isEmpty() && stack.peek()<arr[i]){
-                res[index++]=stack.pop();
-            }
-            stack.push(arr[i]);
-        }
-
-        while(!stack.isEmpty()){
-            res[index++]=stack.pop();
-        }
-        return res;
-    }
-
-    public static void main(String[] args) {
-        int[] arr={5,2,1,3,7,6,8};
-        int[] res=process(arr);
-        for(int num :res){
-            System.out.println(num);
-        }
-    }
-
-}
Index: src/面试相关/公司笔面试真题/网易/二一/Solution1.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/网易/二一/Solution1.java b/src/面试相关/公司笔面试真题/网易/二一/Solution1.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/网易/二一/Solution1.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,62 +0,0 @@
-package 面试相关.公司笔面试真题.网易.二一;
-
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:现在有n个物品，每一个物品都有一个价值，现在想将这份物品分给两个人，要求这两个人每一个人
- * 分到的物品的价值总和相同（个数可以不同），剩下的物品就需要扔掉，现在想知道最少需要扔掉多少价值的物品才能满足要求
- * @date 2020/8/8 17:57
- */
-public class Solution1 {
-
-
-    public static void main(String[] args) {
-        Scanner sc=new Scanner(System.in);
-        int t=sc.nextInt();
-        while(t>0){
-            t--;
-            int n=sc.nextInt();
-            int[] arr=new int[n];
-            for(int i=0;i<n;i++){
-                arr[i]=sc.nextInt();
-            }
-
-            System.out.println(new Solution1().new Solution().process(n,arr));
-        }
-    }
-
-    class Solution{
-        int n;
-        int[] arr;
-        int res=Integer.MAX_VALUE;
-
-
-        public int process(int n,int[] arr){
-            this.n=n;
-            this.arr=arr;
-            dfs(n-1,0,0,0);
-            return res;
-        }
-
-        /**
-         *
-         * @param index:遍历到数组中的第几个元素了
-         * @param p1：第一个人持有的总价值
-         * @param p2:第二个人持有的总价值
-         * @param value：丢弃的总价值
-         */
-        private void dfs(int index,int p1,int p2,int value){
-            if(index==-1){
-                if(p1==p2 && value<res) res=value;
-                return;
-            }
-
-            dfs(index-1,p1+arr[index],p2,value);//分配给第一个人
-            dfs(index-1,p1,p2+arr[index],value);//分配给第二个人
-            dfs(index-1,p1,p2,value+arr[index]);//直接丢弃
-
-        }
-    }
-}
Index: src/挑战程序设计竞赛/第二章/Solution2.java
===================================================================
diff --git a/src/挑战程序设计竞赛/第二章/Solution2.java b/src/挑战程序设计竞赛/第二章/Solution2.java
deleted file mode 100644
--- a/src/挑战程序设计竞赛/第二章/Solution2.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,41 +0,0 @@
-package 挑战程序设计竞赛.第二章;
-
-import java.util.Arrays;
-
-/**
- * @Author zbl
- * @Date 2020/12/2 18:49
- * @Content:
- * 直线上有N个点，点i的位置为Xi。从这N个点中选择若干个，给他们加上标记。对每一个点，其距离为R
- * 以内的区域里必须有带有标记的点，在满足这个条件的情况下，给出最少需要多少个点加标记
- * @Version 1.0
- */
-public class Solution2 {
-
-    public int getMin(int[] arr,int R){
-
-        Arrays.sort(arr);//从小到达排序
-        int n=arr.length;
-        int ans=0;
-        int idx=0;
-
-        while(idx<n){
-            int pos=arr[idx++];//距离下一个要确定的做标记点最左边的点的位置
-            while(idx<n && arr[idx]-pos<=R){
-                idx++;
-            }
-            int target=arr[idx-1];//加标记的点
-            while(idx<n && arr[idx]-target<=R){//寻找下一个最左端的点的位置
-                idx++;
-            }
-            ans++;
-
-        }
-        return ans;
-    }
-
-    public static void main(String[] args) {
-          int[] arr=new int[]{3,2,6,8,10,13};
-        System.out.println(new Solution2().getMin(arr,3));
-    }
-}
Index: src/面试相关/公司笔面试真题/拼多多/Solution2.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/拼多多/Solution2.java b/src/面试相关/公司笔面试真题/拼多多/Solution2.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/拼多多/Solution2.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,78 +0,0 @@
-package 面试相关.公司笔面试真题.拼多多;
-
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:数列 {An} 为N的一种排列。
-例如N=3，可能的排列共6种：
-1
-2
-3
-4
-5
-6
-1, 2, 3
-1, 3, 2
-2, 1, 3
-2, 3, 1
-3, 1, 2
-3, 2, 1
-定义函数F:
-
-其中|X|表示X的绝对值。
-
-现在多多鸡想知道，在所有可能的数列 {An} 中，F(N)的最小值和最大值分别是多少。
-
-输入描述:
-第一行输入1个整数T，表示测试用例的组数。
-( 1 <= T <= 10 )
-第二行开始，共T行，每行包含1个整数N，表示数列 {An} 的元素个数。
-( 1 <= N <= 100,000 )
-
-输出描述:
-共T行，每行2个整数，分别表示F(N)最小值和最大值
-
-输入例子1:
-2
-2
-3
-
-输出例子1:
-1 1
-0 2
-
-例子说明1:
-对于N=3：
-- 当{An}为3，2，1时可以得到F(N)的最小值0
-- 当{An}为2，1，3时可以得到F(N)的最大值2
- * @date 2020/7/29 20:32
- */
-public class Solution2{
-
-        public static void main(String[] args) {
-            Scanner sc=new Scanner(System.in);
-            int n=sc.nextInt();
-            long[] nums=new long[n];//因为有可能越界，所以这里设置成long类型
-            for(int i=0;i<n;i++){
-                nums[i]=sc.nextLong();
-            }
-            for(int i=0;i<n;i++){
-                long[] res=process(nums[i]);
-                System.out.println(res[0]+" "+res[1]);
-            }
-
-        }
-
-        public static long[] process(long n){
-            long[] res=new long[2];
-            long sum=n*(n+1)/2;
-            if(sum%2==1) res[0]=1;//最小值
-            else res[0]=0;
-            long help=(n-1)*n/2;
-            res[1]=n-(int)(help%2);//最大值=n-(n-1)时的最小值
-            return res;
-
-        }
-}
Index: src/面试相关/公司笔面试真题/猿辅导/二零_1/Solution2.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/猿辅导/二零_1/Solution2.java b/src/面试相关/公司笔面试真题/猿辅导/二零_1/Solution2.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/猿辅导/二零_1/Solution2.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,81 +0,0 @@
-package 面试相关.公司笔面试真题.猿辅导.二零_1;
-
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:有一个N*M大小的迷宫矩阵，迷宫的每一个格子有一个数值（a[i][j] <10^9）。小猿在迷宫中发现，它只能朝着上下左右四个方向的相邻格子前进，并且只能进入比当前位置数值更大的格子。但是小猿有个紧急呼救按钮，他可以通过按下按钮，强行进入到不满足数值大小要求的相邻格子，可惜这个按钮只能按K次。请问小猿从这个迷宫任选一个格子出发，在紧急呼救按钮的帮助下，最多能走多少步（开始位置计入步数，即站在起点是步数为1）。
-
-输入描述:
-第一行输入三个数N, M, K。接下来N行，每行M个数，表示迷宫中每个格子的值。
-1 ≤ N ≤ 500
-1 ≤ M ≤ 500
-0 ≤ K ≤ 10
-
-输出描述:
-输出小猿在迷宫中能走的最大步数
-
-输入例子1:
-3 3 1
-1 3 3
-2 4 9
-8 9 2
-
-输出例子1:
-6
-
-例子说明1:
-其中一种行走方案： (0, 0) -> (0, 1) -> (0, 0) -> (1, 0) -> (2, 0) -> (2, 1)
- * @date 2020/7/26 14:38
- */
-public class Solution2 {
-
-    public static int max=1;
-    public static int[] dr={1,0,-1,0};
-    public static int[] dc={0,1,0,-1};
-    public static void main(String[] args) {
-        Scanner sc=new Scanner(System.in);
-        int n=sc.nextInt();
-        int m=sc.nextInt();
-        int k=sc.nextInt();
-        int[][] matrix=new int[n][m];
-        for(int i=0;i<n;i++){
-            for(int j=0;j<m;j++)
-                matrix[i][j]=sc.nextInt();
-        }
-
-        int[][][] dp=new int[n][m][k+1];//从i,j位置出发，有k次机会最多能走的步数
-        for(int i=0;i<n;i++){
-            for(int j=0;j<m;j++){
-                max=Math.max(max,process(i,j,matrix,k,dp));
-            }
-        }
-
-        System.out.println(max);
-
-    }
-
-    public static int process(int i,int j,int[][] matrix,int k,int[][][] dp){
-
-        if(i<0 || j<0 || i>=matrix.length || j>=matrix[0].length)
-            return 0;
-        if(k>=0 && dp[i][j][k]!=0)
-            return dp[i][j][k];
-        int ans=0;
-        for(int m=0;m<4;m++){
-            int newr=i+dr[m];
-            int newc=j+dc[m];
-            if(newr>=0 && newr<matrix.length
-            && newc>=0 && newc<matrix[0].length && matrix[newr][newc]>matrix[i][j]){
-                ans=Math.max(ans,process(newr,newc,matrix,k,dp));
-            }else{
-                if(k>0)
-                ans=Math.max(ans,process(newr,newc,matrix,k-1,dp));
-            }
-        }
-        ans+=1;
-        dp[i][j][k]=ans;
-        return ans;
-    }
-}
Index: src/面试相关/公司笔面试真题/猿辅导/二零_2/Solution2.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/猿辅导/二零_2/Solution2.java b/src/面试相关/公司笔面试真题/猿辅导/二零_2/Solution2.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/猿辅导/二零_2/Solution2.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,183 +0,0 @@
-package 面试相关.公司笔面试真题.猿辅导.二零_2;
-
-import java.util.HashMap;
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:  2020 校招笔试2
- * 小猿有一台打字机，只能打出‘A’、‘B’、‘C’三种字符。某天，小猿打了一段长度为N的字符串1，然后发现可以通过打字机的快捷操作来快速改写字符串。
-已知一次快捷操作必须同时改写K个不同位置的字符，且被改写的字符必须改成打字机可以打出的其他字符。例如，K=2时，"AB"可以被改写为"CA"，也可以被改写为"BC"，但不可以被改写为"AA"(必须恰好改写K个字符)或"EF"。
-可以请问通过M次快捷操作，能有多少种将字符串1改写为目标字符串2的方案？输出方案数对1000000007取模的结果。
-
-输入描述:
-第一行输入三个整数，N、M、K。
-接下来两行输入原始字符串1和目标字符串2。
-1 ≤ N ≤ 100
-1 ≤ M ≤ 100
-0 ≤ K ≤ N
-
-输出描述:
-方案数对1000000007取模的结果
-
-输入例子1:
-3 2 3
-AAA
-CCC
-
-输出例子1:
-1
-
-例子说明1:
-只有 AAA -> BBB -> CCC 一种方案
-
-输入例子2:
-2 2 2
-AA
-AA
-
-输出例子2:
-4
-
-例子说明2:
-AA->BB->AA
-
-AA->BC->AA
-
-AA->CB->AA
-
-AA->CC->AA
-
-4种方案
- * @date 2020/7/25 17:59
- */
-public class Solution2 {
-
-    private static int res=0;
-    private static final int M=1000000007;
-    public static void main(String[] args) {
-        Scanner sc=new Scanner(System.in);
-        int n=sc.nextInt();//长度
-        int m=sc.nextInt();//m次快捷操作
-        int k=sc.nextInt();//每次操作修改k个数
-        String source=sc.next();
-        String target=sc.next();
-        if(source.length()!=target.length()){
-            System.out.println(0);
-            return;
-        }
-        HashMap<String,Integer>map=new HashMap<>();//key:str val:剩余修改的次数
-        char[] chs={'A','B','C'};
-        process(source,target,n,m,k,chs,map);
-        System.out.println(res);
-    }
-
-    public static int process(String source, String target, int n, int m, int k,
-
-                               char[] chs, HashMap<String,Integer>map){
-
-
-        if(m==0 && source.equals(target)){
-            return 1;
-        }
-        String key=source+"_"+m;
-        if(map.containsKey(key))
-            return map.get(key);
-
-        int res=0;
-        if(m>0){
-            String tmp=source;
-            for(int i=0;i<=n-k;i++)
-                for(int s=i;s<n;s++)
-                    for(int j=0;j<k;j++)
-                        for(int p=0;p<3;p++){
-
-
-
-                        }
-        }
-    return 1;
-
-    }
-    /**
-     * c++写法
-     */
-//    #include<iostream>
-//#include<vector>
-//#include<queue>
-//#include<string>
-//#include<functional>
-//#define LL long long
-//    using namespace std;
-//    int main()
-//    {
-//        LL n, m, k;
-//        cin >> n >> m >> k;
-//        string s1, s2;
-//        cin >> s1 >> s2;
-//        int cnt = 0;
-//        for (int i = 0; i < n; i++)
-//        {
-//            if (s1[i] == s2[i])cnt++;
-//        }
-//        if (k == 0)
-//        {
-//            if (s1.compare(s2) == 0)
-//                cout << "1" << endl;
-//            else cout << "0" << endl;
-//            return 0;
-//        }
-//        int mod = 1e9 + 7;
-//        vector<vector<LL>>C(n + 1, vector<LL>(n + 1, 0));
-//        vector<vector<LL>>change(n + 1, vector<LL>(n + 1, 0));//the coefficient of change[a-i+j] to change[a]
-//        vector<LL>mi;
-//        mi.push_back(1);
-//        for (int i = 0; i <= k; i++)
-//        {
-//            mi.push_back(mi.back() % mod << 1);
-//            //cout << mi.back() << endl;
-//        }
-//        for (int i = 0; i < n + 1; i++)
-//            C[i][0] = 1;
-//        for (int i = 1; i < n + 1; i++)
-//        {
-//            for (int j = 1; j <= i; j++)
-//            {
-//                C[i][j] = C[i - 1][j] + C[i - 1][j - 1];
-//                C[i][j] %= mod;
-//            }
-//        }
-//        for (int a = 0; a <= n; a++)
-//        {
-//            for (int i = 0; i <= k; i++)
-//            {
-//                int tmp = mi[i] * C[a][i] % mod * C[n - a][k - i] % mod;
-//                for (int j = 0; j <= k - i; j++)
-//                {
-//                    if (a - i + j >= 0 && a - i + j <= n)
-//                        change[a][a - i + j] = (tmp*C[k - i][j]+change[a][a - i + j]) % mod;
-//                }
-//            }
-//        }
-//        vector<int>ans(n + 1, 0), mm;
-//        ans[n] = 1;
-//        while (m--)
-//        {
-//            mm.clear();
-//            for (int i = 0; i <= n; i++)
-//            {
-//                int tmp = 0;
-//                for (int j = 0; j <= n; j++)
-//                {
-//                    tmp = (change[i][j] * ans[j]+tmp) % mod;
-//                }
-//                mm.push_back(tmp);
-//            }
-//            ans = mm;
-//        }
-//
-//        cout << ans[cnt] << endl;
-//    }
-
-}
Index: src/面试相关/公司笔面试真题/猿辅导/二零_3/Solution2.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/猿辅导/二零_3/Solution2.java b/src/面试相关/公司笔面试真题/猿辅导/二零_3/Solution2.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/猿辅导/二零_3/Solution2.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,239 +0,0 @@
-package 面试相关.公司笔面试真题.猿辅导.二零_3;
-
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:猿辅导课程中需要记录各个班的同学们的出勤情况并进行班级排名，授予冠军班级的奖励。
-
-但是今天粗心的小猿出公司门的时候摔了一跤，把榜单给弄丢了，幸好考勤记录还没丢，但是顺序被弄乱了，现在他把考勤记录和班级名册整理了一下，请你写个程序，帮他把班级排名恢复吧！
-
-排名规则是各班的出勤率，即老师在教室时同学们在教室听讲的比例，具体为：班级同学有效出勤分钟数之和/(老师在教室时间*班级人数)，出勤率相同的班级，按班级名称的字典序进行排序。
-其中，有效出勤分钟数表示该同学与老师同在教室内的时间和，即各个区间的结束时间(分)与开始时间(分)之差的和。
-
-输入描述:
-第一行为两个数字N，M，以空格分隔，分别表示总考勤记录数和班级个数。
-
-接下来M行，每行表示一个班级的情况，其中第i+1行数据为：
-
-数字Ki表示该班级人数，数字ti表示该班老师的用户id，namei表示班级的名称，接下来Ki个数字表示该班的同学的用户id。
-
-例如：3 999 yuanxiaoyiban 0001 0002 0004
-
-表示yuanxiaoyiban班的老师id为999，3位同学的用户id分别为0001，0002，0004
-
-接下来N行表示乱序的考勤记录，每一行表示一条记录，记录由命令cmdj表示进出教室情况，有IN和OUT两种，数字idj表示进出教室的用户id，timej表示该记录发生的时间距2000年1月1日的分钟数。
-
-例如：IN 999 1表示id为999的用户在2000年1月1日00:01进入了教室。
-
-数据保证，
-所有人开始和结束记录时都不在教室内；
-每个班级的老师在教室时间和班级人数不为0；同一个用户在同一分钟可以进出教室各一次；班级名称各不相同。
-
-输出描述:
-共M行，第i行为排名为i的班级的名称。
-
-输入例子1:
-12 2
-3 999 yuanxiaoyiban 0001 0002 0004
-2 9988 yuanxiaoerban 0003 0009
-IN 0001 9001
-OUT 0001 9006
-IN 999 8888
-OUT 999 8888
-IN 999 9003
-OUT 999 9004
-IN 9988 9005
-OUT 9988 9006
-IN 0003 9001
-OUT 0003 9002
-IN 0003 9005
-OUT 0003 9006
-
-输出例子1:
-yuanxiaoerban
-yuanxiaoyiban
-
-例子说明1:
-yuanxiaoyiban出勤率为1/3，yuanxiaoerban出勤率为1/2，因此yuanxiaoerban比yuanxiaoyiban出勤率高
- * @date 2020/7/25 21:57
- */
-public class Solution2 {
-
-
-    public static class ClassName{
-        public int k;//班级人数
-        public int tid;//教师id
-        public String name;//班级名称
-        public int[] nums=new int[k];//班级同学编号
-    }
-
-    public static class Person{
-        public String inOut;//进出
-        public int  id;//用户id
-        public long time;//分钟数
-    }
-
-    public static void main(String[] args) {
-        Scanner sc=new Scanner(System.in);
-        int n=sc.nextInt();//总考勤记录
-        int m=sc.nextInt();//班级数
-        ClassName[] classes=new ClassName[m];
-        Person[] persons=new Person[n];
-        for(int i=0;i<m;i++){
-            classes[i]=new ClassName();
-            classes[i].k=sc.nextInt();
-            classes[i].tid=sc.nextInt();
-            classes[i].name=sc.next();
-
-            for(int j=0;j<classes[i].k;j++){
-                classes[i].nums=new int[classes[i].k];
-                classes[i].nums[j]=sc.nextInt();
-            }
-        }
-
-        for(int i=0;i<n;i++) {
-            persons[i] = new Person();
-            persons[i].inOut = sc.next();
-            persons[i].id = sc.nextInt();
-            persons[i].time = sc.nextLong();
-        }
-        String[] res=process(persons,classes,m,n);
-    }
-
-    public static String[] process(Person[] persons,ClassName[] classes,int m,int n){
-
-        for(int i=0;i<m;i++){
-            int tid=classes[i].tid;
-            int[] stus=classes[i].nums;
-
-        }
-        return null;
-    }
-
-    /**
-     * c++写法
-     */
-//    #include <vector>
-//#include <iostream>
-//#include <unordered_map>
-//#include <set>
-//#include <map>
-//#include <string>
-//#include <functional>
-//#include <algorithm>
-//
-//    using namespace std;
-//
-//    bool compare(pair<double, string>& p1, pair<double, string>& p2)
-//    {
-//        if (p1.first == p2.first){
-//            return p1.second < p2.second;
-//        }
-//
-//        return p1.first > p2.first;
-//    }
-//
-//    int main()
-//    {
-//        int N, M;
-//        cin >> N;
-//        cin >> M;
-//
-//        unordered_map<int, pair<string, int>> tMap;
-//        unordered_map<int, int> sMap;
-//        for(int i = 0; i < M; i++){
-//            int num;
-//            int tId;
-//            string name;
-//            cin >> num;
-//            cin >> tId;
-//            cin >> name;
-//            tMap[tId] = {name, num};
-//            for(int j = 0; j < num; j++){
-//                int sId;
-//                cin >> sId;
-//                sMap[sId] = tId;
-//            }
-//        }
-//
-//        unordered_map<int, multiset<pair<int, int>>> tTime;
-//        unordered_map<int, multiset<pair<int, int>>> sTime;
-//        for(int i = 0; i < N; i++){
-//            string dir;
-//            int id;
-//            int time;
-//            cin >> dir;//IN
-//            cin >> id;
-//            cin >> time;
-//
-//            if(tMap.count(id)){//是老师
-//                if(dir == "IN"){
-//                    tTime[id].insert({time, 0});
-//                }else{
-//                    tTime[id].insert({time, 1});
-//                }
-//            }else{//是学生
-//                if(dir == "IN"){
-//                    sTime[sMap[id]].insert({time, 0});
-//                }else{
-//                    sTime[sMap[id]].insert({time, 1});
-//                }
-//            }
-//        }
-//
-//        //cout << "pass" << endl;
-//        unordered_map<int, vector<vector<int>>> ttTime;
-//        for(auto &c : tTime){
-//        int id = c.first;
-//        int left = 0;
-//        for(auto &v : c.second){
-//            if(v.second == 0){
-//                ttTime[id].push_back({v.first});
-//            }else{
-//                ttTime[id][left++].push_back(v.first);
-//            }
-//        }
-//    }
-//
-//
-//        unordered_map<int, vector<vector<int>>> ssTime;
-//        for(auto &c : sTime){
-//        int id = c.first;
-//        int left = 0;
-//        for(auto &v : c.second){
-//            if(v.second == 0){
-//                ssTime[id].push_back({v.first});
-//            }else{
-//                ssTime[id][left++].push_back(v.first);
-//            }
-//        }
-//    }
-//
-//
-//        vector<pair<double, string>> ret;
-//        for(auto &c : ttTime){
-//        int tId = c.first;
-//        long long tSum = 0;
-//        long long sum = 0;
-//        for(auto &t : c.second){
-//            tSum += t[1] - t[0];
-//            for(auto &s : ssTime[tId]){
-//                if(s[0] >= t[1] || s[1] <= t[0]){
-//                    continue;
-//                }
-//                sum += min(t[1], s[1]) - max(t[0], s[0]);
-//            }
-//        }
-//        ret.push_back({(double)sum / (double)(tSum * tMap[tId].second), tMap[tId].first});
-//    }
-//
-//        sort(ret.begin(), ret.end(), compare);
-//        for(auto &v : ret){
-//        cout << v.second << endl;
-//    }
-//
-//        return 0;
-//    }
-}
Index: src/面试相关/公司笔面试真题/猿辅导/Solution2.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/猿辅导/Solution2.java b/src/面试相关/公司笔面试真题/猿辅导/Solution2.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/猿辅导/Solution2.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,34 +0,0 @@
-package 面试相关.公司笔面试真题.猿辅导;
-
-import java.util.Stack;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:2.给定一个数组，求另一个数组是否为该数组的栈输出序列。
-
- * @date 2020/8/26 21:53
- */
-public class Solution2 {
-
-    public static boolean process(int[] arr1,int[] arr2){
-        if(arr1.length!=arr2.length)
-            return false;
-        Stack<Integer> stack=new Stack<>();
-        int index=0;
-        for(int i=0;i<arr1.length;i++){
-            stack.push(arr1[i]);
-            while(!stack.isEmpty() && stack.peek()==arr2[index]){
-                stack.pop();
-                index++;
-            }
-
-        }
-        return stack.isEmpty();
-    }
-
-    public static void main(String[] args) {
-
-    }
-
-}
Index: src/Leetcode/Solution3.java
===================================================================
diff --git a/src/Leetcode/Solution3.java b/src/Leetcode/Solution3.java
deleted file mode 100644
--- a/src/Leetcode/Solution3.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,49 +0,0 @@
-package Leetcode;
-
-import java.util.HashSet;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
-
-示例 1:
-
-输入: "abcabcbb"
-输出: 3
-解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
-
-示例 2:
-
-输入: "bbbbb"
-输出: 1
-解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/4/25 15:03
- */
-public class Solution3 {
-
-    public static  int lengthOfLongestSubstring(String s) {
-        if(s==null || s.length()==0) return 0;
-        char[] chs=s.toCharArray();
-        int len=chs.length,left=0,right=0,max=0;
-        HashSet<Character> set=new HashSet<>();
-        while(right<len){
-            if(!set.contains(chs[right])){
-                set.add(chs[right++]);
-                max=Math.max(max,right-left);
-            }else{
-                set.remove(chs[left++]);
-            }
-        }
-        return max;
-    }
-
-    public static void main(String[] args) {
-        String s="abcabcbb";
-        System.out.println(lengthOfLongestSubstring(s));
-    }
-}
Index: src/面试相关/公司笔面试真题/拼多多/Solution3.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/拼多多/Solution3.java b/src/面试相关/公司笔面试真题/拼多多/Solution3.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/拼多多/Solution3.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,51 +0,0 @@
-package 面试相关.公司笔面试真题.拼多多;
-
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:多多鸡打算造一本自己的电子字典，里面的所有单词都只由a和b组成。
-每个单词的组成里a的数量不能超过N个且b的数量不能超过M个。
-多多鸡的幸运数字是K，它打算把所有满足条件的单词里的字典序第K小的单词找出来，作为字典的封面。
-
-输入描述:
-共一行，三个整数N, M, K。(0 < N, M < 50, 0 < K < 1,000,000,000,000,000)
-
-输出描述:
-共一行，为字典序第K小的单词。
-
-输入例子1:
-2 1 4
-
-输出例子1:
-ab
-
-例子说明1:
-满足条件的单词里，按照字典序从小到大排列的结果是
-a
-aa
-aab
-ab
-aba
-b
-ba
-baa
- * @date 2020/7/29 21:37
- */
-public class Solution3 {
-
-    public static void main(String[] args) {
-        Scanner sc=new Scanner(System.in);
-        int n=sc.nextInt();
-        int m=sc.nextInt();
-        long k=sc.nextInt();
-        StringBuilder sb=new StringBuilder();
-        System.out.println(process(n,m,k,sb));
-    }
-
-    private static int process(int n,int m,long k,StringBuilder sb){
-
-        return 1;
-    }
-}
Index: src/面试相关/公司笔面试真题/猿辅导/二零_1/Solution3.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/猿辅导/二零_1/Solution3.java b/src/面试相关/公司笔面试真题/猿辅导/二零_1/Solution3.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/猿辅导/二零_1/Solution3.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,182 +0,0 @@
-package 面试相关.公司笔面试真题.猿辅导.二零_1;
-
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:猿辅导APP需要下发一些宣传文本给学生，工程师们使用了一种字符压缩算法，为简单起见，假设被压缩的字符全部为大写字母序列，A,B,C,D....Z,压缩规则如下：
-1.AAAB可以压缩为A3B (单字符压缩不加括号)
-2.ABABA可以压缩为(AB)2A （多字符串压缩才加括号）
-
-输入数据保证不会出现冗余括号，且表示重复的数字一定合法且大于1，即不会出现：
-1.（A)2B   ------- （应为：A2B）
-2.  ((AB))2C,-----(应为：（AB)2C  )
-3. （A)B  ----- （应为：AB）
-4.   A1B，（AB)1C，（应为 AB，ABC）
-
-注意：数字可能出现多位数即A11B或者(AB)10C或者A02这种情况。
-A11B = AAAAAAAAAAAB
-(AB)10C = ABABABABABABABABABABC
-A02 = AA
-
-数据分布：
-对于60%的数据，括号不会出现嵌套，即不会有 ((AB)2C)2这种结构。
-对于80%的数据，括号最多只嵌套一层，即不会有 (((AB)2C)2D)99 这种结构。
-对于100%的数据，括号可以嵌套任意层。
-
-输入描述:
-第一行是正整数C(C <= 100)，表示下面有C组数据。之后C行，每行为一组数据，每组数据为一个字符串。
-
-每个字符串由A-Z,数字0-9和(,)组成表示一个压缩后的串，保证输入数据一定合法且字符串长度小于50。
-
-输出描述:
-输出C行，每行对应一个数据的输出结果，表示压缩前的字符串，保证每个字符串展开后的长度不超过10^6。
-
-输入例子1:
-5
-A11B
-(AA)2A
-((A2B)2)2G
-(YUANFUDAO)2JIAYOU
-A2BC4D2
-
-输出例子1:
-AAAAAAAAAAAB
-AAAAA
-AABAABAABAABG
-YUANFUDAOYUANFUDAOJIAYOU
-AABCCCCDD
- * @date 2020/7/26 13:03
- */
-public class Solution3 {
-
-    public static void main(String[] args) {
-        Scanner sc=new Scanner(System.in);
-        int c=sc.nextInt();
-        String[] strs=new String[c];
-        for(int i=0;i<c;i++){
-            strs[i]=sc.next();
-        }
-        for(int i=0;i<c;i++){
-            System.out.println(process(strs[i]));
-        }
-
-    }
-
-    private static String process(String str){
-        int len=str.length();
-        StringBuilder sb=new StringBuilder();
-        String res="";
-        int index=0;
-        String tmp="";
-        while(index<len){
-            char c=str.charAt(index);
-            if(c>='A' && c<='Z' )
-                if(index>=1 && str.charAt(index-1)>='A' && str.charAt(index-1)<='Z') {
-                    res += sb.toString();
-                    sb = new StringBuilder();
-                    sb.append(c);
-                    index++;
-                }else {
-                    sb.append(c);
-                    index++;
-            }else if(c>='0' && c<='9'){
-                int num=c-'0';
-                index++;
-                while(index<len && Character.isDigit(str.charAt(index))){
-                    num=num*10+str.charAt(index++)-'0';
-                }
-                if(!"".equals(tmp)){
-                    for(int i=0;i<num;i++){
-                        res+=tmp;
-                    }
-                    tmp="";
-                }else{
-                    String s=sb.toString();
-                    for(int i=1;i<num;i++){
-                        sb.append(s);
-                    }
-                    res+=sb.toString();
-                    sb=new StringBuilder();
-                }
-            }else if(c=='('){ //遇到了（
-                //先结算前面的
-                if(sb.length()>0){
-                    res+=sb.toString();
-                    sb=new StringBuilder();
-                }
-                String[] help= process(str,index+1);
-                index=Integer.valueOf(help[1]);
-                tmp=help[0];
-            }
-        }
-        res+=sb.toString();
-        return res;
-
-    }
-
-    /**
-     * 遇到(就进入该方法计算，遇到）终止计算
-     * @param str
-     * @param index
-     * @return ：当前计算的结果值以及）后一个位置的索引
-     */
-    private static String[] process(String str,int index){
-         String[] ans=new String[2];
-         ans[0]="";
-         int len=str.length();
-         String rs="";
-         String tmp="";
-         StringBuilder sb=new StringBuilder();
-         while(str.charAt(index)!=')'){
-             char c=str.charAt(index);
-             if(c=='('){
-                 //先结算前面的
-                 if(sb.length()>0){
-                     ans[0]+=sb.toString();
-                     sb=new StringBuilder();
-                 }
-                 String[] help=process(str,index+1);
-                 index=Integer.valueOf(help[1]);
-                 tmp=help[0];
-             }else if(c>='A' && c<='Z'){
-                 if(index>=1 && str.charAt(index-1)>='A' && str.charAt(index-1)<='Z') {
-                     ans[0] += sb.toString();
-                     sb = new StringBuilder();
-                     sb.append(c);
-                     index++;
-                 }else {
-                     sb.append(c);
-                     index++;
-                 }
-             }else if(c>='0' && c<='9'){
-                 int num=c-'0';
-                 index++;
-                 while(str.charAt(index)!=')' && Character.isDigit(str.charAt(index))){
-                     num=num*10+str.charAt(index++)-'0';
-                 }
-                 if(!"".equals(tmp)){
-                     for(int i=0;i<num;i++){
-                         rs+=tmp;
-                     }
-                     ans[0]+=rs;
-                     tmp="";
-                     rs="";
-                 }else{
-                     String s=sb.toString();
-                     for(int i=1;i<num;i++){
-                         sb.append(s);
-                     }
-                     ans[0]+=sb.toString();
-                     sb=new StringBuilder();
-                 }
-
-             }
-         }
-         ans[0]+=sb.toString();
-         ans[1]=String.valueOf(index+1);
-         return ans;
-    }
-
-}
Index: src/面试相关/公司笔面试真题/猿辅导/二零_2/Solution3.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/猿辅导/二零_2/Solution3.java b/src/面试相关/公司笔面试真题/猿辅导/二零_2/Solution3.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/猿辅导/二零_2/Solution3.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,83 +0,0 @@
-package 面试相关.公司笔面试真题.猿辅导.二零_2;
-
-import java.util.Comparator;
-import java.util.PriorityQueue;
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:猿辅导课堂上老师提供了一些角色，学生可以从中选择一个自己喜欢的角色扮演，每3个不同的角色就可以组成一个小组，进行分组对话。
-当老师点击开始分组对话按钮的时候，服务器会为已经选择自己角色的同学分配对话小组，请问最多能组成多少个对话小组？
-
-输入描述:
-第一行为测试用例数量C(C<=100)，接下来的C行每行为一个测试用例
-
-每个用例的第一个数字表示可供选择的角色数量T(T<=1000)，接下来的T个数字表示每个角色的选择人数Pi(Pi<=500)
-
-输出描述:
-一共C行，每行表示一个测试用例中的最大对话小组数量。
-
-输入例子1:
-3
-3 1 1 1
-3 2 2 3
-4 0 2 3 99
-
-输出例子1:
-1
-2
-2
-
-例子说明1:
-对于用例1，正好3个不同角色，每个角色1个人选，于是构成且只能构成一个小组。
-
-对于用例2，在构成两个小组之后，第3个角色单了1人无法构成任何小组，所以最大小组数量是2。
-
-对于用例3，学生扎堆选择了最后一个角色，但是第二个角色只有2个人，所以还是只能构成2个对话小组。
- * @date 2020/7/25 20:26
- */
-public class Solution3 {
-
-    public static void main(String[] args) {
-        Scanner sc=new Scanner(System.in);
-        int c=sc.nextInt();
-        for(int i=0;i<c;i++){
-            int num=sc.nextInt();
-            int[] arr=new int[num];
-            for(int j=0;j<num;j++){
-                arr[j]=sc.nextInt();
-            }
-            System.out.println(process(arr));
-        }
-    }
-
-    public static int process(int[] arr){
-        PriorityQueue<Integer> pq=new PriorityQueue<>(new Comparator<Integer>() {
-            @Override
-            public int compare(Integer o1, Integer o2) {
-                return o2-o1;
-            }
-        });
-
-        for(int num:arr){
-            if(num>0)
-                pq.add(num);
-        }
-        int res=0;
-        while(pq.size()>2){
-            int first=pq.poll();
-            int second=pq.poll();
-            int third=pq.poll();
-            if(--first>0)
-                pq.add(first);
-            if(--second>0)
-                pq.add(second);
-            if(--third>0)
-                pq.add(third);
-            res++;
-        }
-        return res;
-    }
-
-}
Index: src/面试相关/公司笔面试真题/猿辅导/二零_3/Solution3.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/猿辅导/二零_3/Solution3.java b/src/面试相关/公司笔面试真题/猿辅导/二零_3/Solution3.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/猿辅导/二零_3/Solution3.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,78 +0,0 @@
-package 面试相关.公司笔面试真题.猿辅导.二零_3;
-
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:辅导课堂在推进质量建设，需要分析每堂直播课的用户报障数量。
-当连续多个课程的报障数量之和大于一个数s的时候，系统会发出报警。小猿想知道最长连续的没有触发报警的课程数量。
-
-输入描述:
-第一行两个整数 n，s
-
-第二行 n 个整数，每个整数表示一次课程报障数量ai
-
-对于 10% 的数据，满足 1 ≤ n ≤ 2 * 10^3
-
-对于 100% 的数据，满足 1 ≤ n ≤ 2 * 10^6，0 ≤ ai ≤ 10^2
-
-输出描述:
-最长连续的没有触发报警的课程数量
-
-输入例子1:
-3 2
-1 1 3
-
-输出例子1:
-2
-
-例子说明1:
-前面两次课程分别为1，1 没有触发报警 所以答案是2
-
-输入例子2:
-6 5
-5 1 1 1 2 3
-
-输出例子2:
-4
-
-例子说明2:
-中间的课程打分 1 1 1 2之和等于5 没有触发报警
- * @date 2020/7/25 22:11
- */
-public class Solution3 {
-
-
-    public static void main(String[] args) {
-        Scanner sc=new Scanner(System.in);
-        int n=sc.nextInt();
-        int s=sc.nextInt();
-        int[] arr=new int[n];
-        for(int i=0;i<n;i++){
-            arr[i]=sc.nextInt();
-        }
-        System.out.println(process(arr,s));
-    }
-
-    public static int process(int[]arr,int s){
-        int n=arr.length;
-        int max=0;
-        int left=0,right=0;
-        int sum=0;
-        while(right<n){
-
-            if(sum<=s){
-                sum+=arr[right++];
-            }
-            //每次加完arr[right]后判断是否存在sun>s的情况
-            while(left<right && sum>s){
-                sum-=arr[left++];
-            }
-            max=Math.max(right-left,max);
-
-        }
-        return max;
-    }
-
-}
Index: src/面试相关/公司笔面试真题/猿辅导/Solution3.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/猿辅导/Solution3.java b/src/面试相关/公司笔面试真题/猿辅导/Solution3.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/猿辅导/Solution3.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,80 +0,0 @@
-package 面试相关.公司笔面试真题.猿辅导;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:将一个链表中位置m到位置n的节点进行反转，要求只遍历一次
-
- * @date 2020/8/29 21:36
- */
-public class Solution3 {
-
-    public static class ListNode{
-        int val;
-        ListNode next;
-        public ListNode(int val){
-            this.val=val;
-        }
-
-    }
-
-    public static ListNode reverseBetween(ListNode head,int m,int n){
-        if(head==null)
-            return null;
-        int i=1;
-        ListNode cur=head,pre=null,next=null;
-        if(m==1){
-
-            while(i<=n && cur!=null){
-                next=cur.next;
-                cur.next=pre;
-                pre=cur;
-                cur=next;
-                i++;
-            }
-            head.next=cur;
-            return pre;
-        }else{
-            ListNode tmp=null;
-            while(i<m){
-                tmp=cur;
-                cur=cur.next;
-                i++;
-            }
-            //tmp.next=null;
-            ListNode help=cur;
-            while(i<=n && cur!=null){
-                next=cur.next;
-                cur.next=pre;
-                pre=cur;
-                cur=next;
-                i++;
-            }
-            tmp.next=pre;
-            help.next=cur;
-            return head;
-
-        }
-    }
-
-    public static void main(String[] args) {
-        ListNode head=new ListNode(1);
-        ListNode next1=new ListNode(2);
-        ListNode next2=new ListNode(3);
-        ListNode next3=new ListNode(4);
-        ListNode next4=new ListNode(5);
-        ListNode next5=new ListNode(7);
-        head.next=next1;
-        next1.next=next2;
-        next2.next=next3;
-        next3.next=next4;
-        next4.next=next5;
-        ListNode listNode = reverseBetween(head, 1, 8);
-        while(listNode!=null){
-            System.out.println(listNode.val);
-            listNode=listNode.next;
-        }
-
-
-    }
-}
Index: src/面试相关/公司笔面试真题/拼多多/Solution4.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/拼多多/Solution4.java b/src/面试相关/公司笔面试真题/拼多多/Solution4.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/拼多多/Solution4.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,66 +0,0 @@
-package 面试相关.公司笔面试真题.拼多多;
-
-import java.util.Arrays;
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:扔n个骰子，第i个骰子有可能投掷出Xi种等概率的不同的结果，数字从1到Xi。所有骰子的结果的最大值将作为最终结果。求最终结果的期望。
-
-输入描述:
-第一行一个整数n，表示有n个骰子。（1 <= n <= 50）
-第二行n个整数，表示每个骰子的结果数Xi。(2 <= Xi <= 50)
-
-输出描述:
-输出最终结果的期望，保留两位小数。
-
-输入例子1:
-2
-2 2
-
-输出例子1:
-1.75
- * @date 2020/7/30 19:51
- */
-public class Solution4 {
-
-    public static void main(String[] args) {
-        Scanner sc=new Scanner(System.in);
-        int n=sc.nextInt();
-        int[] nums=new int[n];
-        for(int i=0;i<n;i++){
-            nums[i]=sc.nextInt();
-        }
-
-        System.out.println(process(n,nums));
-    }
-
-    private static String process(int n,int[] nums){
-        double[] help=new double[n];
-        double sum=1;
-        for(int i=0;i<n;i++){
-            help[i]=nums[i];
-            sum*=help[i];
-        }
-        double p=1/sum;
-        Arrays.sort(help);
-        double maxsum=0;
-        while(help[0]!=0){
-            maxsum+=help[n-1]*multi(help,n);
-            help[n-1]--;
-            Arrays.sort(help);
-        }
-        return String.format("%.2f",maxsum*p);//保留两位小数
-
-    }
-
-    private static double multi(double[] help,int n){
-        double mul=1;
-        for(int i=0;i<n-1;i++){
-            mul*=help[i];
-        }
-        return mul;
-    }
-
-}
Index: src/面试相关/公司笔面试真题/猿辅导/Solution4.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/猿辅导/Solution4.java b/src/面试相关/公司笔面试真题/猿辅导/Solution4.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/猿辅导/Solution4.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,32 +0,0 @@
-package 面试相关.公司笔面试真题.猿辅导;
-
-import java.util.Stack;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:一个栈中元素的类型为整型，现在想将该栈从顶到底按从大到小的顺序排序，
- * 只许申请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。如何完成排序？
- * @date 2020/9/2 20:33
- */
-public class Solution4 {
-
-    public static  void stackSort(Stack<Integer> stack){
-        if(stack.isEmpty() || stack.size()<2) return;
-        Stack<Integer> help=new Stack<>();
-        while(!stack.isEmpty()){
-            int num=stack.pop();
-            while(!help.isEmpty() && help.peek()<num){
-                stack.push(help.pop());
-            }
-            help.push(num);
-        }
-        while(!help.isEmpty()){
-            stack.push(help.pop());
-        }
-    }
-
-
-
-
-}
Index: src/面试相关/公司笔面试真题/拼多多/Solution5.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/拼多多/Solution5.java b/src/面试相关/公司笔面试真题/拼多多/Solution5.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/拼多多/Solution5.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,68 +0,0 @@
-package 面试相关.公司笔面试真题.拼多多;
-
-import java.util.Scanner;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:在一块长为n，宽为m的场地上，有n✖️m个1✖️1的单元格。每个单元格上的数字就是按照从1到n和1到m中的数的乘积。具体如下
-
-n = 3, m = 3
-1   2   3
-2   4   6
-3   6   9
-
-给出一个查询的值k，求出按照这个方式列举的的数中第k大的值v。
-例如上面的例子里，
-从大到小为(9, 6, 6, 4, 3, 3, 2, 2, 1)
-k = 1, v = 9
-k = 2, v = 6
-k = 3, v = 6
-...
-k = 8, v = 2
-k = 9, v = 1
-
-输入描述:
-只有一行是3个数n, m, k 表示场地的宽高和需要查询的k。使用空格隔开。
-
-输出描述:
-给出第k大的数的值。
-
-输入例子1:
-3 3 4
-
-输出例子1:
-4
- * @date 2020/7/29 22:23
- */
-public class Solution5 {
-
-    public static void main(String[] args) {
-        Scanner scanner = new Scanner(System.in);
-        int n = scanner.nextInt();
-        int m = scanner.nextInt();
-        int k = scanner.nextInt();
-        int low = 1;
-        int high = n*m;
-        int mid = 0;
-        k = n*m+1-k;
-        while (low<high){
-            mid = low+(high-low)/2;
-            int count = countMin(n,m,mid);
-            if(count<k){
-                low = mid + 1;
-            }else{
-                high = mid;
-            }
-        }
-        System.out.println(low);
-    }
-
-    private static int countMin(int n, int m, int mid) {
-        int count = 0;
-        for(int i=1;i<=n;i++){
-            count += Math.min(mid/i,m);
-        }
-        return count;
-    }
-}
Index: src/面试相关/公司笔面试真题/猿辅导/Solution5.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/猿辅导/Solution5.java b/src/面试相关/公司笔面试真题/猿辅导/Solution5.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/猿辅导/Solution5.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,21 +0,0 @@
-package 面试相关.公司笔面试真题.猿辅导;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:作者：__椰子皮__
-链接：https://www.nowcoder.com/discuss/492373?type=2&order=3&pos=22&page=1&channel=1009&source_id=discuss_tag
-来源：牛客网
-
-算法题： 两个升序排列的闭区间序列，合并成一个有序的闭区间序列。
-
-A: [1,3], [7,10] B: [2,4], [5,8], [11,13] 结果：[1,4], [5,10], [11,13]
- * @date 2020/9/2 21:09
- */
-public class Solution5 {
-
-    //先合并成一个matrix,然后就是56题了。
-    public static int[][] process(int[][] matrix1,int[][] matrix2){
-        return null;
-    }
-}
Index: src/面试相关/公司笔面试真题/猿辅导/Solution6.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/猿辅导/Solution6.java b/src/面试相关/公司笔面试真题/猿辅导/Solution6.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/猿辅导/Solution6.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,63 +0,0 @@
-package 面试相关.公司笔面试真题.猿辅导;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:算法：一个蛇形矩阵，搜索一个数字是否在其中
-[[1, 2, 3, 4],
-[8, 7, 6, 5],
-[9, 10, 11, 12],
-[16, 15, 14, 13]]
- * @date 2020/9/3 10:16
- */
-public class Solution6 {
-
-    //将二维矩阵看成一个递增的一维矩阵，然后找出坐标的变换逻辑。
-    public static boolean process(int[][] matrix,int target){
-        if(matrix==null || matrix.length==0)
-            return false;
-        int m=matrix.length;
-        int n=matrix[0].length;
-        int left=0,right=m*n-1,mid=0;
-        while(left<right){
-            mid=(left+right)>>>1;
-            int[] ans=help(mid,m,n);
-            if(matrix[ans[0]][ans[1]]<target){
-                left=mid+1;
-            }else {
-                right = mid;
-            }
-        }
-        int[] ans=help(left,m,n);
-        if(matrix[ans[0]][ans[1]]==target){
-            return true;
-
-        }
-        return false;
-
-    }
-
-    //将一维数组中的坐标num映射成蛇形矩阵的相应的坐标位置
-    private static int[] help(int num,int m,int n){
-        int row=num/n;
-        int col=num%n;
-        if(row %2==1){
-            col=n-col-1;
-        }
-        int[] res=new int[2];
-        res[0]=row;
-        res[1]=col;
-        return res;
-    }
-
-
-    public static void main(String[] args) {
-        int[][] matrix={
-                {1, 2, 3, 4},
-                {8, 7, 6, 5},
-                {10, 11, 12, 14},
-                {120, 18, 17, 16}
-        };
-        System.out.println(process(matrix,666));
-    }
-}
Index: src/Leetcode/Solution8.java
===================================================================
diff --git a/src/Leetcode/Solution8.java b/src/Leetcode/Solution8.java
deleted file mode 100644
--- a/src/Leetcode/Solution8.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,91 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:请你来实现一个 atoi 函数，使其能将字符串转换成整数。
-
-首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：
-
-如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。
-假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。
-该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。
-注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。
-
-在任何情况下，若函数不能进行有效的转换时，请返回 0 。
-
-提示：
-
-本题中的空白字符只包括空格字符 ' ' 。
-假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。
- 
-
-示例 1:
-
-输入: "42"
-输出: 42
-示例 2:
-
-输入: "   -42"
-输出: -42
-解释: 第一个非空白字符为 '-', 它是一个负号。
-     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
-示例 3:
-
-输入: "4193 with words"
-输出: 4193
-解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
-示例 4:
-
-输入: "words and 987"
-输出: 0
-解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
-因此无法执行有效的转换。
-示例 5:
-
-输入: "-91283472332"
-输出: -2147483648
-解释: 数字 "-91283472332" 超过 32 位有符号整数范围。
-     因此返回 INT_MIN (−231) 。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/string-to-integer-atoi
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/8/20 21:11
- */
-public class Solution8 {
-
-    public static int strToInt(String str) {
-       str=str.trim();
-       if(str.length()==0)return 0;
-       int sign=1;
-       if(str.charAt(0)=='-'){
-           sign=-1;
-           str=str.substring(1);
-       }else if(str.charAt(0)=='+'){
-           sign=1;
-           str=str.substring(1);
-       }
-
-       int res=0,tmp=0;
-       for(int i=0;i<str.length();i++){
-           char c=str.charAt(i);
-           if(!Character.isDigit(c)){
-               break;
-           }
-           tmp=c-'0';
-           if(res*sign<Integer.MIN_VALUE/10 || res* sign==Integer.MIN_VALUE/10 && tmp>8){
-               return Integer.MIN_VALUE;
-           }
-           if(res*sign>Integer.MAX_VALUE/10 || res*sign==Integer.MAX_VALUE/10 && tmp>7){
-               return Integer.MAX_VALUE;
-           }
-           res=res*10+tmp;
-       }
-       return res*sign;
-    }
-
-    public static void main(String[] args) {
-        System.out.println(strToInt("  -42"));
-    }
-}
Index: src/Leetcode/计算器问题/Solution16_16.java
===================================================================
diff --git a/src/Leetcode/计算器问题/Solution16_16.java b/src/Leetcode/计算器问题/Solution16_16.java
deleted file mode 100644
--- a/src/Leetcode/计算器问题/Solution16_16.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,82 +0,0 @@
-package Leetcode.计算器问题;
-
-import java.util.Stack;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一个包含正整数、加(+)、减(-)、乘(*)、除(/)的算数表达式(括号除外)，计算其结果。
-
-表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。
-
-示例 1:
-
-输入: "3+2*2"
-输出: 7
-示例 2:
-
-输入: " 3/2 "
-输出: 1
-示例 3:
-
-输入: " 3+5 / 2 "
-输出: 5
-说明：
-
-你可以假设所给定的表达式都是有效的。
-请不要使用内置的库函数 eval。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/calculator-lcci
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/7/10 22:50
- */
-public class Solution16_16 {
-
-    public static int calculate(String s) {
-        if(s==null || s.trim().length()==0)
-            return 0;
-        char[] chs=s.toCharArray();
-        int index=0;
-        Stack<Integer> stack=new Stack<>();
-        int n=chs.length;
-        while(index<n){
-            if(chs[index]==' '){
-                index++;
-                continue;
-            }
-            char tmp=chs[index];
-            if(tmp=='+' || tmp=='-' || tmp=='/' || tmp=='*'){
-                index++;
-                while(index<n && chs[index]==' ') index++;
-            }
-            int num=0;
-            while(index<n && Character.isDigit(chs[index])){
-                num=num*10+chs[index]-'0';
-                index++;
-            }
-            if(tmp=='+'){
-                stack.push(num);
-            }else if(tmp=='-'){
-                stack.push(-num);
-            }else if(tmp=='/'){
-                stack.push(stack.pop()/num);
-            }else if(tmp=='*'){
-                stack.push(stack.pop()*num);
-            }else{
-                stack.push(num);//当tmp不是运算符的时候
-            }
-        }
-        int res=0;
-        while(!stack.isEmpty()){
-            res+=stack.pop();
-        }
-        return res;
-    }
-
-
-    public static void main(String[] args) {
-        String s="3/2";
-        System.out.println(calculate(s));
-    }
-}
Index: src/Leetcode/数组/Solution41.java
===================================================================
diff --git a/src/Leetcode/数组/Solution41.java b/src/Leetcode/数组/Solution41.java
deleted file mode 100644
--- a/src/Leetcode/数组/Solution41.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,68 +0,0 @@
-package Leetcode.数组;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。
-
- 
-
-示例 1:
-
-输入: [1,2,0]
-输出: 3
-示例 2:
-
-输入: [3,4,-1,1]
-输出: 2
-示例 3:
-
-输入: [7,8,9,11,12]
-输出: 1
- 
-
-提示：
-
-你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/first-missing-positive
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/28 9:33
- */
-public class Solution41 {
-
-    public int firstMissingPositive(int[] nums) {
-        int len = nums.length;
-
-        for (int i = 0; i < len; i++) {
-            while (nums[i] > 0 && nums[i] <= len && nums[nums[i] - 1] != nums[i]) {
-                // 满足在指定范围内、并且没有放在正确的位置上，才交换
-                // 例如：数值 3 应该放在索引 2 的位置上
-                swap(nums, nums[i] - 1, i);
-            }
-        }
-
-        // [1, -1, 3, 4]
-        for (int i = 0; i < len; i++) {
-            if (nums[i] != i + 1) {
-                return i + 1;
-            }
-        }
-        // 都正确则返回数组长度 + 1
-        return len + 1;
-    }
-
-    private void swap(int[] nums, int index1, int index2) {
-        int temp = nums[index1];
-        nums[index1] = nums[index2];
-        nums[index2] = temp;
-    }
-
-    public static void main(String[] args) {
-        int[] nums={7,8,9,11,12};
-        System.out.println(new Solution41().firstMissingPositive(nums));
-
-    }
-}
Index: src/Leetcode/Solution42.java
===================================================================
diff --git a/src/Leetcode/Solution42.java b/src/Leetcode/Solution42.java
deleted file mode 100644
--- a/src/Leetcode/Solution42.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,60 +0,0 @@
-package Leetcode;
-
-import java.util.HashMap;
-import java.util.List;
-import java.util.Stack;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
-
-
-
-上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。
-
-示例:
-
-输入: [0,1,0,2,1,0,1,3,2,1,2,1]
-输出: 6
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/trapping-rain-water
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/14 21:38
- */
-public class Solution42 {
-    //单调栈解法
-    public static int trap(int[] height) {
-        if(height==null || height.length==0)
-            return 0;
-        int len=height.length;
-        Stack<Integer> stack=new Stack<>();
-        Stack<Integer> help=new Stack<>();
-        int count=0;
-        for(int i=0;i<len;i++){
-            while(!stack.isEmpty() && height[i]>=height[stack.peek()]){
-                int d=height[stack.pop()];
-                if(!stack.isEmpty()){
-                    int left=stack.peek();
-                    int l=i-left-1;
-                    int h=Math.min(height[left],height[i])-d;
-                    count+=h*l;
-                }
-
-            }
-            stack.push(i);
-        }
-
-        return count;
-
-    }
-
-    public static void main(String[] args) {
-        int [] height={0,1,0,2,1,0,1,3,2,1,2,1};
-        System.out.println(trap(height));
-    }
-
-
-
-}
Index: src/Leetcode/数组/Solution56.java
===================================================================
diff --git a/src/Leetcode/数组/Solution56.java b/src/Leetcode/数组/Solution56.java
deleted file mode 100644
--- a/src/Leetcode/数组/Solution56.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,65 +0,0 @@
-package Leetcode.数组;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给出一个区间的集合，请合并所有重叠的区间。
-
-示例 1:
-
-输入: [[1,3],[2,6],[8,10],[15,18]]
-输出: [[1,6],[8,10],[15,18]]
-解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
-示例 2:
-
-输入: [[1,4],[4,5]]
-输出: [[1,5]]
-解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/merge-intervals
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/7/8 21:24
- */
-public class Solution56 {
-
-    public static int[][] merge(int[][] intervals) {
-        if(intervals==null || intervals.length==0)
-            return intervals;
-        Arrays.sort(intervals,(a, b)->{return a[0]-b[0];});//根据每一个子数组的第一个元素的大小从小到大排序
-        int n=intervals.length;
-        List<int[]> list=new ArrayList<>();
-        int index=0;
-        while(index<n){
-            int[] help=new int[2];
-            help[0]=intervals[index][0];
-            int max=intervals[index][1];
-            //因为后面涉及到了index+1,所以需要满足index+1<n
-            while(index+1<n && (max>=intervals[index+1][0] || max>=intervals[index+1][1])){
-                index++;
-                if(max<intervals[index][1])
-                    max=intervals[index][1];
-            }
-            index++;//都得需要++
-            help[1]=max;
-            list.add(help);
-        }
-        int[][] res=new int[list.size()][2];
-        index=0;
-        for(int[] tmp:list){
-            res[index++]=tmp;
-        }
-        return res;
-    }
-
-    public static void main(String[] args) {
-        int[][] arr=new int[][]{{1,3},{2,6},{8,10},{15,18}};
-        int[][] merge = merge(arr);
-
-    }
-}
Index: src/Leetcode/数组/Solution57.java
===================================================================
diff --git a/src/Leetcode/数组/Solution57.java b/src/Leetcode/数组/Solution57.java
deleted file mode 100644
--- a/src/Leetcode/数组/Solution57.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,65 +0,0 @@
-package Leetcode.数组;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2020/9/1 10:57
- */
-public class Solution57 {
-
-    public static int[][] insert(int[][] intervals, int[] newInterval) {
-        if(newInterval==null || newInterval.length==0) return intervals;
-        int n=intervals.length;
-        List<int[]> list=new ArrayList<>();
-        int index=0;
-        int max=Integer.MIN_VALUE;
-        while(index<n){
-            int[] help=new int[2];
-            help[0]=intervals[index][0];
-            help[1]=intervals[index][1];
-            max=intervals[index][1];
-            boolean flag=false;
-            while(newInterval[0]<=max){
-                help[0]=Math.min(help[0],newInterval[0]);
-                help[1]=Math.max(help[1],newInterval[1]);
-                if(max==intervals[index][1]){
-                    flag=true;
-                    break;
-                }else{
-                    newInterval[0]=help[0];
-                    if(index<n-1)
-                        max=intervals[index++][1];
-                    else
-                        break;
-                }
-            }
-            if(flag){
-                index++;
-                list.add(help);
-                break;
-            }
-            list.add(help);
-
-        }
-        while(index<n){
-            list.add(intervals[index++]);
-        }
-        int[][] res=new int[list.size()][2];
-        index=0;
-        for(int[] arr :list){
-            res[index][0]=arr[0];
-            res[index++][1]=arr[1];
-        }
-        return res;
-    }
-
-    public static void main(String[] args) {
-        int[][] matrix={{1,2},{3,5},{6,7},{8,10},{12,16}};
-        int[] newInterval={4,8};
-        insert(matrix,newInterval);
-    }
-}
Index: src/Leetcode/list/Solution82.java
===================================================================
diff --git a/src/Leetcode/list/Solution82.java b/src/Leetcode/list/Solution82.java
deleted file mode 100644
--- a/src/Leetcode/list/Solution82.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,98 +0,0 @@
-package Leetcode.list;
-
-import java.util.LinkedList;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。
-
-示例 1:
-
-输入: 1->2->3->3->4->4->5
-输出: 1->2->5
-示例 2:
-
-输入: 1->1->1->2->3
-输出: 2->3
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/7/21 22:35
- */
-public class Solution82 {
-
-    public static class ListNode {
-        int val;
-        ListNode next;
-
-        ListNode(int x) {
-            val = x;
-        }
-    }
-
-    public static ListNode deleteDuplicates(ListNode head) {
-        if(head==null || head.next==null) return head;
-        LinkedList<ListNode>list=new LinkedList<>();
-        ListNode cur=head;
-        while(cur!=null){
-            if(list.isEmpty() || list.peekLast().val!=cur.val){
-                list.add(cur);
-                cur=cur.next;
-            }else{
-                while(cur!=null && list.peekLast().val==cur.val){
-                    cur=cur.next;
-                }
-                list.pollLast();
-                if(!list.isEmpty())list.peekLast().next=null;//断开list中最后一个元素与原来元素的连接关系
-            }
-        }
-        if(list.isEmpty()) return null;
-        ListNode newhead=list.pollFirst();
-        ListNode next=newhead;
-        while(!list.isEmpty()){
-            next.next=list.pollFirst();
-            next=next.next;
-        }
-        return newhead;
-    }
-
-    public static ListNode deleteDuplicates2(ListNode head) {
-        if(head==null || head.next==null) return head;
-        ListNode cur=head,pre=null,prepre=null;
-        boolean flag=false;//表示 是否找到了头结点
-        ListNode newHead=null;
-        while(cur!=null){
-            if(cur!=cur.next){
-                if(!flag){
-                    newHead=cur;
-                    flag=true;
-                }
-                prepre=pre;
-                pre=cur;
-                cur=cur.next;
-            }else{
-                if(pre!=null) pre.next=null;//断开连接
-                while(cur!=null && cur==cur.next){
-                    cur=cur.next;
-                }
-                if(cur!=null){
-                    ListNode tmp=cur.next;
-                    cur.next=null;//断开连接
-                    cur=tmp;
-                    if(pre!=null) pre.next=cur;
-                }
-            }
-        }
-        return newHead;
-    }
-
-    public static void main(String[] args) {
-        ListNode head=new ListNode(1);
-        head.next=new ListNode(2);
-        head.next.next=new ListNode(2);
-        deleteDuplicates(head);
-    }
-
-}
Index: src/Leetcode/数组/Solution85.java
===================================================================
diff --git a/src/Leetcode/数组/Solution85.java b/src/Leetcode/数组/Solution85.java
deleted file mode 100644
--- a/src/Leetcode/数组/Solution85.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,75 +0,0 @@
-package Leetcode.数组;
-
-import java.util.Arrays;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。
-
-示例:
-
-输入:
-[
-["1","0","1","0","0"],
-["1","0","1","1","1"],
-["1","1","1","1","1"],
-["1","0","0","1","0"]
-]
-输出: 6
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/maximal-rectangle
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/8/31 20:06
- */
-public class Solution85 {
-
-    public static int maximalRectangle(char[][] matrix) {
-        if(matrix==null || matrix.length==0)
-            return 0;
-        int m=matrix.length;
-        int n=matrix[0].length;
-        int res=0;
-        for(int i=0;i<m;i++){//从第i行开始
-            int[] help=new int[n];
-            Arrays.fill(help,-1);
-            for(int j=i;j<m;j++){//计算i-m行的矩形面积
-                for(int k=0;k<n;k++){
-                    if(matrix[j][k]=='0' || help[k]==0){
-                        help[k]=0;
-                    }else{
-                        help[k]=help[k]==-1 ? 0: help[k];
-                        help[k]+=matrix[j][k]-'0';
-                    }
-                }
-                int ans=process(help);
-                res=Math.max(res,ans);
-            }
-        }
-        return res;
-
-    }
-    //返回数组arr中最大矩形的面积
-    private static int process(int[] arr){
-        int n=arr.length;
-        int[] dp=new int[n];
-        int res=0;
-        for(int i=0;i<n;i++){
-            if(arr[i]==0)
-                continue;
-            if(i>=1){
-                dp[i]=arr[i]+dp[i-1];
-                res=Math.max(res,dp[i]);
-            }else{
-                dp[i]=arr[i];
-                res=Math.max(res,dp[i]);
-            }
-        }
-        return res;
-    }
-
-    public static void main(String[] args) {
-
-    }
-}
Index: src/Leetcode/树/Solution129.java
===================================================================
diff --git a/src/Leetcode/树/Solution129.java b/src/Leetcode/树/Solution129.java
deleted file mode 100644
--- a/src/Leetcode/树/Solution129.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,57 +0,0 @@
-package Leetcode.树;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。
-
-例如，从根到叶子节点路径 1->2->3 代表数字 123。
-
-计算从根到叶子节点生成的所有数字之和。
-
-说明: 叶子节点是指没有子节点的节点。
-
-示例 1:
-
-输入: [1,2,3]
-1
-/ \
-2   3
-输出: 25
-解释:
-从根到叶子节点路径 1->2 代表数字 12.
-从根到叶子节点路径 1->3 代表数字 13.
-因此，数字总和 = 12 + 13 = 25.
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/sum-root-to-leaf-numbers
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/10/30 15:07
- */
-public class Solution129 {
-
-
-     public class TreeNode {
-        int val;
-         TreeNode left;
-        TreeNode right;
-        TreeNode(int x) { val = x; }
-      }
-
-    class Solution {
-        public int sumNumbers(TreeNode root) {
-            return dfs(root,0);
-        }
-
-        private int dfs(TreeNode root,int preNum){
-            if(root==null)
-                return 0;
-            int sum=preNum*10+root.val;
-            if(root.left==null && root.right==null){
-                return sum;
-            }else{
-                return dfs(root.left,sum)+dfs(root.right,sum);
-            }
-        }
-    }
-}
Index: src/Leetcode/字符串/Solution131.java
===================================================================
diff --git a/src/Leetcode/字符串/Solution131.java b/src/Leetcode/字符串/Solution131.java
deleted file mode 100644
--- a/src/Leetcode/字符串/Solution131.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,48 +0,0 @@
-package Leetcode.字符串;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class Solution131 {
-
-    List<List<String>> res=new ArrayList<>();
-    public List<List<String>> partition(String s) {
-        if(s==null || s.length()==0) return res;
-        int n=s.length();
-        for(int i=0;i<n;i++){
-            process(s,0,i,new ArrayList<String>());
-        }
-        return res;
-
-    }
-
-    private void process(String s,int start,int end,List<String> list){
-        if(isPrime(s,start,end)){
-            list.add(s.substring(start,end+1));
-            if(end==s.length()-1){
-                res.add(new ArrayList<>(list));
-                return;
-            }
-            for(int i=end+1;i<s.length();i++){
-                process(s,end+1,i,list);
-            }
-        }
-
-    }
-    //判断s从start到end是否为回文串
-    private  boolean isPrime(String s,int start,int end){
-        while(start<end){
-            if(s.charAt(start)==s.charAt(end)){
-                start++;
-                end--;
-            }else{
-                return false;
-            }
-        }
-        return true;
-    }
-
-    public static void main(String[] args) {
-        new Solution131().partition("cbb");
-    }
-}
Index: src/Leetcode/Solution140.java
===================================================================
diff --git a/src/Leetcode/Solution140.java b/src/Leetcode/Solution140.java
deleted file mode 100644
--- a/src/Leetcode/Solution140.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,64 +0,0 @@
-package Leetcode;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2020/5/12 11:54
- */
-public class Solution140 {
-    public static List<String> wordBreak(String s, List<String> wordDict) {
-
-        int len=s.length();
-        List<String>[] dp=new List [len+1];//代表前i个字符组成的字符串可以拼接的情况
-        if(!cwordBreak(s,wordDict)) return new ArrayList<String>();
-        for(int i=0;i<=len;i++){
-            dp[i]=new ArrayList<String>();
-        }
-        dp[0].add("");
-        for(int i=1;i<=len;i++){
-            for(int j=0;j<i;j++){
-                if(dp[j].size()>0 && wordDict.contains(s.substring(j,i)))
-                {
-                    for(String str : dp[j]){
-                        dp[i].add(str+(str.equals("")?"":" ")+s.substring(j,i));
-                    }
-                }
-            }
-        }
-        return dp[len];
-    }
-
-    public static boolean cwordBreak(String s, List<String> wordDict) {
-        int len=s.length();//代表s的前i个字符是否可以拆分成wordDict中的单词
-        boolean [] dp=new boolean[len+1];
-        dp[0]=true;
-        for(int i=1;i<=len;i++){
-            for(String str:wordDict){
-                int l=str.length();
-                if(i-l>=0 && dp[i-l] && s.substring(i-l,i).equals(str)){
-                    dp[i]=true;
-                    break;
-                }
-            }
-
-        }
-
-        return dp[len];
-    }
-
-    public static void main(String[] args) {
-        String str="catsanddog";
-        List<String> list=new ArrayList<>();
-        list.add("cat");
-        list.add("cats");
-        list.add("and");
-        list.add("sand");
-        list.add("dog");
-        //System.out.println(wordBreak(str,list));
-
-    }
-}
Index: src/Leetcode/Solution148.java
===================================================================
diff --git a/src/Leetcode/Solution148.java b/src/Leetcode/Solution148.java
deleted file mode 100644
--- a/src/Leetcode/Solution148.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,103 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。
-
-示例 1:
-
-输入: 4->2->1->3
-输出: 1->2->3->4
-
-示例 2:
-
-输入: -1->5->3->4->0
-输出: -1->0->3->4->5
-
- * @date 2020/4/21 19:54
- */
-public class Solution148 {
-
-    public class ListNode {
-     int val;
-     ListNode next;
-     ListNode(int x) { val = x; }
- }
-
-    public ListNode sortList(ListNode head) {
-        if(head==null ||head.next==null)
-            return head;
-        ListNode first=head;//新链表的头
-        ListNode cur=head.next;
-        ListNode last=head;//新链表的尾结点
-        first.next=null;//将新链表与旧链表分开
-        last.next=null;//将新链表与旧链表分开
-        ListNode next=null;
-        while(cur!=null){
-            next=cur.next;
-            if(cur.val>=last.val){
-                last.next=cur;
-                last=cur;
-                last.next=null;
-            }else if(first.val>=cur.val){
-                cur.next=first;
-                first=cur;
-            }else{
-                ListNode tmp=first;
-                while(tmp.next!=null && tmp.next.val<cur.val){
-                    tmp=tmp.next;
-                }
-                cur.next=tmp.next;
-                tmp.next=cur;
-            }
-            cur=next;
-
-        }
-
-        return first;
-    }
-
-    //时间复杂度O(nlogn),空间复杂度O(1)
-    public ListNode sortList2(ListNode head) {
-        if(head==null ||head.next==null)
-            return head;
-        //通过快慢指针的方式找到链表的中点
-        return sort(head);
-    }
-
-    public ListNode sort(ListNode head){
-        if(head==null ||head.next==null)
-            return head;
-        //通过快慢指针的方式找到链表的中点
-        ListNode slow=head;
-        ListNode fast=head.next;//这样可以保证在偶数个结点的时候也能恰好均分，而不是造成分布不均匀
-        while(fast!=null && fast.next!=null){
-            slow=slow.next;
-            fast=fast.next.next;
-        }
-        ListNode tmp=slow.next;//后半部分的起点
-        slow.next=null;//前后两部分断开
-        ListNode first=sort(head);
-        ListNode second=sort(tmp);
-        return merge(first,second);
-    }
-
-    public ListNode merge(ListNode first,ListNode second){
-        ListNode tmp=new ListNode(0);//辅助结点
-        ListNode res=tmp;
-        while(first!=null && second!=null){
-            if(first.val<=second.val){
-                tmp.next=first;
-                tmp=first;
-                first=first.next;
-            }else{
-                tmp.next=second;
-                tmp=second;
-                second=second.next;
-            }
-        }
-        tmp.next=first==null ? second:first;
-        return res.next;
-    }
-}
Index: src/Leetcode/Solution151.java
===================================================================
diff --git a/src/Leetcode/Solution151.java b/src/Leetcode/Solution151.java
deleted file mode 100644
--- a/src/Leetcode/Solution151.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,81 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一个字符串，逐个翻转字符串中的每个单词。
-
-
-
-示例 1：
-
-输入: "the sky is blue"
-输出: "blue is sky the"
-
-示例 2：
-
-输入: "  hello world!  "
-输出: "world! hello"
-解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
-
-示例 3：
-
-输入: "a good   example"
-输出: "example good a"
-解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
-
-
-
-说明：
-
-无空格字符构成一个单词。
-输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
-如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/reverse-words-in-a-string
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/4 18:24
- */
-public class Solution151 {
-
-    public static String reverseWords(String s) {
-        if(s==null || s.length()==0)
-            return s;
-        s=s.trim();
-        if(s.length()==0) return s;
-        String[] strs=s.split(" ");
-        StringBuilder sb=new StringBuilder();
-        for(int i=0;i<strs.length;i++){
-            if(!strs[i].equals("")){
-                sb.append(strs[i]+" ");
-            }
-        }
-        String temp=sb.toString().substring(0,sb.length()-1);
-        String[] help=temp.split(" ");
-        int left=0,right=help.length-1;
-        while(left<right){
-            swap(help,left,right);
-            left++;
-            right--;
-        }
-        StringBuilder sb1=new StringBuilder();
-        for(String str: help){
-            sb1.append(str+" ");
-        }
-        return sb1.toString().substring(0,sb1.length()-1);
-
-
-    }
-    private static void swap(String[] strs,int i,int j){
-        String t=strs[i];
-        strs[i]=strs[j];
-        strs[j]=t;
-    }
-
-    public static void main(String[] args) {
-        String str="a good   example";
-        System.out.println(reverseWords(str));
-
-    }
-}
Index: src/Leetcode/Solution152.java
===================================================================
diff --git a/src/Leetcode/Solution152.java b/src/Leetcode/Solution152.java
deleted file mode 100644
--- a/src/Leetcode/Solution152.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,57 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）。
-
-
-
-示例 1:
-
-输入: [2,3,-2,4]
-输出: 6
-解释: 子数组 [2,3] 有最大乘积 6。
-
-示例 2:
-
-输入: [-2,0,-1]
-输出: 0
-解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/maximum-product-subarray
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/4/28 10:56
- */
-public class Solution152 {
-
-    public static int maxProduct(int[] nums) {
-        if(nums==null || nums.length==0) return 0;
-        int len=nums.length;
-        int[] dpmin=new int[len+1];//以数组中每一个数结尾的最小乘积子数组
-        int[] dpmax=new int[len+1];//以数组中每一个数结尾的最大乘积子数组
-
-        dpmin[1]=nums[0];
-        dpmax[1]=nums[0];
-        int max=nums[0];
-        for(int i=2;i<=len;i++){
-            if(nums[i-1]<0){//遇到负数的时候，最大的变成最小的，最小的变成最大的
-                int temp=dpmin[i-1];
-                dpmin[i-1]=dpmax[i-1];
-                dpmax[i-1]=temp;
-            }
-            dpmax[i]=Math.max(nums[i-1],dpmax[i-1]*nums[i-1]);
-            dpmin[i]=Math.min(nums[i-1],dpmin[i-1]*nums[i-1]);
-            max=Math.max(max,dpmax[i]);
-        }
-
-
-        return max;
-    }
-
-    public static void main(String[] args) {
-        int[] nums={-2,3,-4};
-        System.out.println(maxProduct(nums));
-    }
-}
Index: src/Leetcode/树/Solution156.java
===================================================================
diff --git a/src/Leetcode/树/Solution156.java b/src/Leetcode/树/Solution156.java
deleted file mode 100644
--- a/src/Leetcode/树/Solution156.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,85 +0,0 @@
-package Leetcode.树;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.
-
-Example:
-
-Input: [1,2,3,4,5]
-
-1
-/ \
-2   3
-/ \
-4   5
-
-Output: return the root of the binary tree [4,5,2,#,#,3,1]
-
-4
-/ \
-5   2
-/ \
-3   1
-Clarification:
-
-Confused what [4,5,2,#,#,3,1] means? Read more below on how binary tree is serialized on OJ.
-
-The serialization of a binary tree follows a level order traversal, where '#' signifies a path terminator where no node exists below.
-
-Here's an example:
-
-1
-/ \
-2   3
-/
-4
-\
-5
-The above binary tree is serialized as [1,2,3,#,#,4,#,#,5].
- * @date 2020/9/14 21:14
- */
-public class Solution156 {
-
-    public static class TreeNode{
-        int val;
-        TreeNode left;
-        TreeNode right;
-        public TreeNode(int val){
-            this.val=val;
-        }
-    }
-   //递归的思路
-    public static  TreeNode upsideDownBinaryTree(TreeNode root){
-        if(root==null ||root.left==null) return root;
-        TreeNode newRoot=upsideDownBinaryTree(root.left);
-        root.left.left=root.right;
-        root.left.right=root;
-        //将原来root左右孩子设置为null
-        root.left=null;
-        root.right=null;
-        return newRoot;
-
-    }
-    //迭代
-    public static TreeNode upsideDownBinaryTree2(TreeNode root){
-        TreeNode cur=root;
-        TreeNode pre=null;
-        TreeNode next=null;
-        TreeNode tmp=null;
-        while(cur!=null){
-            next=cur.left;
-            cur.left=tmp;
-            tmp=cur.right;
-            cur.right=pre;
-
-            pre=cur;
-            cur=next;
-        }
-        return pre;
-    }
-
-
-
-}
Index: src/Leetcode/Solution190.java
===================================================================
diff --git a/src/Leetcode/Solution190.java b/src/Leetcode/Solution190.java
deleted file mode 100644
--- a/src/Leetcode/Solution190.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,47 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:颠倒给定的 32 位无符号整数的二进制位。
-
- 
-
-示例 1：
-
-输入: 00000010100101000001111010011100
-输出: 00111001011110000010100101000000
-解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
-因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
-示例 2：
-
-输入：11111111111111111111111111111101
-输出：10111111111111111111111111111111
-解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
-     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
- 
-
-提示：
-
-请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
-在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/reverse-bits
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/7/9 22:46
- */
-public class Solution190 {
-
-
-    // you need treat n as an unsigned value
-    public static int reverseBits(int n) {
-        return 1;
-    }
-
-    public static void main(String[] args) {
-        int n=43261596;
-        System.out.println(reverseBits(n));
-
-    }
-}
Index: src/Leetcode/Solution207.java
===================================================================
diff --git a/src/Leetcode/Solution207.java b/src/Leetcode/Solution207.java
deleted file mode 100644
--- a/src/Leetcode/Solution207.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,40 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2020/5/5 12:25
- */
-public class Solution207 {
-
-    public static boolean canFinish(int numCourses, int[][] prerequisites) {
-        if(prerequisites==null || prerequisites.length==0) return true;
-        int len=prerequisites.length;
-        int tmp=len;
-        //if(len>=numCourses) return false;
-        int[] res=new int[]{prerequisites[0][0],prerequisites[0][1]};
-        int i=1;
-        while(tmp!=1){
-            tmp--;
-            for(i=1;i<len;i++){
-                if(prerequisites[i][0]==res[1]){
-                    res[1]=prerequisites[i][1];
-                    prerequisites[i][0]=-1;
-                    prerequisites[i][1]=-1;
-                    break;
-                }
-            }
-            if(i==len)
-                return true;
-        }
-        if(res[0]==res[1]) return false;
-        return true;
-
-    }
-
-    public static void main(String[] args) {
-        int[][] arr=new int[][]{{0,1},{0,2},{1,2}};
-        System.out.println(canFinish(3,arr));
-    }
-}
Index: src/Leetcode/TrieTree/Solution211.java
===================================================================
diff --git a/src/Leetcode/TrieTree/Solution211.java b/src/Leetcode/TrieTree/Solution211.java
deleted file mode 100644
--- a/src/Leetcode/TrieTree/Solution211.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,127 +0,0 @@
-package Leetcode.TrieTree;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:设计一个支持以下两种操作的数据结构：
-
-void addWord(word)
-bool search(word)
-search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 . 可以表示任何一个字母。
-
-示例:
-
-addWord("bad")
-addWord("dad")
-addWord("mad")
-search("pad") -> false
-search("bad") -> true
-search(".ad") -> true
-search("b..") -> true
-说明:
-
-你可以假设所有单词都是由小写字母 a-z 组成的。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/add-and-search-word-data-structure-design
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/20 17:09
- */
-public class Solution211 {
-    private Node root;
-    public class Node{
-        Node[] children=new Node[26];
-        boolean end;
-        public Node(){
-            this.end=false;
-        }
-    }
-
-    /** Initialize your data structure here. */
-    public Solution211() {
-        this.root=new Node();
-    }
-
-    /** Adds a word into the data structure. */
-    public void addWord(String word) {
-        Node cur=root;
-        for(char ch: word.toCharArray()){
-            if(cur.children[ch-'a']!=null){
-                cur=cur.children[ch-'a'];
-            }else{
-                cur.children[ch-'a']=new Node();
-                cur=cur.children[ch-'a'];
-            }
-        }
-        cur.end=true;
-
-    }
-
-    /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */
-    public boolean search(String word) {
-        Node cur=root;
-        for(int i=0;i<word.length();i++){
-            char ch=word.charAt(i);
-            if(ch>='a' && ch<='z'){
-                if(cur.children[ch-'a']!=null) {
-                    cur = cur.children[ch - 'a'];
-                }
-                else
-                    return false;
-            }else{//遇到了.
-                for(Node next :cur.children){
-                    if(next!=null)
-                    if(process(word,next,i+1))
-                        return true;
-                }
-                return false;//字典中的单词已经到了最后一个字符，但是查找的单词还有在最后还有一个.的情况。
-
-            }
-        }
-        if(cur.end) return true;
-        return false;
-    }
-
-    private boolean process(String word,Node cur,int pos){
-        if(pos==word.length())
-            return true;
-        for(int i=pos;i<word.length();i++){
-            char ch=word.charAt(i);
-            if(ch>='a' && ch<='z'){
-                if(cur.children[ch-'a']!=null){
-                    cur=cur.children[ch-'a'];
-                }else{
-                    return false;
-                }
-            }else{
-                for(Node next:cur.children){
-                    if(next!=null)
-                    if(process(word,next,i+1))
-                        return true;
-                }
-                return false;//字典中的单词已经到了最后一个字符，但是查找的单词还有在最后还有一个.的情况。
-            }
-        }
-
-        if(cur.end) return true;
-        return false;
-
-    }
-
-    public static void main(String[] args) {
-        Solution211 solution211=new Solution211();
-        solution211.addWord("bad");
-        solution211.addWord("dad");
-
-        solution211.addWord("mad");
-        solution211.addWord("pad");
-        solution211.search("bad");
-        System.out.println( solution211.search(".ad"));
-
-        solution211.search("p..");
-
-
-
-
-    }
-}
Index: src/Leetcode/TrieTree/Solution212.java
===================================================================
diff --git a/src/Leetcode/TrieTree/Solution212.java b/src/Leetcode/TrieTree/Solution212.java
deleted file mode 100644
--- a/src/Leetcode/TrieTree/Solution212.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,188 +0,0 @@
-package Leetcode.TrieTree;
-
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 给定一个二维网格 board 和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。
-
-单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。
-
-示例:
-
-输入:
-words = ["oath","pea","eat","rain"] and board =
-[
-['o','a','a','n'],
-['e','t','a','e'],
-['i','h','k','r'],
-['i','f','l','v']
-]
-
-输出: ["eat","oath"]
-说明:
-你可以假设所有输入都由小写字母 a-z 组成。
-
-提示:
-
-你需要优化回溯算法以通过更大数据量的测试。你能否早点停止回溯？
-如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。什么样的数据结构可以有效地执行这样的操作？散列表是否可行？为什么？ 前缀树如何？如果你想学习如何实现一个基本的前缀树，请先查看这个问题： 实现Trie（前缀树）。
-通过次数15,287提交次数37,454
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/word-search-ii
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/19 10:58
- */
-public class Solution212 {
-
-//    //回溯法
-//    private List<String> res=new ArrayList<>();
-//    public List<String> findWords(char[][] board, String[] words) {
-//       // res=new ArrayList<>();
-//        if(board==null || board.length==0 || words==null || words.length==0)
-//            return res;
-//        int row=board.length;
-//        int col=board[0].length;
-//        int len=words.length;
-//        boolean[][] visited=new boolean[row][col];
-//        for(int i=0;i<len;i++){
-//            String str=words[i];
-//           boolean flag=false;
-//            for(int m=0;m<row;m++){
-//                Arrays.fill(visited[m],false);
-//            }
-//            for(int j=0;j<row;j++){
-//                for(int k=0;k<col;k++){
-//                    if(board[j][k]==str.charAt(0)){
-//                        if(process(j,k,board,visited,str,0)){
-//                            flag=true;
-//                           break;
-//                        }
-//                    }
-//                }
-//               if(flag)
-//                   break;
-//            }
-//        }
-//        return res;
-//    }
-//
-//    private boolean process(int i,int j,char[][] board,boolean[][] visited,String str,int pos){
-//        if(pos==str.length()){
-//            res.add(str);
-//            return true;
-//        }
-//        if(i<0 || j<0 || i>=board.length || j>=board[0].length || visited[i][j]){
-//            return false;
-//        }
-//        if(board[i][j]==str.charAt(pos)){
-//            visited[i][j]=true;//记录该点被访问
-//        }else{
-//            return false;
-//        }
-//
-//        if(process(i+1,j,board,visited,str,pos+1)) return true;
-//        if(process(i-1,j,board,visited,str,pos+1)) return true;
-//        if(process(i,j+1,board,visited,str,pos+1)) return true;
-//        if(process(i,j-1,board,visited,str,pos+1)) return true;
-//        visited[i][j]=false;//回溯
-//        return false;
-//    }
-
-    //前缀树回溯方法
-//前缀树结点
-public class Node{
-    Node[] children=new Node[26];
-    boolean end=false;//是否是结尾
-    String val;//当前节点代表的字符串值
-    public Node(){
-    }
-}
-
-    //前缀树
-    public class TrieTree{
-        public Node root;
-        public TrieTree(){
-            this.root=new Node();
-        }
-        public void insert(String str){
-            Node cur=root;
-            for(char ch :str.toCharArray()){
-                if(cur.children[ch-'a']!=null){
-                    cur=cur.children[ch-'a'];
-                }else{
-                    cur.children[ch-'a']=new Node();
-                    cur=cur.children[ch-'a'];
-                }
-            }
-            cur.end=true;
-            cur.val=str;
-        }
-    }
-
-    public List<String> findWords(char[][] board, String[] words) {
-        if(board==null || board.length==0 || words==null || words.length==0)
-            return new ArrayList<>();
-        int row=board.length;
-        int col=board[0].length;
-        int len=words.length;
-        boolean[][] visited=new boolean[row][col];
-        TrieTree trieTree=new TrieTree();
-        for(int i=0;i<len;i++){
-            trieTree.insert(words[i]);
-        }
-
-        Set<String> set=new HashSet<>();//将可能的结果加入的set中，防止重复
-        for(int i=0;i<row;i++){
-            for(int j=0;j<col;j++){//以board中的每一个字符为开始进行遍历
-                process(i,j,visited,board,set,trieTree.root);
-            }
-        }
-        return new ArrayList<>(set);
-
-    }
-
-    //i,j:表示下一步要去board中要去的位置，
-    public void process(int i,int j,boolean[][] visited,char[][] board,Set<String> set,Node cur){
-        if(i<0 || j<0 || i>=board.length || j>=board[0].length || visited[i][j]) //越界或者已经访问了
-            return ;
-        cur=cur.children[board[i][j]-'a'];
-        visited[i][j]=true;
-        if(cur==null){
-            visited[i][j]=false;
-            return;
-        }
-
-        //已经找到了单词
-        if(cur.end){
-            set.add(cur.val);//找到单词后不回退，因为可能同时存在"add",“addd"这样的单词
-        }
-
-        process(i+1,j,visited,board,set,cur);
-        process(i-1,j,visited,board,set,cur);
-        process(i,j+1,visited,board,set,cur);
-        process(i,j-1,visited,board,set,cur);
-        visited[i][j]=false;//最后回退
-
-
-
-    }
-    public static void main(String[] args) {
-        String []words={"oath","pea","eat","rain"};
-        char[][] boards={{'o','a','a','n'},
-                {'e','t','a','e'},
-                {'i','h','k','r'},
-                {'i','f','l','v'}
-                  };
-
-        List<String> list = new Solution212().findWords(boards, words);
-        System.out.println(list.size());
-
-    }
-}
Index: src/Leetcode/Solution290.java
===================================================================
diff --git a/src/Leetcode/Solution290.java b/src/Leetcode/Solution290.java
deleted file mode 100644
--- a/src/Leetcode/Solution290.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,119 +0,0 @@
-package Leetcode;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。
-
-这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。
-
-示例1:
-
-输入: pattern = "abba", str = "dog cat cat dog"
-输出: true
-示例 2:
-
-输入:pattern = "abba", str = "dog cat cat fish"
-输出: false
-示例 3:
-
-输入: pattern = "aaaa", str = "dog cat cat dog"
-输出: false
-示例 4:
-
-输入: pattern = "abba", str = "dog dog dog dog"
-输出: false
-说明:
-你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/word-pattern
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/12/16 14:42
- */
-public class Solution290 {
-
-    //方法一：
-    public static boolean wordPattern(String pattern, String s) {
-        if(pattern==null || pattern.length()==0)
-            return s==null || s.length()==0;
-        if(s==null || s.length()==0) return false;
-        String[] strs=s.split(" ");
-        int m=pattern.length();
-        int n=strs.length;
-        if(m!=n) return false;
-        HashMap<Integer,String> map=new HashMap<>();
-        HashMap<String,List<Integer>> map2 = new HashMap<>();
-        for(int i=0;i<n;i++){
-            map.put(i,strs[i]);
-            if(map2.containsKey(strs[i])){
-                List<Integer> list=map2.get(strs[i]);
-                list.add(i);
-            }else{
-                List<Integer> list = new ArrayList<>();
-                list.add(i);
-                map2.put(strs[i],list);
-            }
-        }
-        List<Integer>[] help=new List[26];
-        for(int i=0;i<26;i++){
-            help[i]=new ArrayList<>();
-        }
-        for(int i=0;i<m;i++){
-            char c=pattern.charAt(i);
-            help[c-'a'].add(i);
-        }
-        for(int i=0;i<26;i++){
-            if(help[i].size()>0){
-                int first=help[i].get(0);
-                String str=map.get(first);
-                List<Integer> list=map2.get(str);
-                if(list.size() != help[i].size()){
-                    return false;
-                }
-                for(int j=0;j<help[i].size();j++){
-                    if(! help[i].get(j).equals(list.get(j))){ //因为是Integer包装类型，所以这里如果使用!=可能会报错
-                        return false;
-                    }
-                }
-            }
-        }
-        return true;
-    }
-
-    //方法二：
-    public static boolean wordPattern2(String pattern, String s) {
-        if(pattern==null || pattern.length()==0)
-            return s==null || s.length()==0;
-        if(s==null || s.length()==0) return false;
-        String[] strs=s.split(" ");
-        int m=pattern.length();
-        int n=strs.length;
-        if(m!=n) return false;
-        HashMap<Character,String> map=new HashMap<>();//字符：字符串的映射
-        for(int i=0;i<m;i++){
-            char c=pattern.charAt(i);
-            if(!map.containsKey(c)){
-                if(map.containsValue(strs[i]))
-                    return false;
-                map.put(c,strs[i]);
-            }else{
-                if(!map.get(c).equals(strs[i]))
-                    return false;
-            }
-        }
-        return true;
-    }
-
-
-
-    public static void main(String[] args) {
-        String pattern="ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccdd";
-        String s="s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s t t";
-        System.out.println(wordPattern(pattern,s));
-    }
-}
Index: src/Leetcode/博弈问题/Solution293.java
===================================================================
diff --git a/src/Leetcode/博弈问题/Solution293.java b/src/Leetcode/博弈问题/Solution293.java
deleted file mode 100644
--- a/src/Leetcode/博弈问题/Solution293.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,43 +0,0 @@
-package Leetcode.博弈问题;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip twoconsecutive "++" into "--". The game ends when a person can no longer make a move and therefore the other person will be the winner.
-
-Write a function to compute all possible states of the string after one valid move.
-
-For example, given s = "++++", after one move, it may become one of the following states:
-
-[
-"--++",
-"+--+",
-"++--"
-]
-If there is no valid move, return an empty list [].
-
-给一个只含有'+', '-'的字符串，每次可翻动两个连续的'+'，求有多少种翻法。
- * @date 2020/6/15 15:30
- */
-public class Solution293 {
-
-    public List<String> generatePossibleNextMoves(String s){
-        List<String> res=new ArrayList<>();
-        char[] chs = s.toCharArray();
-        for(int i=0;i<s.length()-1;i++){
-            if(chs[i]=='+' && chs[i+1]=='+')
-            {
-                chs[i]='-';
-                chs[i+1]='-';
-                res.add(new String(chs));
-                chs[i]='+';
-                chs[i+1]='+';
-            }
-        }
-        return res;
-    }
-}
Index: src/Leetcode/博弈问题/Solution294.java
===================================================================
diff --git a/src/Leetcode/博弈问题/Solution294.java b/src/Leetcode/博弈问题/Solution294.java
deleted file mode 100644
--- a/src/Leetcode/博弈问题/Solution294.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,36 +0,0 @@
-package Leetcode.博弈问题;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -,
- * you and your friend take turns to flip two consecutive "++" into "--". The game ends when a person can no longer make a
- * move and therefore the other person will be the winner.
-
-Write a function to determine if the starting player can guarantee a win.
-
-Example:
-
-Input: s = "++++"
-Output: true
-Explanation: The starting player can guarantee a win by flipping the middle "++" to become "+--+".
- * @date 2020/6/15 16:07
- */
-public class Solution294 {
-
-    //题目的意思是只要存在一种方式使得第一个先翻牌的人赢便返回true
-    public boolean canWin(String s){
-        if(s==null || s.length()<2)
-              return false;
-        int len=s.length();
-        for(int i=0;i<len-1;i++){
-            if(s.charAt(i)=='+' && s.charAt(i+1)=='+' && !canWin(s.substring(0,i)+"--"+s.substring(i+2)))
-                //第一个人将i以及i+1位置的+翻转成‘--’，然后if中的canwin表示第二个的操作，此时新的s,
-                // 第二个人相当于是第一个对新的s进行操作的人，并且他无论如何操作都返回false,从而说明存在使第一个人赢的翻牌操作
-                return true;
-        }
-        return false;
-
-    }
-}
Index: src/Leetcode/Solution300.java
===================================================================
diff --git a/src/Leetcode/Solution300.java b/src/Leetcode/Solution300.java
deleted file mode 100644
--- a/src/Leetcode/Solution300.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,69 +0,0 @@
-package Leetcode;
-
-import java.util.ArrayList;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 给定一个无序的整数数组，找到其中最长上升子序列的长度。
-
-示例:
-
-输入: [10,9,2,5,3,7,101,18]
-输出: 4
-解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
-
-说明:
-
-可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
-你算法的时间复杂度应该为 O(n2) 。
-
-进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/longest-increasing-subsequence
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/5/4 13:11
- */
-public class Solution300 {
-
-
-        public static int lengthOfLIS(int[] nums) {
-
-            if(nums==null || nums.length==0)
-                return 0;
-            int len=nums.length;
-            int[] dp=new int[len];//代表长度为i+1的递增子序列的最小结尾
-            dp[0]=nums[0];
-            int l=0,r=0,right=1;//right代表dp的有效长度
-            for(int i=1;i<len;i++){
-                l=0;r=right;
-                while(l<r){
-                    int m=(l+r)>>>1;
-                    if(nums[i]>dp[m]){
-                        l=m+1;
-                    }else{
-                        r=m;
-                    }
-                }
-                dp[l]=nums[i];
-//                right=Math.max(right,l);
-                if(l==right) right++;
-            }
-            return right;
-        }
-
-    public static void main(String[] args) {
-        int[] arr=new int[]{10,9,2,5,3,7,101,18};
-        //System.out.println(lengthOfLIS(arr));
-        ArrayList<Integer> list=new ArrayList<>();
-        list.add(1);
-        ArrayList<ArrayList<Integer>>res=new ArrayList<>();
-        res.add(new ArrayList<Integer>(list){{add(2);}});
-        System.out.println(res.size());
-
-
-     }
-    }
-
Index: src/Leetcode/dp/Solution312.java
===================================================================
diff --git a/src/Leetcode/dp/Solution312.java b/src/Leetcode/dp/Solution312.java
deleted file mode 100644
--- a/src/Leetcode/dp/Solution312.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,71 +0,0 @@
-package Leetcode.dp;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。
-
-现在要求你戳破所有的气球。如果你戳破气球 i ，就可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。
-
-求所能获得硬币的最大数量。
-
-说明:
-
-你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。
-0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100
-示例:
-
-输入: [3,1,5,8]
-输出: 167
-解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
-     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
-通过次数16,358提交次数26,232
-在真实的面试中遇到过这道题？
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/burst-balloons
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/7/19 11:00
- */
-public class Solution312 {
-
-    public static int maxCoins(int[] nums) {
-        if(nums==null || nums.length==0)
-            return 0;
-        int n=nums.length;
-        int[] help=new int[n+2];
-        help[0]=1;
-        help[n+1]=1;
-        for(int i=0;i<n;i++){
-            help[i+1]=nums[i];
-        }
-        int[][] dp=new int[help.length][help.length];
-        for(int i=1;i<=n;i++){
-            for(int j=i;j>=1;j--){//戳破j-i范围内的气球
-                if(i==j){
-                    dp[i][j]=help[i]*help[i-1]*help[i+1];
-                }else{
-                    int max=Integer.MIN_VALUE;
-                    for(int k=j;k<=i;k++){//最后戳破哪个气球
-                        if(k==j){
-                            max=Math.max(max,help[j]*help[j-1]*help[i+1]+dp[j+1][i]);
-                        }else if(k==i){
-                            max=Math.max(max,help[i]*help[j-1]*help[i+1]+dp[j][i-1]);
-                        }else{
-                            max=Math.max(max,dp[j][k-1]+dp[k+1][i]+help[i+1]*help[k]*help[j-1]);
-                        }
-                        dp[j][i]=max;
-                    }
-                }
-            }
-        }
-        return dp[1][n];
-
-    }
-
-    public static void main(String[] args) {
-
-        int[] nums={3,1,5,8};
-        System.out.println(maxCoins(nums));
-    }
-}
Index: src/Leetcode/字符串/Solution316.java
===================================================================
diff --git a/src/Leetcode/字符串/Solution316.java b/src/Leetcode/字符串/Solution316.java
deleted file mode 100644
--- a/src/Leetcode/字符串/Solution316.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,65 +0,0 @@
-package Leetcode.字符串;
-
-/**
- * @Author zbl
- * @Date 2020/12/20 16:32
- * @Content给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。
- * <p>
- * 注意：该题与 1081 https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters 相同
- * <p>
- *  
- * <p>
- * 示例 1：
- * <p>
- * 输入：s = "bcabc"
- * 输出："abc"
- * 示例 2：
- * <p>
- * 输入：s = "cbacdcbc"
- * 输出："acdb"
- *  
- * <p>
- * 提示：
- * <p>
- * 1 <= s.length <= 104
- * s 由小写英文字母组成
- * <p>
- * 来源：力扣（LeetCode）
- * 链接：https://leetcode-cn.com/problems/remove-duplicate-letters
- * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @Version 1.0
- */
-public class Solution316 {
-
-    public static String removeDuplicateLetters(String s) {
-        boolean[] vis = new boolean[26];
-        int[] num = new int[26];
-        for (int i = 0; i < s.length(); i++) {
-            num[s.charAt(i) - 'a']++;
-        }
-
-        StringBuffer sb = new StringBuffer();
-        for (int i = 0; i < s.length(); i++) {
-            char ch = s.charAt(i);
-            if (!vis[ch - 'a']) {
-                while (sb.length() > 0 && sb.charAt(sb.length() - 1) > ch) {
-                    if (num[sb.charAt(sb.length() - 1) - 'a'] > 0) {
-                        vis[sb.charAt(sb.length() - 1) - 'a'] = false;
-                        sb.deleteCharAt(sb.length() - 1);
-                    } else {
-                        break;
-                    }
-                }
-                vis[ch - 'a'] = true;
-                sb.append(ch);
-            }
-            num[ch - 'a'] -= 1;
-        }
-        return sb.toString();
-    }
-
-    public static void main(String[] args) {
-        String str = "cbacdcbc";
-        System.out.println(removeDuplicateLetters(str));
-    }
-}
Index: src/Leetcode/数组/Solution321.java
===================================================================
diff --git a/src/Leetcode/数组/Solution321.java b/src/Leetcode/数组/Solution321.java
deleted file mode 100644
--- a/src/Leetcode/数组/Solution321.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,159 +0,0 @@
-package Leetcode.数组;
-
-import java.util.Stack;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k <= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。
-
-求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。
-
-说明: 请尽可能地优化你算法的时间和空间复杂度。
-
-示例 1:
-
-输入:
-nums1 = [3, 4, 6, 5]
-nums2 = [9, 1, 2, 5, 8, 3]
-k = 5
-输出:
-[9, 8, 6, 5, 3]
-示例 2:
-
-输入:
-nums1 = [6, 7]
-nums2 = [6, 0, 4]
-k = 5
-输出:
-[6, 7, 6, 0, 4]
-示例 3:
-
-输入:
-nums1 = [3, 9]
-nums2 = [8, 9]
-k = 3
-输出:
-[9, 8, 9]
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/create-maximum-number
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/7/31 22:55
- */
-public class Solution321 {
-
-    public static int[] maxNumber(int[] nums1, int[] nums2, int k) {
-        if((nums1==null || nums1.length==0) && (nums2==null || nums2.length==0))
-            return new int[0];
-        int m=nums1.length;
-        int n=nums2.length;
-        int [] res=new int[k];
-        if(k==m+n){
-            return getMax(k,nums1,nums2);
-        }else{ //k<m+n;
-            for(int i=0;i<=k;i++){//从nums1中取i个数
-                if(m-i>=0 && n-k+i>=0){
-                    int[] ans1=process(nums1,m-i);
-                    int[] ans2=process(nums2,n-k+i);
-                    int[] ans=getMax(k,ans1,ans2);
-                    if(!isBiger(res,ans)) res=ans;
-                }
-            }
-        }
-        return res;
-
-    }
-
-    private static int[] getMax(int k,int[] nums1,int[] nums2){
-        if(nums1==null || nums2==null){
-            return nums2==null ? nums1:nums2;
-        }
-        int[] res=new int[k];
-        int left=0,right=0;
-        int index=0;
-        int m=nums1.length;
-        int n=nums2.length;
-        while(left<m && right<n){
-            if(nums1[left]>nums2[right]){
-                res[index++]=nums1[left];
-                left++;
-            }else if(nums1[left]<nums2[right]){
-                res[index++]=nums2[right++];
-            }else{//相等的情况
-                if(compare(nums1,nums2,left,right)){
-                    res[index++]=nums1[left++];
-                }else{
-                    res[index++]=nums2[right++];
-                }
-            }
-        }
-        while(left<m){
-            res[index++]=nums1[left++];
-        }
-        while(right<n){
-            res[index++]=nums2[right++];
-        }
-        return res;
-    }
-
-    //长度为n的数组中，去掉k个数字，使他们组成的数值最大
-    private static int[] process(int[] nums,int k){
-        int n=nums.length;
-        int[] res=new int[n-k];
-        if(k==0) return nums;
-        if(k==n) return null;
-        Stack<Integer> stack=new Stack<>();
-        for(int i=0;i<n;i++){
-            int num=nums[i];
-            while(!stack.isEmpty() && k>0 && stack.peek()<num){
-                stack.pop();
-                k--;
-            }
-            stack.push(num);
-        }
-        while(k>0){
-            stack.pop();
-            k--;
-        }
-        int len=res.length-1;
-        while(!stack.isEmpty()){
-            res[len--]=stack.pop();
-        }
-        return res;
-    }
-
-    //长度相同的nums1与nums2,是否num1形成的数字大于nums2形成的数字
-    private static boolean isBiger(int[] nums1,int[] nums2){
-        int n=nums1.length;
-        for(int i=0;i<n;i++){
-            if(nums1[i]>nums2[i]) return true;
-            if(nums1[i]<nums2[i]) return false;
-            continue;
-        }
-        return false;
-
-    }
-
-    //当nums1与nums2分别在p1、p2位置相同的时候应该移动谁的坐标。true:移动p1
-    private static boolean compare(int[] nums1,int[] nums2,int p1,int p2){
-        int m=nums1.length;
-        int n=nums2.length;
-        while(p1<m && p2<n && nums1[p1]==nums2[p2]){
-            p1++;
-            p2++;
-        }
-        return p2==n ||(p1<m && nums1[p1]>nums2[p2]);
-    }
-
-    public static void main(String[] args) {
-        int[] nums1={3,4,6,5};
-        int[] nums2={9, 1, 2, 5, 8, 3};
-        int[] ints = maxNumber(nums1, nums2, 5);
-        for(int num:ints){
-            System.out.println(num);
-        }
-    }
-
-
-}
Index: src/Leetcode/Solution368.java
===================================================================
diff --git a/src/Leetcode/Solution368.java b/src/Leetcode/Solution368.java
deleted file mode 100644
--- a/src/Leetcode/Solution368.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,87 +0,0 @@
-package Leetcode;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对 (answer[i], answer[j]) 都应当满足：
-answer[i] % answer[j] == 0 ，或
-answer[j] % answer[i] == 0
-如果存在多个有效解子集，返回其中任何一个均可。
-
- 
-
-示例 1：
-
-输入：nums = [1,2,3]
-输出：[1,2]
-解释：[1,3] 也会被视为正确答案。
-示例 2：
-
-输入：nums = [1,2,4,8]
-输出：[1,2,4,8]
- 
-
-提示：
-
-1 <= nums.length <= 1000
-1 <= nums[i] <= 2 * 109
-nums 中的所有整数 互不相同
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/largest-divisible-subset
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2021/4/23 18:10
- */
-public class Solution368 {
-
-    public static List<Integer> largestDivisibleSubset(int[] nums) {
-        int len = nums.length;
-        Arrays.sort(nums);
-
-        // 第 1 步：动态规划找出最大子集的个数、最大子集中的最大整数
-        int[] dp = new int[len];
-        Arrays.fill(dp, 1);
-        int maxSize = 1;
-        int maxVal = dp[0];
-        for (int i = 1; i < len; i++) {
-            for (int j = 0; j < i; j++) {
-                // 题目中说「没有重复元素」很重要
-                if (nums[i] % nums[j] == 0) {
-                    dp[i] = Math.max(dp[i], dp[j] + 1);
-                }
-            }
-
-            if (dp[i] > maxSize) {
-                maxSize = dp[i];
-                maxVal = nums[i];
-            }
-        }
-
-        // 第 2 步：倒推获得最大子集
-        List<Integer> res = new ArrayList<Integer>();
-        if (maxSize == 1) {
-            res.add(nums[0]);
-            return res;
-        }
-
-        for (int i = len - 1; i >= 0 && maxSize > 0; i--) {
-            if (dp[i] == maxSize && maxVal % nums[i] == 0) {
-                res.add(nums[i]);
-                maxVal = nums[i];
-                maxSize--;
-            }
-        }
-        return res;
-    }
-
-    public static void main(String[] args) {
-        int[] arr = {5,9,18,54,108,540,90,180,360,720};
-        largestDivisibleSubset(arr);
-
-    }
-
-}
Index: src/Leetcode/子序列/Solution392.java
===================================================================
diff --git a/src/Leetcode/子序列/Solution392.java b/src/Leetcode/子序列/Solution392.java
deleted file mode 100644
--- a/src/Leetcode/子序列/Solution392.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,57 +0,0 @@
-package Leetcode.子序列;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
-
-你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。
-
-字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。
-
-示例 1:
-s = "abc", t = "ahbgdc"
-
-返回 true.
-
-示例 2:
-s = "axc", t = "ahbgdc"
-
-返回 false.
-
-后续挑战 :
-
-如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/is-subsequence
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/7/27 22:07
- */
-public class Solution392 {
-
-    public static boolean isSubsequence(String s, String t) {
-        if(t==null || t.length()==0){
-            if(s==null || s.length()==0)
-                return true;
-            else
-                return false;
-        }
-        int n=t.length(),m=s.length();
-        int i=0,j=0;
-        while(i<n && j<m){
-            if(s.charAt(j)==t.charAt(i)){
-                j++;
-            }
-            i++;
-        }
-        return j==m;
-
-    }
-
-    public static void main(String[] args) {
-       String s="abc" ;
-       String t="ahbgdc";
-        System.out.println(isSubsequence(s,t));
-    }
-}
Index: src/Leetcode/Solution394.java
===================================================================
diff --git a/src/Leetcode/Solution394.java b/src/Leetcode/Solution394.java
deleted file mode 100644
--- a/src/Leetcode/Solution394.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,98 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一个经过编码的字符串，返回它解码后的字符串。
-
-编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。
-
-你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。
-
-此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。
-
-示例:
-
-s = "3[a]2[bc]", 返回 "aaabcbc".
-s = "3[a2[c]]", 返回 "accaccacc".
-s = "2[abc]3[cd]ef", 返回 "abcabccdcdcdef"
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/decode-string
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/5/28 15:43
- */
-public class Solution394 {
-
-    public static String decodeString(String s) {
-        StringBuilder sb=new StringBuilder();
-        char[] chs=s.toCharArray();
-        int num=0;
-        int i=0;
-        while(i<chs.length){
-            if(chs[i]>='0' && chs[i]<='9'){
-                if(num==0){
-                    num=chs[i]-'0';
-                    i++;
-                }else{
-                    num=num*10+(chs[i++]-'0');
-                }
-            }else if(chs[i]=='['){
-                String[] res=process(s,i);
-                for(int j=0;j<num;j++){
-                    sb.append(res[0]);
-                }
-                num=0;
-                if(Integer.valueOf(res[1])==chs.length-1)
-                    break;
-                else
-                    i=Integer.valueOf(res[1])+1;
-            }else{
-                sb.append(chs[i++]);
-            }
-        }
-        return sb.toString();
-
-    }
-
-    private static String[] process(String s,int start) {//返回部分结果值以及终结的位置
-        String [] ans=new String[2];
-        int len=s.length();
-        int num=0;
-        StringBuilder sb=new StringBuilder();
-        if(s.charAt(start)=='['){
-            start++;
-        }
-        while(start<len){
-            if(s.charAt(start)!=']' && !(s.charAt(start)>='0' && s.charAt(start)<='9') && s.charAt(start)!='['){
-                sb.append(s.charAt(start++));
-            }else if(s.charAt(start)==']'){
-                String res=sb.toString();
-                ans[0]=res;
-                ans[1]=String.valueOf(start);
-                return ans;
-            }else if(s.charAt(start)>='0' && s.charAt(start)<='9' ){ //当前start位置为数字
-                 if(num==0)
-                      num=s.charAt(start++)-'0';
-                 else{
-                     num=num*10+(s.charAt(start++)-'0');
-                 }
-
-            }else{
-                String[] tmp=process(s,start);
-                for(int i=0;i<num;i++){
-                    sb.append(tmp[0]);
-                }
-                num=0;
-                start=Integer.valueOf(tmp[1])+1;
-            }
-        }
-        ans[0]=sb.toString();
-        ans[1]=String.valueOf(start-1);
-        return ans;
-    }
-    public static void main(String[] args) {
-        String str="3[a10[bc]]";
-        System.out.println(decodeString(str));
-    }
-}
Index: src/Leetcode/Solution415.java
===================================================================
diff --git a/src/Leetcode/Solution415.java b/src/Leetcode/Solution415.java
deleted file mode 100644
--- a/src/Leetcode/Solution415.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,63 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。
-
-注意：
-
-num1 和num2 的长度都小于 5100.
-num1 和num2 都只包含数字 0-9.
-num1 和num2 都不包含任何前导零。
-你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/add-strings
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/17 15:41
- */
-public class Solution415 {
-
-    public String addStrings(String num1, String num2) {
-        StringBuilder sb=new StringBuilder();
-        int len1=num1.length()-1;
-        int len2=num2.length()-1;
-        int help=0;
-        while(len1>=0 && len2>=0){
-            int n1=num1.charAt(len1--)-'0';
-            int n2=num2.charAt(len2--)-'0';
-            int h=(n1+n2+help)%10;
-            help=(n1+n2+help)/10;
-            sb.append(h);
-
-
-        }
-
-        while(len1>=0){
-            int n1=num1.charAt(len1--)-'0';
-            int h=(n1+help)%10;
-            help=(n1+help)/10;
-            sb.append(h);
-
-        }
-
-        while(len2>=0){
-            int n1=num2.charAt(len2--)-'0';
-            int h=(n1+help)%10;
-            help=(n1+help)/10;
-            sb.append(h);
-
-        }
-        if(help!=0)
-            sb.append(help);
-        return sb.reverse().toString();
-    }
-
-    public static void main(String[] args) {
-        String str1="98";
-        String str2="9";
-        System.out.println(new Solution415().addStrings(str1,str2));
-    }
-}
Index: src/Leetcode/TrieTree/Solution421.java
===================================================================
diff --git a/src/Leetcode/TrieTree/Solution421.java b/src/Leetcode/TrieTree/Solution421.java
deleted file mode 100644
--- a/src/Leetcode/TrieTree/Solution421.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,52 +0,0 @@
-package Leetcode.TrieTree;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2020/6/18 20:03
- */
-public class Solution421 {
-
-    public class Node{
-        Node[] children=new Node[2];;
-        public Node(){}
-    }
-    public int findMaximumXOR(int[] nums) {
-        int len=nums.length;
-        Node trie=new Node();
-        int max_xor=0;
-        for(int i=0;i<len;i++){
-            int num=nums[i];
-            Node cur=trie,xor_node=trie;
-            int xor_num=0;
-            for(int j=31;j>=0;j--){
-                int index=num & (1<<j);
-                if(cur.children[index]!=null){
-                    cur=cur.children[index];
-                }else{
-                    cur.children[index]=new Node();
-                    cur=cur.children[index];
-                }
-
-                //选择最大的xor的值
-                int toggledindex=index==1 ? 0:1;
-                if(xor_node.children[toggledindex]!=null){
-                    xor_num=(xor_num<<1) | 1;
-                    xor_node=xor_node.children[toggledindex];
-                }else{
-                    xor_num=xor_num<<1;
-                    xor_node=xor_node.children[index];
-                }
-
-            }
-            max_xor=Math.max(max_xor,xor_num);
-        }
-        return max_xor;
-    }
-
-    public static void main(String[] args) {
-        int[] nums={3,10,5,25,2,8};
-        System.out.println(new Solution421().findMaximumXOR(nums));
-    }
-}
Index: src/Leetcode/数组/Solution448.java
===================================================================
diff --git a/src/Leetcode/数组/Solution448.java b/src/Leetcode/数组/Solution448.java
deleted file mode 100644
--- a/src/Leetcode/数组/Solution448.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,60 +0,0 @@
-package Leetcode.数组;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 448. 找到所有数组中消失的数字
-给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。
-
-找到所有在 [1, n] 范围之间没有出现在数组中的数字。
-
-您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。
-
-示例:
-
-输入:
-[4,3,2,7,8,2,3,1]
-
-输出:
-[5,6]
- * @date 2020/7/3 22:05
- */
-public class Solution448 {
-
-    public static List<Integer> findDisappearedNumbers(int[] nums) {
-        List<Integer> list=new ArrayList<>();
-        if(nums==null || nums.length==0) return list;
-        int n=nums.length;
-        for(int i=0;i<n;i++){
-            if(nums[i]==i+1){
-                continue;
-            }
-            if(nums[i]<=n)
-                swap(nums,i,nums[i]-1);
-        }
-        for(int i=0;i<n;i++){
-            if(nums[i]!=i+1)
-                list.add(nums[i]);
-        }
-        return list;
-    }
-
-    private static void swap(int[] nums,int i,int j){
-        int tmp=nums[i];
-        nums[i]=nums[j];
-        nums[j]=tmp;
-    }
-
-    public static void main(String[] args) {
-        int[] nums=new int[]{4,3,2,7,8,2,3,1};
-        List<Integer> list = findDisappearedNumbers(nums);
-        for(Integer num:list){
-            System.out.println(num);
-        }
-
-    }
-}
Index: src/Leetcode/数组/Solution452.java
===================================================================
diff --git a/src/Leetcode/数组/Solution452.java b/src/Leetcode/数组/Solution452.java
deleted file mode 100644
--- a/src/Leetcode/数组/Solution452.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,84 +0,0 @@
-package Leetcode.数组;
-
-import java.util.Arrays;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，
- * 因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。
-
-一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。
-
-给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。
-
- 
-示例 1：
-
-输入：points = [[10,16],[2,8],[1,6],[7,12]]
-输出：2
-解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球
-示例 2：
-
-输入：points = [[1,2],[3,4],[5,6],[7,8]]
-输出：4
-示例 3：
-
-输入：points = [[1,2],[2,3],[3,4],[4,5]]
-输出：2
-示例 4：
-
-输入：points = [[1,2]]
-输出：1
-示例 5：
-
-输入：points = [[2,3],[2,3]]
-输出：1
- 
-
-提示：
-
-0 <= points.length <= 104
-points[i].length == 2
--231 <= xstart < xend <= 231 - 1
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/11/23 15:28
- */
-public class Solution452 {
-
-    public static int findMinArrowShots(int[][] points) {
-        if(points==null || points.length==0) return 0;
-        if(points.length==1) return 1;
-        int n=points.length;
-        Arrays.sort(points,(a,b)->{ //注意这里不要做加减运算来比较大小，因为可能存在溢出问题
-            if(a[0]==b[0]){
-                return a[1]<b[1] ? -1:1;
-            }
-            return a[0]<b[0]  ? -1:1;
-        });
-        int count=0;
-        int[] help={points[0][0],points[0][1]};
-        int idx=1;
-        while(idx<n){
-            if(points[idx][0]>help[1]){
-                help[0]=points[idx][0];
-                help[1]=points[idx][1];
-                idx++;
-                count++;
-            }else{
-                help[0]=points[idx][0];
-                help[1]=Math.min(help[1],points[idx][1]);
-                idx++;
-            }
-        }
-        return ++count;
-    }
-
-    public static void main(String[] args) {
-        int[][] matrix={{-2147483646,-2147483645},{2147483646,2147483647}};
-        System.out.println(findMinArrowShots(matrix));
-    }
-}
Index: src/Leetcode/Solution468.java
===================================================================
diff --git a/src/Leetcode/Solution468.java b/src/Leetcode/Solution468.java
deleted file mode 100644
--- a/src/Leetcode/Solution468.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,111 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址。
-
-IPv4 地址由十进制数和点来表示，每个地址包含4个十进制数，其范围为 0 - 255， 用(".")分割。比如，172.16.254.1；
-
-同时，IPv4 地址内的数不会以 0 开头。比如，地址 172.16.254.01 是不合法的。
-
-IPv6 地址由8组16进制的数字来表示，每组表示 16 比特。这些组数字通过 (":")分割。比如,  2001:0db8:85a3:0000:0000:8a2e:0370:7334 是一个有效的地址。而且，我们可以加入一些以 0 开头的数字，字母可以使用大写，也可以是小写。所以， 2001:db8:85a3:0:0:8A2E:0370:7334 也是一个有效的 IPv6 address地址 (即，忽略 0 开头，忽略大小写)。
-
-然而，我们不能因为某个组的值为 0，而使用一个空的组，以至于出现 (::) 的情况。 比如， 2001:0db8:85a3::8A2E:0370:7334 是无效的 IPv6 地址。
-
-同时，在 IPv6 地址中，多余的 0 也是不被允许的。比如， 02001:0db8:85a3:0000:0000:8a2e:0370:7334 是无效的。
-
-说明: 你可以认为给定的字符串里没有空格或者其他特殊字符。
-
-示例 1:
-
-输入: "172.16.254.1"
-
-输出: "IPv4"
-
-解释: 这是一个有效的 IPv4 地址, 所以返回 "IPv4"。
-
-示例 2:
-
-输入: "2001:0db8:85a3:0:0:8A2E:0370:7334"
-
-输出: "IPv6"
-
-解释: 这是一个有效的 IPv6 地址, 所以返回 "IPv6"。
-
-示例 3:
-
-输入: "256.256.256.256"
-
-输出: "Neither"
-
-解释: 这个地址既不是 IPv4 也不是 IPv6 地址。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/validate-ip-address
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/4 21:36
- */
-public class Solution468 {
-
-    public  static String validIPAddress(String IP) {
-        if(IP==null || IP.length()==0) return "Neither";
-        int len=IP.length();
-        int odd=0,even=0;//统计.的数量以及：的数量
-        if(IP.charAt(0)=='.' || IP.charAt(0)==':' || IP.charAt(len-1)=='.' || IP.charAt(len-1)==':')
-            return "Neither";
-        for(int i=1;i<len;i++){
-            if(IP.charAt(i)=='.')
-                odd++;
-            else if(IP.charAt(i)==':')
-                even++;
-            if(IP.charAt(i)=='.' && IP.charAt(i-1)==IP.charAt(i))
-                return "Neither";
-            if(IP.charAt(i)==':' && IP.charAt(i-1)==IP.charAt(i))
-                return "Neither";
-
-        }
-        if((odd!=0 && even!=0) || (odd!=0 && odd!=3) || (even!=0 && even!=7))
-            return "Neither";
-        if(odd==3){//可能是ipv4的情况
-            String[] strs=IP.split("\\.");//这里的“|”或者“.”等作为分隔符的时候需要转义，即：加上\\
-            for(int j=0;j<strs.length;j++){
-                String str=strs[j];
-                if(str.length()>3 || (str.charAt(0)=='0' && str.length()!=1))
-                    return "Neither";
-                for(int i=0;i<str.length();i++){
-                    if(!(str.charAt(i)>='0' && str.charAt(i)<='9'))
-                        return "Neither";
-                }
-                if(Integer.valueOf(str)>255) return "Neither";
-            }
-            return "IPv4";
-        }
-
-        if(even==7){
-            String[] strs=IP.split(":");
-            for(int i=0;i<strs.length;i++){
-                String str=strs[i];
-                if(str.length()>4)
-                    return "Neither";
-                for(int j=0;j<str.length();j++){
-                    if(!(str.charAt(j)>='0' && str.charAt(j)<='9') &&
-                            !(str.charAt(j)>='a' && str.charAt(j)<='f') &&
-                            !(str.charAt(j)>='A' && str.charAt(j)<='F'))
-                        return "Neither";
-                }
-            }
-            return "IPv6";
-
-        }
-        return "Neither";
-
-
-    }
-
-    public static void main(String[] args) {
-        String str="1e1.4.5.6";
-        System.out.println(validIPAddress(str));
-
-    }
-}
Index: src/Leetcode/TrieTree/Solution472.java
===================================================================
diff --git a/src/Leetcode/TrieTree/Solution472.java b/src/Leetcode/TrieTree/Solution472.java
deleted file mode 100644
--- a/src/Leetcode/TrieTree/Solution472.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,99 +0,0 @@
-package Leetcode.TrieTree;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一个不含重复单词的列表，编写一个程序，返回给定单词列表中所有的连接词。
-
-连接词的定义为：一个字符串完全是由至少两个给定数组中的单词组成的。
-
-示例:
-
-输入: ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]
-
-输出: ["catsdogcats","dogcatsdog","ratcatdogcat"]
-
-解释: "catsdogcats"由"cats", "dog" 和 "cats"组成;
-"dogcatsdog"由"dog", "cats"和"dog"组成;
-"ratcatdogcat"由"rat", "cat", "dog"和"cat"组成。
-说明:
-
-给定数组的元素总数不超过 10000。
-给定数组中元素的长度总和不超过 600000。
-所有输入字符串只包含小写字母。
-不需要考虑答案输出的顺序。
-通过次数3,187提交次数7,201
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/concatenated-words
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/7/4 18:24
- */
-public class Solution472 {
-
-
-    //Trie Tree +dfs的方式
-    class Node{
-        private Node[] children=new Node[26];
-        private boolean end;
-
-        public Node(){
-
-        }
-    }
-
-    class Trie{
-        private Node root;
-        public Trie(){
-            this.root=new Node();
-        }
-        //构建trie tree
-        public void insert(String s){
-            Node cur=root;
-            for(char c:s.toCharArray()){
-                if(cur.children[c-'a']!=null){
-                    cur=cur.children[c-'a'];
-                }else{
-                    cur.children[c-'a']=new Node();
-                    cur=cur.children[c-'a'];
-                }
-            }
-            cur.end=true;
-
-        }
-        //判断
-        public boolean search(String s,int pos,int num){
-            Node cur=root;
-            for(int i=pos;i<s.length();i++){
-                if(cur.children[s.charAt(i)-'a']==null)
-                    return false;
-                cur=cur.children[s.charAt(i)-'a'];
-                if(cur.end){
-                    if(i==s.length()-1) return num>=1;//注意这里是>=1,而不是>1
-                    if(search(s,i+1,num+1)) return true;
-                }
-            }
-            return false;
-        }
-    }
-
-    public List<String> findAllConcatenatedWordsInADict(String[] words) {
-        List<String> list=new ArrayList<>();
-        if(words==null || words.length==0)
-            return list;
-        Trie trie=new Trie();
-        for(String str:words){
-            trie.insert(str);
-        }
-        for(String str: words){
-            if(trie.search(str,0,0))
-                list.add(str);
-        }
-        return list;
-    }
-
-
-}
Index: src/Leetcode/数组/Solution487.java
===================================================================
diff --git a/src/Leetcode/数组/Solution487.java b/src/Leetcode/数组/Solution487.java
deleted file mode 100644
--- a/src/Leetcode/数组/Solution487.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,55 +0,0 @@
-package Leetcode.数组;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一个二进制数组，你可以最多将 1 个 0 翻转为 1，找出其中最大连续 1 的个数。
-
-示例 1：
-
-输入：[1,0,1,1,0]
-输出：4
-解释：翻转第一个 0 可以得到最长的连续 1。
-当翻转以后，最大连续 1 的个数为 4。
-
-
-注：
-
-输入数组只包含 0 和 1.
-输入数组的长度为正整数，且不超过 10,000
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/max-consecutive-ones-ii
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/9/8 20:11
- */
-public class Solution487 {
-
-       public static int  process(int [] arr) {
-           int n = arr.length;
-           int left = 0, right = 0;
-           boolean flag = false;
-           int tmp=0;
-           int res = 0;
-           while (right < n) {
-               if (arr[right] == 0) {
-                   if(flag) {
-                       left = tmp + 1;
-                       flag = false;
-                   }
-                   else{
-                       flag = true;
-                       tmp=right;
-                   }
-
-               }
-               res = Math.max(res, ++right - left);
-           }
-           return res;
-       }
-
-    public static void main(String[] args) {
-        int[] arr=new int[]{1,0,1,1,0,1,1,1,1};
-        System.out.println(process(arr));
-    }
-}
Index: src/Leetcode/背包dp/Solution494.java
===================================================================
diff --git a/src/Leetcode/背包dp/Solution494.java b/src/Leetcode/背包dp/Solution494.java
deleted file mode 100644
--- a/src/Leetcode/背包dp/Solution494.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,68 +0,0 @@
-package Leetcode.背包dp;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。
-
-返回可以使最终数组和为目标数 S 的所有添加符号的方法数。
-
- 
-
-示例：
-
-输入：nums: [1, 1, 1, 1, 1], S: 3
-输出：5
-解释：
-
--1+1+1+1+1 = 3
-+1-1+1+1+1 = 3
-+1+1-1+1+1 = 3
-+1+1+1-1+1 = 3
-+1+1+1+1-1 = 3
-
-一共有5种方法让最终目标和为3。
- 
-
-提示：
-
-数组非空，且长度不会超过 20 。
-初始的数组的和不会超过 1000 。
-保证返回的最终结果能被 32 位整数存下。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/target-sum
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/25 13:21
- */
-public class Solution494 {
-
-    public int findTargetSumWays(int[] nums, int S) {
-        int n=nums.length;
-        int sum=0;
-        for(int i=0;i<n;i++){
-            sum+=nums[i];
-        }
-        if((sum+S)%2!=0 || sum<S)
-            return 0;
-        int target=(sum+S)/2;
-        int[] dp=new int[target+1];//前i个元素，组合得到和为j一共有多少种方案
-        for(int i=0;i<=n;i++){
-            dp[0]=1;//和为0的组合一共有1种
-        }
-
-        for(int i=1;i<=n;i++){
-            for(int j=target;j>=0;j--){
-                if(j-nums[i-1]>=0)
-                    dp[j]+=dp[j-nums[i-1]];
-            }
-        }
-        return dp[target];
-
-    }
-
-    public static void main(String[] args) {
-        int[] nums={1,1,1,1,1};
-        System.out.println(new Solution494().findTargetSumWays(nums,3));
-    }
-}
Index: src/Leetcode/Solution562.java
===================================================================
diff --git a/src/Leetcode/Solution562.java b/src/Leetcode/Solution562.java
deleted file mode 100644
--- a/src/Leetcode/Solution562.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,46 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:Given a 01 matrix M, find the longest line of consecutive one in the matrix. The line could be horizontal, vertical, diagonal or anti-diagonal.
-
-Example:
-
-Input:
-[[0,1,1,0],
-[0,1,1,0],
-[0,0,0,1]]
-Output: 3
-Hint: The number of elements in the given matrix will not exceed 10,000.
- * @date 2020/7/22 22:16
- */
-public class Solution562 {
-
-
-    public static int longestLine(int[][] matrix){
-        if(matrix==null || matrix.length==0) return 0;
-        int row=matrix.length;
-        int col=matrix[0].length;
-        int[][][] dp=new int[row][col][4];//表示从00-ij位置的元素在每个方向上最大的连续的1个数
-        int res=0;
-        for(int i=0;i<row;i++){
-            for(int j=0;j<col;j++){
-
-                if(matrix[i][j]==0)
-                    continue;//skip 0
-                for(int k=0;i<4;k++) dp[i][j][k]=1;//当i,j位置为1时，每个方向上至少结果值为1
-                if(i-1>=0) dp[i][j][0]+=dp[i-1][j][0];//垂直方向
-                res=Math.max(res,dp[i][j][0]);
-                if(j-1>=0) dp[i][j][1]+=dp[i][j-1][1];//水平方向
-                res=Math.max(res,dp[i][j][1]);
-                if(i-1>=0 && j-1>=0) dp[i][j][2]+=dp[i-1][j-1][2];// 对角线方向
-                res=Math.max(res,dp[i][j][2]);
-                if(i-1>=0 && j+1<col) dp[i][j][3]+=dp[i-1][j+1][3];//反对角线
-                res=Math.max(res,dp[i][j][3]);
-            }
-        }
-        return res;
-    }
-
-}
Index: src/Leetcode/Solution567.java
===================================================================
diff --git a/src/Leetcode/Solution567.java b/src/Leetcode/Solution567.java
deleted file mode 100644
--- a/src/Leetcode/Solution567.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,74 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。
-
-换句话说，第一个字符串的排列之一是第二个字符串的子串。
-
-示例1:
-
-输入: s1 = "ab" s2 = "eidbaooo"
-输出: True
-解释: s2 包含 s1 的排列之一 ("ba").
-
-
-
-示例2:
-
-输入: s1= "ab" s2 = "eidboaoo"
-输出: False
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/permutation-in-string
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/3 16:26
- */
-public class Solution567 {
-    public static boolean checkInclusion(String s1, String s2) {
-        if((s2==null || s2.length()==0) && s1!=null) return false;
-        if(s1==null || s1.length()==0) return true;
-        int len1=s1.length();
-        int len2=s2.length();
-        int[] help1=new int[26];//s1的辅助数组，代替map的作用
-        int [] help2=new int[26];//s2的辅助数组，代替map的作用
-        int left=0,right=0,count=0,valid=0;
-        for(int i=0;i<len1;i++){
-            help1[s1.charAt(i)-'a']++;//统计s1中每个字符的个数
-        }
-        //计算s1中不同字符的数量
-        for(int i=0;i<26;i++){
-            if(help1[i]!=0)
-                count++;
-        }
-
-        while(right!=len2){
-            int index=s2.charAt(right++)-'a';
-            if(help1[index]!=0){
-                help2[index]++;
-                if(help2[index]==help1[index])
-                    valid++;
-            }
-
-            //left--right的范围已经包含了s1的所有字符，进行判断缩小窗口
-            while(valid==count){
-                if(right-left==len1)
-                    return true;
-                int p=s2.charAt(left++)-'a';
-                if(help1[p]!=0){
-                    help2[p]--;
-                    if(help1[p]>help2[p])
-                        valid--;
-                }
-            }
-        }
-        return false;
-    }
-
-    public static void main(String[] args) {
-        String s1="adc";
-        String s2="dcda";
-        System.out.println(checkInclusion(s1,s2));
-    }
-}
Index: src/Leetcode/Solution605.java
===================================================================
diff --git a/src/Leetcode/Solution605.java b/src/Leetcode/Solution605.java
deleted file mode 100644
--- a/src/Leetcode/Solution605.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,110 +0,0 @@
-package Leetcode;
-
-import java.util.ArrayList;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。
-
-给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。
-
-示例 1:
-
-输入: flowerbed = [1,0,0,0,1], n = 1
-输出: True
-示例 2:
-
-输入: flowerbed = [1,0,0,0,1], n = 2
-输出: False
-注意:
-
-数组内已种好的花不会违反种植规则。
-输入的数组长度范围为 [1, 20000]。
-n 是非负整数，且不会超过输入数组的大小。
-通过次数51,826提交次数157,237
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/can-place-flowers
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2021/1/1 12:24
- */
-public class Solution605 {
-
-    public static boolean canPlaceFlowers(int[] flowerbed, int n) {
-        int m = flowerbed.length;
-        if(n == 0) {
-            return true;
-        }
-        if(n > (m + 1) / 2) {
-            return false;
-        }
-        int oneCount = 0;
-        ArrayList<Integer> list = new ArrayList<>();
-        for(int i = 0; i < m; i++){
-            if(flowerbed[i] == 1){
-                oneCount++;
-                list.add(i);
-            }
-        }
-        if(oneCount == 0){
-            return true;
-        }
-        if((oneCount + n) > (m + 1) / 2) {
-            return false;
-        }
-        int pos = list.get(0);
-        if(pos >= 2){
-            n -= pos/2;
-        }
-        if(n == 0){
-            return true;
-        }
-        int pre = pos;
-        for(int i = 1; i < list.size(); i++){
-            pos = list.get(i);
-            int diff = pos - pre -3;
-            if(diff >=1) {
-                n -= (diff + 1)/2;
-            }
-            if(n <= 0){
-                return true;
-            }
-            pre = pos;
-        }
-        n -= (m - pos - 1)/2;
-        return n > 0 ? false : true;
-    }
-    //方法二：
-    public static boolean canPlaceFlowers2(int[] flowerbed, int n) {
-        int m = flowerbed.length;
-        //用来统计可以最大种花的数量
-        int count = 0;
-        //上一个1出现的位置
-        int pre = -1;
-        for(int i = 0; i < m; i++){
-            if(flowerbed[i] == 1){
-                if(pre == -1){
-                    count += i / 2;
-                }else{
-                    count += (i - pre - 2) / 2;
-                }
-                pre = i;
-            }
-        }
-        if(pre == -1){
-            //一个1也没有的情况
-            count += (m + 1) / 2;
-        }else{
-            count += (m - pre - 1)/2;
-        }
-        return count >= n;
-
-    }
-
-    public static void main(String[] args) {
-        int[] arr={1,0,0,0,1};
-        System.out.println(canPlaceFlowers(arr,1));
-    }
-}
Index: src/Leetcode/数组/Solution621.java
===================================================================
diff --git a/src/Leetcode/数组/Solution621.java b/src/Leetcode/数组/Solution621.java
deleted file mode 100644
--- a/src/Leetcode/数组/Solution621.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,118 +0,0 @@
-package Leetcode.数组;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.PriorityQueue;
-
-/**
- * @Author zbl
- * @Date 2020/12/5 13:28
- * @Content
- * 给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。
- *
- * 然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。
- *
- * 你需要计算完成所有任务所需要的 最短时间 。
- *
- *  
- *
- * 示例 1：
- *
- * 输入：tasks = ["A","A","A","B","B","B"], n = 2
- * 输出：8
- * 解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B
- *      在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。
- * 示例 2：
- *
- * 输入：tasks = ["A","A","A","B","B","B"], n = 0
- * 输出：6
- * 解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0
- * ["A","A","A","B","B","B"]
- * ["A","B","A","B","A","B"]
- * ["B","B","B","A","A","A"]
- * ...
- * 诸如此类
- * 示例 3：
- *
- * 输入：tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2
- * 输出：16
- * 解释：一种可能的解决方案是：
- *      A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> (待命) -> (待命) -> A -> (待命) -> (待命) -> A
- *  
- *
- * 提示：
- *
- * 1 <= task.length <= 104
- * tasks[i] 是大写英文字母
- * n 的取值范围为 [0, 100]
- * 通过次数42,275提交次数79,564
- *
- * 来源：力扣（LeetCode）
- * 链接：https://leetcode-cn.com/problems/task-scheduler
- * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @Version 1.0
- */
-public class Solution621 {
-
-    public static int leastInterval(char[] tasks, int n) {
-        int m=tasks.length;
-        if(n==0) return m;
-        int ans=0;
-        HashMap<Character,Integer> map=new HashMap<>();
-        for(char ch : tasks){
-            map.put(ch,map.getOrDefault(ch,0)+1);
-        }
-
-        PriorityQueue<Character> queue=new PriorityQueue<>((a, b)->{
-            return map.get(b)-map.get(a);
-        });
-        for(Character ch: map.keySet()){
-            queue.add(ch);
-        }
-
-        int tmp=n;
-        List<Character> help=new ArrayList<>();
-        while(queue.size()>n){
-            ans+=(n+1);
-            while(tmp>-1){
-                tmp--;
-                Character ch=queue.poll();
-                int num=map.get(ch);
-                if(num>1) {
-                    map.put(ch,num-1);
-                    help.add(ch);
-                }else
-                    map.remove(ch);
-            }
-            for(Character ch :help){
-                queue.add(ch);
-            }
-            help.clear();
-            tmp=n;
-        }
-        if(queue.isEmpty()) return  ans;
-        int preNum=map.get(queue.poll());
-        int ll=preNum!=0 ? 1 : 0;
-        boolean flag=false;
-        while(!queue.isEmpty()){
-            char ch1=queue.poll();
-            int num=map.get(ch1);
-            if(num!=preNum){
-                ans+=(preNum-1)*(n+1);
-                flag=true;
-                break;
-            }else{
-                ll++;
-            }
-        }
-        ans+=ll;
-        if(!flag) ans+=(preNum-1)*(n+1);
-        return ans;
-    }
-
-    public static void main(String[] args) {
-        char[] arr={'A','B','C','D','E','A','B','C','D','E'};
-        System.out.println(leastInterval(arr,4));
-    }
-}
Index: src/Leetcode/TrieTree/Solution648.java
===================================================================
diff --git a/src/Leetcode/TrieTree/Solution648.java b/src/Leetcode/TrieTree/Solution648.java
deleted file mode 100644
--- a/src/Leetcode/TrieTree/Solution648.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,105 +0,0 @@
-package Leetcode.TrieTree;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:在英语中，我们有一个叫做 词根(root)的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。
-
-现在，给定一个由许多词根组成的词典和一个句子。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。
-
-你需要输出替换之后的句子。
-
- 
-
-示例：
-
-输入：dict(词典) = ["cat", "bat", "rat"] sentence(句子) = "the cattle was rattled by the battery"
-输出："the cat was rat by the bat"
- 
-
-提示：
-
-输入只包含小写字母。
-1 <= dict.length <= 1000
-1 <= dict[i].length <= 100
-1 <= 句中词语数 <= 1000
-1 <= 句中词语长度 <= 1000
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/replace-words
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/18 22:23
- */
-public class Solution648 {
-
-    public class Node{
-        Node[] children=new Node[26];
-        boolean end;
-        public Node(){
-            this.end=false;
-        }
-    }
-
-    public String replaceWords(List<String> dict, String sentence) {
-        String[] strs=sentence.split(" ");
-        StringBuilder sb=new StringBuilder();
-        Node root=new Node();
-        //将字典中的元素构建前缀树
-        for(String str :dict){
-            Node cur=root;
-            for(char ch :str.toCharArray()){
-                if(cur.children[ch-'a']!=null){
-                    cur=cur.children[ch-'a'];
-                }else{
-                    cur.children[ch-'a']=new Node();
-                    cur=cur.children[ch-'a'];
-                }
-            }
-            cur.end=true;//词根的结尾
-        }
-
-        for(String str: strs){
-            Node cur=root;
-            boolean flag=false;//判断是否没有碰到end结点
-            StringBuilder tmp=new StringBuilder();
-            for(char ch :str.toCharArray()){
-                if(cur.end) {
-                    sb.append(tmp.toString());
-                    sb.append(" ");
-                    flag=true;
-                    break;
-                }
-
-                if(cur.children[ch-'a']!=null){
-                    tmp.append(ch);
-                    cur=cur.children[ch-'a'];
-                }else{
-                    sb.append(str+" ");
-                    flag=true;
-                    break;
-                }
-
-            }
-            if(!flag)
-                sb.append(tmp.toString()+" ");
-        }
-        String res=sb.toString();
-        return res.substring(0,res.length()-1);
-
-
-    }
-
-    public static void main(String[] args) {
-        List<String> dict=new ArrayList<>();
-        dict.add("a");
-        dict.add("aa");
-        dict.add("aaa");
-        dict.add("aaaa");
-        String strs="a aa a aaaa aaa aaa aaa aaaaaa bbb baba ababa";
-        System.out.println(new Solution648().replaceWords(dict,strs));
-    }
-
-}
Index: src/Leetcode/字符串/Solution649.java
===================================================================
diff --git a/src/Leetcode/字符串/Solution649.java b/src/Leetcode/字符串/Solution649.java
deleted file mode 100644
--- a/src/Leetcode/字符串/Solution649.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,152 +0,0 @@
-package Leetcode.字符串;
-
-import java.util.LinkedList;
-import java.util.Queue;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)
-
-Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：
-
-禁止一名参议员的权利：
-
-参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。
-
-宣布胜利：
-
-          如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。
-
- 
-
-给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。
-
-以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。
-
-假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 Radiant 或 Dire。
-
- 
-
-示例 1：
-
-输入："RD"
-输出："Radiant"
-解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人
-示例 2：
-
-输入："RDD"
-输出："Dire"
-解释：
-第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利
-第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止
-第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利
-因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利
- 
-
-提示：
-
-给定字符串的长度在 [1, 10,000] 之间.
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/dota2-senate
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/12/11 19:10
- */
-public class Solution649 {
-
-    public static String predictPartyVictory(String senate) {
-        int m=senate.length();
-        boolean [] valid=new boolean[m];//表示第i个参议员是否有权利
-        int Rnum=0,Dnum=0;
-        for(int i=0;i<m;i++){
-            char c=senate.charAt(i);
-            if(c=='R') Rnum++;
-            else Dnum++;
-        }
-        while(Rnum!=0 && Dnum!=0){
-            for(int i=0;i<m;i++){
-                char c=senate.charAt(i);
-                if(!valid[i]){
-                    if(c=='D'){
-                        boolean flag=false;
-                        for(int j=i+1;j<m;j++){
-                            if(senate.charAt(j)=='R' && !valid[j]){
-                                valid[j]=true;
-                                flag=true;
-                                break;
-                            }
-                        }
-                        if(!flag){
-                            for(int j=0;j<i;j++){
-                                if(senate.charAt(j)=='R' && !valid[j]){
-                                    valid[j]=true;
-                                    flag=true;
-                                    break;
-                                }
-                            }
-                        }
-                        if(!flag){
-                            return "Dire";
-                        }
-                        Rnum--;
-                    }else if(c=='R'){
-                        boolean flag=false;
-                        for(int j=i+1;j<m;j++){
-                            if(senate.charAt(j)=='D' && !valid[j]){
-                                valid[j]=true;
-                                flag=true;
-                                break;
-                            }
-                        }
-                        if(!flag){
-                            for(int j=0;j<i;j++){
-                                if(senate.charAt(j)=='D' && !valid[j]){
-                                    valid[j]=true;
-                                    flag=true;
-                                    break;
-                                }
-                            }
-                        }
-                        if(!flag){
-                            return "Radiant";
-                        }
-                        Dnum--;
-                    }
-                }
-            }
-        }
-        return Dnum==0 ? "Radiant" : "Dire";
-    }
-
-    //方法二：贪心+对列
-    public static String predictPartyVictory2(String senate){
-        int n = senate.length();
-        Queue<Integer> radiant = new LinkedList<Integer>();
-        Queue<Integer> dire = new LinkedList<Integer>();
-        for (int i = 0; i < n; ++i) {
-            if (senate.charAt(i) == 'R') {
-                radiant.offer(i);
-            } else {
-                dire.offer(i);
-            }
-        }
-        while (!radiant.isEmpty() && !dire.isEmpty()) {
-            int radiantIndex = radiant.poll(), direIndex = dire.poll();
-            if (radiantIndex < direIndex) {
-                radiant.offer(radiantIndex + n);//序号加上senate的长度后再次放入队列，
-            } else {
-                dire.offer(direIndex + n);
-            }
-        }
-        return !radiant.isEmpty() ? "Radiant" : "Dire";
-
-
-    }
-
-
-    public static void main(String[] args) {
-        String str="RDDDRR";
-        System.out.println(predictPartyVictory(str));
-    }
-}
Index: src/Leetcode/Solution680.java
===================================================================
diff --git a/src/Leetcode/Solution680.java b/src/Leetcode/Solution680.java
deleted file mode 100644
--- a/src/Leetcode/Solution680.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,49 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。
-
-示例 1:
-
-输入: "aba"
-输出: True
-
-示例 2:
-
-输入: "abca"
-输出: True
-解释: 你可以删除c字符。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/valid-palindrome-ii
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/4/30 21:09
- */
-public class Solution680 {
-
-    public static boolean validPalindrome(String s) {
-        for(int i = 0, j = s.length()-1; i < j ; i++, j--){
-            if(s.charAt(i) != s.charAt(j)){
-                //分两种情况，一是右边减一，二是左边加一
-                return isPalindrome(s,i,j-1) || isPalindrome(s, i+1, j);
-            }
-        }
-        return true;
-    }
-
-    public static boolean isPalindrome(String s, int i, int j) {
-        while (i < j) {
-            if (s.charAt(i++) != s.charAt(j--)) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    public static void main(String[] args) {
-        String s="aguokepatgbnvfqmgmlcupuufxoohdfpgjdmysgvhmvffcnqxjjxqncffvmhvgsymdjgpfdhooxfuupuculmgmqfvnbgtapekouga";
-        System.out.println(validPalindrome(s));
-    }
-}
Index: src/Leetcode/Solution698.java
===================================================================
diff --git a/src/Leetcode/Solution698.java b/src/Leetcode/Solution698.java
deleted file mode 100644
--- a/src/Leetcode/Solution698.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,67 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一个整数数组  nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。
-
-示例 1：
-
-输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4
-输出： True
-说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。
-
-
-
-提示：
-
-1 <= k <= len(nums) <= 16
-0 < nums[i] < 10000
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/1 10:06
- */
-public class Solution698 {
-
-    public  static  boolean canPartitionKSubsets(int[] nums, int k) {
-        int len=nums.length;
-        if(len<k) return false;
-        int count=0,max=0;
-        for(int i=0;i<len;i++){
-            count+=nums[i];
-            max=Math.max(max,nums[i]);
-        }
-        if(count%k!=0) return false;
-        int num=count/k;
-        if(num<max) return false;
-        boolean[] flag=new boolean[len];
-        return process(nums,k,flag,num,num,0);
-
-    }
-
-    private static boolean process(int[] nums,int k,boolean[] flags,int target,int num,int start){//target：当前的目标值，num:总额目标值,start开始位置
-        if(k==0)
-            return true;
-        if(target==0)
-            return process(nums,k-1,flags,num,num,0);//当target==0时，开始时下一轮
-        for(int i=start;i<nums.length;i++){
-            if(!flags[i] && target-nums[i]>=0){
-                flags[i]=true;
-                if(process(nums,k,flags,target-nums[i],num,i+1)) return true;
-                flags[i]=false;
-            }
-        }
-        return false;
-    }
-
-
-    public static void main(String[] args) {
-        int[] arr={5,2,5,5,5,5,5,5,5,5,5,5,5,5,5,3};
-        int k=15;
-        System.out.println(canPartitionKSubsets(arr,k));
-
-
-    }
-}
Index: src/Leetcode/Solution726.java
===================================================================
diff --git a/src/Leetcode/Solution726.java b/src/Leetcode/Solution726.java
deleted file mode 100644
--- a/src/Leetcode/Solution726.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,208 +0,0 @@
-package Leetcode;
-
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一个化学式formula（作为字符串），返回每种原子的数量。
-
-原子总是以一个大写字母开始，接着跟随0个或任意个小写字母，表示原子的名字。
-
-如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。例如，H2O 和 H2O2 是可行的，但 H1O2 这个表达是不可行的。
-
-两个化学式连在一起是新的化学式。例如 H2O2He3Mg4 也是化学式。
-
-一个括号中的化学式和数字（可选择性添加）也是化学式。例如 (H2O2) 和 (H2O2)3 是化学式。
-
-给定一个化学式，输出所有原子的数量。格式为：第一个（按字典序）原子的名子，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。
-
-示例 1:
-
-输入:
-formula = "H2O"
-输出: "H2O"
-解释:
-原子的数量是 {'H': 2, 'O': 1}。
-
-示例 2:
-
-输入:
-formula = "Mg(OH)2"
-输出: "H2MgO2"
-解释:
-原子的数量是 {'H': 2, 'Mg': 1, 'O': 2}。
-
-示例 3:
-
-输入:
-formula = "K4(ON(SO3)2)2"
-输出: "K4N2O14S4"
-解释:
-原子的数量是 {'K': 4, 'N': 2, 'O': 14, 'S': 4}。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/number-of-atoms
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/5 17:38
- */
-public class Solution726 {
-
-    private  static Integer index;
-    private  static HashMap<String,Integer> map;
-
-    public static String countOfAtoms(String formula) {
-        int len=formula.length();
-        map=new HashMap<>();
-        index=0;
-        while(index<len){
-            char c=formula.charAt(index++);
-            if(c=='('){//遇到“(”，交给process计算
-                HashMap<String,Integer> help=process(formula,index);
-                //将括号中的元素统计进入map.
-                for(Map.Entry<String,Integer> entry: help.entrySet()){
-                    String key=entry.getKey();
-                    Integer value=entry.getValue();
-                    if(!key.equals("index"))
-                    map.put(key,map.getOrDefault(key,0)+value);
-                }
-                index=help.get("index");
-                continue;
-            }else if(c>='A' && c<='Z'){
-                //int pos=index++;
-                StringBuilder sb=new StringBuilder();
-                sb.append(c);
-                while(index<len){
-                    if(formula.charAt(index)>='a' && formula.charAt(index)<='z')
-                        sb.append(formula.charAt(index++));
-                    else
-                        break;
-                }
-                String key=sb.toString();
-                //当因为到了最后，或者遇到（，或者遇到大写字目停止的时候，直接加入到map
-                if(index==len || formula.charAt(index)=='(' || (formula.charAt(index)>='A' && formula.charAt(index)<='Z')){
-                    map.put(key,map.getOrDefault(key,0)+1);
-                }else{
-                    //当遇到数字停止的时候
-                    int pos=index++;
-                    while(index<len){
-                        if(formula.charAt(index)>='0' && formula.charAt(index)<='9')
-                            index++;
-                        else
-                            break;
-                    }
-                    Integer val=Integer.valueOf(formula.substring(pos,index));
-                    map.put(key,map.getOrDefault(key,0)+val);
-
-                }
-
-            }
-
-
-        }
-
-        String[] strs=new String[map.size()];
-        int start=0;
-        for(Map.Entry<String,Integer> entry: map.entrySet()){
-            String key=entry.getKey();
-            strs[start++]=key;
-        }
-
-        Arrays.sort(strs);//字典序排序
-        StringBuilder res=new StringBuilder();
-        for(int i=0;i<strs.length;i++){
-            res.append(strs[i]);
-            res.append(map.get(String.valueOf(strs[i])));
-        }
-        return res.toString();
-    }
-
-    //结算递归函数
-    private static HashMap<String,Integer> process(String s,Integer index){//index:（后的坐标
-        HashMap<String,Integer> res=new HashMap<>();
-        int len=s.length();
-        while(index<s.length()){
-            char c=s.charAt(index++);
-            if(c=='('){
-                HashMap<String,Integer>help=process(s,index);
-                for(Map.Entry<String,Integer> entry: help.entrySet()){
-                    String key=entry.getKey();
-                    Integer value=entry.getValue();
-                    if(!key.equals("index"))
-                    res.put(key,res.getOrDefault(key,0)+value);
-                }
-                index=help.get("index");
-                continue;
-            }else if(c>='A' && c<='Z'){
-                //int pos=index++;
-                StringBuilder sb=new StringBuilder();
-                sb.append(c);
-                while(index<len){
-                    if(s.charAt(index)>='a' && s.charAt(index)<='z')
-                        sb.append(s.charAt(index++));
-                    else
-                        break;
-                }
-                String key=sb.toString();
-                //当因为到了最后，或者遇到（，或者遇到大写字目停止的时候，直接加入到map
-                if( s.charAt(index)=='(' || (s.charAt(index)>='A' && s.charAt(index)<='Z')){
-                    res.put(key,res.getOrDefault(key,0)+1);
-                }else if(s.charAt(index)>='0' && s.charAt(index)<='9'){
-                    //当遇到数字停止的时候
-                    int pos=index++;
-                    while(index<len){
-                        if(s.charAt(index)>='0' && s.charAt(index)<='9')
-                            index++;
-                        else
-                            break;
-                    }
-                    Integer val=Integer.valueOf(s.substring(pos,index));
-                    res.put(key,res.getOrDefault(key,0)+val);
-                }else if(s.charAt(index)==')'){
-                    res.put(key,res.getOrDefault(key,0)+1);
-                    int pos=++index;
-                    while(index<len){
-                        if(s.charAt(index)>='0' && s.charAt(index)<='9')
-                            index++;
-                        else break;
-                    }
-                    Integer val=Integer.valueOf(s.substring(pos,index));
-                    for(Map.Entry<String,Integer> entry: res.entrySet()){
-                        String key1=entry.getKey();
-                        Integer value=entry.getValue();
-                        res.put(key1,val*value);
-                    }
-                    break;
-                }
-
-            }else if(c==')'){
-                int pos=index++;
-                while(index<len){
-                    if(s.charAt(index)>='0' && s.charAt(index)<='9')
-                        index++;
-                    else break;
-                }
-                Integer val=Integer.valueOf(s.substring(pos,index));
-                for(Map.Entry<String,Integer> entry: res.entrySet()){
-                    String key=entry.getKey();
-                    Integer value=entry.getValue();
-                    res.put(key,val*value);
-                }
-                break;
-            }
-
-        }
-        res.put("index",index);
-        return res;
-
-    }
-
-    public static void main(String[] args) {
-        String str = "Mg(OH)2";
-        System.out.println(countOfAtoms(str));
-    }
-
-
-}
Index: src/Leetcode/Solution738.java
===================================================================
diff --git a/src/Leetcode/Solution738.java b/src/Leetcode/Solution738.java
deleted file mode 100644
--- a/src/Leetcode/Solution738.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,96 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。
-
-（当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。）
-
-示例 1:
-
-输入: N = 10
-输出: 9
-示例 2:
-
-输入: N = 1234
-输出: 1234
-示例 3:
-
-输入: N = 332
-输出: 299
-说明: N 是在 [0, 10^9] 范围内的一个整数。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/monotone-increasing-digits
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/12/15 12:25
- */
-public class Solution738 {
-
-    //方法一：
-    public static int monotoneIncreasingDigits(int N) {
-        String str=String.valueOf(N);
-        int m=str.length();
-        int index=0;
-        char pre=str.charAt(0);
-        int j=1;
-        for(;j<m;j++){
-            char c=str.charAt(j);
-            if(c<pre){
-                index=j-1;
-                break;
-            }
-            pre=c;
-        }
-        if(j==m) return N;
-        while(index>0 && str.charAt(index)==str.charAt(index-1)){
-            index--;
-        }
-        StringBuilder sb=new StringBuilder();
-        if(index==0 && str.charAt(index)=='1'){
-            int i=0;
-            while(i<m-1){
-                sb.append(9);
-                i++;
-            }
-        }else{
-            for(int i=0;i<index;i++){
-                sb.append(str.charAt(i));
-            }
-            int target=str.charAt(index)-'0';
-            sb.append(target-1);
-            int i=index+1;
-            while(i<m){
-                sb.append(9);
-                i++;
-            }
-        }
-
-        return Integer.valueOf(sb.toString());
-    }
-
-    //方法二：
-    public  static int monotoneIncreasingDigits2(int N) {
-        char[] chs=Integer.toString(N).toCharArray();
-        int i=1;
-        while(i<chs.length && chs[i-1] <= chs[i]){//找到第一个不符合要求的位置
-            i+=1;
-        }
-        if(i < chs.length){
-            while(i > 0 && chs[i-1] > chs[i]){//从不符合要求的前一个位置开始-1操作
-                chs[i - 1] -= 1;
-                i -= 1;
-            }
-            for(++i; i < chs.length; i++){
-                chs[i]='9';
-            }
-        }
-        return Integer.parseInt(new String(chs));
-    }
-
-    public static void main(String[] args) {
-        System.out.println(monotoneIncreasingDigits2(10));
-    }
-}
Index: src/Leetcode/贪心/Solution781.java
===================================================================
diff --git a/src/Leetcode/贪心/Solution781.java b/src/Leetcode/贪心/Solution781.java
deleted file mode 100644
--- a/src/Leetcode/贪心/Solution781.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,108 +0,0 @@
-package Leetcode.贪心;
-
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 answers 数组里。
-
-返回森林中兔子的最少数量。
-
-示例:
-输入: answers = [1, 1, 2]
-输出: 5
-解释:
-两只回答了 "1" 的兔子可能有相同的颜色，设为红色。
-之后回答了 "2" 的兔子不会是红色，否则他们的回答会相互矛盾。
-设回答了 "2" 的兔子为蓝色。
-此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。
-因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的。
-
-输入: answers = [10, 10, 10]
-输出: 11
-
-输入: answers = []
-输出: 0
-说明:
-
-answers 的长度最大为1000。
-answers[i] 是在 [0, 999] 范围内的整数。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/rabbits-in-forest
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2021/4/4 12:31
- */
-public class Solution781 {
-
-    /**
-     * * O(nlogn),O(1)
-     * @param answers
-     * @return
-     */
-    public static int numRabbits(int[] answers) {
-        if(answers == null || answers.length == 0){
-            return 0;
-        }
-        int n = answers.length;
-        Arrays.sort(answers);
-        int index = 0;
-        int res = 0;
-        while(index < n && answers[index] == 0){
-            res++;
-            index++;
-        }
-        if(index == n){
-            return res;
-        }
-        int num = answers[index];
-        int start = index;
-        while(index < n){
-            if(answers[index] == num){
-                index++;
-            }else{
-                int dist = index - start;
-                int tmp = dist / (num + 1);
-                int tmp2 =(dist % (num + 1)) == 0 ? 0 : 1;
-                res += (tmp + tmp2) * (num + 1);
-                //更新num及index,start
-                num = answers[index];
-                start = index;
-                index++;
-            }
-        }
-        int dist = index - start;
-        int tmp = dist / (num + 1);
-        int tmp2 =(dist % (num + 1)) == 0 ? 0 : 1;
-        res += (tmp + tmp2) * (num + 1);
-        return res;
-
-    }
-
-    /**
-     * O(n),O(n)
-     * @param answers
-     * @return
-     */
-    public int numRabbits2(int[] answers) {
-        Map<Integer, Integer> count = new HashMap<Integer, Integer>();
-        for (int y : answers) {
-            count.put(y, count.getOrDefault(y, 0) + 1);
-        }
-        int ans = 0;
-        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {
-            int y = entry.getKey(), x = entry.getValue();
-            ans += (x + y) / (y + 1) * (y + 1);
-        }
-        return ans;
-    }
-
-    public static void main(String[] args) {
-        int[] arr = {0,2,0,2,1};
-        System.out.println(numRabbits(arr));
-    }
-
-}
Index: src/Leetcode/Solution794.java
===================================================================
diff --git a/src/Leetcode/Solution794.java b/src/Leetcode/Solution794.java
deleted file mode 100644
--- a/src/Leetcode/Solution794.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,114 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:用字符串数组作为井字游戏的游戏板 board。当且仅当在井字游戏过程中，玩家有可能将字符放置成游戏板所显示的状态时，才返回 true。
-
-该游戏板是一个 3 x 3 数组，由字符 " "，"X" 和 "O" 组成。字符 " " 代表一个空位。
-
-以下是井字游戏的规则：
-
-玩家轮流将字符放入空位（" "）中。
-第一个玩家总是放字符 “X”，且第二个玩家总是放字符 “O”。
-“X” 和 “O” 只允许放置在空位中，不允许对已放有字符的位置进行填充。
-当有 3 个相同（且非空）的字符填充任何行、列或对角线时，游戏结束。
-当所有位置非空时，也算为游戏结束。
-如果游戏结束，玩家不允许再放置字符。
-
-示例 1:
-输入: board = ["O  ", "   ", "   "]
-输出: false
-解释: 第一个玩家总是放置“X”。
-
-示例 2:
-输入: board = ["XOX", " X ", "   "]
-输出: false
-解释: 玩家应该是轮流放置的。
-
-示例 3:
-输入: board = ["XXX", "   ", "OOO"]
-输出: false
-
-示例 4:
-输入: board = ["XOX", "O O", "XOX"]
-输出: true
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/valid-tic-tac-toe-state
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/5 15:50
- */
-public class Solution794 {
-
-    public static boolean validTicTacToe(String[] board) {
-        int counto=0,countx=0,rcounto=0,rcountx=0,ccounto=0,ccountx=0,xcounto=0,xcountx=0;
-        boolean flag=false;
-        for(int i=0;i<3;i++){//考虑行
-            String str=board[i];
-            for(int j=0;j<3;j++){
-                if(str.charAt(j)=='O'){
-                    counto++;
-                    if(!flag)
-                        rcounto++;
-                }
-                if(str.charAt(j)=='X'){
-                    countx++;
-                    if(!flag)
-                        rcountx++;
-                }
-            }
-            if(rcounto==3 || rcountx==3)
-                flag=true;
-            else{
-                rcounto=0;
-                rcountx=0;
-            }
-
-        }
-        if(countx<counto || countx-counto>1)
-            return false;
-        //统计是否存在列全部为相同的情况
-        if(board[0].charAt(0)==board[1].charAt(0) && board[1].charAt(0)==board[2].charAt(0))
-        {
-            if(board[0].charAt(0)=='O') ccounto=3;
-            if(board[0].charAt(0)=='X') ccountx=3;
-        }
-        if (board[0].charAt(1)==board[1].charAt(1) && board[1].charAt(1)==board[2].charAt(1)){
-            if(board[0].charAt(1)=='O') ccounto=3;
-            if(board[0].charAt(1)=='X') ccountx=3;
-        }
-        if(board[0].charAt(2)==board[1].charAt(2) && board[1].charAt(2)==board[2].charAt(2)){
-            if(board[0].charAt(2)=='O') ccounto=3;
-            if(board[0].charAt(2)=='X') ccountx=3;
-        }
-        //对角线
-        if(board[0].charAt(0)==board[1].charAt(1) && board[2].charAt(2)==board[1].charAt(1)){
-            if(board[0].charAt(0)=='O') xcounto=3;
-            if(board[0].charAt(0)=='X') xcountx=3;
-        }
-        if(board[0].charAt(2)==board[1].charAt(1) && board[2].charAt(0)==board[1].charAt(1)){
-            if(board[0].charAt(2)=='O') xcounto=3;
-            if(board[0].charAt(2)=='X') xcountx=3;
-        }
-
-
-        if(ccounto==3 || rcounto==3 || xcounto==3){
-            if(countx>counto)
-                return false;
-
-        }
-        if(rcountx==3 || ccountx==3 || xcountx==3){
-            if(counto==countx)
-                return false;
-        }
-        return true;
-
-    }
-
-    public static void main(String[] args) {
-        String[] strs={"XXO","XOX","OXO"};
-        System.out.println(validTicTacToe(strs));
-
-    }
-}
Index: src/Leetcode/回溯剪枝/Solution842.java
===================================================================
diff --git a/src/Leetcode/回溯剪枝/Solution842.java b/src/Leetcode/回溯剪枝/Solution842.java
deleted file mode 100644
--- a/src/Leetcode/回溯剪枝/Solution842.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,100 +0,0 @@
-package Leetcode.回溯剪枝;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定一个数字字符串 S，比如 S = "123456579"，我们可以将它分成斐波那契式的序列 [123, 456, 579]。
-
-形式上，斐波那契式序列是一个非负整数列表 F，且满足：
-
-0 <= F[i] <= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；
-F.length >= 3；
-对于所有的0 <= i < F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。
-另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。
-
-返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。
-
- 
-
-示例 1：
-
-输入："123456579"
-输出：[123,456,579]
-示例 2：
-
-输入: "11235813"
-输出: [1,1,2,3,5,8,13]
-示例 3：
-
-输入: "112358130"
-输出: []
-解释: 这项任务无法完成。
-示例 4：
-
-输入："0123"
-输出：[]
-解释：每个块的数字不能以零开头，因此 "01"，"2"，"3" 不是有效答案。
-示例 5：
-
-输入: "1101111"
-输出: [110, 1, 111]
-解释: 输出 [11,0,11,11] 也同样被接受。
- 
-
-提示：
-
-1 <= S.length <= 200
-字符串 S 中只含有数字。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/12/8 12:01
- */
-public class Solution842 {
-
-    List<Integer> res=new ArrayList<>();
-    public List<Integer> splitIntoFibonacci(String S) {
-        if(S==null || S.length()<3) return res;
-        process(S,0,0);
-        return res;
-
-    }
-
-    private boolean process(String s,int start,int num){
-        if(start==s.length() && num>=3)
-            return true;
-        for(int i=start+1;i<=s.length();i++){
-            if(s.charAt(start)=='0' && i>start+1){//说明当前取得数字大于一位，并且开头是0；
-                break;
-            }
-            long next=getNum(s,start,i);
-            if(next>Integer.MAX_VALUE) //根据题目的意思，不能大于int的最大范围
-                break;
-            if(num>=2 &&  next>res.get(res.size()-1)+res.get(res.size()-2)){//剪枝过程
-                break;
-            }
-            if(num<=1 || next==res.get(res.size()-1)+res.get(res.size()-2)){
-                res.add((int)next);
-                if(process(s,i,num+1)){
-                    return true;
-                }
-                res.remove(res.size()-1);
-            }
-        }
-        return false;
-    }
-
-    //将字符串数字转化成整数数字
-    private long getNum(String s,int start,int end){
-        char[] chs=s.toCharArray();
-        long ans=0;
-        for(int i=start;i<end;i++){
-            ans=ans*10+chs[i]-'0';
-        }
-        return ans;
-    }
-}
Index: src/Leetcode/Solution935.java
===================================================================
diff --git a/src/Leetcode/Solution935.java b/src/Leetcode/Solution935.java
deleted file mode 100644
--- a/src/Leetcode/Solution935.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,72 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:国际象棋中的骑士可以按下图所示进行移动：
-
-.
-
-
-这一次，我们将 “骑士” 放在电话拨号盘的任意数字键（如上图所示）上，接下来，骑士将会跳 N-1 步。每一步必须是从一个数字键跳到另一个数字键。
-
-每当它落在一个键上（包括骑士的初始位置），都会拨出键所对应的数字，总共按下 N 位数字。
-
-你能用这种方式拨出多少个不同的号码？
-
-因为答案可能很大，所以输出答案模 10^9 + 7。
-
-
-
-示例 1：
-
-输入：1
-输出：10
-
-示例 2：
-
-输入：2
-输出：20
-
-示例 3：
-
-输入：3
-输出：46
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/knight-dialer
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/5/16 21:27
- */
-public class Solution935 {
-    private static int M=1000000007;
-    public static  int knightDialer(int N) {
-        int[][][] dp=new int[8][7][N];
-        for(int i=2;i<6;i++){
-            for(int j=2;j<5;j++){
-                if(!((i==5 && j==2) || (i==5 && j==4)))
-                    dp[i][j][0]=1;
-            }
-        }
-        for(int k=1;k<N;k++){
-            for(int i=2;i<6;i++){
-                for(int j=2;j<5;j++){
-                    if(!((i==5 && j==2) || (i==5 && j==4)))
-                        dp[i][j][k] = (((dp[i - 2][j - 1][k - 1]%M + dp[i - 2][j + 1][k - 1]%M)%M +
-                                (dp[i - 1][j - 2][k - 1]%M + dp[i - 1][j + 2][k - 1]%M)%M)%M +
-                                ((dp[i + 1][j - 2][k - 1]%M + dp[i + 1][j + 2][k - 1]%M)%M +
-                                        (dp[i + 2][j - 1][k - 1]%M + dp[i + 2][j + 1][k - 1]%M)%M)%M)%M;
-                }
-            }
-        }
-        int sum=0;
-        sum=((((dp[2][2][N-1]+dp[2][3][N-1])%M+(dp[5][3][N-1]+dp[2][4][N-1])%M)%M+((dp[3][2][N-1]
-                +dp[3][3][N-1])%M+(dp[3][4][N-1]+dp[4][2][N-1])%M)%M)%M+(dp[4][3][N-1]+dp[4][4][N-1])%M)%M;
-        return sum;
-
-    }
-
-    public static void main(String[] args) {
-        System.out.println(knightDialer(3));
-    }
-}
Index: src/Leetcode/数组/Solution937.java
===================================================================
diff --git a/src/Leetcode/数组/Solution937.java b/src/Leetcode/数组/Solution937.java
deleted file mode 100644
--- a/src/Leetcode/数组/Solution937.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,77 +0,0 @@
-package Leetcode.数组;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-
-/**
- * 我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。
- *
- * （这里，平面上两点之间的距离是欧几里德距离。）
- *
- * 你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。
- *
- *  
- *
- * 示例 1：
- *
- * 输入：points = [[1,3],[-2,2]], K = 1
- * 输出：[[-2,2]]
- * 解释：
- * (1, 3) 和原点之间的距离为 sqrt(10)，
- * (-2, 2) 和原点之间的距离为 sqrt(8)，
- * 由于 sqrt(8) < sqrt(10)，(-2, 2) 离原点更近。
- * 我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。
- *
- * 来源：力扣（LeetCode）
- * 链接：https://leetcode-cn.com/problems/k-closest-points-to-origin
- * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- */
-public class Solution937 {
-
-    public int[][] kClosest(int[][] points, int K) {
-        if(points==null || points.length==0) return new int[0][0];
-        int n=points.length;
-        if(n<=K) return points;
-        int[][] res=new int[K][2];
-        int[] help=new int[n];//记录第i个点距离远点的距离的平方
-        HashMap<Integer, List<Integer>> map=new HashMap<>();
-        for(int i=0;i<n;i++){
-            int x=points[i][0] * points[i][0];
-            int y=points[i][1] * points[i][1];
-            help[i]=x+y;
-            if(map.containsKey(help[i])){
-                List<Integer>list=map.get(help[i]);
-                list.add(i);
-                map.put(help[i],list);
-            }else{
-                List<Integer>list=new ArrayList<>();
-                list.add(i);
-                map.put(help[i],list);
-            }
-        }
-        Arrays.sort(help);
-        for(int i=0;i<K;i++){
-            int target=help[i];
-            List<Integer> list=map.get(target);
-            for(Integer num :list){
-                if(i<K){
-                    res[i][0]=points[num][0];
-                    res[i][1]=points[num][1];
-                    i++;
-                }else {
-                    return res;
-                }
-            }
-            --i;
-        }
-        return res;
-
-    }
-
-    public static void main(String[] args) {
-        int[][] nums={{3,3},{5,1},{-2,4}};
-        new Solution937().kClosest(nums,2);
-    }
-}
Index: src/Leetcode/Solution990.java
===================================================================
diff --git a/src/Leetcode/Solution990.java b/src/Leetcode/Solution990.java
deleted file mode 100644
--- a/src/Leetcode/Solution990.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,104 +0,0 @@
-package Leetcode;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:990. 等式方程的可满足性
-
-给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一："a==b" 或 "a!=b"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。
-
-只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。
-
-
-
-示例 1：
-
-输入：["a==b","b!=a"]
-输出：false
-解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。
-
-示例 2：
-
-输出：["b==a","a==b"]
-输入：true
-解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。
-
-示例 3：
-
-输入：["a==b","b==c","a==c"]
-输出：true
-
-示例 4：
-
-输入：["a==b","b!=c","c==a"]
-输出：false
-
-示例 5：
-
-输入：["c==c","b==d","x!=z"]
-输出：true
-
- * @date 2020/6/8 14:55
- */
-public class Solution990 {
-
-
-    //通过floyd算法来计算
-    public static boolean equationsPossible(String[] equations) {
-        int len=equations.length;
-        if(len==1){
-            if(equations[0].charAt(0)==equations[0].charAt(3) && equations[0].charAt(1)=='=')
-                return true;
-            else if(equations[0].charAt(0)!=equations[0].charAt(3) && equations[0].charAt(1)=='!')
-                return true;
-            else
-                return false;
-        }
-        //构建图，先假设为真
-        boolean res=true;
-        boolean[][] letter=new boolean[26][26];
-        List<Integer> list=new ArrayList<>();//用来记录！==表达式的序号
-        for(int i=0;i<len;i++){
-            int m=equations[i].charAt(0)-'a';
-            int n=equations[i].charAt(3)-'a';
-            if(equations[i].charAt(1)=='='){
-                letter[m][n]=true;
-                letter[n][m]=true;
-            }else{
-                list.add(i);
-            }
-        }
-        //通过floyd算法来更新数据表
-        for(int k=0;k<26;k++){//中间结点
-            for(int i=0;i<26;i++){
-                for(int j=0;j<26;j++){
-                    if(letter[i][k] && letter[k][j]){
-                        letter[i][j]=true;
-                        letter[j][i]=true;
-                    }
-
-                }
-            }
-        }
-
-        //遍历不相等的表达式
-        for(Integer id :list){
-            int m=equations[id].charAt(0)-'a';
-            int n=equations[id].charAt(3)-'a';
-            if(letter[m][n] || m==n){//如果m,n位置已经相等相连接，或者n==m，直接返回false;
-                return false;
-            }
-        }
-        return res;
-    }
-
-    public static void main(String[] args) {
-
-    }
-
-
-
-}
Index: src/Leetcode/Solution1006.java
===================================================================
diff --git a/src/Leetcode/Solution1006.java b/src/Leetcode/Solution1006.java
deleted file mode 100644
--- a/src/Leetcode/Solution1006.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,90 +0,0 @@
-package Leetcode;
-
-import java.util.Deque;
-import java.util.LinkedList;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。例如，factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1。
-
-相反，我们设计了一个笨阶乘 clumsy：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。
-
-例如，clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。
-
-另外，我们使用的除法是地板除法（floor division），所以 10 * 9 / 8 等于 11。这保证结果是一个整数。
-
-实现上面定义的笨函数：给定一个整数 N，它返回 N 的笨阶乘。
-
- 
-
-示例 1：
-
-输入：4
-输出：7
-解释：7 = 4 * 3 / 2 + 1
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/clumsy-factorial
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2021/4/1 19:17
- */
-public class Solution1006 {
-
-    public  static int clumsy(int N) {
-        if(N == 1 || N == 2){
-            return N;
-        }
-        int res = N * (N - 1) / (N - 2);
-        N -= 3;
-        if(N > 0){
-            res += N;
-            N--;
-        }
-        while(N >= 3){
-            int tmp = 0;
-            tmp += N * (N - 1) / (N - 2);
-            res -= tmp;
-            res += (N - 3);
-            N -= 4;
-        }
-        if(N >= 0){
-            res -= N;
-        }
-
-        return res;
-    }
-
-         public static int clumsy1(int N) {
-         Deque<Integer> stack = new LinkedList<Integer>();
-         stack.push(N);
-         N--;
-
-         int index = 0; // 用于控制乘、除、加、减
-         while (N > 0) {
-             if (index % 4 == 0) {
-                 stack.push(stack.pop() * N);
-             } else if (index % 4 == 1) {
-                 stack.push(stack.pop() / N);
-             } else if (index % 4 == 2) {
-                 stack.push(N);
-             } else {
-                 stack.push(-N);
-             }
-             index++;
-             N--;
-         }
-
-         // 把栈中所有的数字依次弹出求和
-         int sum = 0;
-         while (!stack.isEmpty()) {
-             sum += stack.pop();
-         }
-         return sum;
-     }
-
-    public static void main(String[] args) {
-        System.out.println(clumsy(7));
-        System.out.println(clumsy1(7));
-    }
-}
Index: src/Leetcode/Solution1011.java
===================================================================
diff --git a/src/Leetcode/Solution1011.java b/src/Leetcode/Solution1011.java
deleted file mode 100644
--- a/src/Leetcode/Solution1011.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,99 +0,0 @@
-package Leetcode;
-
-import java.util.Arrays;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。
-
-传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。
-
-返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。
-
- 
-
-示例 1：
-
-输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5
-输出：15
-解释：
-船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：
-第 1 天：1, 2, 3, 4, 5
-第 2 天：6, 7
-第 3 天：8
-第 4 天：9
-第 5 天：10
-
-请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2021/4/26 13:09
- */
-public class Solution1011 {
-    public static int shipWithinDays(int[] weights, int D) {
-        int len = weights.length;
-        int sum = 0;
-        for(int i = 0;i < len;i++){
-            sum += weights[i];
-        }
-        int left = sum % D == 0 ? sum / D : sum / D + 1;
-        int right = sum;
-        int num = D,idx = 0;
-        while(left < right){
-            int mid = left + (right - left) / 2;
-            num = D;
-            idx = 0;
-            int tmp = 0;
-            while(num > 0 && idx < len){
-                if(tmp >= mid){
-                    tmp = 0;
-                    num--;
-                }else{
-                    tmp += weights[idx];
-                    idx = tmp > mid ? idx : idx + 1;
-                }
-            }
-            if(num >= 0){
-                right = mid;
-            }else{
-                left = mid + 1;
-            }
-        }
-        return left;
-    }
-
-    //二分的方式
-    public static int shipWithinDays2(int[] weights, int D) {
-        int len = weights.length;
-        int left = Arrays.stream(weights).max().getAsInt();//由于不能拆分一个包裹，所以左边界就是单个包裹重量的最大值
-        int right = Arrays.stream(weights).sum();
-        int num = D,idx = 0;
-        while(left < right){
-            int mid = left + (right - left) / 2;
-            int need = 1, cur = 0;
-            //计算需要的天数的过程
-            for(int weight : weights){
-                if(cur + weight > mid){
-                    cur = 0;
-                    need++;
-                }
-                cur += weight;
-            }
-            if (need <= D) {
-                right = mid;
-            }
-            else {
-                left = mid + 1;
-            }
-        }
-        return left;
-    }
-
-    public static void main(String[] args) {
-        int[] arr = {1,2,3,4,5,6,7,8,9,10};
-        System.out.println(shipWithinDays(arr,5));
-    }
-}
Index: src/Leetcode/TrieTree/Solution1023.java
===================================================================
diff --git a/src/Leetcode/TrieTree/Solution1023.java b/src/Leetcode/TrieTree/Solution1023.java
deleted file mode 100644
--- a/src/Leetcode/TrieTree/Solution1023.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,155 +0,0 @@
-package Leetcode.TrieTree;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 如果我们可以将小写字母插入模式串 pattern 得到待查询项 query，那么待查询项与给定模式串匹配。（我们可以在任何位置插入每个字符，也可以插入 0 个字符。）
-
-给定待查询列表 queries，和模式串 pattern，返回由布尔值组成的答案列表 answer。只有在待查项 queries[i] 与模式串 pattern 匹配时， answer[i] 才为 true，否则为 false。
-
- 
-
-示例 1：
-
-输入：queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FB"
-输出：[true,false,true,true,false]
-示例：
-"FooBar" 可以这样生成："F" + "oo" + "B" + "ar"。
-"FootBall" 可以这样生成："F" + "oot" + "B" + "all".
-"FrameBuffer" 可以这样生成："F" + "rame" + "B" + "uffer".
-示例 2：
-
-输入：queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBa"
-输出：[true,false,true,false,false]
-解释：
-"FooBar" 可以这样生成："Fo" + "o" + "Ba" + "r".
-"FootBall" 可以这样生成："Fo" + "ot" + "Ba" + "ll".
-示例 3：
-
-输出：queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBaT"
-输入：[false,true,false,false,false]
-解释：
-"FooBarTest" 可以这样生成："Fo" + "o" + "Ba" + "r" + "T" + "est".
- 
-
-提示：
-
-1 <= queries.length <= 100
-1 <= queries[i].length <= 100
-1 <= pattern.length <= 100
-所有字符串都仅由大写和小写英文字母组成。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/camelcase-matching
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/20 20:03
- */
-public class Solution1023 {
-
-    //法一：使用前缀树
-    public class Node{
-        Node[] lowerchildren=new Node[26];//小写字母
-        Node[] upperchildren=new Node[26];//大写字母
-        public Node(){
-        }
-    }
-
-    public List<Boolean> camelMatch(String[] queries, String pattern) {
-        List<Boolean>res=new ArrayList<>();
-        int len=pattern.length();
-        int big=0;
-        for(int i=0;i<len;i++){
-            if(pattern.charAt(i)>='A' && pattern.charAt(i)<='Z')
-                big++;
-        }
-        Node root=new Node();
-        //初始化前缀树
-        for(String str :queries){
-            Node cur=root;
-            int index=0;
-            int help=big;
-            for(char ch :str.toCharArray()){
-                if(index<len && ch==pattern.charAt(index)){
-                    index++;
-                }
-                if(ch>='A' && ch<='Z'){//比较pattern中的大写字母的数量是否与query中的大写字母数量相等
-                    help--;
-                    if(help<0)
-                        break;
-                }
-
-                if(ch>='a' && ch<='z'){
-                    if(cur.lowerchildren[ch-'a']!=null){
-                        cur=cur.lowerchildren[ch-'a'];
-                    }else{
-                        cur.lowerchildren[ch-'a']=new Node();
-                        cur=cur.lowerchildren[ch-'a'];
-                    }
-                }else if(ch>='A' && ch<='Z'){
-                    if(cur.upperchildren[ch-'A']!=null){
-                        cur=cur.upperchildren[ch-'A'];
-                    }else{
-                        cur.upperchildren[ch-'A']=new Node();
-                        cur=cur.upperchildren[ch-'A'];
-                    }
-                }
-
-            }
-            if(index==len && help==0) res.add(true);
-            else res.add(false);
-
-        }
-
-        return res;
-    }
-    //=================================================
-    //法二
-    public List<Boolean> camelMatch2(String[] queries, String pattern) {
-        List<Boolean> res=new ArrayList<>();
-        for(String str:queries){
-            res.add(isMatch(str,pattern));
-        }
-        return res;
-    }
-
-    public Boolean isMatch(String str,String pattern){
-        int idx1=0,idx2=0;
-        int n1=str.length();
-        int n2=pattern.length();
-        while(idx1<n1 && idx2<n2){
-            char ch1=str.charAt(idx1),ch2=pattern.charAt(idx2);
-            if(ch1==ch2){
-                idx1++;
-                idx2++;
-            }else{
-                if(ch1>='A' && ch1<='Z'){
-                    return false;
-                }
-                idx1++;
-            }
-        }
-        if(idx2!=n2) return false;
-        while(idx1<n1){
-            if(!(str.charAt(idx1)>='a' && str.charAt(idx1)<='z')){
-                return false;
-            }
-            idx1++;
-        }
-        return true;
-    }
-
-    public static void main(String[] args) {
-        String[] queries={"FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"};
-        String pattern="FB";
-        Solution1023 solution1023=new Solution1023();
-        List<Boolean> res = solution1023.camelMatch(queries, pattern);
-        for(Boolean b : res){
-            System.out.println(b);
-        }
-
-    }
-}
Index: src/Leetcode/Solution1027.java
===================================================================
diff --git a/src/Leetcode/Solution1027.java b/src/Leetcode/Solution1027.java
deleted file mode 100644
--- a/src/Leetcode/Solution1027.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,51 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2020/5/15 17:50
- */
-public class Solution1027 {
-
-    //
-    public static int longestArithSeqLength(int[] A) {
-        int len=A.length;
-        int min=Integer.MAX_VALUE,max=Integer.MIN_VALUE;
-        for(int i=0;i<len;i++){
-            min=Math.min(min,A[i]);
-            max=Math.max(max,A[i]);
-        }
-        int[][] dp1=new int[max-min+1][len+1];//差为i,前j个元素的等差数列的长度
-        int[][] dp2=new int[max-min+1][len+1];
-        for(int i=0;i<=max-min;i++){
-            for(int j=1;j<=len;j++){
-                dp1[i][j]=1;
-                dp2[i][j]=1;
-            }
-
-        }
-
-        int res=1;
-        for(int i=0;i<=max-min;i++){
-            for(int j=2;j<=len;j++ ){
-                for(int k=1;k<j;k++){
-                    if(A[j-1]-A[k-1]==i){
-                        dp1[i][j]=dp1[i][k]+1;
-                        res=Math.max(res,dp1[i][j]);
-                    }
-                    if(A[j-1]-A[k-1]==-i){
-                        dp2[i][j]=dp2[i][k]+1;
-                        res=Math.max(res,dp2[i][j]);
-                    }
-                }
-            }
-        }
-        return res;
-    }
-
-    public static void main(String[] args) {
-        int[] arr=new int[]{9,4,7,2,10};
-        System.out.println(longestArithSeqLength(arr));
-    }
-}
Index: src/Leetcode/Solution1177.java
===================================================================
diff --git a/src/Leetcode/Solution1177.java b/src/Leetcode/Solution1177.java
deleted file mode 100644
--- a/src/Leetcode/Solution1177.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,88 +0,0 @@
-package Leetcode;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给你一个字符串 s，请你对 s 的子串进行检测。
-
-每次检测，待检子串都可以表示为 queries[i] = [left, right, k]。我们可以 重新排列 子串 s[left], ..., s[right]，并从中选择 最多 k 项替换成任何小写英文字母。
-
-如果在上述检测过程中，子串可以变成回文形式的字符串，那么检测结果为 true，否则结果为 false。
-
-返回答案数组 answer[]，其中 answer[i] 是第 i 个待检子串 queries[i] 的检测结果。
-
-注意：在替换时，子串中的每个字母都必须作为 独立的 项进行计数，也就是说，如果 s[left..right] = "aaa" 且 k = 2，我们只能替换其中的两个字母。（另外，任何检测都不会修改原始字符串 s，可以认为每次检测都是独立的）
-
-
-
-示例：
-
-输入：s = "abcda", queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]
-输出：[true,false,false,true,true]
-解释：
-queries[0] : 子串 = "d"，回文。
-queries[1] : 子串 = "bc"，不是回文。
-queries[2] : 子串 = "abcd"，只替换 1 个字符是变不成回文串的。
-queries[3] : 子串 = "abcd"，可以变成回文的 "abba"。 也可以变成 "baab"，先重新排序变成 "bacd"，然后把 "cd" 替换为 "ab"。
-queries[4] : 子串 = "abcda"，可以变成回文的 "abcba"。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/can-make-palindrome-from-substring
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/4 16:45
- */
-public class Solution1177 {
-
-    public static List<Boolean> canMakePaliQueries(String s, int[][] queries) {
-        List<Boolean> res=new ArrayList<>();
-        int len=queries.length;
-        int len1=s.length();
-        //对字符串进行预处理，统计每个字符在一定位置出现的次数,避免后面的重复计算
-        int[][] count=new int[len1][26];
-        count[0][s.charAt(0)-'a']++;//将第一个字符加入到预处理数组
-        for(int i=1;i<len1;i++){
-            char ch=s.charAt(i);
-            System.arraycopy(count[i-1],0,count[i],0,26);
-            count[i][ch-'a']++;
-        }
-
-        for(int i=0;i<len;i++){
-            int start=queries[i][0];
-            int end=queries[i][1];
-            int k=queries[i][2];
-            String subs=s.substring(start,end+1);
-            if(subs.length()==1) {
-                res.add(true);
-            }else if(k>=subs.length())
-                res.add(true);
-            else{
-                int [] help=new int[26];
-                int sublen=subs.length();
-                for(int j=0;j<26;j++){
-                    help[j]=count[end][j]-(start>0 ? count[start-1][j] : 0);
-                }
-                for(int j=0;j<26;j++){
-                    if(help[j]%2==0)
-                        sublen-=help[j];
-                    else if(help[j]>2){
-                        sublen-=(help[j]-1);
-                    }
-                }
-                sublen=sublen/2;
-                if(sublen>k) res.add(false);
-                else res.add(true);
-
-            }
-        }
-        return res;
-    }
-
-    public static void main(String[] args) {
-        String s="ninmjmj";
-        int[][] arr={{3,3,0},{1,1,1},{2,5,4},{1,3,1},{5,6,1}};
-        System.out.println(canMakePaliQueries(s,arr));
-    }
-}
Index: src/Leetcode/Solution1220.java
===================================================================
diff --git a/src/Leetcode/Solution1220.java b/src/Leetcode/Solution1220.java
deleted file mode 100644
--- a/src/Leetcode/Solution1220.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,74 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2020/5/16 22:51
- */
-public class Solution1220 {
-
-    private static int M=1000000007;
-    private static int[][] dp;
-    private static String[] strs={"a","e","i","o","u"};
-    public static int countVowelPermutation(int n) {
-        if(n==1)
-            return 5;
-        return process("",n,0);
-    }
-    //递归的方式
-    private static int process(String s,int n,int position){
-        if(position==n)
-            return 1;
-        int count=0;
-        if(position==0){
-            for(int i=0;i<5;i++){
-                count=(count+process(strs[i],n,1)%M)%M;
-            }
-            return count;
-        }else{
-            if(s.charAt(position-1)=='a'){
-                count=(count+process(s+"e",n,position+1)%M)%M;
-            }
-            if(s.charAt(position-1)=='e'){
-                count=((count+process(s+"a",n,position+1)%M)%M+process(s+"i",n,position+1)%M)%M;
-            }
-            if(s.charAt(position-1)=='i'){
-                count=((count+process(s+"a",n,position+1)%M)%M+((process(s+"e",n,position+1)%M+process(s+"o",n,position+1)%M)%M+process(s+"u",n,position+1)%M)%M)%M;
-            }
-            if(s.charAt(position-1)=='o'){
-                count=((count+process(s+"i",n,position+1)%M)%M+process(s+"u",n,position+1)%M)%M;
-            }
-            if(s.charAt(position-1)=='u'){
-                count=(count+process(s+"a",n,position+1)%M)%M;
-            }
-        }
-        return count;
-    }
-
-    //动态规划
-    public static int countVowelPermutation2(int n) {
-        if(n==1)
-            return 5;
-        dp=new int[n+1][5];//表示长度为i,以a,e,i,o,u结尾的字符串的种类
-        //dp[i][0]:表示长度为i,已a结尾的字符串的种类数，以此类推
-        dp[1][0]=1;
-        dp[1][1]=1;
-        dp[1][2]=1;
-        dp[1][3]=1;
-        dp[1][4]=1;
-        for(int i=2;i<=n;i++){
-            dp[i][0]=((dp[i-1][1]+dp[i-1][2])%M+dp[i-1][4])%M;
-            dp[i][1]=(dp[i-1][0]+dp[i-1][2])%M;
-            dp[i][2]=(dp[i-1][1]+dp[i-1][3])%M;
-            dp[i][3]=dp[i-1][2];
-            dp[i][4]=(dp[i-1][2]+dp[i-1][3])%M;
-        }
-        return ((dp[n][0]+dp[n][1])%M+((dp[n][2]+dp[n][3])%M+dp[n][4])%M)%M;
-    }
-
-    public static void main(String[] args) {
-        System.out.println(countVowelPermutation(80));
-        System.out.println(countVowelPermutation2(80));
-    }
-}
Index: src/Leetcode/Solution1349.java
===================================================================
diff --git a/src/Leetcode/Solution1349.java b/src/Leetcode/Solution1349.java
deleted file mode 100644
--- a/src/Leetcode/Solution1349.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,109 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给你一个 m * n 的矩阵 seats 表示教室中的座位分布。如果座位是坏的（不可用），就用 '#' 表示；否则，用 '.' 表示。
-
-学生可以看到左侧、右侧、左上、右上这四个方向上紧邻他的学生的答卷，但是看不到直接坐在他前面或者后面的学生的答卷。请你计算并返回该考场可以容纳的一起参加考试且无法作弊的最大学生人数。
-
-学生必须坐在状况良好的座位上。
-
- 
-
-示例 1：
-
-
-
-输入：seats = [["#",".","#","#",".","#"],
-              [".","#","#","#","#","."],
-              ["#",".","#","#",".","#"]]
-输出：4
-解释：教师可以让 4 个学生坐在可用的座位上，这样他们就无法在考试中作弊。
-示例 2：
-
-输入：seats = [[".","#"],
-              ["#","#"],
-              ["#","."],
-              ["#","#"],
-              [".","#"]]
-输出：3
-解释：让所有学生坐在可用的座位上。
-示例 3：
-
-输入：seats = [["#",".",".",".","#"],
-              [".","#",".","#","."],
-              [".",".","#",".","."],
-              [".","#",".","#","."],
-              ["#",".",".",".","#"]]
-输出：10
-解释：让学生坐在第 1、3 和 5 列的可用座位上。
- 
-
-提示：
-
-seats 只包含字符 '.' 和'#'
-m == seats.length
-n == seats[i].length
-1 <= m <= 8
-1 <= n <= 8
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/maximum-students-taking-exam
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/14 19:55
- */
-public class Solution1349 {
-
-    public static int maxStudents(char[][] seats) {
-        int m=seats.length;
-        int n=seats[0].length;
-        int [][] dp=new int[m+1][1<<n];//表示第i行的状态为j,其中j的可能性有2^n种
-        int res=0;
-        for(int row=1;row<=m;row++){ //第几行
-            for(int state=0;state<(1<<n);state++){//每行可能的状态
-                for(int laststate=0;laststate<(1<<n);laststate++){
-                    if(isValid(seats,row,state,laststate)){
-                        dp[row][state]=Math.max(dp[row][state],dp[row-1][laststate]+Integer.bitCount(state));
-                        res=Math.max(res,dp[row][state]);
-                    }
-                }
-            }
-        }
-        return res;
-
-    }
-
-    //判断第row行的状态为mark时，第row-1行的状态为lastmark时，是否是合法的。
-    private static boolean isValid(char[][] seats,int row,int mark,int lastmark){
-        int n=seats[0].length;
-        for(int i=0;i<n;i++){//每一行的座位数
-            if((mark & (1<<i))==0)
-                continue;
-            if(seats[row-1][i]=='#')
-                return false;
-            if(i==0 && seats[row-1][i+1]=='.' && (mark & 1<<1)!=0)
-                return false;
-            else if(i==n-1 && seats[row-1][i-1]=='.' && (mark & 1<<(n-2))!=0)
-                return false;
-            else if(i>0 && i<n-1)
-                if((seats[row-1][i-1]=='.' && (mark & 1<<(i-1))!=0) || (seats[row-1][i+1]=='.' && (mark & 1<<(i+1))!=0))
-                    return false;
-            if(row>1){
-                if(i==0 && seats[row-2][i+1]=='.' && (mark & lastmark>>1)!=0)
-                    return false;
-                else if(i==n-1 && seats[row-2][i-1]=='.' && (mark & lastmark<<1)!=0)
-                    return false;
-                else if(i>0 && i<n-1)
-                    if((seats[row-2][i-1]=='.' && (mark & lastmark<<1)!=0) ||(seats[row-2][i+1]=='.' && (mark & lastmark>>1)!=0))
-                        return false;
-            }
-        }
-        return true;
-    }
-
-    public static void main(String[] args) {
-        char[][] seats={{'#','.','#','#','.','#'},{'.','#','#','#','#','.'},{'#','.','#','#','.','#'}};
-        System.out.println(maxStudents(seats));
-    }
-}
Index: src/Leetcode/Solution1373.java
===================================================================
diff --git a/src/Leetcode/Solution1373.java b/src/Leetcode/Solution1373.java
deleted file mode 100644
--- a/src/Leetcode/Solution1373.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,123 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给你一棵以 root 为根的 二叉树 ，请你返回 任意 二叉搜索子树的最大键值和。
-
-二叉搜索树的定义如下：
-
-任意节点的左子树中的键值都 小于 此节点的键值。
-任意节点的右子树中的键值都 大于 此节点的键值。
-任意节点的左子树和右子树都是二叉搜索树。
- 
-
-示例 1：
-
-
-
-输入：root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]
-输出：20
-解释：键值为 3 的子树是和最大的二叉搜索树。
-示例 2：
-
-
-
-输入：root = [4,3,null,1,2]
-输出：2
-解释：键值为 2 的单节点子树是和最大的二叉搜索树。
-示例 3：
-
-输入：root = [-4,-2,-5]
-输出：0
-解释：所有节点键值都为负数，和最大的二叉搜索树为空。
-示例 4：
-
-输入：root = [2,1,3]
-输出：6
-示例 5：
-
-输入：root = [5,4,8,3,null,6,3]
-输出：7
- 
-
-提示：
-
-每棵树最多有 40000 个节点。
-每个节点的键值在 [-4 * 10^4 , 4 * 10^4] 之间。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/16 22:02
- */
-public class Solution1373 {
-
-    public class TreeNode {
-     int val;
-    TreeNode left;
-     TreeNode right;
-     TreeNode() {}
-     TreeNode(int val) { this.val = val; }
-     TreeNode(int val, TreeNode left, TreeNode right) {
-         this.val = val;
-         this.left = left;
-         this.right = right;
-     }
-  }
-
-    public class Result{
-        boolean isBST;
-        int nums;
-        int Max;
-        int Min;
-        public Result(boolean isBst,int nums,int max,int min){
-            this.isBST=isBst;
-            this.nums=nums;
-            this.Max=max;
-            this.Min=min;
-        }
-    }
-
-    public int maxSum=0;
-    public int maxSumBST(TreeNode root) {
-        if(root==null)
-            return 0;
-        process(root);
-        return maxSum;
-    }
-
-    private Result process(TreeNode root){
-        if(root==null){
-            return new Result(true,0,Integer.MIN_VALUE,Integer.MAX_VALUE);
-        }
-        Result left=process(root.left);
-        Result right=process(root.right);
-        if(!(left.isBST && right.isBST)){
-            return new Result(false,Integer.MIN_VALUE,Integer.MIN_VALUE,Integer.MIN_VALUE);
-        }else{
-            if(!(left.Max<root.val && right.Min>root.val)){
-                return new Result(false,Integer.MIN_VALUE,Integer.MIN_VALUE,Integer.MIN_VALUE);
-            }
-        }
-        int nums=left.nums+right.nums+root.val;
-        int min=Math.min(Math.min(left.Min,right.Min),root.val);
-        int max=Math.max(Math.max(left.Max,right.Max),root.val);
-        maxSum=Math.max(maxSum,nums);
-        return new Result(true,nums,max,min);
-
-
-    }
-
-    public static void main(String[] args) {
-        Solution1373 solution=new Solution1373();
-        TreeNode root=solution.new TreeNode(4);
-        TreeNode left=solution.new TreeNode(3);
-        root.left=left;
-        left.left=solution.new TreeNode(1);
-        left.right=solution.new TreeNode(5);
-
-        System.out.println(solution.maxSumBST(root));
-
-    }
-}
Index: src/Leetcode/数组/Solutionjian51.java
===================================================================
diff --git a/src/Leetcode/数组/Solutionjian51.java b/src/Leetcode/数组/Solutionjian51.java
deleted file mode 100644
--- a/src/Leetcode/数组/Solutionjian51.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,78 +0,0 @@
-package Leetcode.数组;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
-
- 
-
-示例 1:
-
-输入: [7,5,6,4]
-输出: 5
- 
-
-限制：
-
-0 <= 数组长度 <= 50000
-
-通过次数39,944提交次数86,959
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/9/9 10:02
- */
-public class Solutionjian51 {
-
-    public int res=0;
-    public int reversePairs(int[] nums) {
-        if(nums==null || nums.length<2) return 0;
-        int left=0,right=nums.length-1;
-        reversePairs(nums,left,right);
-        return res;
-
-    }
-
-    public void reversePairs(int[] nums,int left,int right){
-        if(left<right){
-            int mid=(left+right)>>>1;
-            reversePairs(nums,left,mid);
-            reversePairs(nums,mid+1,right);
-            if(nums[mid]<=nums[mid+1])
-                return;
-            sort(nums,left,right);
-        }
-    }
-
-    public void sort(int[]nums,int left,int right){
-        if(left==right) return;
-        int[] help=new int[right-left+1];
-        int mid=(left+right)>>>1;
-        int index=0,l=left,r=mid+1;
-        while(l<=mid && r<=right){
-            if(nums[l]<=nums[r]){//左边的小就计算一下逆序对的数量，此时说明有r-mid-1个小于nums[l]的数跑到了l位置的后面，所以计算一下逆序对的数量r-mid-1;
-                help[index++]=nums[l++];
-            }else{
-                res+=(mid-l+1);
-                help[index++]=nums[r++];
-            }
-        }
-        while(l<=mid){
-            help[index++]=nums[l++];
-        }
-        while(r<=right){
-            help[index++]=nums[r++];
-        }
-        index=0;
-        for(int i=left;i<=right;i++){
-            nums[i]=help[index++];
-        }
-    }
-
-    public static void main(String[] args) {
-        int[] arr=new int[]{1,3,2,3,1};
-        System.out.println(new Solutionjian51().reversePairs(arr));
-    }
-}
Index: src/Leetcode/Solutionmain1722.java
===================================================================
diff --git a/src/Leetcode/Solutionmain1722.java b/src/Leetcode/Solutionmain1722.java
deleted file mode 100644
--- a/src/Leetcode/Solutionmain1722.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,129 +0,0 @@
-package Leetcode;
-
-import java.util.*;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:给定字典中的两个词，长度相等。写一个方法，把一个词转换成另一个词， 但是一次只能改变一个字符。每一步得到的新词都必须能在字典中找到。
-
-编写一个程序，返回一个可能的转换序列。如有多个可能的转换序列，你可以返回任何一个。
-
-示例 1:
-
-输入:
-beginWord = "hit",
-endWord = "cog",
-wordList = ["hot","dot","dog","lot","log","cog"]
-
-输出:
-["hit","hot","dot","lot","log","cog"]
-
-示例 2:
-
-输入:
-beginWord = "hit"
-endWord = "cog"
-wordList = ["hot","dot","dog","lot","log"]
-
-输出: []
-
-解释: endWord "cog" 不在字典中，所以不存在符合要求的转换序列。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/word-transformer-lcci
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/10 18:55
- */
-public class Solutionmain1722 {
-
-    public List<String> res=new ArrayList<>();
-    public List<String> findLadders(String beginWord, String endWord, List<String> wordList) {
-        if(!wordList.contains(endWord)){
-            return new ArrayList<>();
-        }
-        wordList.add(beginWord);
-        HashMap<String,List<String>> map=getNexts(wordList);
-        HashMap<String,Integer> distances=getDistances(beginWord,map);
-        getShortestPaths(beginWord,endWord,map,distances,new LinkedList<>());
-        return res;
-
-
-    }
-
-    //返回每个单词的邻居
-    public  HashMap<String, List<String>> getNexts(List<String> words) {
-        Set<String> dict = new HashSet<>(words);
-        HashMap<String, List<String>> nexts = new HashMap<>();
-        for (int i = 0; i < words.size(); i++) {
-            nexts.put(words.get(i), new ArrayList<>());
-        }
-        for (int i = 0; i < words.size(); i++) {
-            nexts.put(words.get(i), getNext(words.get(i), dict));
-        }
-        return nexts;
-    }
-    //dict是将原来的list字典变换成set结构的，HashSet的增删改查都可以看做O(1);
-    //返回的是与word差别一个字母的单词的集合
-    private  ArrayList<String> getNext(String word, Set<String> dict) {
-        ArrayList<String> res = new ArrayList<String>();
-        char[] chs = word.toCharArray();
-        for (char cur = 'a'; cur <= 'z'; cur++) {//代价：26*chs.length
-            for (int i = 0; i < chs.length; i++) {
-                if (chs[i] != cur) {
-                    char tmp = chs[i];
-                    chs[i] = cur;
-                    if (dict.contains(String.valueOf(chs))) {
-                        res.add(String.valueOf(chs));
-                    }
-                    chs[i] = tmp;
-                }
-            }
-        }
-        return res;
-    }
-
-    public  HashMap<String, Integer> getDistances(String begin,
-                                                  HashMap<String, List<String>> nexts) {
-        HashMap<String, Integer> distances = new HashMap<>();
-        distances.put(begin, 0);
-        Queue<String> queue = new LinkedList<String>();
-        queue.add(begin);
-        HashSet<String> set = new HashSet<String>();//记录是否已经遍历过
-        set.add(begin);
-        while (!queue.isEmpty()) {//宽度优先遍历
-            String cur = queue.poll();
-            for (String str : nexts.get(cur)) {
-                if (!set.contains(str)) {
-                    distances.put(str, distances.get(cur) + 1);
-                    queue.add(str);
-                    set.add(str);
-                }
-            }
-        }
-        return distances;
-    }
-
-
-    //最终求解的答案在输入参数中的递归
-    private  boolean getShortestPaths(String cur, String end,
-                                      HashMap<String, List<String>> nexts,
-                                      HashMap<String, Integer> distances, LinkedList<String> solution
-    ) {
-        solution.add(cur);
-        if (end.equals(cur)) {
-            res=new LinkedList<String>(solution);
-            return true;
-        } else {
-            for (String next : nexts.get(cur)) {//cur的所有后代，搜索的过程又运用了深度优先遍历dfs
-                if (distances.get(next) == distances.get(cur) + 1) {
-                    if(getShortestPaths(next, end, nexts, distances, solution))
-                        return true;
-                    solution.pollLast();//弹出solution最后的值，深度优先遍历dfs
-                }
-            }
-        }
-        return false;
-
-    }
-}
Index: src/Leetcode/Solutionmian16.java
===================================================================
diff --git a/src/Leetcode/Solutionmian16.java b/src/Leetcode/Solutionmian16.java
deleted file mode 100644
--- a/src/Leetcode/Solutionmian16.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,88 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。
-
-
-
-示例 1:
-
-输入: 2.00000, 10
-输出: 1024.00000
-
-示例 2:
-
-输入: 2.10000, 3
-输出: 9.26100
-
-示例 3:
-
-输入: 2.00000, -2
-输出: 0.25000
-解释: 2-2 = 1/22 = 1/4 = 0.25
-
-
-
-说明:
-
--100.0 < x < 100.0
-n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1]
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/4 9:45
- */
-public class Solutionmian16 {
-    public static double myPow(double x, int n) {
-        if(n==0) return 1;
-        if(x==0.0){
-            if(n>=0) return 0;
-            //throw new Exception("数据不合法");
-        }
-        boolean flag=false;
-        double part=1.0;//当n=Integer.MIN_VALUE的时候，如果取反，则会出现数据丢失的情况
-        if(n<0){//将n装变成正数
-            flag=true;
-            if(n==Integer.MIN_VALUE){
-                n=Integer.MAX_VALUE;
-                part=x;
-            }else{
-                n=-n;
-            }
-
-        }
-
-        double res=process(x,n);
-        return flag ? 1.0/part*res : part*res;
-
-    }
-    private  static double process(double x,int n){
-        if(n==0)
-            return 1.0;
-        int m=lowbit(n);
-        n-=m;
-        double tmp=x;
-        while(m!=1){
-            tmp=tmp*tmp;
-            m/=2;
-        }
-
-        return tmp*process(x,n);
-
-    }
-    //返回n的最有一个1代表的数的大小
-    private  static int lowbit(int n){
-        return n & (-n);
-    }
-
-    public static void main(String[] args) {
-        System.out.println(myPow(2.000,-2));
-        String str="a good   example";
-        String[] split = str.split(" ");
-        System.out.println(split.length);
-    }
-}
Index: src/Leetcode/Solutionmian29.java
===================================================================
diff --git a/src/Leetcode/Solutionmian29.java b/src/Leetcode/Solutionmian29.java
deleted file mode 100644
--- a/src/Leetcode/Solutionmian29.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,63 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
-
-
-
-示例 1：
-
-输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
-输出：[1,2,3,6,9,8,7,4,5]
-
-示例 2：
-
-输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
-输出：[1,2,3,4,8,12,11,10,9,5,6,7]
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/5 13:37
- */
-public class Solutionmian29 {
-    public static int[] spiralOrder(int[][] matrix) {
-        if(matrix==null || matrix.length==0)
-            return new int[0];
-        int len=matrix.length;
-        int len1=matrix[0].length;
-        int [] res=new int[len*len1];
-        int srow=0,scol=0,erow=len-1,ecol=len1-1;//记录左上点的坐标以及右上点的坐标
-        int index=0;
-        while(srow<erow && scol<ecol){
-            for(int i=srow,j=scol;j<=ecol;j++)
-                res[index++]=matrix[i][j];
-
-
-            for(int i=srow+1,j=ecol;i<=erow;i++)
-                res[index++]=matrix[i][j];
-
-            for(int i=erow,j=ecol-1;j>=scol;j--)
-                res[index++]=matrix[i][j];
-
-            for(int i=erow-1,j=scol;i>srow;i--)
-                res[index++]=matrix[i][j];
-
-            srow++;
-            scol++;
-            erow--;
-            ecol--;
-        }
-        for(int i=srow;i<=erow;i++)
-            for(int j=scol;j<=ecol;j++)
-                res[index++]=matrix[i][j];
-        return res;
-    }
-
-    public static void main(String[] args) {
-        int[][] matrix={{1,2,3},{4,5,6},{7,8,9}};
-        spiralOrder(matrix);
-    }
-}
Index: src/Leetcode/Solutionmian36.java
===================================================================
diff --git a/src/Leetcode/Solutionmian36.java b/src/Leetcode/Solutionmian36.java
deleted file mode 100644
--- a/src/Leetcode/Solutionmian36.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,80 +0,0 @@
-package Leetcode;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。
-
-
-
-为了让您更好地理解问题，以下面的二叉搜索树为例：
-
-
-
-
-
-我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。
-
-下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。
-
-
-
-
-
-特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/2 21:01
- */
-public class Solutionmian36 {
-
-    public static class Node {
-        public int value;
-        public Node right;
-        public Node left;
-        public Node(int value)
-        {
-            this.value=value;
-        }
-    }
-
-    public static Node treeToDoublyList(Node root) {
-        //递归写法
-        if(root==null) return null;
-        Node[] res=process(root);
-        res[0].left=res[1];
-        res[1].right=res[0];
-        return res[0];
-    }
-    //返回以root作为根节点形成的双向链表的头结点以及最后一个结点
-    private static Node[] process(Node root){
-        Node[] res=new Node[2];
-        if(root==null) return res;
-        Node[] left=process(root.left);
-        Node[] right=process(root.right);
-        if(left[1]!=null)
-            left[1].right=root;
-        root.left=left[1];
-        root.right=right[0];
-        if(right[0]!=null)
-            right[0].left=root;
-        res[0]=left[0]!=null ? left[0]:root;//当子树返回的结果不为null的时候才能使res[0]=left[0]
-        res[1]=right[1]!=null ? right[1] : root ;//与上面同理
-        return res;
-    }
-
-    public static void main(String[] args) {
-        Node head = new Node(4);
-        head.left = new Node(2);
-        head.right = new Node(6);
-        head.left.left = new Node(1);
-        head.left.right = new Node(3);
-        head.right.left = new Node(5);
-
-        treeToDoublyList(head);
-
-    }
-
-}
Index: src/Leetcode/数组/Solutonmian1620.java
===================================================================
diff --git a/src/Leetcode/数组/Solutonmian1620.java b/src/Leetcode/数组/Solutonmian1620.java
deleted file mode 100644
--- a/src/Leetcode/数组/Solutonmian1620.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,71 +0,0 @@
-package Leetcode.数组;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:在老式手机上，用户通过数字键盘输入，手机将提供与这些数字相匹配的单词列表。每个数字映射到0至4个字母。给定一个数字序列，实现一个算法来返回匹配单词的列表。你会得到一张含有有效单词的列表。映射如下图所示：
-
-
-
-示例 1:
-
-输入: num = "8733", words = ["tree", "used"]
-输出: ["tree", "used"]
-示例 2:
-
-输入: num = "2", words = ["a", "b", "c", "d"]
-输出: ["a", "b", "c"]
-提示：
-
-num.length <= 1000
-words.length <= 500
-words[i].length == num.length
-num中不会出现 0, 1 这两个数字
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/t9-lcci
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/17 14:16
- */
-public class Solutonmian1620 {
-
-    private char[][] nums=new char[][]{{},{},{'a','b','c'},{'d','e','f'},{'g','h','i'},
-            {'j','k','l'},{'m','n','o'},{'p','q','r','s'},{'t','u','v'},{'w','x','y','z'}};
-    public List<String> getValidT9Words(String num, String[] words) {
-        List<String> res=new ArrayList<>();
-        int n=num.length();
-        char[] chs=num.toCharArray();
-        for(String str: words){
-            char[] target=str.toCharArray();
-            if(process(chs,target)){
-                res.add(str);
-            }
-        }
-        return res;
-    }
-
-    private boolean process(char[] chs,char[] target){
-        int len=chs.length;
-        for(int i=0;i<len;i++){
-            char[] des=nums[chs[i]-'0'];
-            int j=0;
-            for(;j<des.length;j++){
-                if(des[j]==target[i])
-                    break;
-            }
-            if(j==des.length)
-                return false;
-        }
-        return true;
-
-    }
-
-    public static void main(String[] args) {
-        String num="2";
-        String[] words={"a","b","c","d"};
-        System.out.println(new Solutonmian1620().getValidT9Words(num,words));
-    }
-}
Index: src/codeTop/SortOddEvenList.java
===================================================================
diff --git a/src/codeTop/SortOddEvenList.java b/src/codeTop/SortOddEvenList.java
deleted file mode 100644
--- a/src/codeTop/SortOddEvenList.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,63 +0,0 @@
-package codeTop;
-
-/**
- * 给定一个奇数位升序，偶数位降序的链表，将其重新排序。
- *
- * 输入: 1->8->3->6->5->4->7->2->NULL
- * 输出: 1->2->3->4->5->6->7->8->NULL
- */
-public class SortOddEvenList {
-    class ListNode{
-        int val;
-        ListNode next;
-        ListNode() {}
-        ListNode(int val) { this.val = val; }
-        ListNode(int val, ListNode next) { this.val = val; this.next = next; }
-    }
-
-    public ListNode sortOddEvenList(ListNode root){
-        if(root == null || root.next == null){
-            return root;
-        }
-        ListNode oddHead = root,evenHead = root.next;
-        ListNode cur1 = oddHead,cur2 = evenHead;
-        //将链表分成两部分
-        while(cur2 != null && cur2.next != null){
-            cur1.next = cur2.next;
-            cur2.next = cur2.next.next;
-            cur1 = cur1.next;
-            cur2 = cur2.next;
-        }
-        //将偶数位置的链表翻转
-        ListNode pre = null;
-        ListNode cur = evenHead;
-        ListNode next = null;
-        while(cur != null) {
-            next = cur.next;
-            cur.next = pre;
-            pre = cur;
-            cur = next;
-        }
-        //合并两个链表
-        ListNode dumpy = new ListNode(0);
-        ListNode tmp =  dumpy;
-        while(pre != null && oddHead != null){
-            if(pre.val <= oddHead.val){
-                tmp.next = pre;
-                pre = pre.next;
-            }else{
-                tmp.next = oddHead;
-                oddHead = oddHead.next;
-            }
-            tmp = tmp.next;
-        }
-        if(pre != null){
-            tmp.next = pre;
-        }
-        if(oddHead != null){
-            tmp.next = oddHead;
-        }
-        return dumpy.next;
-    }
-
-}
Index: src/Gof/template/SoyaMilk.java
===================================================================
diff --git a/src/Gof/template/SoyaMilk.java b/src/Gof/template/SoyaMilk.java
deleted file mode 100644
--- a/src/Gof/template/SoyaMilk.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,37 +0,0 @@
-package Gof.template;
-
-public abstract class SoyaMilk {
-
-    final void make(){
-        select();
-        if(customerWantCondiments())
-            addCondiments();
-        soak();
-        beat();
-    }
-
-    void select()
-    {
-        System.out.println("第一部：选择豆子");
-    }
-
-    //添加不同的配料
-    abstract void addCondiments();
-
-    //浸泡
-    void soak()
-    {
-        System.out.println("第三步：黄豆和配料开始浸泡，需要3小时");
-    }
-
-    void beat(){
-        System.out.println("第四步：黄豆和配料打碎");
-    }
-
-    //钩子方法
-    public boolean customerWantCondiments()
-    {
-        return true;
-    }
-
-}
Index: src/org/sd/array/SparseArr.java
===================================================================
diff --git a/src/org/sd/array/SparseArr.java b/src/org/sd/array/SparseArr.java
deleted file mode 100644
--- a/src/org/sd/array/SparseArr.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,65 +0,0 @@
-package org.sd.array;
-
-import java.util.Arrays;
-
-public class SparseArr {
-
-    public static void main(String[] args) {
-        int[][] arr=new int[11][11];
-        arr[1][2]=1;
-        arr[2][3]=2;
-        //遍历原始数组
-        int sum=0;
-        for(int[] row:arr)
-        {
-            for(int i:row)
-            {
-                System.out.printf("%d\t",i);
-                if(i!=0)
-                    sum++;
-            }
-            System.out.println();
-        }
-        //创建稀疏数组
-        int[][] sparseArr=new int[sum+1][3];
-        sparseArr[0][0]=11;
-        sparseArr[0][1]=11;
-        sparseArr[0][2]=sum;
-
-        //遍历二维数组，将非0值放入稀疏数组
-        int count=0;
-        for(int i=0;i<11;i++)
-        {
-            for(int j=0;j<11;j++)
-            {
-                if(arr[i][j]!=0)
-                {
-                    count++;
-                    sparseArr[count][0]=i;
-                    sparseArr[count][1]=j;
-                    sparseArr[count][2]=arr[i][j];
-                }
-            }
-        }
-        System.out.println();
-        System.out.println("稀疏数组为：。。。");
-        for(int i=0;i<sparseArr.length;i++)
-        {
-            System.out.printf("%d\t%d\t%d\t",sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]);
-            System.out.println();
-        }
-        //稀疏数组转为二维数组,先读取稀疏数组的第一行，根据第一行的数据创建二维数组
-        int [][] sArr= new int[sparseArr[0][0]][sparseArr[0][1]];
-        for(int i=1;i<sparseArr[0][2];i++)
-        {
-            sArr[sparseArr[i][0]][sparseArr[i][1]]=sparseArr[i][2];
-        }
-
-        for(int[] row :sArr)
-        {
-            for(int j:row)
-                System.out.printf("%d\t",j);
-            System.out.println();
-        }
-    }
-}
Index: src/JUC/SpinLockDemo/SpinLockDemo.java
===================================================================
diff --git a/src/JUC/SpinLockDemo/SpinLockDemo.java b/src/JUC/SpinLockDemo/SpinLockDemo.java
deleted file mode 100644
--- a/src/JUC/SpinLockDemo/SpinLockDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,41 +0,0 @@
-package JUC.SpinLockDemo;
-
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-
-//写一个自旋锁的例子
-public class SpinLockDemo {
-
-    AtomicReference<Thread> atomicReference=new AtomicReference<>();
-
-    public void myLock(){
-        Thread thread=Thread.currentThread();
-        System.out.println(Thread.currentThread().getName()+"\t coming in ");
-        while(!atomicReference.compareAndSet(null,thread))
-        {
-
-        }
-    }
-    public void myUnlock(){
-        Thread thread=Thread.currentThread();
-        atomicReference.compareAndSet(thread,null);
-        System.out.println(Thread.currentThread().getName()+"\tinvoke myUnlock");
-    }
-
-    public static void main(String[] args) {
-      SpinLockDemo spinLockDemo=new SpinLockDemo();
-      new Thread(()->{
-          spinLockDemo.myLock();
-          try{TimeUnit.SECONDS.sleep(5);}catch (Exception e){e.printStackTrace();}
-          spinLockDemo.myUnlock();
-      },"AA").start();
-
-      try{TimeUnit.SECONDS.sleep(1);}catch (Exception e){e.printStackTrace();}
-      new Thread(()->{
-          spinLockDemo.myLock();
-          try{TimeUnit.SECONDS.sleep(2);}catch (Exception e){e.printStackTrace();}
-          spinLockDemo.myUnlock();
-      },"BB").start();
-
-    }
-}
Index: src/左神算法/高频面试题/十京东/SplitNumberToTwoParts.java
===================================================================
diff --git a/src/左神算法/高频面试题/十京东/SplitNumberToTwoParts.java b/src/左神算法/高频面试题/十京东/SplitNumberToTwoParts.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/十京东/SplitNumberToTwoParts.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,40 +0,0 @@
-package 左神算法.高频面试题.十京东;
-
-/*
-  如果一个数字能够分成两组，其中一组的数字的和等于另一组数字的和，我们就将这个数成为神奇数。判断一个数是否为神奇数
- */
-public class SplitNumberToTwoParts {
-
-    public static boolean isMagic(int number){
-        int sum=0;
-        int temp=number;
-        while(number!=0){
-            sum+=number%10;//求所有位上的数的和
-            number=number/10;
-        }
-        if((sum & 1)==1){ //奇数一定不是
-            return false;
-        }
-        //只要找到可以达到sum的一半的组合便可
-        boolean[] dp=new boolean[sum/2+1];//使用一个一维数组滚动刷新来实现
-        sum=sum/2;
-        dp[0]=true;
-        while(temp!=0){
-            int cur=temp%10;
-            for(int i=sum;i>-1;i--){//数组从右往左滚动刷新
-                dp[i]=dp[i] || (i-cur>=0 ? dp[i-cur]:false);
-            }
-            if(dp[sum]){
-                return true;
-            }
-            temp=temp/10;
-        }
-        return false;
-    }
-
-
-    public static void main(String[] args) {
-        int test = 2544;
-        System.out.println(isMagic(test));
-    }
-}
Index: src/重温设计模式/结构型设计模式/适配器模式/示例/SquarePeg.java
===================================================================
diff --git a/src/重温设计模式/结构型设计模式/适配器模式/示例/SquarePeg.java b/src/重温设计模式/结构型设计模式/适配器模式/示例/SquarePeg.java
deleted file mode 100644
--- a/src/重温设计模式/结构型设计模式/适配器模式/示例/SquarePeg.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,27 +0,0 @@
-package 重温设计模式.结构型设计模式.适配器模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/4/29 19:40
- */
-public class SquarePeg {
-
-    private double width;
-
-    public SquarePeg(double width){
-        this.width = width;
-    }
-
-    public double getWidth(){
-        return width;
-    }
-
-    public double getSquare(){
-        double result;
-        result = Math.pow(width,2);
-        return result;
-    }
-
-}
Index: src/重温设计模式/结构型设计模式/适配器模式/示例/SquarePegAdapter.java
===================================================================
diff --git a/src/重温设计模式/结构型设计模式/适配器模式/示例/SquarePegAdapter.java b/src/重温设计模式/结构型设计模式/适配器模式/示例/SquarePegAdapter.java
deleted file mode 100644
--- a/src/重温设计模式/结构型设计模式/适配器模式/示例/SquarePegAdapter.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,25 +0,0 @@
-package 重温设计模式.结构型设计模式.适配器模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/4/29 19:41
- */
-public class SquarePegAdapter extends RoundPeg {
-
-    private SquarePeg squarePeg;
-
-    public  SquarePegAdapter(SquarePeg squarePeg){
-        this.squarePeg = squarePeg;
-    }
-
-    //适配器的转换工作
-    @Override
-    public double getRadius(){
-        double result;
-        result = (Math.sqrt(Math.pow(squarePeg.getWidth() / 2,2) * 2));
-        return result;
-    }
-
-}
Index: src/左神算法/基础班/第三课/StackAndQueueConvert.java
===================================================================
diff --git a/src/左神算法/基础班/第三课/StackAndQueueConvert.java b/src/左神算法/基础班/第三课/StackAndQueueConvert.java
deleted file mode 100644
--- a/src/左神算法/基础班/第三课/StackAndQueueConvert.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,99 +0,0 @@
-package 左神算法.基础班.第三课;
-
-import java.util.LinkedList;
-import java.util.Queue;
-import java.util.Stack;
-
-public class StackAndQueueConvert {
-
-    public static class TwoStackQueue{
-        private Stack<Integer>stackPush;
-        private Stack<Integer>stackPop;
-
-        public TwoStackQueue(Stack<Integer> stackPush, Stack<Integer> stackPop) {
-            this.stackPush = stackPush;
-            this.stackPop = stackPop;
-        }
-
-        public void push(int nums)
-        {
-            stackPush.push(nums);
-        }
-        public int pop()
-        {
-            if(stackPush.isEmpty() && stackPop.isEmpty())
-                throw new RuntimeException("queue is empty");
-            else if(stackPop.isEmpty())
-            {
-                while(!stackPop.isEmpty())
-                stackPop.push(stackPush.pop());
-            }
-            return stackPop.pop();
-        }
-        public int peek()
-        {
-            if(stackPush.isEmpty() && stackPop.isEmpty())
-                throw new RuntimeException("queue is empty");
-            else if(stackPop.isEmpty())
-            {
-                while(!stackPop.isEmpty())
-                    stackPop.push(stackPush.pop());
-            }
-            return stackPop.peek();
-        }
-
-
-    }
-
-    public static class twoQueueStack{
-
-        private Queue<Integer>queue;
-        private Queue<Integer>help;
-        public twoQueueStack(){
-            this.help=new LinkedList<>();
-            this.queue=new LinkedList<>();
-        }
-
-        public void push(Integer nums)
-        {
-            queue.add(nums);
-        }
-
-        public int peek()
-        {
-            if(queue.isEmpty())
-                throw new RuntimeException("stack is empty");
-            while(queue.size()!=1)
-            {
-                help.add(queue.poll());
-            }
-            int res=queue.peek();
-            help.add(res);
-            swap(queue,help);
-            return res;
-        }
-
-
-        public void swap(Queue queue,Queue help)
-        {
-            Queue temp=queue;
-            queue=help;
-            help=temp;
-        }
-
-        public int poll()
-        {
-            if(queue.isEmpty())
-                throw new RuntimeException("stack is empty");
-            while(queue.size()!=1)
-            {
-                help.add(queue.poll());
-            }
-            int res=queue.poll();
-            swap(queue,help);
-            return res;
-        }
-
-
-    }
-}
Index: src/org/sd/dyanmicProxy/Star.java
===================================================================
diff --git a/src/org/sd/dyanmicProxy/Star.java b/src/org/sd/dyanmicProxy/Star.java
deleted file mode 100644
--- a/src/org/sd/dyanmicProxy/Star.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,24 +0,0 @@
-package org.sd.dyanmicProxy;
-
-public interface Star {
-    /**
-     * 面谈
-     */
-    void confer() throws Throwable;
-    /**
-     * 签合同
-     */
-    void signContract() throws Throwable;
-    /**
-     * 订票
-     */
-    void bookTicket() throws Throwable;
-    /**
-     * 唱歌
-     */
-    void sing() throws Throwable;
-    /**
-     * 收钱
-     */
-    void collectMoney() throws Throwable;
-}
Index: src/org/sd/StaticProxy/Star.java
===================================================================
diff --git a/src/org/sd/StaticProxy/Star.java b/src/org/sd/StaticProxy/Star.java
deleted file mode 100644
--- a/src/org/sd/StaticProxy/Star.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,24 +0,0 @@
-package org.sd.StaticProxy;
-
-public interface Star {
-    /**
-     * 面谈
-     */
-    void confer() throws Throwable;
-    /**
-     * 签合同
-     */
-    void signContract() throws Throwable;
-    /**
-     * 订票
-     */
-    void bookTicket() throws Throwable;
-    /**
-     * 唱歌
-     */
-    void sing() throws Throwable;
-    /**
-     * 收钱
-     */
-    void collectMoney() throws Throwable;
-}
Index: src/org/sd/dyanmicProxy/StarHandler.java
===================================================================
diff --git a/src/org/sd/dyanmicProxy/StarHandler.java b/src/org/sd/dyanmicProxy/StarHandler.java
deleted file mode 100644
--- a/src/org/sd/dyanmicProxy/StarHandler.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,29 +0,0 @@
-package org.sd.dyanmicProxy;
-
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.Method;
-
-public class StarHandler implements InvocationHandler {
-    Star realStar;
-
-    public StarHandler(Star realStar) {
-        this.realStar = realStar;
-    }
-
-    @Override
-    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-         Object object=null;
-        System.out.println("真正的方法执行前！！");
-        System.out.println("面谈，签合同，预付款，订机票");
-        if(method.getName().equals("sing"))
-        {
-            object=method.invoke(realStar,args);
-        }
-        System.out.println("真正的方法执行后！！");
-        System.out.println("收尾款");
-        return object;
-
-
-
-    }
-}
Index: src/Gof/state/State.java
===================================================================
diff --git a/src/Gof/state/State.java b/src/Gof/state/State.java
deleted file mode 100644
--- a/src/Gof/state/State.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package Gof.state;
-
-public interface State {
-
-    public abstract  void deductMoney();//扣除积分
-    public abstract boolean raffle();//是否抽中奖品
-    public abstract void dispensePrize();//发放奖品
-}
\ No newline at end of file
Index: src/Gof/facade/Stereo.java
===================================================================
diff --git a/src/Gof/facade/Stereo.java b/src/Gof/facade/Stereo.java
deleted file mode 100644
--- a/src/Gof/facade/Stereo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,22 +0,0 @@
-package Gof.facade;
-
-import com.sun.org.apache.xml.internal.security.keys.storage.implementations.CertsInFilesystemDirectoryResolver;
-
-public class Stereo {
-     private static final Stereo instance=new Stereo();
-     private Stereo(){};
-     public static Stereo getInstance()
-     {return instance;
-     }
-    public void on()
-    {
-        System.out.println("stereo on");
-    }
-    public void off() {
-        System.out.println("stereo off");
-    }
-    public void up()
-    {
-        System.out.println("stereo up");
-    }
-}
Index: src/面试相关/面试手撕代码/StringPlus.java
===================================================================
diff --git a/src/面试相关/面试手撕代码/StringPlus.java b/src/面试相关/面试手撕代码/StringPlus.java
deleted file mode 100644
--- a/src/面试相关/面试手撕代码/StringPlus.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,14 +0,0 @@
-package 面试相关.面试手撕代码;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 两个表示小数的字符串相加，返回字符串表示的结果
- * @date 2020/11/13 19:45
- */
-public class StringPlus {
-
-    //类似两个表示整数的字符串相加，首先将两个字符串的整数部分与小数部分分开，分别做运算，不过小数部分如果长度不同需要在右边
-    //补零将他们变成长度相同的两个字符串，其次需要注意小数部分的进位，如果小数部分有进位，那么需要将进位加入到整数部分。
-
-}
Index: src/org/sd/singleton/Student.java
===================================================================
diff --git a/src/org/sd/singleton/Student.java b/src/org/sd/singleton/Student.java
deleted file mode 100644
--- a/src/org/sd/singleton/Student.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,87 +0,0 @@
-package org.sd.singleton;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
-
-public class Student implements Comparable<Student>{
-
-
-        private int id;
-        private int age;
-        private String name;
-
-        public Student(int id, int age, String name) {
-            this.id = id;
-            this.age = age;
-            this.name = name;
-        }
-        @Override
-        public int compareTo(Student o) {
-            //降序
-            //return o.age - this.age;
-            //升序
-            return this.age - o.age;
-        }
-        @Override
-        public String toString() {
-            return "Student{" +
-                    "id=" + id +
-                    ", age=" + age +
-                    ", name='" + name + '\'' +
-                    '}';
-        }
-
-    public int getId() {
-        return id;
-    }
-
-    public void setId(int id) {
-        this.id = id;
-    }
-
-    public int getAge() {
-        return age;
-    }
-
-    public void setAge(int age) {
-        this.age = age;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    public static void main(String args[]){
-        List<Student> list = new ArrayList<>();
-        list.add(new Student(1,25,"关羽"));
-        list.add(new Student(2,21,"张飞"));
-        list.add(new Student(3,18,"刘备"));
-        list.add(new Student(4,32,"袁绍"));
-        list.add(new Student(5,36,"赵云"));
-        list.add(new Student(6,16,"曹操"));
-        System.out.println("排序前:");
-        for (Student student : list) {
-            System.out.println(student.toString());
-        }
-        //使用默认排序
-        Collections.sort(list);
-
-
-        System.out.println("默认排序后:");
-        for (Student student : list) {
-            System.out.println(student.toString());
-        }
-    }
-
-
-
-}
-
-
-
Index: src/org/sd/singleton/StudentComparator.java
===================================================================
diff --git a/src/org/sd/singleton/StudentComparator.java b/src/org/sd/singleton/StudentComparator.java
deleted file mode 100644
--- a/src/org/sd/singleton/StudentComparator.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,38 +0,0 @@
-package org.sd.singleton;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
-
-public class StudentComparator implements Comparator<Student> {
-
-    @Override
-    public int compare(Student o1, Student o2) {
-        if (o1.getAge() == o2.getAge()) {
-            return o1.getId() - o2.getId();
-        } else {
-            return o1.getAge() - o2.getAge();
-        }
-    }
-
-    public static void main(String args[]) {
-        List<Student> list = new ArrayList<>();
-        list.add(new Student(1, 21, "关羽"));
-        list.add(new Student(2, 21, "张飞"));
-        list.add(new Student(3, 18, "刘备"));
-        list.add(new Student(4, 32, "袁绍"));
-        list.add(new Student(5, 36, "赵云"));
-        list.add(new Student(6, 16, "曹操"));
-        System.out.println("排序前:");
-        for (Student student : list) {
-            System.out.println(student.toString());
-        }
-
-        Collections.sort(list, new StudentComparator());
-        System.out.println("排序后：  ");
-        for(Student student:list){
-            System.out.println(student);
-        }
-    }
-}
Index: src/Gof/observer/Subject.java
===================================================================
diff --git a/src/Gof/observer/Subject.java b/src/Gof/observer/Subject.java
deleted file mode 100644
--- a/src/Gof/observer/Subject.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package Gof.observer;
-
-public interface Subject {
-
-    public void registObserver(Observer o);
-    public void removeObserver(Observer o);
-    public void notifyObservers();
-}
Index: src/左神算法/高频面试题/数组问题/SubMatrixMaxSum.java
===================================================================
diff --git a/src/左神算法/高频面试题/数组问题/SubMatrixMaxSum.java b/src/左神算法/高频面试题/数组问题/SubMatrixMaxSum.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/数组问题/SubMatrixMaxSum.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,43 +0,0 @@
-package 左神算法.高频面试题.数组问题;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 求一个矩阵中最大子矩阵的和。具体要求见笔记：左神高频面试题 ---》三
- * @date 2020/1/2 10:12
- */
-public class SubMatrixMaxSum {
-
-
-     //该实现没有判断矩阵的行与列哪个更小，可以判断一下
-    public static int maxSum(int[][] arr){
-        if(arr==null || arr.length==0 || arr[0]==null || arr[0].length==0)
-            return 0;
-        int max=Integer.MIN_VALUE;
-        int cur=0;
-        int[] s=null;//累加数组
-        for(int i=0;i<arr.length;i++){
-            s=new int[arr[0].length];
-            for(int j=i;j<arr.length;j++)
-            {    cur=0;
-                for(int k=0;k<s.length;k++){
-                    s[k]+=arr[j][k];
-                    cur+=s[k];
-                    max=Math.max(max,cur);
-                    cur=cur<0 ? 0:cur;
-                }
-
-            }
-        }
-        return max;
-    }
-
-
-    public static void main(String[] args) {
-        int[][] matrix = { { -90, 48, 78 }, { 64, -40, 64 }, { -81, -7, 66 } };
-        System.out.println(maxSum(matrix));
-
-
-    }
-
-}
Index: src/Gof/visitor/Success.java
===================================================================
diff --git a/src/Gof/visitor/Success.java b/src/Gof/visitor/Success.java
deleted file mode 100644
--- a/src/Gof/visitor/Success.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,14 +0,0 @@
-package Gof.visitor;
-
-public class Success extends Action {
-    @Override
-    public void getManResult(Man man) {
-        System.out.println(" 男人给的评价该歌手成功 !");
-    }
-
-    @Override
-    public void getWomanResult(Woman woman) {
-        System.out.println(" 女人给的评价该歌手成功 !");
-
-    }
-}
Index: src/JUC/SynchronousQueueDemo/SynchronousQueueDemo.java
===================================================================
diff --git a/src/JUC/SynchronousQueueDemo/SynchronousQueueDemo.java b/src/JUC/SynchronousQueueDemo/SynchronousQueueDemo.java
deleted file mode 100644
--- a/src/JUC/SynchronousQueueDemo/SynchronousQueueDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,81 +0,0 @@
-package JUC.SynchronousQueueDemo;
-
-import java.util.Scanner;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.TimeUnit;
-
-public class SynchronousQueueDemo {
-
-    public static void main(String[] args) {
-//        SynchronousQueue<Integer> synchronousQueue=new SynchronousQueue<>();
-//        new Thread(()->{
-//
-//                try {
-//                    for(int i=1;i<6;i++) {
-//                        synchronousQueue.put(i);
-//
-//                        System.out.println(Thread.currentThread().getName()+"\t"+"进队列"+i);
-//                         TimeUnit.SECONDS.sleep(4);
-//                    }
-//
-//                } catch (InterruptedException e) {
-//                    e.printStackTrace();
-//                }
-//        },"AAA").start();
-//
-//
-//        new Thread(()->{
-//
-//            try {
-//                for(int i=0;i<6;i++) {
-//                    Integer take = synchronousQueue.take();
-//                    System.out.println(Thread.currentThread().getName()+"\t取到了"+take);
-//                    TimeUnit.SECONDS.sleep(5);
-//                }
-//            } catch (InterruptedException e) {
-//                e.printStackTrace();
-//            }
-//
-//        },"BBB").start();
-
-//        Scanner in=new Scanner(System.in);
-//
-//        while(in.hasNextInt())
-//        {
-//            int  l=in.nextInt();
-//            int  r=in.nextInt();
-//            StringBuilder sb=new StringBuilder();
-//            for(int i=1;i<l;i++)
-//                sb.append(i);
-//            int count=0;
-//            for(int i=l;i<=r;i++)
-//            {
-//                sb.append(i);
-//                StringBuilder temp=sb;
-//                if(Integer.parseInt(temp.toString())%3==0)
-//                    count++;
-//            }
-//            System.out.println(count);
-//        }
-        System.out.println(divided(2,5));
-    }
-
-    public static int divided(int l,int r)
-    {
-        if(l<1 || r>1e9)
-            return 0;
-        StringBuilder sb=new StringBuilder();
-        StringBuilder sbr = new StringBuilder("");
-        int count=0;
-        for(int i=1;i<l;i++)
-            sb.append(i);
-        for(int i=l;i<=r;i++)
-        {
-            sb.append(i);
-            StringBuilder temp=sb;
-            if(Integer.parseInt(temp.toString())%3==0)
-                count++;
-        }
-        return count;
-    }
-}
Index: src/左神算法/进阶班一/KMP/T1SubtreeEqualsT2.java
===================================================================
diff --git a/src/左神算法/进阶班一/KMP/T1SubtreeEqualsT2.java b/src/左神算法/进阶班一/KMP/T1SubtreeEqualsT2.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/KMP/T1SubtreeEqualsT2.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,105 +0,0 @@
-package 左神算法.进阶班一.KMP;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 一棵树T1，另一个树T2,T1中是否存在与T2完全一致的子树，存在返回true,不存在返回false.
- * @date 2019/12/27 10:46
- */
-public class T1SubtreeEqualsT2 {
-
-    public static class Node{
-        public int value;
-        public Node left;
-        public Node right;
-        public Node(int value){
-            this.value=value;
-        }
-    }
-
-    public static boolean isSubtree(Node node1,Node node2){
-        String s = serializeTree(node1);
-        String s1 = serializeTree(node2);
-        int indexOf = getIndexOf(s, s1);
-        return indexOf!=-1;
-    }
-
-    //将树序列化，然后看一下t2是否t1的子串即可
-    public static String serializeTree(Node head)
-    {
-        if(head==null)
-            return "#!";
-        String str=head.value+"!";
-        str+=serializeTree(head.left);
-        str+=serializeTree(head.right);
-        return str;
-    }
-    //kmp算法
-    public static int getIndexOf(String str1,String str2){
-        if(str1==null || str2==null || str2.length()>str1.length()|| str2.length()<1)
-            return -1;
-        char[] str1Arr=str1.toCharArray();
-        char[] str2Arr=str2.toCharArray();
-        int[] next=getNextArray(str2);
-        int index1=0;
-        int index2=0;
-        while(index1<str1Arr.length && index2<str2Arr.length){
-
-            if(str1Arr[index1]==str2Arr[index2])
-            {
-                index1++;
-                index2++;
-            }else if(next[index2]==-1)//说明第一个字符都不一样
-            {
-                index1++;
-            }else{
-                index2=next[index2];
-            }
-        }
-
-        return index2==str2Arr.length ? index1-index2:-1;
-    }
-
-    public static int[] getNextArray(String str){
-        char[] chas=str.toCharArray();
-        int[] next=new int[chas.length];
-        next[0]=-1;
-        next[1]=0;
-        int pos=2;//初始化位置
-        int cn=0;//下一条的位置，初始化为next[pos-1]的值
-        while(pos<chas.length)
-        {
-            if(chas[pos-1]==chas[cn])
-            {
-                next[pos++]=++cn;
-            }else if(cn>0)
-            {
-                cn=next[cn];
-            }else {
-                next[pos++]=0;
-            }
-        }
-        return next;
-    }
-
-    public static void main(String[] args) {
-        Node t1 = new Node(1);
-        t1.left = new Node(2);
-        t1.right = new Node(3);
-        t1.left.left = new Node(4);
-        t1.left.right = new Node(5);
-        t1.right.left = new Node(6);
-        t1.right.right = new Node(7);
-        t1.left.left.right = new Node(8);
-        t1.left.right.left = new Node(9);
-
-        Node t2 = new Node(2);
-        t2.left = new Node(4);
-        t2.left.right = new Node(8);
-        t2.right = new Node(5);
-        t2.right.left = new Node(9);
-
-        System.out.println(isSubtree(t1, t2));
-
-    }
-}
Index: src/org/sd/Adapter/Target.java
===================================================================
diff --git a/src/org/sd/Adapter/Target.java b/src/org/sd/Adapter/Target.java
deleted file mode 100644
--- a/src/org/sd/Adapter/Target.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,5 +0,0 @@
-package org.sd.Adapter;
-
-public interface Target {
-    void handleReq();
-}
Index: src/左神算法/基础班/并查集/TarjanAndDisjoinSetsForLCA.java
===================================================================
diff --git a/src/左神算法/基础班/并查集/TarjanAndDisjoinSetsForLCA.java b/src/左神算法/基础班/并查集/TarjanAndDisjoinSetsForLCA.java
deleted file mode 100644
--- a/src/左神算法/基础班/并查集/TarjanAndDisjoinSetsForLCA.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,236 +0,0 @@
-package 左神算法.基础班.并查集;
-
-import java.util.HashMap;
-import java.util.LinkedList;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 题目要求见笔记并查集部分
- * @date 2020/1/1 10:17
- */
-public class TarjanAndDisjoinSetsForLCA {
-
-    public static class Node {
-        public int value;
-        public Node left;
-        public Node right;
-
-        public Node(int data) {
-            this.value = data;
-        }
-    }
-
-    public static class Query {
-        public Node o1;
-        public Node o2;
-
-        public Query(Node o1, Node o2) {
-            this.o1 = o1;
-            this.o2 = o2;
-        }
-    }
-
-    // 主函数
-    public static Node[] tarJanQuery(Node head, Query[] quries) {
-        Node[] ans = new Tarjan().query(head, quries);
-        return ans;
-    }
-
-    // Tarjan算法实现处理流程
-    public static class Tarjan {
-        private HashMap<Node, LinkedList<Node>> queryMap;
-        private HashMap<Node, LinkedList<Integer>> indexMap;
-        private HashMap<Node, Node> ancestorMap;
-        private DisjointSets sets;
-
-        public Tarjan() {
-            queryMap = new HashMap<Node, LinkedList<Node>>();
-            indexMap = new HashMap<Node, LinkedList<Integer>>();
-            ancestorMap = new HashMap<Node, Node>();
-            sets = new DisjointSets();
-        }
-
-        public Node[] query(Node head, Query[] ques) {
-            Node[] ans = new Node[ques.length];
-            setQueries(ques, ans);
-            sets.makeSets(head); //使用并查集之前，先构造并查集最初的形态，
-            setAnswers(head, ans);
-            return ans;
-        }
-
-        private void setQueries(Query[] ques, Node[] ans) {
-            Node o1 = null;
-            Node o2 = null;
-            for (int i = 0; i != ans.length; i++) {
-                o1 = ques[i].o1;
-                o2 = ques[i].o2;
-                if (o1 == o2 || o1 == null || o2 == null) {
-                    ans[i] = o1 != null ? o1 : o2;
-                } else {
-                    if (!queryMap.containsKey(o1)) {
-                        queryMap.put(o1, new LinkedList<Node>());
-                        indexMap.put(o1, new LinkedList<Integer>());
-                    }
-                    if (!queryMap.containsKey(o2)) {
-                        queryMap.put(o2, new LinkedList<Node>());
-                        indexMap.put(o2, new LinkedList<Integer>());
-                    }
-                    queryMap.get(o1).add(o2);
-                    indexMap.get(o1).add(i);
-                    queryMap.get(o2).add(o1);
-                    indexMap.get(o2).add(i);
-                }
-            }
-        }
-
-        private void setAnswers(Node head, Node[] ans) {
-            if (head == null) {
-                return;
-            }
-            setAnswers(head.left, ans);
-            sets.union(head.left, head);//合并并查集
-            ancestorMap.put(sets.findFather(head), head);
-            setAnswers(head.right, ans);
-            sets.union(head.right, head);
-            ancestorMap.put(sets.findFather(head), head);
-            LinkedList<Node> nList = queryMap.get(head);
-            LinkedList<Integer> iList = indexMap.get(head);
-            Node node = null;
-            Node nodeFather = null;
-            int index = 0;
-            while (nList != null && !nList.isEmpty()) {
-                node = nList.poll();
-                index = iList.poll();
-                nodeFather = sets.findFather(node);
-                if (ancestorMap.containsKey(nodeFather)) {
-                    ans[index] = ancestorMap.get(nodeFather);
-                }
-            }
-        }
-
-    }
-
-    // 实现Tarjan类中使用的并查集结构
-    public static class DisjointSets {
-        public HashMap<Node, Node> fatherMap;
-        public HashMap<Node, Integer> rankMap;
-
-        public DisjointSets() {
-            fatherMap = new HashMap<Node, Node>(); // (B,A)
-            rankMap = new HashMap<Node, Integer>();
-        }
-
-        public void makeSets(Node head) {
-            fatherMap.clear();
-            rankMap.clear();
-            preOrderMake(head);
-        }
-
-        private void preOrderMake(Node head) {
-            if (head == null) {
-                return;
-            }
-            fatherMap.put(head, head);
-            rankMap.put(head, 0);
-            preOrderMake(head.left);
-            preOrderMake(head.right);
-        }
-
-        public Node findFather(Node n) {
-            Node father = fatherMap.get(n);
-            if (father != n) {
-                father = findFather(father);
-            }
-            fatherMap.put(n, father);
-            return father;
-        }
-
-        public void union(Node a, Node b) {
-            if (a == null || b == null) {
-                return;
-            }
-            Node aFather = findFather(a);
-            Node bFather = findFather(b);
-            if (aFather != bFather) {
-                int aFrank = rankMap.get(aFather);
-                int bFrank = rankMap.get(bFather);
-                if (aFrank < bFrank) {
-                    fatherMap.put(aFather, bFather);
-                } else if (aFrank > bFrank) {
-                    fatherMap.put(bFather, aFather);
-                } else {
-                    fatherMap.put(bFather, aFather);
-                    rankMap.put(aFather, aFrank + 1);
-                }
-            }
-        }
-
-    }
-
-    // for test -- print tree
-    public static void printTree(Node head) {
-        System.out.println("Binary Tree:");
-        printInOrder(head, 0, "H", 17);
-        System.out.println();
-    }
-
-    public static void printInOrder(Node head, int height, String to, int len) {
-        if (head == null) {
-            return;
-        }
-        printInOrder(head.right, height + 1, "v", len);
-        String val = to + head.value + to;
-        int lenM = val.length();
-        int lenL = (len - lenM) / 2;
-        int lenR = len - lenM - lenL;
-        val = getSpace(lenL) + val + getSpace(lenR);
-        System.out.println(getSpace(height * len) + val);
-        printInOrder(head.left, height + 1, "^", len);
-    }
-
-    public static String getSpace(int num) {
-        String space = " ";
-        StringBuffer buf = new StringBuffer("");
-        for (int i = 0; i < num; i++) {
-            buf.append(space);
-        }
-        return buf.toString();
-    }
-
-    public static void main(String[] args) {
-        Node head = new Node(1);
-        head.left = new Node(2);
-        head.right = new Node(3);
-        head.left.left = new Node(4);
-        head.left.right = new Node(5);
-        head.right.left = new Node(6);
-        head.right.right = new Node(7);
-        head.right.right.left = new Node(8);
-        printTree(head);
-        System.out.println("===============");
-
-        // 生成查询数组
-        Query[] qs = new Query[7];
-        qs[0] = new Query(head.left.right, head.right.left);
-        qs[1] = new Query(head.left.left, head.left);
-        qs[2] = new Query(head.right.left, head.right.right.left);
-        qs[3] = new Query(head.left.left, head.right.right);
-        qs[4] = new Query(head.right.right, head.right.right.left);
-        qs[5] = new Query(head, head);
-        qs[6] = new Query(head.left, head.right.right.left);
-
-        // Tarjan算法结合并查集解决所有查询问题
-        Node[] ans = tarJanQuery(head, qs);
-
-        // 打印答案
-        for (int i = 0; i != ans.length; i++) {
-            System.out.println("o1 : " + qs[i].o1.value);
-            System.out.println("o2 : " + qs[i].o2.value);
-            System.out.println("ancestor : " + ans[i].value);
-            System.out.println("===============");
-        }
-
-    }
-
-}
Index: src/左神算法/进阶班一/并查集/TarjanAndDisjoinSetsForLCA难.java
===================================================================
diff --git a/src/左神算法/进阶班一/并查集/TarjanAndDisjoinSetsForLCA难.java b/src/左神算法/进阶班一/并查集/TarjanAndDisjoinSetsForLCA难.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/并查集/TarjanAndDisjoinSetsForLCA难.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,236 +0,0 @@
-package 左神算法.进阶班一.并查集;
-
-import java.util.HashMap;
-import java.util.LinkedList;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 题目要求见笔记并查集部分
- * @date 2020/1/1 10:17
- */
-public class TarjanAndDisjoinSetsForLCA难 {
-
-    public static class Node {
-        public int value;
-        public Node left;
-        public Node right;
-
-        public Node(int data) {
-            this.value = data;
-        }
-    }
-
-    public static class Query {
-        public Node o1;
-        public Node o2;
-
-        public Query(Node o1, Node o2) {
-            this.o1 = o1;
-            this.o2 = o2;
-        }
-    }
-
-    // 主函数
-    public static Node[] tarJanQuery(Node head, Query[] quries) {
-        Node[] ans = new Tarjan().query(head, quries);
-        return ans;
-    }
-
-    // Tarjan算法实现处理流程
-    public static class Tarjan {
-        private HashMap<Node, LinkedList<Node>> queryMap;
-        private HashMap<Node, LinkedList<Integer>> indexMap;
-        private HashMap<Node, Node> ancestorMap;
-        private DisjointSets sets;
-
-        public Tarjan() {
-            queryMap = new HashMap<Node, LinkedList<Node>>();
-            indexMap = new HashMap<Node, LinkedList<Integer>>();
-            ancestorMap = new HashMap<Node, Node>();
-            sets = new DisjointSets();
-        }
-
-        public Node[] query(Node head, Query[] ques) {
-            Node[] ans = new Node[ques.length];
-            setQueries(ques, ans);
-            sets.makeSets(head); //使用并查集之前，先构造并查集最初的形态，
-            setAnswers(head, ans);
-            return ans;
-        }
-
-        private void setQueries(Query[] ques, Node[] ans) {
-            Node o1 = null;
-            Node o2 = null;
-            for (int i = 0; i != ans.length; i++) {
-                o1 = ques[i].o1;
-                o2 = ques[i].o2;
-                if (o1 == o2 || o1 == null || o2 == null) {
-                    ans[i] = o1 != null ? o1 : o2;
-                } else {
-                    if (!queryMap.containsKey(o1)) {
-                        queryMap.put(o1, new LinkedList<Node>());
-                        indexMap.put(o1, new LinkedList<Integer>());
-                    }
-                    if (!queryMap.containsKey(o2)) {
-                        queryMap.put(o2, new LinkedList<Node>());
-                        indexMap.put(o2, new LinkedList<Integer>());
-                    }
-                    queryMap.get(o1).add(o2);
-                    indexMap.get(o1).add(i);
-                    queryMap.get(o2).add(o1);
-                    indexMap.get(o2).add(i);
-                }
-            }
-        }
-
-        private void setAnswers(Node head, Node[] ans) {
-            if (head == null) {
-                return;
-            }
-            setAnswers(head.left, ans);
-            sets.union(head.left, head);//合并并查集
-            ancestorMap.put(sets.findFather(head), head);
-            setAnswers(head.right, ans);
-            sets.union(head.right, head);
-            ancestorMap.put(sets.findFather(head), head);
-            LinkedList<Node> nList = queryMap.get(head);
-            LinkedList<Integer> iList = indexMap.get(head);
-            Node node = null;
-            Node nodeFather = null;
-            int index = 0;
-            while (nList != null && !nList.isEmpty()) {
-                node = nList.poll();
-                index = iList.poll();
-                nodeFather = sets.findFather(node);
-                if (ancestorMap.containsKey(nodeFather)) {
-                    ans[index] = ancestorMap.get(nodeFather);
-                }
-            }
-        }
-
-    }
-
-    // 实现Tarjan类中使用的并查集结构
-    public static class DisjointSets {
-        public HashMap<Node, Node> fatherMap;
-        public HashMap<Node, Integer> rankMap;
-
-        public DisjointSets() {
-            fatherMap = new HashMap<Node, Node>(); // (B,A)
-            rankMap = new HashMap<Node, Integer>();
-        }
-
-        public void makeSets(Node head) {
-            fatherMap.clear();
-            rankMap.clear();
-            preOrderMake(head);
-        }
-
-        private void preOrderMake(Node head) {
-            if (head == null) {
-                return;
-            }
-            fatherMap.put(head, head);
-            rankMap.put(head, 0);
-            preOrderMake(head.left);
-            preOrderMake(head.right);
-        }
-
-        public Node findFather(Node n) {
-            Node father = fatherMap.get(n);
-            if (father != n) {
-                father = findFather(father);
-            }
-            fatherMap.put(n, father);
-            return father;
-        }
-
-        public void union(Node a, Node b) {
-            if (a == null || b == null) {
-                return;
-            }
-            Node aFather = findFather(a);
-            Node bFather = findFather(b);
-            if (aFather != bFather) {
-                int aFrank = rankMap.get(aFather);
-                int bFrank = rankMap.get(bFather);
-                if (aFrank < bFrank) {
-                    fatherMap.put(aFather, bFather);
-                } else if (aFrank > bFrank) {
-                    fatherMap.put(bFather, aFather);
-                } else {
-                    fatherMap.put(bFather, aFather);
-                    rankMap.put(aFather, aFrank + 1);
-                }
-            }
-        }
-
-    }
-
-    // for test -- print tree
-    public static void printTree(Node head) {
-        System.out.println("Binary Tree:");
-        printInOrder(head, 0, "H", 17);
-        System.out.println();
-    }
-
-    public static void printInOrder(Node head, int height, String to, int len) {
-        if (head == null) {
-            return;
-        }
-        printInOrder(head.right, height + 1, "v", len);
-        String val = to + head.value + to;
-        int lenM = val.length();
-        int lenL = (len - lenM) / 2;
-        int lenR = len - lenM - lenL;
-        val = getSpace(lenL) + val + getSpace(lenR);
-        System.out.println(getSpace(height * len) + val);
-        printInOrder(head.left, height + 1, "^", len);
-    }
-
-    public static String getSpace(int num) {
-        String space = " ";
-        StringBuffer buf = new StringBuffer("");
-        for (int i = 0; i < num; i++) {
-            buf.append(space);
-        }
-        return buf.toString();
-    }
-
-    public static void main(String[] args) {
-        Node head = new Node(1);
-        head.left = new Node(2);
-        head.right = new Node(3);
-        head.left.left = new Node(4);
-        head.left.right = new Node(5);
-        head.right.left = new Node(6);
-        head.right.right = new Node(7);
-        head.right.right.left = new Node(8);
-        printTree(head);
-        System.out.println("===============");
-
-        // 生成查询数组
-        Query[] qs = new Query[7];
-        qs[0] = new Query(head.left.right, head.right.left);
-        qs[1] = new Query(head.left.left, head.left);
-        qs[2] = new Query(head.right.left, head.right.right.left);
-        qs[3] = new Query(head.left.left, head.right.right);
-        qs[4] = new Query(head.right.right, head.right.right.left);
-        qs[5] = new Query(head, head);
-        qs[6] = new Query(head.left, head.right.right.left);
-
-        // Tarjan算法结合并查集解决所有查询问题
-        Node[] ans = tarJanQuery(head, qs);
-
-        // 打印答案
-        for (int i = 0; i != ans.length; i++) {
-            System.out.println("o1 : " + qs[i].o1.value);
-            System.out.println("o2 : " + qs[i].o2.value);
-            System.out.println("ancestor : " + ans[i].value);
-            System.out.println("===============");
-        }
-
-    }
-
-}
Index: src/Gof/proxy/CglibProxy/TeacherDao.java
===================================================================
diff --git a/src/Gof/proxy/CglibProxy/TeacherDao.java b/src/Gof/proxy/CglibProxy/TeacherDao.java
deleted file mode 100644
--- a/src/Gof/proxy/CglibProxy/TeacherDao.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,9 +0,0 @@
-package Gof.proxy.CglibProxy;
-
-public class TeacherDao {
-
-    public String teach(){
-        System.out.println("老师上课中，我是cglib代理，不需要实现接口");
-        return "hello";
-    }
-}
Index: src/Gof/proxy/dynamicProxy/TeacherDao.java
===================================================================
diff --git a/src/Gof/proxy/dynamicProxy/TeacherDao.java b/src/Gof/proxy/dynamicProxy/TeacherDao.java
deleted file mode 100644
--- a/src/Gof/proxy/dynamicProxy/TeacherDao.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,13 +0,0 @@
-package Gof.proxy.dynamicProxy;
-
-public class TeacherDao implements ITeacherDao {
-    @Override
-    public void teach(String name) {
-        System.out.println("老师教 "+name+"中,.......");
-    }
-
-    @Override
-    public void lesson(String name) {
-        System.out.println("老师正在上课: "+name);
-    }
-}
Index: src/Gof/proxy/staticProxy/TeacherDao.java
===================================================================
diff --git a/src/Gof/proxy/staticProxy/TeacherDao.java b/src/Gof/proxy/staticProxy/TeacherDao.java
deleted file mode 100644
--- a/src/Gof/proxy/staticProxy/TeacherDao.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package Gof.proxy.staticProxy;
-
-public class TeacherDao implements ITeacherDao {
-    @Override
-    public void teach(String name) {
-        System.out.println("老师教 "+name+"中,.......");
-    }
-}
Index: src/Gof/proxy/staticProxy/TeacherDaoProxy.java
===================================================================
diff --git a/src/Gof/proxy/staticProxy/TeacherDaoProxy.java b/src/Gof/proxy/staticProxy/TeacherDaoProxy.java
deleted file mode 100644
--- a/src/Gof/proxy/staticProxy/TeacherDaoProxy.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,17 +0,0 @@
-package Gof.proxy.staticProxy;
-
-public class TeacherDaoProxy implements ITeacherDao {
-
-    private ITeacherDao target;
-
-    public TeacherDaoProxy(TeacherDao teacherDao) {
-        this.target = teacherDao;
-    }
-
-    @Override
-    public void teach(String name) {
-        System.out.println("开始上课。。。。");
-        target.teach(name);
-        System.out.println("下课了。。。。");
-    }
-}
Index: src/Gof/Factory/simpleFactory/Test.java
===================================================================
diff --git a/src/Gof/Factory/simpleFactory/Test.java b/src/Gof/Factory/simpleFactory/Test.java
deleted file mode 100644
--- a/src/Gof/Factory/simpleFactory/Test.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package Gof.Factory.simpleFactory;
-
-public class Test {
-    public static void main(String[] args) {
-        new OrderPizza(new SimpleFatory());
-        System.out.println("结束");
-    }
-}
Index: src/org/sd/Adapter/Test.java
===================================================================
diff --git a/src/org/sd/Adapter/Test.java b/src/org/sd/Adapter/Test.java
deleted file mode 100644
--- a/src/org/sd/Adapter/Test.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,15 +0,0 @@
-package org.sd.Adapter;
-
-public class Test {
-    public static void main(String[] args) {
-        String str="000";
-        changeStr(str);
-        System.out.println(str);
-    }
-
-    public static void changeStr(String str)
-    {
-        str="welcome";
-
-    }
-}
Index: src/org/sd/QRcode/Test.java
===================================================================
diff --git a/src/org/sd/QRcode/Test.java b/src/org/sd/QRcode/Test.java
deleted file mode 100644
--- a/src/org/sd/QRcode/Test.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,13 +0,0 @@
-package org.sd.QRcode;
-
-public class Test {
-    public static void main(String[] args)throws Exception {
-       //生成二维码的路径
-        //内容
-        String path="src/二维码.png";
-        String content="http://www.baidu.com";
-        QRCodeUtil qrCodeUtil=new QRCodeUtil();
-        qrCodeUtil.encoderQRCode(content,path,"png",7);
-
-    }
-}
Index: src/org/sd/Zxing/Test.java
===================================================================
diff --git a/src/org/sd/Zxing/Test.java b/src/org/sd/Zxing/Test.java
deleted file mode 100644
--- a/src/org/sd/Zxing/Test.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,19 +0,0 @@
-package org.sd.Zxing;
-
-import com.google.zxing.NotFoundException;
-import com.google.zxing.WriterException;
-
-import java.io.File;
-import java.io.IOException;
-
-public class Test {
-    public static void main(String[] args) throws IOException, WriterException, NotFoundException {
-        String content="http://www.baidu.com";
-        String imgPath="src/百度.png";
-        String logo="src/flower.jpg";
-        //加密：文字---》二维码
-       // ZxingUtil.encodingImg(content,"gif",imgPath,430,430,logo);
-        //解密：二维码--》文字
-        ZxingUtil.decodeImage(new File("src/百度.png"));
-    }
-}
Index: src/Test.java
===================================================================
diff --git a/src/Test.java b/src/Test.java
deleted file mode 100644
--- a/src/Test.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,3 +0,0 @@
-public class Test {
-
-}
Index: src/org/sd/array/TestArray.java
===================================================================
diff --git a/src/org/sd/array/TestArray.java b/src/org/sd/array/TestArray.java
deleted file mode 100644
--- a/src/org/sd/array/TestArray.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,32 +0,0 @@
-package org.sd.array;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-
-public class TestArray {
-
-    public static void main(String[] args) {
-//        int[] arr=new int[]{1,2,3,4,5,6,76};
-//////        int dst=4;
-//////        //创建一个新数组
-//////        int [] newArr=new int[arr.length-1];
-//////        for(int i=0;i<newArr.length;i++)
-//////        {
-//////            if(i<dst)
-//////            {
-//////                newArr[i]=arr[i];
-//////            }else {
-//////                newArr[i]=arr[i+1];
-//////            }
-//////        }
-//////        //旧数组指向新数组
-//////        arr=newArr;
-//////        System.out.println(Arrays.toString(arr));
-        String str = " a    b ";
-        String str1 = str.trim(); //String表示一个不可变的字符串.去掉空格之后生成了一个新的字符串,原来的字符串并没有改变
-        System.out.println("!"+str1+"!");
-
-    }
-
-
-}
Index: src/JUC/Demo/ThreadDemo.java
===================================================================
diff --git a/src/JUC/Demo/ThreadDemo.java b/src/JUC/Demo/ThreadDemo.java
deleted file mode 100644
--- a/src/JUC/Demo/ThreadDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,36 +0,0 @@
-package JUC.Demo;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: test isInterrupted(）与interrupted()方法
- * @date 2020/4/15 22:42
- */
-public class ThreadDemo {
-
-    public static class MyThread extends Thread{
-        @Override
-        public void run() {
-//            try {
-//                Thread.sleep(4000);
-//            } catch (InterruptedException e) {
-//                e.printStackTrace();
-//            }
-            for(;;);
-        }
-    }
-    public static void main(String[] args) {
-
-        MyThread myThread=new MyThread();
-        myThread.start();
-        try{
-            Thread.sleep(1000);
-            myThread.interrupt();
-            System.out.println(myThread.isInterrupted());
-        } catch (InterruptedException e) {
-            e.printStackTrace();
-        }
-
-
-    }
-}
Index: src/韩顺平算法与数据结构/datastructure/tree/ThreadedBinaryTreeDemo/ThreadedBinaryTreeDemo.java
===================================================================
diff --git a/src/韩顺平算法与数据结构/datastructure/tree/ThreadedBinaryTreeDemo/ThreadedBinaryTreeDemo.java b/src/韩顺平算法与数据结构/datastructure/tree/ThreadedBinaryTreeDemo/ThreadedBinaryTreeDemo.java
deleted file mode 100644
--- a/src/韩顺平算法与数据结构/datastructure/tree/ThreadedBinaryTreeDemo/ThreadedBinaryTreeDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,288 +0,0 @@
-package 韩顺平算法与数据结构.datastructure.tree.ThreadedBinaryTreeDemo;
-
-public class ThreadedBinaryTreeDemo {
-    public static void main(String[] args) {
-        //测试一把中序线索二叉树的功能
-        HeroNode root = new HeroNode(1, "tom");
-        HeroNode node2 = new HeroNode(3, "jack");
-        HeroNode node3 = new HeroNode(6, "smith");
-        HeroNode node4 = new HeroNode(8, "mary");
-        HeroNode node5 = new HeroNode(10, "king");
-        HeroNode node6 = new HeroNode(14, "dim");
-
-        //二叉树，后面我们要递归创建, 现在简单处理使用手动创建
-        root.setLeft(node2);
-        root.setRight(node3);
-        node2.setLeft(node4);
-        node2.setRight(node5);
-        node3.setLeft(node6);
-
-        //测试中序线索化
-        ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree();
-        threadedBinaryTree.setRoot(root);
-        threadedBinaryTree.postThreaded(root);
-        //测试: 以10号节点测试
-        HeroNode leftNode = node5.getLeft();
-        HeroNode rightNode = node5.getRight();
-        System.out.println("10号结点的前驱结点是 ="  + leftNode); //3
-        System.out.println("10号结点的后继结点是="  + rightNode); //1
-
-        System.out.println("使用线索化的方式遍历 线索化二叉树");
-       // threadedBinaryTree.postOrderThreadedTree(); // 8, 3, 10, 1, 14, 6
-    }
-}
-
-//创建树
-class ThreadedBinaryTree{
-
-    private HeroNode root;
-
-    //为了实现线索化，需要创建一个总是指向当前节点前驱结点的指针
-    private HeroNode pre=null;
-
-    public void setRoot(HeroNode root) {
-        this.root = root;
-    }
-
-    public void threadedNodes()
-    {
-        this.threadedNodes(root);
-    }
-
-   //对二叉树进行后序线索化
-    public void postThreaded(HeroNode node)
-    {
-        if(node==null)
-        {
-            return;
-        }
-
-        postThreaded(node.getLeft());
-
-        postThreaded(node.getRight());
-
-        if(node.getLeft()==null)
-        {
-            node.setLeft(pre);
-            node.setLeftType(1);
-        }
-        if(pre!=null && pre.getRight()==null)
-        {
-            pre.setRight(node);
-            pre.setRigthType(1);
-        }
-        pre=node;
-    }
-
-
-    //编写对二叉树进行中序线索化的方法
-    public void threadedNodes(HeroNode node)
-    {
-        if(node==null)
-        {
-            return;
-        }
-        //先线索化左子树
-        threadedNodes(node.getLeft());
-
-        //线索化当前节点的前驱结点，即：如果当前节点的左结点为空，则指向前驱结点
-        if(node.getLeft()==null)
-        {
-            node.setLeft(pre);
-            node.setLeftType(1);
-        }
-        //前一个结点的后继结点指向当前节点，
-        if(pre!=null && pre.getRight()==null)
-        {
-            //让前驱结点的右指针指向当前节点
-           pre.setRight(node);
-           pre.setRigthType(1);
-        }
-         pre=node;//没处理一个结点后，让当前节点是下一个节点的前驱结点
-        //最后线索化右子树
-        threadedNodes(node.getRight());
-    }
-
-    //编写对二叉树进行前序线索化二叉树的方法
-    public void preThreaded(HeroNode node)
-    {
-        if(node==null)
-        {
-            return;
-        }
-        //处理当前节点的前驱结点
-        if(node.getLeft()==null)
-        {
-            node.setLeft(pre);
-            node.setLeftType(1);
-        }
-       // System.out.println(node);
-        //处理后继结点，如果
-        if(pre!=null && pre.getRight()==null)
-        {
-            pre.setRight(node);
-            pre.setRigthType(1);
-        }
-        pre=node;
-        //处理左子树
-        if(node.getLeftType()==0)
-        {
-            preThreaded(node.getLeft());
-        }
-
-         //处理右子树
-        if(node.getRigthType()==0)
-        {
-            preThreaded(node.getRight());
-        }
-
-    }
-
-    //中序遍历线索化二叉树
-    public void midThreadedOrder()
-    {
-        HeroNode node=root;
-        while(node!=null)
-        {
-            while(node.getLeftType()==0)
-                node=node.getLeft();
-            System.out.println(node);
-            //如果当前节点的右指针指向的是后继结点，则就一直输出
-            while (node.getRigthType()==1)
-            {
-                node=node.getRight();
-                System.out.println(node);
-            }
-            //替换这个遍历的结点
-            node=node.getRight();
-        }
-    }
-
-    //前序遍历线索化二叉树
-    public void preOrderThreadedTree()
-    {
-        HeroNode node=root;
-        while(node!=null)
-        {
-            System.out.println(node);
-            while(node.getLeftType()==0)
-            {
-                node=node.getLeft();
-                System.out.println(node);
-            }
-           while(node.getRigthType()==1)
-           {
-               node=node.getRight();
-               System.out.println(node);
-           }
-            node=node.getRight();
-
-        }
-    }
-    //后序遍历线索化二叉树
-    public void postOrderThreadedTree()
-    {
-        HeroNode node=root;
-        //找到后序遍历开始的结点
-        while(node !=null && node.getLeftType()==0)
-        {
-            node=node.getLeft();
-        }
-        //
-        while(node!=null)
-        {
-            if(node.getRigthType()==1)
-            {
-                System.out.println(node);
-                pre=node;
-                node=node.getRight();
-            }else{
-                if(node.getRight()==pre)
-                {
-                    System.out.println(node);
-                    if(node==root)
-                        break;
-                     pre=node;
-
-                }
-            }
-        }
-    }
-
-}
-
-
-//创建结点
-class HeroNode {
-    private int no;
-    private String name;
-    private HeroNode left;
-    private HeroNode right;
-
-    //标志位
-    private int leftType; //0表示指向的是左子树，1表示指向的是前驱结点
-    private int rigthType;
-
-    public int getNo() {
-        return no;
-    }
-
-    public void setNo(int no) {
-        this.no = no;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    public HeroNode getLeft() {
-        return left;
-    }
-
-    public void setLeft(HeroNode left) {
-        this.left = left;
-    }
-
-    public HeroNode getRight() {
-        return right;
-    }
-
-    public void setRight(HeroNode right) {
-        this.right = right;
-    }
-
-    public int getLeftType() {
-        return leftType;
-    }
-
-    public void setLeftType(int leftType) {
-        this.leftType = leftType;
-    }
-
-    public int getRigthType() {
-        return rigthType;
-    }
-
-    public void setRigthType(int rigthType) {
-        this.rigthType = rigthType;
-    }
-
-    public HeroNode(int no, String name) {
-        this.no = no;
-        this.name = name;
-    }
-
-    @Override
-    public String toString() {
-        return "HeroNode{" +
-                "no=" + no +
-                ", name='" + name + '\'' +
-                '}';
-    }
-
-
-}
Index: src/JUC/threadlocal/ThreadLocalDemo.java
===================================================================
diff --git a/src/JUC/threadlocal/ThreadLocalDemo.java b/src/JUC/threadlocal/ThreadLocalDemo.java
deleted file mode 100644
--- a/src/JUC/threadlocal/ThreadLocalDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,44 +0,0 @@
-package JUC.threadlocal;
-
-import java.util.concurrent.CountDownLatch;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2020/3/29 10:47
- */
-public class ThreadLocalDemo {
-    private String string;
-    ThreadLocal<String> threadLocal=new ThreadLocal<>();
-
-    private String getString() {
-        return threadLocal.get();
-    }
-
-    private void setString(String string) {
-        threadLocal.set(string);
-    }
-
-    public static void main(String[] args) {
-        int threads = 9;
-        ThreadLocalDemo demo = new ThreadLocalDemo();
-        CountDownLatch countDownLatch = new CountDownLatch(threads);
-        for (int i = 0; i < threads; i++) {
-            Thread thread = new Thread(() -> {
-                demo.setString(Thread.currentThread().getName());
-                try {
-                    Thread.sleep(1000);
-                } catch (InterruptedException e) {
-                    e.printStackTrace();
-                }
-                System.out.println("demo.getString()================>" +
-                        Thread.currentThread().getName()+" "+ demo.getString());
-                countDownLatch.countDown();
-            }, "执行线程 - " + i);
-            thread.start();
-        }
-
-    }
-
-}
Index: src/JUC/ThreadPoolDemo/ThreadPoolDemo.java
===================================================================
diff --git a/src/JUC/ThreadPoolDemo/ThreadPoolDemo.java b/src/JUC/ThreadPoolDemo/ThreadPoolDemo.java
deleted file mode 100644
--- a/src/JUC/ThreadPoolDemo/ThreadPoolDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,33 +0,0 @@
-package JUC.ThreadPoolDemo;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.TimeUnit;
-
-public class ThreadPoolDemo {
-
-    public static void main(String[] args) {
-        ExecutorService executorService = Executors.newSingleThreadExecutor();
-        ExecutorService executorService2 = Executors.newCachedThreadPool();
-        ExecutorService executorService1 = Executors.newFixedThreadPool(5);
-
-        try {
-            for (int i = 0; i < 10; i++) {
-                executorService.execute(()->{
-                    System.out.println(Thread.currentThread().getName()+"\t执行任务");
-                });
-                TimeUnit.MICROSECONDS.sleep(100);
-
-            }
-        } catch (Exception e){
-            e.printStackTrace();
-        }
-         finally{
-            executorService.shutdown();
-        }
-    }
-
-
-}
\ No newline at end of file
Index: src/重温设计模式/行为模式/责任链模式/示例/ThrottlingMiddleware.java
===================================================================
diff --git a/src/重温设计模式/行为模式/责任链模式/示例/ThrottlingMiddleware.java b/src/重温设计模式/行为模式/责任链模式/示例/ThrottlingMiddleware.java
deleted file mode 100644
--- a/src/重温设计模式/行为模式/责任链模式/示例/ThrottlingMiddleware.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,34 +0,0 @@
-package 重温设计模式.行为模式.责任链模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/14 21:41
- */
-public class ThrottlingMiddleware extends Middleware {
-
-    private int requestPerMinute;
-    private int request;
-    private long currentTime;
-
-    public ThrottlingMiddleware(int requestPerMinute){
-        this.requestPerMinute = requestPerMinute;
-        this.currentTime = System.currentTimeMillis();
-    }
-
-
-    @Override
-    public boolean check(String email, String password) {
-        if(System.currentTimeMillis() > currentTime + 60000){
-            request = 0;
-            currentTime = System.currentTimeMillis();
-        }
-        request++;
-        if(request > requestPerMinute){
-            System.out.println("Request limit exceeded!");
-            Thread.currentThread().stop();
-        }
-        return checkNext(email,password);
-    }
-}
Index: src/左神算法/高频面试题/九TOP_K问题/TopKSumCrossTwoArrays.java
===================================================================
diff --git a/src/左神算法/高频面试题/九TOP_K问题/TopKSumCrossTwoArrays.java b/src/左神算法/高频面试题/九TOP_K问题/TopKSumCrossTwoArrays.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/九TOP_K问题/TopKSumCrossTwoArrays.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,189 +0,0 @@
-package 左神算法.高频面试题.九TOP_K问题;
-
-import java.util.Arrays;
-import java.util.HashSet;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 给定两个有序的数组arr1与arr2，再给定一个整数k,返回来自arr1和arr2的两个数相加和最大的前k个，两个数
- * 必须分别来自两个数组。
- * @date 2020/1/21 17:30
- */
-public class TopKSumCrossTwoArrays {
-    public static class HeapNode {
-        public int row;
-        public int col;
-        public int value;
-
-        public HeapNode(int row, int col, int value) {
-            this.row = row;
-            this.col = col;
-            this.value = value;
-        }
-    }
-
-    public static int[] topKSum(int[] a1, int[] a2, int topK) {
-        if (a1 == null || a2 == null || topK < 1) {
-            return null;
-        }
-        topK = Math.min(topK, a1.length * a2.length);
-        HeapNode[] heap = new HeapNode[topK+1];
-        int heapSize = 0;
-        int headR = a1.length - 1;
-        int headC = a2.length - 1;
-        int uR = -1;
-        int uC = -1;
-        int lR = -1;
-        int lC = -1;
-        heapInsert(heap, heapSize++, headR, headC, a1[headR] + a2[headC]);
-        HashSet<String> positionSet = new HashSet<String>();
-        int[] res = new int[topK];
-        int resIndex = 0;
-        while (resIndex != topK) {
-            HeapNode head = popHead(heap, heapSize--);
-            res[resIndex++] = head.value;
-            headR = head.row;
-            headC = head.col;
-            uR = headR - 1;
-            uC = headC;
-            if (headR != 0 && !isContains(uR, uC, positionSet)) {
-                heapInsert(heap, heapSize++, uR, uC, a1[uR] + a2[uC]);
-                addPositionToSet(uR, uC, positionSet);
-            }
-            lR = headR;
-            lC = headC - 1;
-            if (headC != 0 && !isContains(lR, lC, positionSet)) {
-                heapInsert(heap, heapSize++, lR, lC, a1[lR] + a2[lC]);
-                addPositionToSet(lR, lC, positionSet);
-            }
-        }
-        return res;
-    }
-
-    public static HeapNode popHead(HeapNode[] heap, int heapSize) {
-        HeapNode res = heap[0];
-        swap(heap, 0, heapSize - 1);
-        heap[--heapSize] = null;
-        heapify(heap, 0, heapSize);
-        return res;
-    }
-
-    public static void heapify(HeapNode[] heap, int index, int heapSize) {
-        int left = index * 2 + 1;
-        int right = index * 2 + 2;
-        int largest = index;
-        while (left < heapSize) {
-            if (heap[left].value > heap[index].value) {
-                largest = left;
-            }
-            if (right < heapSize && heap[right].value > heap[largest].value) {
-                largest = right;
-            }
-            if (largest != index) {
-                swap(heap, largest, index);
-            } else {
-                break;
-            }
-            index = largest;
-            left = index * 2 + 1;
-            right = index * 2 + 2;
-        }
-    }
-
-    public static void heapInsert(HeapNode[] heap, int index, int row, int col,
-                                  int value) {
-        heap[index] = new HeapNode(row, col, value);
-        int parent = (index - 1) / 2;
-        while (index != 0) {
-            if (heap[index].value > heap[parent].value) {
-                swap(heap, parent, index);
-                index = parent;
-                parent = (index - 1) / 2;
-            } else {
-                break;
-            }
-        }
-    }
-
-    public static void swap(HeapNode[] heap, int index1, int index2) {
-        HeapNode tmp = heap[index1];
-        heap[index1] = heap[index2];
-        heap[index2] = tmp;
-    }
-
-    public static boolean isContains(int row, int col, HashSet<String> set) {
-        return set.contains(String.valueOf(row + "_" + col));
-    }
-
-    public static void addPositionToSet(int row, int col, HashSet<String> set) {
-        set.add(String.valueOf(row + "_" + col));
-    }
-
-    // For test, this method is inefficient but absolutely right
-    public static int[] topKSumTest(int[] arr1, int[] arr2, int topK) {
-        int[] all = new int[arr1.length * arr2.length];
-        int index = 0;
-        for (int i = 0; i != arr1.length; i++) {
-            for (int j = 0; j != arr2.length; j++) {
-                all[index++] = arr1[i] + arr2[j];
-            }
-        }
-        Arrays.sort(all);
-        int[] res = new int[Math.min(topK, all.length)];
-        index = all.length - 1;
-        for (int i = 0; i != res.length; i++) {
-            res[i] = all[index--];
-        }
-        return res;
-    }
-
-    public static int[] generateRandomSortArray(int len) {
-        int[] res = new int[len];
-        for (int i = 0; i != res.length; i++) {
-            res[i] = (int) (Math.random() * 50000) + 1;
-        }
-        Arrays.sort(res);
-        return res;
-    }
-
-    public static void printArray(int[] arr) {
-        for (int i = 0; i != arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    public static boolean isEqual(int[] arr1, int[] arr2) {
-        if (arr1 == null || arr2 == null || arr1.length != arr2.length) {
-            return false;
-        }
-        for (int i = 0; i != arr1.length; i++) {
-            if (arr1[i] != arr2[i]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    public static void main(String[] args) {
-        int a1Len = 5000;
-        int a2Len = 4000;
-        int k = 2000;
-        int[] arr1 = generateRandomSortArray(a1Len);
-        int[] arr2 = generateRandomSortArray(a2Len);
-        long start = System.currentTimeMillis();
-        int[] res = topKSum(arr1, arr2, k);
-        long end = System.currentTimeMillis();
-        System.out.println(end - start + " ms");
-
-        start = System.currentTimeMillis();
-        int[] absolutelyRight = topKSumTest(arr1, arr2, k);
-        end = System.currentTimeMillis();
-        System.out.println(end - start + " ms");
-
-        System.out.println(isEqual(res, absolutelyRight));
-
-    }
-
-}
Index: src/左神算法/高频面试题/九TOP_K问题/TopkTime1.java
===================================================================
diff --git a/src/左神算法/高频面试题/九TOP_K问题/TopkTime1.java b/src/左神算法/高频面试题/九TOP_K问题/TopkTime1.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/九TOP_K问题/TopkTime1.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,132 +0,0 @@
-package 左神算法.高频面试题.九TOP_K问题;
-
-import java.util.HashMap;
-import java.util.Map.Entry;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 给出次数的top k问题
- * 给定String类型的数组strArr，再给定整数k,请严格按照排名顺序打印出次数前k名的字符串。要求：strArr长度为N，时间复杂度为O（Nlogk)
- * @date 2020/1/16 16:27
- */
-public class TopkTime1 {
-
-    public static class Node {
-        public String str;
-        public int times;
-
-        public Node(String s, int t) {
-            str = s;
-            times = t;
-        }
-    }
-
-    public static void printTopKAndRank(String[] arr, int topK) {
-        if (arr == null || topK < 1) {
-            return;
-        }
-        HashMap<String, Integer> map = new HashMap<String, Integer>();
-        for (int i = 0; i != arr.length; i++) {
-            String cur = arr[i];
-            if (!map.containsKey(cur)) {
-                map.put(cur, 1);
-            } else {
-                map.put(cur, map.get(cur) + 1);
-            }
-        }
-        Node[] heap = new Node[topK];
-        int index = 0;
-        for (Entry<String, Integer> entry : map.entrySet()) {
-            String str = entry.getKey();
-            int times = entry.getValue();
-            Node node = new Node(str, times);
-            if (index != topK) {
-                heap[index] = node;
-                heapInsert(heap, index++);
-            } else {
-                if (heap[0].times < node.times) {
-                    heap[0] = node;
-                    heapify(heap, 0, topK);
-                }
-            }
-        }
-        //实现严格按照次数的多少从大到小排序
-        for (int i = index - 1; i != 0; i--) {
-            swap(heap, 0, i);//最小的放在最后
-            heapify(heap, 0, i);
-        }
-        for (int i = 0; i != heap.length; i++) {
-            if (heap[i] == null) {
-                break;
-            } else {
-                System.out.print("No." + (i + 1) + ": ");
-                System.out.print(heap[i].str + ", times: ");
-                System.out.println(heap[i].times);
-            }
-        }
-    }
-
-    public static void heapInsert(Node[] heap, int index) {
-        while (index != 0) {
-            int parent = (index - 1) / 2;
-            if (heap[index].times < heap[parent].times) {
-                swap(heap, parent, index);
-                index = parent;
-            } else {
-                break;
-            }
-        }
-    }
-
-    public static void heapify(Node[] heap, int index, int heapSize) {
-        int left = index * 2 + 1;
-        int right = index * 2 + 2;
-        int smallest = index;
-        while (left < heapSize) {
-            if (heap[left].times < heap[index].times) {
-                smallest = left;
-            }
-            if (right < heapSize && heap[right].times < heap[smallest].times) {
-                smallest = right;
-            }
-            if (smallest != index) {
-                swap(heap, smallest, index);
-            } else {
-                break;
-            }
-            index = smallest;
-            left = index * 2 + 1;
-            right = index * 2 + 2;
-        }
-    }
-
-    public static void swap(Node[] heap, int index1, int index2) {
-        Node tmp = heap[index1];
-        heap[index1] = heap[index2];
-        heap[index2] = tmp;
-    }
-
-    public static String[] generateRandomArray(int len, int max) {
-        String[] res = new String[len];
-        for (int i = 0; i != len; i++) {
-            res[i] = String.valueOf((int) (Math.random() * (max + 1)));
-        }
-        return res;
-    }
-
-    public static void printArray(String[] arr) {
-        for (int i = 0; i != arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-        String[] arr = generateRandomArray(50, 10);
-        int topK = 5;
-        printArray(arr);
-        printTopKAndRank(arr, topK);
-
-    }
-}
Index: src/左神算法/高频面试题/九TOP_K问题/TopKTime2.java
===================================================================
diff --git a/src/左神算法/高频面试题/九TOP_K问题/TopKTime2.java b/src/左神算法/高频面试题/九TOP_K问题/TopKTime2.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/九TOP_K问题/TopKTime2.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,149 +0,0 @@
-package 左神算法.高频面试题.九TOP_K问题;
-
-import java.util.HashMap;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:设计并实现TopKRecord结构，可以不断地向其中加入字符串，并且可以根据字符串出现的情况随时打印加入次数最多前K个字符串，具体为：
- * 1.k在TopKRecord实例生成时随机指定，并且不再变化（k是构造函数的参数）
- * 2.含有add(String str)方法，即向TopKRecord中加入字符串
- * 3.含有printTopK()方法，即打印加入次数最多的前k个字符串，打印有哪些字符串和对应的次数即可，不要求严格按排名顺序打印
- * 要求：
- * 在任何时刻，add方法的时间复杂度不超过O(logk)
- * 在任何时刻，printTopk方法的时间复杂度不超过o(k)
- * @date 2020/1/16 16:29
- */
-public class TopKTime2 {
-
-    public static class Node{
-        public String str;
-        public int times;
-
-        public Node(String str, int times) {
-            this.str = str;
-            this.times = times;
-        }
-    }
-
-    public static class TopKRecord{
-        public Node[] heap;
-        public int index;
-        public HashMap<String ,Node> strNodeMap;
-        public HashMap<Node,Integer> nodeIndexMap;
-
-        public TopKRecord(int size) {
-            heap=new Node[size];
-            index=0;
-            strNodeMap=new HashMap<>();
-            nodeIndexMap=new HashMap<>();
-        }
-
-        public void add(String str){
-            Node cur=null;
-            int preIndex=-1;//表示是否在堆中，如果不在堆中为-1，在堆中则是对应的下标
-            if(!strNodeMap.containsKey(str)){
-                cur=new Node(str,1);
-                strNodeMap.put(str,cur);
-                nodeIndexMap.put(cur,-1);
-            }else{
-                cur=strNodeMap.get(str);
-                cur.times++;
-                preIndex=nodeIndexMap.get(cur);
-            }
-            if(preIndex==-1){
-                if(index==heap.length){
-                    if(heap[0].times<cur.times){
-                        nodeIndexMap.put(heap[0],-1);
-                        nodeIndexMap.put(cur,0);
-                        heap[0]=cur;
-                        heapify(0,index);
-                    }
-                }else{
-                    heap[index]=cur;
-                    nodeIndexMap.put(cur,index);
-                    heapInsert(index++);
-                }
-            }else{
-                heapify(preIndex,index);
-            }
-        }
-
-        public void printTopK(){
-            System.out.println("Top: ");
-            for(int i=0;i<heap.length;i++){
-                if(heap[i]==null){
-                    break;
-                }
-                System.out.println("Str: "+heap[i].str);
-                System.out.println("Times: "+heap[i].times);
-            }
-        }
-
-        public void heapInsert(int index){
-            while(index!=0){
-                int parent=(index-1)/2;
-                if(heap[index].times<heap[parent].times){
-                    swap(heap,index,parent);
-                    index=parent;
-                }else {
-                    break;
-                }
-            }
-        }
-
-        public void swap(Node[] heap,int index1,int index2){
-            //交换位置的同时，也交换在堆中的位置
-            nodeIndexMap.put(heap[index1],index2);
-            nodeIndexMap.put(heap[index2],index1);
-            Node temp=heap[index1];
-            heap[index1]=heap[index2];
-            heap[index2]=temp;
-        }
-
-        public void heapify(int index,int heapsize){
-            int left=index*2+1;
-            while(left<heapsize){
-                int longest=(left+1<heapsize) && heap[left].times<heap[left+1].times ? left+1:left;
-                if(heap[longest].times<heap[index].times){
-                    swap(heap,longest,index);
-                }else {
-                    break;
-                }
-                index=longest;
-                left=index*2+1;
-            }
-        }
-    }
-
-    public static String[] generateRandomArray(int len, int max) {
-        String[] res = new String[len];
-        for (int i = 0; i != len; i++) {
-            res[i] = String.valueOf((int) (Math.random() * (max + 1)));
-        }
-        return res;
-    }
-
-    public static void printArray(String[] arr) {
-        for (int i = 0; i != arr.length; i++) {
-            System.out.print(arr[i] + " ");
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-        TopKRecord record = new TopKRecord(2);
-        record.add("zuo");
-        record.printTopK();
-        System.out.println("======");
-        record.add("cheng");
-        record.add("cheng");
-        record.printTopK();
-        System.out.println("0-----");
-        record.add("Yun");
-        record.add("Yun");
-        record.printTopK();
-
-    }
-
-}
Index: src/左神算法/基础班/图/TopologySort.java
===================================================================
diff --git a/src/左神算法/基础班/图/TopologySort.java b/src/左神算法/基础班/图/TopologySort.java
deleted file mode 100644
--- a/src/左神算法/基础班/图/TopologySort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,38 +0,0 @@
-package 左神算法.基础班.图;
-
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Queue;
-
-public class TopologySort {
-
-    public static List<Node> sortedTopology(Graph graph)
-    {
-        HashMap<Node ,Integer>inMap=new HashMap<>();//结点：结点的入度
-        Queue<Node> zeroInQueue=new LinkedList<>();
-        for(Node node:graph.nodes.values()){
-            inMap.put(node,node.in);
-            if(node.in==0)
-            {
-                zeroInQueue.add(node);
-            }
-        }
-        List<Node> result=new LinkedList<>();
-        while(!zeroInQueue.isEmpty())
-        {
-            Node cur=zeroInQueue.poll();//弹出入度为0的结点
-            result.add(cur);
-            for(Node node:cur.nexts)
-            {
-                inMap.put(node,inMap.get(node)-1);//弹出入度为零的结点后，将他的后序结点的入度全部减1，消除弹出结点的影响，
-                                                   //消除影响后，入度变为0的结点在此如队里
-                 if(inMap.get(node)==0)
-                {
-                    zeroInQueue.add(node);
-                }
-            }
-        }
-        return result;
-    }
-}
Index: src/Gof/Strategy/ToyDuck.java
===================================================================
diff --git a/src/Gof/Strategy/ToyDuck.java b/src/Gof/Strategy/ToyDuck.java
deleted file mode 100644
--- a/src/Gof/Strategy/ToyDuck.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,24 +0,0 @@
-package Gof.Strategy;
-
-import com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;
-
-public class ToyDuck extends Duck{
-
-    public ToyDuck(){
-        flyBehavior=new NoFlyBehavior();
-        quackBehavior=new NoQuackBehavior();
-    }
-
-    @Override
-    public void display() {
-        System.out.println("玩具鸭");
-    }
-
-    public void quack() {
-        System.out.println("玩具鸭不能叫~~");
-    }
-
-    public void swim() {
-        System.out.println("玩具鸭不会游泳~~");
-    }
-}
Index: src/Leetcode/TrieTree/Trie.java
===================================================================
diff --git a/src/Leetcode/TrieTree/Trie.java b/src/Leetcode/TrieTree/Trie.java
deleted file mode 100644
--- a/src/Leetcode/TrieTree/Trie.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,96 +0,0 @@
-package Leetcode.TrieTree;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。
-
-示例:
-
-Trie trie = new Trie();
-
-trie.insert("apple");
-trie.search("apple");   // 返回 true
-trie.search("app");     // 返回 false
-trie.startsWith("app"); // 返回 true
-trie.insert("app");
-trie.search("app");     // 返回 true
-说明:
-
-你可以假设所有的输入都是由小写字母 a-z 构成的。
-保证所有输入均为非空字符串。
-
-来源：力扣（LeetCode）
-链接：https://leetcode-cn.com/problems/implement-trie-prefix-tree
-著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
- * @date 2020/6/18 20:54
- */
-public class Trie {
-
-    private Node head;
-
-    class Node{
-        private Node[] children=new Node[26];
-        private boolean end;
-        public Node(){
-            this.end=false;
-        }
-    }
-
-
-    /** Initialize your data structure here. */
-    public Trie() {
-        this.head=new Node();
-    }
-
-    /** Inserts a word into the trie. */
-    public void insert(String word) {
-        int len=word.length();
-        Node cur=head;
-        for(char ch :word.toCharArray()){
-            if(cur.children[ch-'a']!=null){
-                cur=cur.children[ch-'a'];
-            }else{
-                cur.children[ch-'a']=new Node();
-                cur=cur.children[ch-'a'];
-            }
-        }
-        cur.end=true;
-    }
-
-    /** Returns if the word is in the trie. */
-    public boolean search(String word) {
-        Node cur=head;
-        for(char ch : word.toCharArray()){
-            if(cur.children[ch-'a']!=null){
-                cur=cur.children[ch-'a'];
-            }else
-                return false;
-        }
-        return cur.end==true ? true :false;
-    }
-
-    /** Returns if there is any word in the trie that starts with the given prefix. */
-    public boolean startsWith(String prefix) {
-        Node cur=head;
-        for(char ch :prefix.toCharArray()){
-            if(cur.children[ch-'a']!=null){
-                cur=cur.children[ch-'a'];
-            }else
-                return false;
-        }
-        return true;
-    }
-
-    public static void main(String[] args) {
-        Trie trie=new Trie();
-        trie.insert("apple");
-        trie.search("apple");   // 返回 true
-        trie.search("app");     // 返回 false
-        trie.startsWith("app"); // 返回 true
-        trie.insert("app");
-        trie.search("app");     // 返回 true
-
-
-    }
-}
Index: src/左神算法/基础班/图/TrieTree.java
===================================================================
diff --git a/src/左神算法/基础班/图/TrieTree.java b/src/左神算法/基础班/图/TrieTree.java
deleted file mode 100644
--- a/src/左神算法/基础班/图/TrieTree.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,125 +0,0 @@
-package 左神算法.基础班.图;
-
-public class TrieTree {
-
-    public static class TrieNode{
-        private int path;//有多少个字符串到达过这个结点
-        private int end;////有多少个字符串是以这个结点结尾的
-        private TrieNode[] map;//每个结点可以有的路的数目（即数组的长度），也可以通过HashMap<Char,TrieNode>来定义。
-        //这里为了简便使用了长度为26的数组，每条路必须是字母，数组的index表示路，map[index]!=null时，表示该条路的存在
-
-
-        public TrieNode(){
-            path=0;
-            end=0;
-            map=new TrieNode[26];
-        }
-    }
-
-    public static class Trie{
-        private TrieNode root;
-        public Trie(){
-            root=new TrieNode();
-        }
-
-        public void insert(String word){
-            if(word==null)
-            {
-                return;
-            }
-            char[] chs=word.toCharArray();
-            TrieNode node=root;
-            int index=0;
-            for(int i=0;i<chs.length;i++)
-            {
-                index=chs[i]-'a';
-                if(node.map[index]==null)
-                {
-                    node.map[index]=new TrieNode();
-                }
-                node=node.map[index];
-                node.path++;
-            }
-            node.end++;
-        }
-
-        public void delete(String word){
-            if(search(word)){
-                char[] chs=word.toCharArray();
-                int index=0;
-                TrieNode node=root;
-                for(int i=0;i<chs.length;i++)
-                {
-                    index=chs[i]-'a';
-                    if(node.map[index].path--==1)
-                    {
-                        node.map[index]=null;//置为null表示删除了。不在需要处理后序的结点了
-                        return;
-                    }
-                    node=node.map[index];
-                }
-                node.end--;
-            }
-        }
-
-        public boolean search(String word){
-            if(word==null)
-                return false;
-            char[] chs=word.toCharArray();
-            int index=0;
-            TrieNode node=root;
-            for(int i=0;i<chs.length;i++)
-            {
-                index=chs[i]-'a';
-                if(node.map[index]==null)
-                    return false;
-                node=node.map[index];
-            }
-            return node.end!=0;
-        }
-
-        public int prefixNumber(String pre)
-        {
-            if(pre==null)
-                return 0;
-            char[] chs=pre.toCharArray();
-            int index=0;
-            TrieNode node=root;
-            for(int i=0;i<chs.length;i++)
-            {
-                index=chs[i]-'a';
-                if(node.map[index]==null)
-                    return 0;
-                node=node.map[index];
-            }
-            return node.path;
-        }
-    }
-
-    public static void main(String[] args) {
-        Trie trie = new Trie();
-        System.out.println(trie.search("zuo"));
-        trie.insert("zuo");
-        System.out.println(trie.search("zuo"));
-        trie.delete("zuo");
-        System.out.println(trie.search("zuo"));
-        trie.insert("zuo");
-        trie.insert("zuo");
-        trie.delete("zuo");
-        System.out.println(trie.search("zuo"));
-        trie.delete("zuo");
-        System.out.println(trie.search("zuo"));
-        trie.insert("zuoa");
-        trie.insert("zuoac");
-        trie.insert("zuoab");
-        trie.insert("zuoad");
-        trie.delete("zuoa");
-        System.out.println(trie.search("zuoa"));
-        System.out.println(trie.prefixNumber("zuo"));
-
-
-    }
-
-
-
-}
Index: src/重温设计模式/行为模式/模版方法模式/示例/Twitter.java
===================================================================
diff --git a/src/重温设计模式/行为模式/模版方法模式/示例/Twitter.java b/src/重温设计模式/行为模式/模版方法模式/示例/Twitter.java
deleted file mode 100644
--- a/src/重温设计模式/行为模式/模版方法模式/示例/Twitter.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,57 +0,0 @@
-package 重温设计模式.行为模式.模版方法模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 与FaceBook 类一样，也是具体实现类
- * @date 2021/5/11 15:12
- */
-public class Twitter extends NetWork{
-    public Twitter(String userName, String password) {
-        this.userName = userName;
-        this.password = password;
-    }
-
-    @Override
-    public boolean logIn(String userName, String password) {
-        System.out.println("\nChecking user's parameters");
-        System.out.println("Name: " + this.userName);
-        System.out.print("Password: ");
-        for (int i = 0; i < this.password.length(); i++) {
-            System.out.print("*");
-        }
-        simulateNetworkLatency();
-        System.out.println("\n\nLogIn success on Twitter");
-        return true;
-    }
-
-    @Override
-    public boolean sendData(byte[] data) {
-        boolean messagePosted = true;
-        if (messagePosted) {
-            System.out.println("Message: '" + new String(data) + "' was posted on Twitter");
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    @Override
-    public void logOut() {
-        System.out.println("User: '" + userName + "' was logged out from Twitter");
-    }
-
-    private void simulateNetworkLatency() {
-        try {
-            int i = 0;
-            System.out.println();
-            while (i < 10) {
-                System.out.print(".");
-                Thread.sleep(500);
-                i++;
-            }
-        } catch (InterruptedException ex) {
-            ex.printStackTrace();
-        }
-    }
-}
Index: src/左神算法/基础班/第三课/TwoListCommons.java
===================================================================
diff --git a/src/左神算法/基础班/第三课/TwoListCommons.java b/src/左神算法/基础班/第三课/TwoListCommons.java
deleted file mode 100644
--- a/src/左神算法/基础班/第三课/TwoListCommons.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,59 +0,0 @@
-package 左神算法.基础班.第三课;
-
-public class TwoListCommons {
-
-    public static class Node {
-        public int value;
-        public Node next;
-        public Node(int data) {
-            this.value = data;
-        }
-    }
-
-    //分别从头开始遍历两个链表，
-    public static void printCommonPart(Node head1,Node head2)
-    {
-        while(head1!=null && head2!=null)
-        {
-            if(head1.value==head2.value){
-                System.out.print(head1.value+"\t");
-                head1=head1.next;
-                head2=head2.next;
-
-            }
-            else if(head1.value<head2.value)
-            {
-                head1=head1.next;
-            }else{
-                head2=head2.next;
-            }
-        }
-    }
-
-    public static void printLinkedList(Node node) {
-        System.out.print("Linked List: ");
-        while (node != null) {
-            System.out.print(node.value + " ");
-            node = node.next;
-        }
-        System.out.println();
-    }
-
-    public static void main(String[] args) {
-        Node node1 = new Node(2);
-        node1.next = new Node(3);
-        node1.next.next = new Node(5);
-        node1.next.next.next = new Node(6);
-
-        Node node2 = new Node(1);
-        node2.next = new Node(2);
-        node2.next.next = new Node(5);
-        node2.next.next.next = new Node(7);
-        node2.next.next.next.next = new Node(8);
-
-        printLinkedList(node1);
-        printLinkedList(node2);
-        printCommonPart(node1, node2);
-
-    }
-}
Index: src/左神算法/高频面试题/数组问题/TwoSubArrayMaxSum.java
===================================================================
diff --git a/src/左神算法/高频面试题/数组问题/TwoSubArrayMaxSum.java b/src/左神算法/高频面试题/数组问题/TwoSubArrayMaxSum.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/数组问题/TwoSubArrayMaxSum.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,119 +0,0 @@
-package 左神算法.高频面试题.数组问题;
-
-import java.util.Arrays;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * 给定一个数组，长度大于2，找出不想交的两个子数组，情况有很多的。请返回这么多情况中，两个不相交子数组最大的和。
- * 例如：-1,3,4，-9,1,2最大的和为[3,4]与[1,2]的和10
- * @date 2020/1/3 10:12
- */
-public class TwoSubArrayMaxSum {
-
-    public static int twoSubArrayMaxSum(int[] arr){
-        if(arr==null || arr.length<2)//注意根据题意，这里要小于2
-            return 0;
-        int[] left=new int[arr.length];//记录数组中每个位置左边形成的数组的最大子数组的和
-        int[] right=new int[arr.length];//记录数组中每个位置右边形成的数组的最大子数组的和
-        int max=Integer.MIN_VALUE;
-        int cur=0;
-        for(int i=0;i<arr.length;i++){
-            cur+=arr[i];
-            max=Math.max(max,cur);
-            left[i]=max;
-            cur=cur>0 ? cur:0;
-        }
-        cur=0;
-        max=Integer.MIN_VALUE;
-        for(int i=arr.length-1;i>-1;i--){
-            cur+=arr[i];
-            max=Math.max(cur,max);
-            right[i]=max;
-            cur=cur>0 ? cur:0;
-        }
-        int res=Integer.MIN_VALUE;
-        for(int i=0;i<arr.length-1;i++){
-            res=Math.max(res,left[i]+right[i+1]);
-        }
-        return res;
-    }
-
-
-    // for test
-    public static int rightAnswer(int[] arr) {
-        if (arr == null || arr.length < 2) {
-            return 0;
-        }
-        int res = Integer.MIN_VALUE;
-        for (int p = 0; p < arr.length - 1; p++) {
-            res = Math.max(res, maxSum(arr, 0, p) + maxSum(arr, p + 1, arr.length - 1));
-        }
-        return res;
-    }
-
-    // for test
-    public static int maxSum(int[] arr, int l, int r) {
-        int max = Integer.MIN_VALUE;
-        int cur = 0;
-        for (int i = l; i <= r; i++) {
-            cur += arr[i];
-            max = Math.max(max, cur);
-            cur = cur < 0 ? 0 : cur;
-        }
-        return max;
-    }
-    public static int twoSubArrayMaxSum2(int[] arr) {
-        if (arr == null || arr.length < 2) {
-            return 0;
-        }
-        int[] rArray = new int[arr.length];
-        int max = Integer.MIN_VALUE;
-        int cur = 0;
-        for (int i = arr.length - 1; i > 0; i--) {
-            cur += arr[i];
-            max = Math.max(max, cur);
-            rArray[i] = max;
-            cur = cur < 0 ? 0 : cur;
-        }
-        int res = Integer.MIN_VALUE;
-        max = Integer.MIN_VALUE;
-        cur = 0;
-        for (int i = 0; i < arr.length - 1; i++) {
-            cur += arr[i];
-            max = Math.max(max, cur);
-            res = Math.max(res, max + rArray[i + 1]);
-            cur = cur < 0 ? 0 : cur;
-        }
-        return res;
-    }
-
-    // for test
-    public static int[] generateRandomArray() {
-        int[] res = new int[(int) (Math.random() * 10) + 1];
-        for (int i = 0; i < res.length; i++) {
-            res[i] = (int) (Math.random() * 20) - 10;
-        }
-        return res;
-    }
-
-    // for test
-    public static void main(String[] args) {
-        int testTime = 5000000;
-        boolean hasErr = false;
-        for (int i = 0; i < testTime; i++) {
-            int[] test = generateRandomArray();
-            if (twoSubArrayMaxSum(test) != rightAnswer(test)) {
-                hasErr = true;
-                System.out.println(Arrays.toString(test));
-            }
-        }
-        if (hasErr) {
-            System.out.println("23333333");
-        } else {
-            System.out.println("66666666");
-        }
-
-    }
-}
Index: src/左神算法/高频面试题/十一/UglyNumber.java
===================================================================
diff --git a/src/左神算法/高频面试题/十一/UglyNumber.java b/src/左神算法/高频面试题/十一/UglyNumber.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/十一/UglyNumber.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,53 +0,0 @@
-package 左神算法.高频面试题.十一;
-
-/**
- * 把只包含因子2,3,5的数称为丑数。例如；6、8都是丑数，但14不是，因为他包含因子7.习惯上我们把1当作第一个丑数
- * 求从小到大的顺序的第n个丑数。
- */
-public class UglyNumber {
-
-    public static int uglyNumber1(int n){
-        int count=0;
-        int num=0;
-        while(count<n){
-            ++num;
-            if(isUgly(num))
-                count++;
-        }
-        return num;
-    }
-    public static boolean isUgly(int num){
-        while(num%2==0)
-            num/=2;
-        while(num%3==0)
-            num/=3;
-        while(num%5==0)
-            num/=5;
-        return num==1 ? true:false;
-    }
-   public static int uglyNumber2(int num){
-      int[] help=new int[num];
-      help[0]=1;
-      int i2=0;
-      int i3=0;
-      int i5=0;
-      int index=1;
-      while(index<num){
-          help[index]=Math.min(2*help[i2],Math.min(3*help[i3],5*help[i5]));
-          if(help[index]==2*help[i2])
-              i2++;
-          if(help[index]==3*help[i3])
-              i3++;
-          if(help[index]==help[i5]*5)
-              i5++;
-          index++;
-      }
-      return help[index-1];
-   }
-
-    public static void main(String[] args) {
-        int test = 1000;
-        System.out.println(uglyNumber1(test));
-        System.out.println(uglyNumber2(test));
-    }
-}
Index: .idea/uiDesigner.xml
===================================================================
diff --git a/.idea/uiDesigner.xml b/.idea/uiDesigner.xml
deleted file mode 100644
--- a/.idea/uiDesigner.xml	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,124 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="Palette2">
-    <group name="Swing">
-      <item class="com.intellij.uiDesigner.HSpacer" tooltip-text="Horizontal Spacer" icon="/com/intellij/uiDesigner/icons/hspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="1" hsize-policy="6" anchor="0" fill="1" />
-      </item>
-      <item class="com.intellij.uiDesigner.VSpacer" tooltip-text="Vertical Spacer" icon="/com/intellij/uiDesigner/icons/vspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="1" anchor="0" fill="2" />
-      </item>
-      <item class="javax.swing.JPanel" icon="/com/intellij/uiDesigner/icons/panel.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3" />
-      </item>
-      <item class="javax.swing.JScrollPane" icon="/com/intellij/uiDesigner/icons/scrollPane.png" removable="false" auto-create-binding="false" can-attach-label="true">
-        <default-constraints vsize-policy="7" hsize-policy="7" anchor="0" fill="3" />
-      </item>
-      <item class="javax.swing.JButton" icon="/com/intellij/uiDesigner/icons/button.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="3" anchor="0" fill="1" />
-        <initial-values>
-          <property name="text" value="Button" />
-        </initial-values>
-      </item>
-      <item class="javax.swing.JRadioButton" icon="/com/intellij/uiDesigner/icons/radioButton.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
-        <initial-values>
-          <property name="text" value="RadioButton" />
-        </initial-values>
-      </item>
-      <item class="javax.swing.JCheckBox" icon="/com/intellij/uiDesigner/icons/checkBox.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
-        <initial-values>
-          <property name="text" value="CheckBox" />
-        </initial-values>
-      </item>
-      <item class="javax.swing.JLabel" icon="/com/intellij/uiDesigner/icons/label.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="0" anchor="8" fill="0" />
-        <initial-values>
-          <property name="text" value="Label" />
-        </initial-values>
-      </item>
-      <item class="javax.swing.JTextField" icon="/com/intellij/uiDesigner/icons/textField.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
-          <preferred-size width="150" height="-1" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JPasswordField" icon="/com/intellij/uiDesigner/icons/passwordField.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
-          <preferred-size width="150" height="-1" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JFormattedTextField" icon="/com/intellij/uiDesigner/icons/formattedTextField.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
-          <preferred-size width="150" height="-1" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JTextArea" icon="/com/intellij/uiDesigner/icons/textArea.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JTextPane" icon="/com/intellij/uiDesigner/icons/textPane.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JEditorPane" icon="/com/intellij/uiDesigner/icons/editorPane.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JComboBox" icon="/com/intellij/uiDesigner/icons/comboBox.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="0" hsize-policy="2" anchor="8" fill="1" />
-      </item>
-      <item class="javax.swing.JTable" icon="/com/intellij/uiDesigner/icons/table.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JList" icon="/com/intellij/uiDesigner/icons/list.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="2" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JTree" icon="/com/intellij/uiDesigner/icons/tree.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JTabbedPane" icon="/com/intellij/uiDesigner/icons/tabbedPane.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
-          <preferred-size width="200" height="200" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JSplitPane" icon="/com/intellij/uiDesigner/icons/splitPane.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
-          <preferred-size width="200" height="200" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JSpinner" icon="/com/intellij/uiDesigner/icons/spinner.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
-      </item>
-      <item class="javax.swing.JSlider" icon="/com/intellij/uiDesigner/icons/slider.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
-      </item>
-      <item class="javax.swing.JSeparator" icon="/com/intellij/uiDesigner/icons/separator.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3" />
-      </item>
-      <item class="javax.swing.JProgressBar" icon="/com/intellij/uiDesigner/icons/progressbar.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1" />
-      </item>
-      <item class="javax.swing.JToolBar" icon="/com/intellij/uiDesigner/icons/toolbar.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1">
-          <preferred-size width="-1" height="20" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JToolBar$Separator" icon="/com/intellij/uiDesigner/icons/toolbarSeparator.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="0" anchor="0" fill="1" />
-      </item>
-      <item class="javax.swing.JScrollBar" icon="/com/intellij/uiDesigner/icons/scrollbar.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="0" anchor="0" fill="2" />
-      </item>
-    </group>
-  </component>
-</project>
\ No newline at end of file
Index: src/左神算法/基础班/并查集/UnionFind.java
===================================================================
diff --git a/src/左神算法/基础班/并查集/UnionFind.java b/src/左神算法/基础班/并查集/UnionFind.java
deleted file mode 100644
--- a/src/左神算法/基础班/并查集/UnionFind.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,101 +0,0 @@
-package 左神算法.基础班.并查集;
-
-import java.util.HashMap;
-import java.util.List;
-import java.util.Stack;
-
-//并查集
-public class UnionFind {
-
-    public static class Node{
-
-    }
-
-
-    public static class DisjoinSets{
-        private HashMap<Node,Node> fatherMap; //key:child,value:father
-        private HashMap<Node,Integer>rankMap;//只有当结点是代表结点的时候，value的值才有意义，
-                                           //当不是代表结点的时候不负责把value值更新成对的，保持原来的值即可,此时这个值已经不起作用了，不是代表结点的value值不再使用。
-        public DisjoinSets(){
-            this.fatherMap=new HashMap<>();
-            this.rankMap=new HashMap<>();
-        }
-
-           //用并查集进程操作，开始的时候，每一个元素各自成一个集合
-        public void makeSets(List<Node> nodes)
-        {
-            fatherMap.clear();
-            rankMap.clear();
-            for(Node node:nodes)
-            {
-                fatherMap.put(node,node);
-                rankMap.put(node,1);
-            }
-        }
-        //长的树变成扁平的树，即：将查询过程中的相关结点直接挂在他的父结点下
-        public  Node findFather(Node n)
-        {
-            Node father=fatherMap.get(n);
-            if(father!=n)
-            {
-                father=findFather(father);
-                // TODO 在更改父节点的同时根据不同的题目内容考虑是否要更改当前节点到父节点的权重，见LeetCode 399
-            }
-            fatherMap.put(n,father);
-            return father;
-        }
-        //非递归实现，-----》递归改为非递归的时候，通常需要借助栈这个结构来保存现场
-        public Node fatherFindUnRec(Node n)
-        {
-            Stack<Node>stack=new Stack<>();
-            Node cur=n;
-            Node father=fatherMap.get(cur);
-            while(father!=cur)
-            {
-                stack.push(cur);
-                cur=father;
-                father=fatherMap.get(cur);
-            }
-            while(!stack.isEmpty())
-            {
-                fatherMap.put(stack.pop(),father);
-            }
-            return father;
-
-        }
-
-        //判断是否是同一个集合
-        public  boolean isSameSet(Node a,Node b)
-        {
-            return findFather(a)==findFather(b);
-        }
-
-
-        //合并集合
-        public void union(Node a,Node b)
-        {
-            if(a==null||b==null)
-            {
-                return;
-            }
-            Node aFather=findFather(a);
-            Node bFather=findFather(b);
-            if(aFather!=bFather)
-            {
-                int aFrank=rankMap.get(a);
-                int bFrank=rankMap.get(b);
-                if(aFrank<=bFrank)
-                {
-                    fatherMap.put(aFather,bFather);
-                    rankMap.put(aFather,aFrank+bFrank);
-                }else {
-                    fatherMap.put(bFather, aFather);
-                    rankMap.put(aFather, aFrank + bFrank);
-                }
-            }
-        }
-
-
-
-    }
-}
Index: src/左神算法/基础班/第四课/UnionFind.java
===================================================================
diff --git a/src/左神算法/基础班/第四课/UnionFind.java b/src/左神算法/基础班/第四课/UnionFind.java
deleted file mode 100644
--- a/src/左神算法/基础班/第四课/UnionFind.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,98 +0,0 @@
-package 左神算法.基础班.第四课;
-
-import java.util.HashMap;
-import java.util.List;
-import java.util.Stack;
-
-//并查集
-public class UnionFind {
-
-    public static class Node{
-
-    }
-    public static class DisjoinSets{
-        private HashMap<Node,Node> fatherMap; //key:child,value:father
-        private HashMap<Node,Integer>rankMap;//只有当结点是代表结点的时候，value的值才有意义，
-                                           //当不是代表结点的时候不负责把value值更新成对的，保持原来的值即可,此时这个值已经不起作用了，不是代表结点的value值不再使用。
-        public DisjoinSets(){
-            this.fatherMap=new HashMap<>();
-            this.rankMap=new HashMap<>();
-        }
-
-           //用并查集进程操作，开始的时候，每一个元素各自成一个集合
-        public void makeSets(List<Node> nodes)
-        {
-            fatherMap.clear();
-            rankMap.clear();
-            for(Node node:nodes)
-            {
-                fatherMap.put(node,node);
-                rankMap.put(node,1);
-            }
-        }
-        //长的树变成扁平的树，即：将查询过程中的相关结点直接挂在他的父结点下
-        public  Node findFather(Node n)
-        {
-            Node father=fatherMap.get(n);
-            if(father!=n)
-            {
-                father=findFather(father);
-            }
-            fatherMap.put(n,father);
-            return father;
-        }
-        //非递归实现，-----》递归改为非递归的时候，通常需要借助栈这个结构来保存现场
-        public Node fatherFindUnRec(Node n)
-        {
-            Stack<Node>stack=new Stack<>();
-            Node cur=n;
-            Node father=fatherMap.get(cur);
-            while(father!=cur)
-            {
-                stack.push(cur);
-                cur=father;
-                father=fatherMap.get(cur);
-            }
-            while(!stack.isEmpty())
-            {
-                fatherMap.put(stack.pop(),father);
-            }
-            return father;
-
-        }
-
-        //判断是否是同一个集合
-        public  boolean isSameSet(Node a,Node b)
-        {
-            return findFather(a)==findFather(b);
-        }
-
-
-        //合并集合
-        public void union(Node a,Node b)
-        {
-            if(a==null||b==null)
-            {
-                return;
-            }
-            Node aFather=findFather(a);
-            Node bFather=findFather(b);
-            if(aFather!=bFather)
-            {
-                int aFrank=rankMap.get(a);
-                int bFrank=rankMap.get(b);
-                if(aFrank<=bFrank)
-                {
-                    fatherMap.put(aFather,bFather);
-                    rankMap.put(aFather,aFrank+bFrank);
-                }else {
-                    fatherMap.put(bFather, aFather);
-                    rankMap.put(aFather, aFrank + bFrank);
-                }
-            }
-        }
-
-
-
-    }
-}
Index: src/左神算法/进阶班一/并查集/UnionFind.java
===================================================================
diff --git a/src/左神算法/进阶班一/并查集/UnionFind.java b/src/左神算法/进阶班一/并查集/UnionFind.java
deleted file mode 100644
--- a/src/左神算法/进阶班一/并查集/UnionFind.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,98 +0,0 @@
-package 左神算法.进阶班一.并查集;
-
-import java.util.HashMap;
-import java.util.List;
-import java.util.Stack;
-
-//并查集
-public class UnionFind {
-
-    public static class Node{
-
-    }
-    public static class DisjoinSets{
-        private HashMap<Node,Node> fatherMap; //key:child,value:father
-        private HashMap<Node,Integer>rankMap;//只有当结点是代表结点的时候，value的值才有意义，
-                                           //当不是代表结点的时候不负责把value值更新成对的，保持原来的值即可,此时这个值已经不起作用了，不是代表结点的value值不再使用。
-        public DisjoinSets(){
-            this.fatherMap=new HashMap<>();
-            this.rankMap=new HashMap<>();
-        }
-
-           //用并查集进程操作，开始的时候，每一个元素各自成一个集合
-        public void makeSets(List<Node> nodes)
-        {
-            fatherMap.clear();
-            rankMap.clear();
-            for(Node node:nodes)
-            {
-                fatherMap.put(node,node);
-                rankMap.put(node,1);
-            }
-        }
-        //长的树变成扁平的树，即：将查询过程中的相关结点直接挂在他的父结点下
-        public  Node findFather(Node n)
-        {
-            Node father=fatherMap.get(n);
-            if(father!=n)
-            {
-                father=findFather(father);
-            }
-            fatherMap.put(n,father);
-            return father;
-        }
-        //非递归实现，-----》递归改为非递归的时候，通常需要借助栈这个结构来保存现场
-        public Node fatherFindUnRec(Node n)
-        {
-            Stack<Node>stack=new Stack<>();
-            Node cur=n;
-            Node father=fatherMap.get(cur);
-            while(father!=cur)
-            {
-                stack.push(cur);
-                cur=father;
-                father=fatherMap.get(cur);
-            }
-            while(!stack.isEmpty())
-            {
-                fatherMap.put(stack.pop(),father);
-            }
-            return father;
-
-        }
-
-        //判断是否是同一个集合
-        public  boolean isSameSet(Node a,Node b)
-        {
-            return findFather(a)==findFather(b);
-        }
-
-
-        //合并集合
-        public void union(Node a,Node b)
-        {
-            if(a==null||b==null)
-            {
-                return;
-            }
-            Node aFather=findFather(a);
-            Node bFather=findFather(b);
-            if(aFather!=bFather)
-            {
-                int aFrank=rankMap.get(a);
-                int bFrank=rankMap.get(b);
-                if(aFrank<=bFrank)
-                {
-                    fatherMap.put(aFather,bFather);
-                    rankMap.put(aFather,aFrank+bFrank);
-                }else {
-                    fatherMap.put(bFather, aFather);
-                    rankMap.put(aFather, aFrank + bFrank);
-                }
-            }
-        }
-
-
-
-    }
-}
Index: src/Gof/composite/University.java
===================================================================
diff --git a/src/Gof/composite/University.java b/src/Gof/composite/University.java
deleted file mode 100644
--- a/src/Gof/composite/University.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,32 +0,0 @@
-package Gof.composite;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class University extends OrganizationComponent {
-
-    List<OrganizationComponent> organizationComponents=new ArrayList<>();
-
-    protected University(String name,String des)
-    {
-        super(name,des);
-    }
-
-    @Override
-    protected void add(OrganizationComponent organizationComponent) {
-        organizationComponents.add(organizationComponent);
-    }
-
-    @Override
-    protected void remove(OrganizationComponent organizationComponent) {
-        organizationComponents.remove(organizationComponent);
-    }
-
-    @Override
-    protected void print() {
-        for(OrganizationComponent organizationComponent:organizationComponents)
-        {
-            organizationComponent.print();
-        }
-    }
-}
Index: src/Gof/bridge/UpRightPhone.java
===================================================================
diff --git a/src/Gof/bridge/UpRightPhone.java b/src/Gof/bridge/UpRightPhone.java
deleted file mode 100644
--- a/src/Gof/bridge/UpRightPhone.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,24 +0,0 @@
-package Gof.bridge;
-
-public class UpRightPhone extends Phone {
-    //构造器
-    public UpRightPhone(Brand brand) {
-        super(brand);
-    }
-
-    public void open() {
-        super.open();
-        System.out.println(" 直立样式手机 ");
-    }
-
-    public void close() {
-        super.close();
-        System.out.println(" 直立样式手机 ");
-    }
-
-    public void call() {
-        super.call();
-        System.out.println(" 直立样式手机 ");
-    }
-
-}
Index: src/Gof/flyweight/User.java
===================================================================
diff --git a/src/Gof/flyweight/User.java b/src/Gof/flyweight/User.java
deleted file mode 100644
--- a/src/Gof/flyweight/User.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,17 +0,0 @@
-package Gof.flyweight;
-
-public class User {
-    private String name;
-
-    public User(String name) {
-        this.name = name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    public String getName() {
-        return name;
-    }
-}
Index: src/重温设计模式/行为模式/责任链模式/示例/UserExistsMiddleware.java
===================================================================
diff --git a/src/重温设计模式/行为模式/责任链模式/示例/UserExistsMiddleware.java b/src/重温设计模式/行为模式/责任链模式/示例/UserExistsMiddleware.java
deleted file mode 100644
--- a/src/重温设计模式/行为模式/责任链模式/示例/UserExistsMiddleware.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,29 +0,0 @@
-package 重温设计模式.行为模式.责任链模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/14 21:41
- */
-public class UserExistsMiddleware extends Middleware{
-
-    private Server server;
-
-    public UserExistsMiddleware(Server server){
-        this.server = server;
-    }
-
-    @Override
-    public boolean check(String email, String password) {
-        if(!server.hasEmail(email)){
-            System.out.println("This email is not registered!");
-            return false;
-        }
-        if(!server.isValidPassword(email,password)){
-            System.out.println("Wrong password!");
-            return false;
-        }
-        return checkNext(email,password);
-    }
-}
Index: src/Gof/responsibilityChain/ViceSchoolMasterApprover.java
===================================================================
diff --git a/src/Gof/responsibilityChain/ViceSchoolMasterApprover.java b/src/Gof/responsibilityChain/ViceSchoolMasterApprover.java
deleted file mode 100644
--- a/src/Gof/responsibilityChain/ViceSchoolMasterApprover.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,18 +0,0 @@
-package Gof.responsibilityChain;
-
-public class ViceSchoolMasterApprover extends Approver{
-    public ViceSchoolMasterApprover(String name) {
-        // TODO Auto-generated constructor stub
-        super(name);
-    }
-
-    @Override
-    public void processRequest(PurchaseRequest purchaseRequest) {
-        // TODO Auto-generated method stub
-        if(purchaseRequest.getPrice() < 10000 && purchaseRequest.getPrice() <= 30000) {
-            System.out.println(" 请求编号 id= " + purchaseRequest.getId() + " 被 " + this.name + " 处理");
-        }else {
-            approver.processRequest(purchaseRequest);
-        }
-    }
-}
Index: src/org/sd/exercise/volatileExercise/VolatileDemo.java
===================================================================
diff --git a/src/org/sd/exercise/volatileExercise/VolatileDemo.java b/src/org/sd/exercise/volatileExercise/VolatileDemo.java
deleted file mode 100644
--- a/src/org/sd/exercise/volatileExercise/VolatileDemo.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,30 +0,0 @@
-package org.sd.exercise.volatileExercise;
-
-
-import java.util.concurrent.TimeUnit;
-
-class MyData{
-    volatile  int number;
-    public void add()
-    {
-        this.number=33;
-    }
-}
-public class VolatileDemo {
-
-    public static void main(String[] args) {
-        MyData myData=new MyData();
-        new Thread(()->{
-            try{
-                TimeUnit.SECONDS.sleep(3);}catch (Exception e){
-                e.printStackTrace();
-            }
-            myData.add();
-            System.out.println(Thread.currentThread().getName()+" "+myData.number);
-        },"aaa").start();
-
-        while(myData.number==0){}
-
-        System.out.println(Thread.currentThread().getName()+" "+myData.number);
-    }
-}
Index: src/Gof/Adapter/Voltage220.java
===================================================================
diff --git a/src/Gof/Adapter/Voltage220.java b/src/Gof/Adapter/Voltage220.java
deleted file mode 100644
--- a/src/Gof/Adapter/Voltage220.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,11 +0,0 @@
-package Gof.Adapter;
-
-public class Voltage220 {
-
-    public int output220v()
-    {
-        int src=220;
-        System.out.println("电压="+src);
-        return src;
-    }
-}
Index: src/Gof/Adapter/VoltageAdapter.java
===================================================================
diff --git a/src/Gof/Adapter/VoltageAdapter.java b/src/Gof/Adapter/VoltageAdapter.java
deleted file mode 100644
--- a/src/Gof/Adapter/VoltageAdapter.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,26 +0,0 @@
-package Gof.Adapter;
-
-import javax.sound.midi.SoundbankResource;
-
-public class VoltageAdapter implements IVoltage5v {
-
-    private Voltage220 voltage220;
-
-    public VoltageAdapter(Voltage220 voltage220) {
-        this.voltage220 = voltage220;
-    }
-
-
-    @Override
-    public int output5v() {
-       int dst=0;
-       if(null!=voltage220)
-       {
-           int src=voltage220.output220v();
-           System.out.println("使用适配器对象进行适配：");
-           dst=src/44;
-           System.out.println("适配完成，输出电压为： "+dst);
-       }
-       return dst;
-    }
-}
Index: src/Gof/visitor/Wait.java
===================================================================
diff --git a/src/Gof/visitor/Wait.java b/src/Gof/visitor/Wait.java
deleted file mode 100644
--- a/src/Gof/visitor/Wait.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,14 +0,0 @@
-package Gof.visitor;
-
-public class Wait extends Action {
-    @Override
-    public void getManResult(Man man) {
-        System.out.println(" 男人给的评价该歌手待定 !");
-    }
-
-    @Override
-    public void getWomanResult(Woman woman) {
-        System.out.println(" 女人给的评价该歌手待定 !");
-
-    }
-}
Index: src/左神算法/高频面试题/数组问题/WaterProblem.java
===================================================================
diff --git a/src/左神算法/高频面试题/数组问题/WaterProblem.java b/src/左神算法/高频面试题/数组问题/WaterProblem.java
deleted file mode 100644
--- a/src/左神算法/高频面试题/数组问题/WaterProblem.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,137 +0,0 @@
-package 左神算法.高频面试题.数组问题;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:  如果把一个数组，每个位置的值代表一个高度，那么整个数组可以看做是一个直方图，如果把这个直方图当做容器的话，求这个容器能装多少水
- * @date 2020/1/2 10:45
- */
-public class WaterProblem {
-    //暴力解
-    public static int getWater0(int[] arr) {
-        if (arr == null || arr.length < 3) {
-            return 0;
-        }
-        int value = 0;
-        for (int i = 1; i < arr.length - 1; i++) {
-            int leftMax = 0;
-            int rightMax = 0;
-            for (int l = 0; l < i; l++) {
-                leftMax = Math.max(arr[l], leftMax);
-            }
-            for (int r = i + 1; r < arr.length; r++) {
-                rightMax = Math.max(arr[r], rightMax);
-            }
-            value += Math.max(0, Math.min(leftMax, rightMax) - arr[i]);
-        }
-        return value;
-    }
-    public static int getWater1(int[] arr) {
-        if (arr == null || arr.length < 3) {
-            return 0;
-        }
-        int n = arr.length - 2;
-        int[] leftMaxs = new int[n];
-        leftMaxs[0] = arr[0];
-        for (int i = 1; i < n; i++) {
-            leftMaxs[i] = Math.max(leftMaxs[i - 1], arr[i]);
-        }
-        int[] rightMaxs = new int[n];
-        rightMaxs[n - 1] = arr[n + 1];
-        for (int i = n - 2; i >= 0; i--) {
-            rightMaxs[i] = Math.max(rightMaxs[i + 1], arr[i + 2]);
-        }
-        int value = 0;
-        for (int i = 1; i <= n; i++) {
-            value += Math.max(0, Math.min(leftMaxs[i - 1], rightMaxs[i - 1]) - arr[i]);
-        }
-        return value;
-    }
-
-    //自己实现
-    public static int getWater2(int[] arr) {
-        if (arr == null || arr.length == 0)
-            return 0;
-        int max = 0;
-        int[] leftArr = new int[arr.length]; //记录原数组中每个元素左边的最大值
-        leftArr[0] = 0;
-        leftArr[1] = arr[0];
-        for (int i = 2; i < arr.length; i++) {
-            leftArr[i] = Math.max(leftArr[i - 1], arr[i - 1]);
-        }
-
-        int[] rightArr = new int[arr.length];//记录原数组中每个元素右边的最大值，只需要反着遍历数组即可。
-        rightArr[arr.length - 1] = 0;
-        rightArr[arr.length - 2] = arr[arr.length - 1];
-        for (int i = arr.length - 3; i >= 0; i--) {
-            rightArr[i] = Math.max(rightArr[i + 1], arr[i + 1]);
-        }
-
-        int res = 0;
-        for (int i = 1; i <= arr.length - 2; i++) {
-            res += Math.max(0, Math.min(leftArr[i], rightArr[i]) - arr[i]);
-        }
-        return res;
-    }
-
-    public static int getWater3(int[] arr) {
-        if (arr == null || arr.length < 3) {
-            return 0;
-        }
-        int n = arr.length - 2;
-        int[] rightMaxs = new int[n];
-        rightMaxs[n - 1] = arr[n + 1];
-        for (int i = n - 2; i >= 0; i--) {
-            rightMaxs[i] = Math.max(rightMaxs[i + 1], arr[i + 2]);
-        }
-        int leftMax = arr[0];
-        int value = 0;
-        for (int i = 1; i <= n; i++) {
-            value += Math.max(0, Math.min(leftMax, rightMaxs[i - 1]) - arr[i]);
-            leftMax = Math.max(leftMax, arr[i]);
-        }
-        return value;
-    }
-
-    //空间复杂度O（1），时间复杂度O(n）
-    public static int getWater4(int[] arr){
-        if(arr==null || arr.length==0)
-            return 0;
-        int maxL=arr[0];
-        int maxR=arr[arr.length-1];
-        int left=1;
-        int right=arr.length-2;
-        int max=0;
-        while(left<=right){
-            if(maxL<=maxR){
-                max+=Math.max(0,maxL-arr[left]);
-                maxL=Math.max(maxL,arr[left++]);
-            }else{
-                max+=Math.max(0,maxR-arr[right]);
-                maxR=Math.max(maxR,arr[right--]);
-            }
-        }
-        return max;
-
-    }
-
-    public static int[] generateRandomArray() {
-        int[] arr = new int[(int) (Math.random() * 4) + 2];
-        for (int i = 0; i < arr.length; i++) {
-            arr[i] = (int) (Math.random() * 10) + 2;
-        }
-        return arr;
-    }
-
-    public static void main(String[] args) {
-        for (int i = 0; i < 1000000; i++) {
-            int[] arr = generateRandomArray();
-            int r1 = getWater1(arr);
-            int r2 = getWater2(arr);
-            int r4=getWater4(arr);
-            if(r1!=r2 || r1!=r4)
-                System.out.println("What a fucking day! fuck that! man!");
-
-    }
-    }
-}
Index: src/Gof/flyweight/WebSite.java
===================================================================
diff --git a/src/Gof/flyweight/WebSite.java b/src/Gof/flyweight/WebSite.java
deleted file mode 100644
--- a/src/Gof/flyweight/WebSite.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,5 +0,0 @@
-package Gof.flyweight;
-
-public abstract class WebSite {
-    public abstract void use(User user);
-}
Index: src/Gof/flyweight/WebSiteFactory.java
===================================================================
diff --git a/src/Gof/flyweight/WebSiteFactory.java b/src/Gof/flyweight/WebSiteFactory.java
deleted file mode 100644
--- a/src/Gof/flyweight/WebSiteFactory.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,18 +0,0 @@
-package Gof.flyweight;
-
-import java.util.HashMap;
-import java.util.HashSet;
-
-public class WebSiteFactory {
-    private HashMap<String,ConcreteWebSite> pool=new HashMap<>();
-    public WebSite getWebSite(String type)
-    {
-        if(!pool.containsKey(type))
-            pool.put(type,new ConcreteWebSite(type));
-        return pool.get(type);
-    }
-    public int getWebSiteCount()
-    {
-        return pool.size();
-    }
-}
Index: src/Gof/observer/WetherData.java
===================================================================
diff --git a/src/Gof/observer/WetherData.java b/src/Gof/observer/WetherData.java
deleted file mode 100644
--- a/src/Gof/observer/WetherData.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,71 +0,0 @@
-package Gof.observer;
-
-import javax.security.auth.Subject;
-import java.util.ArrayList;
-import java.util.List;
-
-public class WetherData implements Gof.observer.Subject {
-
-    private float temperture;
-    private float pressure;
-    private float humidity;
-
-    public float getTemperture() {
-        return temperture;
-    }
-
-    public void setTemperture(float temperture) {
-        this.temperture = temperture;
-    }
-
-    public float getPressure() {
-        return pressure;
-    }
-
-    public void setPressure(float pressure) {
-        this.pressure = pressure;
-    }
-
-    public float getHumidity() {
-        return humidity;
-    }
-
-    public void setHumidity(float humidity) {
-        this.humidity = humidity;
-    }
-
-    List<Observer> observerList=new ArrayList<>();
-
-
-    public void dataChange()
-    {
-        notifyObservers();
-    }
-
-    @Override
-    public void registObserver(Observer o) {
-
-        observerList.add(o);
-    }
-
-    @Override
-    public void removeObserver(Observer o) {
-          if(observerList.contains(o))
-              observerList.remove(o);
-    }
-
-    @Override
-    public void notifyObservers() {
-       for(int i=0;i<observerList.size();i++)
-       {
-           observerList.get(i).update(this.temperture,this.pressure,this.humidity);
-       }
-    }
-
-    public void setData(float temperture,float pressure,float humidity){
-        this.temperture=temperture;
-        this.pressure=pressure;
-        this.humidity=humidity;
-        dataChange();
-    }
-}
Index: src/codeTop/wiggleSort.java
===================================================================
diff --git a/src/codeTop/wiggleSort.java b/src/codeTop/wiggleSort.java
deleted file mode 100644
--- a/src/codeTop/wiggleSort.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,40 +0,0 @@
-package codeTop;
-
-import java.util.ArrayList;
-
-/**
- * LeetCode 280
- * 给一个没有排序的数组，将其重新排序成nums[0] <= nums[1] >= nums[2] <= nums[3]....的样子，要求in-place。
- *
- * 示例
- * 输入: nums = [3,5,2,1,6,4]
- * 输出: 一个可能的解答是 [3,5,1,6,2,4]
- */
-public class wiggleSort {
-
-    public static void wiggleSort(int[] arr){
-        if(arr == null || arr.length < 2){
-            return;
-        }
-        int n = arr.length;
-        for(int i = 1;i < n;i++){
-            if((i % 2 == 0 && arr[i] > arr[i - 1]) || (i % 2 == 1 && arr[i] < arr[i - 1])){
-                int tmp = arr[i - 1];
-                arr[i - 1] = arr[i];
-                arr[i] = tmp;
-            }
-        }
-    }
-
-
-
-    public static void main(String[] args) {
-        int[] nums = new int[]{3,5,2,1,6,4};
-        wiggleSort(nums);
-        ArrayList<Integer> list = new ArrayList<>();
-        for(int num : nums){
-            list.add(num);
-        }
-        System.out.println(list.stream().mapToInt(Integer::intValue).sum());
-    }
-}
Index: src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/WindowButton.java
===================================================================
diff --git a/src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/WindowButton.java b/src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/WindowButton.java
deleted file mode 100644
--- a/src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/WindowButton.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,19 +0,0 @@
-package 重温设计模式.创建型模式.工厂模式.工厂方法模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/18 21:08
- */
-public class WindowButton implements Button{
-    @Override
-    public void render() {
-
-    }
-
-    @Override
-    public void onClick() {
-
-    }
-}
Index: src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/WindowDialog.java
===================================================================
diff --git a/src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/WindowDialog.java b/src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/WindowDialog.java
deleted file mode 100644
--- a/src/重温设计模式/创建型模式/工厂模式/工厂方法模式/示例/WindowDialog.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,14 +0,0 @@
-package 重温设计模式.创建型模式.工厂模式.工厂方法模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 具体创建者
- * @date 2021/5/18 21:12
- */
-public class WindowDialog extends Dialog {
-    @Override
-    Button createButton() {
-        return new WindowButton();
-    }
-}
Index: src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/WindowFactory.java
===================================================================
diff --git a/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/WindowFactory.java b/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/WindowFactory.java
deleted file mode 100644
--- a/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/WindowFactory.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,20 +0,0 @@
-package 重温设计模式.创建型模式.工厂模式.抽象工厂模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/19 17:04
- */
-public class WindowFactory implements GUIFactory {
-    @Override
-    public Button createButton() {
-        return new WindowsButton();
-    }
-
-    @Override
-    public CheckBox createCheckbox() {
-
-        return new WindowsCheckBox();
-    }
-}
Index: src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/WindowsButton.java
===================================================================
diff --git a/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/WindowsButton.java b/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/WindowsButton.java
deleted file mode 100644
--- a/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/WindowsButton.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,14 +0,0 @@
-package 重温设计模式.创建型模式.工厂模式.抽象工厂模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/19 16:59
- */
-public class WindowsButton implements Button {
-    @Override
-    public void paint() {
-        System.out.println("You have created WindowsButton.");
-    }
-}
Index: src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/WindowsCheckBox.java
===================================================================
diff --git a/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/WindowsCheckBox.java b/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/WindowsCheckBox.java
deleted file mode 100644
--- a/src/重温设计模式/创建型模式/工厂模式/抽象工厂模式/示例/WindowsCheckBox.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,14 +0,0 @@
-package 重温设计模式.创建型模式.工厂模式.抽象工厂模式.示例;
-
-/**
- * @author zbl
- * @version 1.0
- * @content:
- * @date 2021/5/19 17:01
- */
-public class WindowsCheckBox implements CheckBox{
-    @Override
-    public void paint() {
-        System.out.println("You have created WindowsCheckbox.");
-    }
-}
Index: src/Gof/visitor/Woman.java
===================================================================
diff --git a/src/Gof/visitor/Woman.java b/src/Gof/visitor/Woman.java
deleted file mode 100644
--- a/src/Gof/visitor/Woman.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,8 +0,0 @@
-package Gof.visitor;
-
-public class Woman extends Person{
-    @Override
-    public void accept(Action action) {
-        action.getWomanResult(this);
-    }
-}
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
deleted file mode 100644
--- a/.idea/workspace.xml	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,564 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="AutoImportSettings">
-    <option name="autoReloadType" value="ALL" />
-  </component>
-  <component name="ChangeListManager">
-    <list default="true" id="9b704386-6ca8-4871-b5f5-5ed74f278305" name="Default" comment="路径总和IV LeetCode666">
-      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/Test.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/Test.java" afterDir="false" />
-    </list>
-    <option name="SHOW_DIALOG" value="false" />
-    <option name="HIGHLIGHT_CONFLICTS" value="true" />
-    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
-    <option name="LAST_RESOLUTION" value="IGNORE" />
-  </component>
-  <component name="FileTemplateManagerImpl">
-    <option name="RECENT_TEMPLATES">
-      <list>
-        <option value="Interface" />
-        <option value="Class" />
-      </list>
-    </option>
-  </component>
-  <component name="Git.Settings">
-    <option name="UPDATE_TYPE" value="MERGE" />
-    <option name="ROOT_SYNC" value="DONT_SYNC" />
-    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
-  </component>
-  <component name="GitSEFilterConfiguration">
-    <file-type-list>
-      <filtered-out-file-type name="LOCAL_BRANCH" />
-      <filtered-out-file-type name="REMOTE_BRANCH" />
-      <filtered-out-file-type name="TAG" />
-      <filtered-out-file-type name="COMMIT_BY_MESSAGE" />
-    </file-type-list>
-  </component>
-  <component name="GithubDefaultAccount">
-    <option name="defaultAccountId" value="e129ef3d-d702-4d84-af59-67dedfa9a69f" />
-  </component>
-  <component name="HighlightingSettingsPerFile">
-    <setting file="file://$PROJECT_DIR$/src/codeTop/ByteDance1.java" root0="FORCE_HIGHLIGHTING" />
-    <setting file="jar://$PROJECT_DIR$/../../jkdk8/src.zip!/java/util/Stack.java" root0="FORCE_HIGHLIGHTING" />
-  </component>
-  <component name="InvalidFacetManager">
-    <ignored-facets>
-      <facet id="sourceResearch/invalid/Spring" />
-    </ignored-facets>
-  </component>
-  <component name="MarkdownSettingsMigration">
-    <option name="stateVersion" value="1" />
-  </component>
-  <component name="MavenImportPreferences">
-    <option name="generalSettings">
-      <MavenGeneralSettings>
-        <option name="localRepository" value="D:\Apache\maven_repository" />
-        <option name="mavenHome" value="$PROJECT_DIR$/../../Apache/maven" />
-        <option name="userSettingsFile" value="D:\Apache\maven\conf\settings.xml" />
-      </MavenGeneralSettings>
-    </option>
-  </component>
-  <component name="ProjectId" id="1uNkcgN4eobSROGlFNavFNfHpUH" />
-  <component name="ProjectViewState">
-    <option name="hideEmptyMiddlePackages" value="true" />
-    <option name="showLibraryContents" value="true" />
-  </component>
-  <component name="PropertiesComponent">
-    <property name="RunOnceActivity.OpenProjectViewOnStart" value="true" />
-    <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />
-    <property name="SearchEverywhereHistoryKey" value="Priority&#9;FILE&#9;jar://E:/jdk1.8/src.zip!/java/util/PriorityQueue.java&#10;String&#9;FILE&#9;jar://E:/jdk1.8/src.zip!/java/lang/String.java&#10;PriorityQ&#9;PSI&#9;JAVA://java.util.PriorityQueue&#10;Executors&#9;PSI&#9;JAVA://java.util.concurrent.Executors&#10;ApplicationContextA&#9;PSI&#9;JAVA://org.springframework.context.ApplicationContextAware&#10;Integer&#9;PSI&#9;JAVA://java.lang.Integer&#10;Arrays&#9;FILE&#9;jar://E:/jdk1.8/src.zip!/java/util/Arrays.java&#10;TreeSet&#9;PSI&#9;JAVA://java.util.TreeSet&#10;TreeMap&#9;PSI&#9;JAVA://java.util.TreeMap&#10;HashMap&#9;PSI&#9;JAVA://java.util.HashMap&#10;LinkedList&#9;PSI&#9;JAVA://java.util.LinkedList&#10;Map&#9;PSI&#9;JAVA://java.util.Map&#10;URL&#9;PSI&#9;JAVA://java.net.URL&#10;Thread&#9;PSI&#9;JAVA://JUC.Demo.ThreadDemo&#10;Class&#9;PSI&#9;JAVA://java.lang.Class&#10;List&#9;FILE&#9;jar://E:/jdk1.8/src.zip!/java/util/List.java&#10;ArrayList&#9;PSI&#9;JAVA://java.util.ArrayList&#10;Collections&#9;PSI&#9;JAVA://java.util.Collections" />
-    <property name="WebServerToolWindowFactoryState" value="false" />
-    <property name="aspect.path.notification.shown" value="true" />
-    <property name="last_opened_file_path" value="$PROJECT_DIR$/../rocketmq" />
-    <property name="project.structure.last.edited" value="Modules" />
-    <property name="project.structure.proportion" value="0.15323994" />
-    <property name="project.structure.side.proportion" value="0.40184757" />
-    <property name="settings.editor.selected.configurable" value="editor.preferences.tabs" />
-  </component>
-  <component name="ReaderModeSettings">
-    <option name="enabled" value="false" />
-  </component>
-  <component name="RecentsManager">
-    <key name="MoveFile.RECENT_KEYS">
-      <recent name="G:\Idea_work\dataSource\src\重温设计模式\行为模式\策略模式" />
-      <recent name="G:\Idea_work\dataSource\src\重温设计模式\行为模式\观察者模式" />
-      <recent name="G:\Idea_work\exerAlgorithm\src\重温设计模式\结构型设计模式\代理模式" />
-    </key>
-  </component>
-  <component name="RunManager" selected="Application.LeetCode666">
-    <configuration default="true" type="Applet" factoryName="Applet">
-      <option name="HTML_USED" value="false" />
-      <option name="WIDTH" value="400" />
-      <option name="HEIGHT" value="300" />
-      <option name="POLICY_FILE" value="$APPLICATION_HOME_DIR$/bin/appletviewer.policy" />
-      <module />
-    </configuration>
-    <configuration name="LeetCode152" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
-      <option name="MAIN_CLASS_NAME" value="LeetCodeHot100.LeetCode152" />
-      <module name="exercise2" />
-      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
-      <extension name="coverage">
-        <pattern>
-          <option name="PATTERN" value="LeetCodeHot100.*" />
-          <option name="ENABLED" value="true" />
-        </pattern>
-      </extension>
-      <method v="2">
-        <option name="Make" enabled="true" />
-      </method>
-    </configuration>
-    <configuration name="LeetCode305" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
-      <option name="MAIN_CLASS_NAME" value="codeTop.hard.LeetCode305" />
-      <module name="exercise2" />
-      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
-      <extension name="coverage">
-        <pattern>
-          <option name="PATTERN" value="codeTop.hard.*" />
-          <option name="ENABLED" value="true" />
-        </pattern>
-      </extension>
-      <method v="2">
-        <option name="Make" enabled="true" />
-      </method>
-    </configuration>
-    <configuration name="LeetCode666" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
-      <option name="MAIN_CLASS_NAME" value="LeetCodeHot100.LeetCode666" />
-      <module name="exercise2" />
-      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
-      <extension name="coverage">
-        <pattern>
-          <option name="PATTERN" value="LeetCodeHot100.*" />
-          <option name="ENABLED" value="true" />
-        </pattern>
-      </extension>
-      <method v="2">
-        <option name="Make" enabled="true" />
-      </method>
-    </configuration>
-    <configuration name="QuickMulti" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
-      <option name="MAIN_CLASS_NAME" value="codeTop.QuickMulti" />
-      <module name="exercise2" />
-      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
-      <extension name="coverage">
-        <pattern>
-          <option name="PATTERN" value="codeTop.*" />
-          <option name="ENABLED" value="true" />
-        </pattern>
-      </extension>
-      <method v="2">
-        <option name="Make" enabled="true" />
-      </method>
-    </configuration>
-    <configuration name="Test" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
-      <option name="MAIN_CLASS_NAME" value="Test" />
-      <module name="exercise2" />
-      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
-      <method v="2">
-        <option name="Make" enabled="true" />
-      </method>
-    </configuration>
-    <configuration default="true" type="Application" factoryName="Application">
-      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
-      <method v="2">
-        <option name="Make" enabled="true" />
-      </method>
-    </configuration>
-    <configuration default="true" type="JUnit" factoryName="JUnit">
-      <option name="TEST_OBJECT" value="class" />
-      <option name="WORKING_DIRECTORY" value="%MODULE_WORKING_DIR%" />
-      <method v="2">
-        <option name="Make" enabled="true" />
-      </method>
-    </configuration>
-    <configuration default="true" type="TestNG">
-      <option name="TEST_OBJECT" value="CLASS" />
-      <option name="WORKING_DIRECTORY" value="%MODULE_WORKING_DIR%" />
-      <properties />
-      <listeners />
-      <method v="2">
-        <option name="Make" enabled="true" />
-      </method>
-    </configuration>
-    <configuration default="true" type="#org.jetbrains.idea.devkit.run.PluginConfigurationType">
-      <module name="" />
-      <option name="VM_PARAMETERS" value="-Xmx512m -Xms256m -XX:MaxPermSize=250m -ea" />
-      <option name="PROGRAM_PARAMETERS" />
-      <predefined_log_file enabled="true" id="idea.log" />
-      <method v="2">
-        <option name="Make" enabled="true" />
-      </method>
-    </configuration>
-    <list>
-      <item itemvalue="Application.LeetCode305" />
-      <item itemvalue="Application.QuickMulti" />
-      <item itemvalue="Application.Test" />
-      <item itemvalue="Application.LeetCode152" />
-      <item itemvalue="Application.LeetCode666" />
-    </list>
-    <recent_temporary>
-      <list>
-        <item itemvalue="Application.LeetCode666" />
-        <item itemvalue="Application.Test" />
-        <item itemvalue="Application.LeetCode152" />
-        <item itemvalue="Application.QuickMulti" />
-        <item itemvalue="Application.LeetCode305" />
-      </list>
-    </recent_temporary>
-  </component>
-  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="project-level" UseSingleDictionary="true" transferred="true" />
-  <component name="SvnConfiguration">
-    <configuration />
-  </component>
-  <component name="TaskManager">
-    <task active="true" id="Default" summary="Default task">
-      <changelist id="9b704386-6ca8-4871-b5f5-5ed74f278305" name="Default" comment="" />
-      <created>1606035842856</created>
-      <option name="number" value="Default" />
-      <option name="presentableId" value="Default" />
-      <updated>1606035842856</updated>
-      <workItem from="1606035844059" duration="8988000" />
-      <workItem from="1606296209940" duration="640000" />
-      <workItem from="1606481621760" duration="2787000" />
-      <workItem from="1606710571096" duration="3359000" />
-      <workItem from="1607156439823" duration="1992000" />
-      <workItem from="1607165640846" duration="142000" />
-      <workItem from="1607400091653" duration="4348000" />
-      <workItem from="1607685001038" duration="1896000" />
-      <workItem from="1607847497392" duration="806000" />
-      <workItem from="1608006295336" duration="1254000" />
-      <workItem from="1608037005234" duration="313000" />
-      <workItem from="1608100944886" duration="1400000" />
-      <workItem from="1608465566133" duration="1088000" />
-      <workItem from="1609475025232" duration="1827000" />
-      <workItem from="1609477015774" duration="48000" />
-      <workItem from="1609917068983" duration="68000" />
-      <workItem from="1611985913449" duration="24000" />
-      <workItem from="1613963751519" duration="8000" />
-      <workItem from="1615105302129" duration="9000" />
-      <workItem from="1615611641743" duration="138000" />
-      <workItem from="1616249574590" duration="662000" />
-      <workItem from="1616302575744" duration="1395000" />
-      <workItem from="1616330950551" duration="11000" />
-      <workItem from="1616744667493" duration="11697000" />
-      <workItem from="1616921893740" duration="3778000" />
-      <workItem from="1617278910124" duration="1318000" />
-      <workItem from="1617280276344" duration="44000" />
-      <workItem from="1617280482881" duration="256000" />
-      <workItem from="1617280880652" duration="16000" />
-      <workItem from="1617371248940" duration="2290000" />
-      <workItem from="1617510695896" duration="1271000" />
-      <workItem from="1617768489634" duration="980000" />
-      <workItem from="1617772011839" duration="39000" />
-      <workItem from="1617772074997" duration="1256000" />
-      <workItem from="1618205876657" duration="77000" />
-      <workItem from="1618636079034" duration="170000" />
-      <workItem from="1618637888248" duration="117000" />
-      <workItem from="1619095504468" duration="163000" />
-      <workItem from="1619172589923" duration="1428000" />
-      <workItem from="1619413781226" duration="1814000" />
-      <workItem from="1619441989680" duration="1191000" />
-      <workItem from="1619674304905" duration="14020000" />
-      <workItem from="1620138344470" duration="147000" />
-      <workItem from="1620138532359" duration="18030000" />
-      <workItem from="1620545746877" duration="2494000" />
-      <workItem from="1620548997447" duration="3814000" />
-      <workItem from="1620553799428" duration="4654000" />
-      <workItem from="1620815667186" duration="18211000" />
-      <workItem from="1621001352273" duration="579000" />
-      <workItem from="1621001984929" duration="37194000" />
-      <workItem from="1621509036139" duration="187000" />
-      <workItem from="1622885644737" duration="612000" />
-      <workItem from="1623316934379" duration="53000" />
-      <workItem from="1624337804760" duration="247000" />
-      <workItem from="1624513518579" duration="412000" />
-      <workItem from="1624513946488" duration="140000" />
-      <workItem from="1624795572174" duration="21000" />
-      <workItem from="1624795872983" duration="652000" />
-    </task>
-    <task id="LOCAL-00001" summary="2020.12.08">
-      <created>1607401717380</created>
-      <option name="number" value="00001" />
-      <option name="presentableId" value="LOCAL-00001" />
-      <option name="project" value="LOCAL" />
-      <updated>1607401717380</updated>
-    </task>
-    <task id="LOCAL-00002" summary="2020.12.08">
-      <created>1607403477268</created>
-      <option name="number" value="00002" />
-      <option name="presentableId" value="LOCAL-00002" />
-      <option name="project" value="LOCAL" />
-      <updated>1607403477268</updated>
-    </task>
-    <task id="LOCAL-00003" summary="2020.12.20">
-      <created>1608465626326</created>
-      <option name="number" value="00003" />
-      <option name="presentableId" value="LOCAL-00003" />
-      <option name="project" value="LOCAL" />
-      <updated>1608465626326</updated>
-    </task>
-    <task id="LOCAL-00004" summary="2021.4.1">
-      <created>1617278973144</created>
-      <option name="number" value="00004" />
-      <option name="presentableId" value="LOCAL-00004" />
-      <option name="project" value="LOCAL" />
-      <updated>1617278973144</updated>
-    </task>
-    <task id="LOCAL-00005" summary="2021.4.1">
-      <created>1617279804673</created>
-      <option name="number" value="00005" />
-      <option name="presentableId" value="LOCAL-00005" />
-      <option name="project" value="LOCAL" />
-      <updated>1617279804673</updated>
-    </task>
-    <task id="LOCAL-00006" summary="2021.4.1">
-      <created>1617280314936</created>
-      <option name="number" value="00006" />
-      <option name="presentableId" value="LOCAL-00006" />
-      <option name="project" value="LOCAL" />
-      <updated>1617280314936</updated>
-    </task>
-    <task id="LOCAL-00007" summary="2021.4.1">
-      <created>1617280506785</created>
-      <option name="number" value="00007" />
-      <option name="presentableId" value="LOCAL-00007" />
-      <option name="project" value="LOCAL" />
-      <updated>1617280506785</updated>
-    </task>
-    <task id="LOCAL-00008" summary="2021.4.1">
-      <created>1617280692227</created>
-      <option name="number" value="00008" />
-      <option name="presentableId" value="LOCAL-00008" />
-      <option name="project" value="LOCAL" />
-      <updated>1617280692227</updated>
-    </task>
-    <task id="LOCAL-00009" summary="2021.5.4">
-      <created>1620138397969</created>
-      <option name="number" value="00009" />
-      <option name="presentableId" value="LOCAL-00009" />
-      <option name="project" value="LOCAL" />
-      <updated>1620138397970</updated>
-    </task>
-    <task id="LOCAL-00010" summary="2021.5.14">
-      <created>1621001171852</created>
-      <option name="number" value="00010" />
-      <option name="presentableId" value="LOCAL-00010" />
-      <option name="project" value="LOCAL" />
-      <updated>1621001171853</updated>
-    </task>
-    <task id="LOCAL-00011" summary="2021.5.14">
-      <created>1621001244534</created>
-      <option name="number" value="00011" />
-      <option name="presentableId" value="LOCAL-00011" />
-      <option name="project" value="LOCAL" />
-      <updated>1621001244534</updated>
-    </task>
-    <task id="LOCAL-00012" summary="2021.5.14">
-      <created>1621001294417</created>
-      <option name="number" value="00012" />
-      <option name="presentableId" value="LOCAL-00012" />
-      <option name="project" value="LOCAL" />
-      <updated>1621001294417</updated>
-    </task>
-    <task id="LOCAL-00013" summary="2021.5.14">
-      <created>1621001364594</created>
-      <option name="number" value="00013" />
-      <option name="presentableId" value="LOCAL-00013" />
-      <option name="project" value="LOCAL" />
-      <updated>1621001364594</updated>
-    </task>
-    <task id="LOCAL-00014" summary="2021.5.20">
-      <created>1621508804187</created>
-      <option name="number" value="00014" />
-      <option name="presentableId" value="LOCAL-00014" />
-      <option name="project" value="LOCAL" />
-      <updated>1621508804187</updated>
-    </task>
-    <task id="LOCAL-00015" summary="2022.02.02 树的前后中序遍历练习">
-      <created>1643852828102</created>
-      <option name="number" value="00015" />
-      <option name="presentableId" value="LOCAL-00015" />
-      <option name="project" value="LOCAL" />
-      <updated>1643852828102</updated>
-    </task>
-    <task id="LOCAL-00016" summary="2022.02.03 n叉树的序列化与反序列化">
-      <created>1643857999624</created>
-      <option name="number" value="00016" />
-      <option name="presentableId" value="LOCAL-00016" />
-      <option name="project" value="LOCAL" />
-      <updated>1643857999624</updated>
-    </task>
-    <task id="LOCAL-00017" summary="2022.02.03 n叉树的序列化与反序列化">
-      <created>1643879941896</created>
-      <option name="number" value="00017" />
-      <option name="presentableId" value="LOCAL-00017" />
-      <option name="project" value="LOCAL" />
-      <updated>1643879941896</updated>
-    </task>
-    <task id="LOCAL-00018" summary="2022.02.03 n叉树的序列化与反序列化22">
-      <created>1647767335727</created>
-      <option name="number" value="00018" />
-      <option name="presentableId" value="LOCAL-00018" />
-      <option name="project" value="LOCAL" />
-      <updated>1647767335727</updated>
-    </task>
-    <task id="LOCAL-00019" summary="2022.04.17 leetCode 253（会员题目）会议室解">
-      <created>1650197238274</created>
-      <option name="number" value="00019" />
-      <option name="presentableId" value="LOCAL-00019" />
-      <option name="project" value="LOCAL" />
-      <updated>1650197238274</updated>
-    </task>
-    <task id="LOCAL-00020" summary="2022.04.22 leetCode 280 vip wiggle array">
-      <created>1650645699447</created>
-      <option name="number" value="00020" />
-      <option name="presentableId" value="LOCAL-00020" />
-      <option name="project" value="LOCAL" />
-      <updated>1650645699448</updated>
-    </task>
-    <task id="LOCAL-00021" summary="2022.05.02">
-      <created>1651514374438</created>
-      <option name="number" value="00021" />
-      <option name="presentableId" value="LOCAL-00021" />
-      <option name="project" value="LOCAL" />
-      <updated>1651514374438</updated>
-    </task>
-    <task id="LOCAL-00022" summary="2022.05.07">
-      <created>1651941232631</created>
-      <option name="number" value="00022" />
-      <option name="presentableId" value="LOCAL-00022" />
-      <option name="project" value="LOCAL" />
-      <updated>1651941232631</updated>
-    </task>
-    <task id="LOCAL-00023" summary="2022.05.15">
-      <created>1652619465623</created>
-      <option name="number" value="00023" />
-      <option name="presentableId" value="LOCAL-00023" />
-      <option name="project" value="LOCAL" />
-      <updated>1652619465623</updated>
-    </task>
-    <task id="LOCAL-00024" summary="2022.05.26">
-      <created>1653573480101</created>
-      <option name="number" value="00024" />
-      <option name="presentableId" value="LOCAL-00024" />
-      <option name="project" value="LOCAL" />
-      <updated>1653573480101</updated>
-    </task>
-    <task id="LOCAL-00025" summary="2022.06.04">
-      <created>1654331343765</created>
-      <option name="number" value="00025" />
-      <option name="presentableId" value="LOCAL-00025" />
-      <option name="project" value="LOCAL" />
-      <updated>1654331343765</updated>
-    </task>
-    <task id="LOCAL-00026" summary="2022.06.09">
-      <created>1654790000519</created>
-      <option name="number" value="00026" />
-      <option name="presentableId" value="LOCAL-00026" />
-      <option name="project" value="LOCAL" />
-      <updated>1654790000519</updated>
-    </task>
-    <task id="LOCAL-00027" summary="并查集添加TODO内容">
-      <created>1663504704340</created>
-      <option name="number" value="00027" />
-      <option name="presentableId" value="LOCAL-00027" />
-      <option name="project" value="LOCAL" />
-      <updated>1663504704340</updated>
-    </task>
-    <task id="LOCAL-00028" summary="路径总和IV LeetCode666">
-      <created>1663596542195</created>
-      <option name="number" value="00028" />
-      <option name="presentableId" value="LOCAL-00028" />
-      <option name="project" value="LOCAL" />
-      <updated>1663596542195</updated>
-    </task>
-    <option name="localTasksCounter" value="29" />
-    <servers />
-  </component>
-  <component name="TypeScriptGeneratedFilesManager">
-    <option name="version" value="3" />
-  </component>
-  <component name="Vcs.Log.Tabs.Properties">
-    <option name="TAB_STATES">
-      <map>
-        <entry key="MAIN">
-          <value>
-            <State />
-          </value>
-        </entry>
-      </map>
-    </option>
-  </component>
-  <component name="VcsManagerConfiguration">
-    <MESSAGE value="2020.12.08" />
-    <MESSAGE value="2020.12.20" />
-    <MESSAGE value="2021.4.1" />
-    <MESSAGE value="2021.5.4" />
-    <MESSAGE value="2021.5.14" />
-    <MESSAGE value="2021.5.20" />
-    <MESSAGE value="2022.02.02 树的前后中序遍历练习" />
-    <MESSAGE value="2022.02.03 n叉树的序列化与反序列化" />
-    <MESSAGE value="2022.02.03 n叉树的序列化与反序列化22" />
-    <MESSAGE value="2022.04.17 leetCode 253（会员题目）会议室解" />
-    <MESSAGE value="2022.04.22 leetCode 280 vip wiggle array" />
-    <MESSAGE value="2022.05.02" />
-    <MESSAGE value="2022.05.07" />
-    <MESSAGE value="2022.05.15" />
-    <MESSAGE value="2022.05.26" />
-    <MESSAGE value="2022.06.04" />
-    <MESSAGE value="2022.06.09" />
-    <MESSAGE value="并查集添加TODO内容" />
-    <MESSAGE value="路径总和IV LeetCode666" />
-    <option name="LAST_COMMIT_MESSAGE" value="路径总和IV LeetCode666" />
-  </component>
-  <component name="XDebuggerManager">
-    <breakpoint-manager>
-      <breakpoints>
-        <line-breakpoint enabled="true" type="java-method">
-          <url>file://$PROJECT_DIR$/src/Leetcode/数组/Solution452.java</url>
-          <line>51</line>
-          <properties class="Leetcode.数组.Solution452" method="findMinArrowShots">
-            <option name="EMULATED" value="true" />
-          </properties>
-          <option name="timeStamp" value="1" />
-        </line-breakpoint>
-        <line-breakpoint type="java-line">
-          <url>file://$PROJECT_DIR$/src/Leetcode/Solution738.java</url>
-          <line>93</line>
-          <option name="timeStamp" value="6" />
-        </line-breakpoint>
-        <line-breakpoint type="java-line">
-          <url>file://$PROJECT_DIR$/src/Leetcode/Solution1006.java</url>
-          <line>86</line>
-          <option name="timeStamp" value="15" />
-        </line-breakpoint>
-        <line-breakpoint type="java-line">
-          <url>file://$PROJECT_DIR$/src/Leetcode/Solution1011.java</url>
-          <line>44</line>
-          <option name="timeStamp" value="21" />
-        </line-breakpoint>
-        <line-breakpoint type="java-line">
-          <url>file://$PROJECT_DIR$/src/Leetcode/Solution.java</url>
-          <line>37</line>
-          <option name="timeStamp" value="22" />
-        </line-breakpoint>
-      </breakpoints>
-    </breakpoint-manager>
-    <watches-manager>
-      <configuration name="Application">
-        <watch expression="map2.entrySet().toArray()[1]" />
-      </configuration>
-    </watches-manager>
-  </component>
-  <component name="debuggerHistoryManager">
-    <expressions id="breakpointCondition">
-      <expression>
-        <expression-string>i==3</expression-string>
-        <language-id>JAVA</language-id>
-        <evaluation-mode>EXPRESSION</evaluation-mode>
-      </expression>
-    </expressions>
-  </component>
-  <component name="mavenExecuteGoalHistory">
-    <option value="" />
-  </component>
-</project>
\ No newline at end of file
Index: src/Gof/bridge/XiaoMi.java
===================================================================
diff --git a/src/Gof/bridge/XiaoMi.java b/src/Gof/bridge/XiaoMi.java
deleted file mode 100644
--- a/src/Gof/bridge/XiaoMi.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,20 +0,0 @@
-package Gof.bridge;
-
-public class XiaoMi implements Brand{
-    @Override
-    public void open() {
-        System.out.println("小米手机开机");
-    }
-
-    @Override
-    public void call() {
-        System.out.println("小米手机打电话");
-
-    }
-
-    @Override
-    public void close() {
-        System.out.println("小米手机开关机");
-
-    }
-}
Index: src/xml/parse/XmlParseUtil.java
===================================================================
diff --git a/src/xml/parse/XmlParseUtil.java b/src/xml/parse/XmlParseUtil.java
deleted file mode 100644
--- a/src/xml/parse/XmlParseUtil.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,58 +0,0 @@
-package xml.parse;
-
-import org.w3c.dom.Document;
-import org.w3c.dom.Element;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-
-import java.io.FileInputStream;
-import java.util.ArrayList;
-import java.util.List;
-
-public class XmlParseUtil {
-    //输入一个xml文件的路径名，得到一个List<>
-    public List<Dog> parseXmlToList(String fileName) throws Exception {
-        //Dom方式解析：入口
-        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
-        DocumentBuilder builder = factory.newDocumentBuilder();
-        //准备输入流，为parse()做准备
-        //解析为可以用java处理的document对象
-        Document document = builder.parse(new FileInputStream(fileName));
-        Element element = document.getDocumentElement();//获取文当的结点
-        NodeList nodeList = element.getElementsByTagName("dog");//获取dog结点
-        List<Dog> dogs=new ArrayList<>();
-        for (int i = 0; i < nodeList.getLength(); i++) {
-            //获取每一个dog
-            Element dogElement = (Element)nodeList.item(i);
-            //获取dog的id属性
-            Dog dog=new Dog();
-            int id = Integer.parseInt(dogElement.getAttribute("id"));
-
-            dog.setId(id);
-            //获取dog的子节点
-            NodeList childNodes = dogElement.getChildNodes();
-            for(int j=0;j<childNodes.getLength();j++)
-            {
-                Node item = childNodes.item(j);
-                //只拿<zxx>形式的子节点
-                if(item.getNodeType()==Node.ELEMENT_NODE) {
-                    if (item.getNodeName().equals("name")) {
-                        String name = item.getFirstChild().getNodeValue();
-                        dog.setName(name);
-                    } else if (item.getNodeName().equals("score")) {
-                        int score = Integer.parseInt(item.getFirstChild().getNodeValue());
-                        dog.setScore(score);
-                    } else {
-                        int level = Integer.parseInt(item.getFirstChild().getNodeValue());
-                        dog.setLevel(level);
-                    }
-                }
-            }
-          dogs.add(dog);
-        }
-        return dogs;
-    }
-}
Index: src/左神算法/基础班/第三课/ZigZagPrintMatrix.java
===================================================================
diff --git a/src/左神算法/基础班/第三课/ZigZagPrintMatrix.java b/src/左神算法/基础班/第三课/ZigZagPrintMatrix.java
deleted file mode 100644
--- a/src/左神算法/基础班/第三课/ZigZagPrintMatrix.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,42 +0,0 @@
-package 左神算法.基础班.第三课;
-
-public class ZigZagPrintMatrix {
-
-    public static void printMatrixZigZag(int[][] matrix) {
-        int tR = 0;
-        int tC = 0;
-        int dR = 0;
-        int dC = 0;
-        int endR = matrix.length - 1;
-        int endC = matrix[0].length - 1;
-        boolean fromUp = false;
-        while (tR != endR + 1) {
-            printLevel(matrix, tR, tC, dR, dC, fromUp);
-            tR = tC == endC ? tR + 1 : tR;
-            tC = tC == endC ? tC : tC + 1;
-            dC = dR == endR ? dC + 1 : dC;
-            dR = dR == endR ? dR : dR + 1;
-            fromUp = !fromUp;
-        }
-        System.out.println();
-    }
-
-    public static void printLevel(int[][] m, int tR, int tC, int dR, int dC,
-                                  boolean f) {
-        if (f) {
-            while (tR != dR + 1) {
-                System.out.print(m[tR++][tC--] + " ");
-            }
-        } else {
-            while (dR != tR - 1) {
-                System.out.print(m[dR--][dC++] + " ");
-            }
-        }
-    }
-
-    public static void main(String[] args) {
-        int[][] matrix = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };
-        printMatrixZigZag(matrix);
-
-    }
-}
Index: src/org/sd/Zxing/ZxingUtil.java
===================================================================
diff --git a/src/org/sd/Zxing/ZxingUtil.java b/src/org/sd/Zxing/ZxingUtil.java
deleted file mode 100644
--- a/src/org/sd/Zxing/ZxingUtil.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,56 +0,0 @@
-package org.sd.Zxing;
-
-import com.google.zxing.*;
-import com.google.zxing.client.j2se.BufferedImageLuminanceSource;
-import com.google.zxing.common.BitMatrix;
-import com.google.zxing.common.HybridBinarizer;
-import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;
-import jp.sourceforge.qrcode.util.Color;
-
-import javax.imageio.ImageIO;
-import java.awt.image.BufferedImage;
-import java.io.File;
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Hashtable;
-import java.util.Map;
-
-public class ZxingUtil {
-    //加密：文字--》二维码
-    public static void encodingImg(String content,String format,String imgPath,int width,int height,String logo) throws WriterException, IOException {
-        Hashtable<EncodeHintType,Object> hints=new Hashtable<>();
-        //设置排错率：L<M<Q<H
-        hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H);
-        //编码
-        hints.put(EncodeHintType.CHARACTER_SET,"utf-8");
-        //外边距
-        hints.put(EncodeHintType.MARGIN, 1);
-
-        BitMatrix bitMatrix=new MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE,width,height,hints);
-        //内存中的图片，此时需要的图片是是二维码---》需要一个boolean[][]-->BitMatrix
-        BufferedImage bufferedImage=new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);
-        for(int x=0;x<width;x++)
-        {
-            for(int y=0;y<height;y++)
-            {
-                bufferedImage.setRGB(x,y,(bitMatrix.get(x,y)? Color.BLACK:Color.WHITE) );
-            }
-        }
-        //画logo
-        bufferedImage=LogUtil.logoMatrix(bufferedImage,logo);
-        File file=new File(imgPath);
-        ImageIO.write(bufferedImage,format,file);
-    }
-    public static void decodeImage(File file) throws IOException, NotFoundException {
-        if(!file.exists()) return;
-        BufferedImage bufferedImage=ImageIO.read(file);
-        MultiFormatReader multiFormatReader=new MultiFormatReader();
-        LuminanceSource luminanceSource=new BufferedImageLuminanceSource(bufferedImage);
-        Binarizer binarizer=new HybridBinarizer(luminanceSource);
-        Map map=new HashMap();
-        map.put(EncodeHintType.CHARACTER_SET,"utf-8");
-        BinaryBitmap binaryBitmap=new BinaryBitmap(binarizer);
-        Result result=multiFormatReader.decode(binaryBitmap,map);
-        System.out.println(result.toString());
-    }
-}
Index: src/面试相关/公司笔面试真题/虾皮面试/两个字符串的最长公共子串.java
===================================================================
diff --git a/src/面试相关/公司笔面试真题/虾皮面试/两个字符串的最长公共子串.java b/src/面试相关/公司笔面试真题/虾皮面试/两个字符串的最长公共子串.java
deleted file mode 100644
--- a/src/面试相关/公司笔面试真题/虾皮面试/两个字符串的最长公共子串.java	(revision e81114db280931b8012d56289699f263cfa17810)
+++ /dev/null	(revision e81114db280931b8012d56289699f263cfa17810)
@@ -1,51 +0,0 @@
-package 面试相关.公司笔面试真题.虾皮面试;
-
-/**
- * @author zbl
- * @version 1.0
- * @content: 求两个字符串的最长公共子串
- * @date 2020/8/17 18:39
- */
-public class 两个字符串的最长公共子串 {
-
-    public static String process(String str1,String str2){
-        if(str1==null || str1.length()==0 || str2==null || str2.length()==0)
-            return "";
-        int n=str1.length();
-        int m=str2.length();
-        char[] chs1=str1.toCharArray();
-        char[] chs2=str2.toCharArray();
-        int[][] dp=new int[str1.length()][str2.length()];//以i,j结尾的最长公共子串的长度
-        int end=0,length=0;
-        for(int i=0;i<m;i++){
-            if(chs1[0]==chs2[i]) dp[0][i]=1;
-        }
-        for(int i=0;i<n;i++){
-            if(chs2[0]==chs1[i]) dp[i][0]=1;
-        }
-        for(int i=1;i<n;i++){
-            for(int j=1;j<m;j++){
-                if(chs1[i]==chs2[j]){
-                    dp[i][j]=dp[i-1][j-1]+1;
-                    if(dp[i][j]>length){
-                        length=dp[i][j];
-                        end=j;
-                    }
-                }else{
-                    dp[i][j]=0;
-                }
-            }
-        }
-        int start=end-length+1;
-        return str2.substring(start,end);
-
-
-
-    }
-
-    public static void main(String[] args) {
-        //String res=process("abractyeyt","dgdsaeactyey");
-        //System.out.println(res);
-
-    }
-}
Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"VcsDirectoryMappings\">\r\n    <mapping directory=\"$PROJECT_DIR$\" vcs=\"Git\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
--- a/.idea/vcs.xml	(revision e81114db280931b8012d56289699f263cfa17810)
+++ b/.idea/vcs.xml	(date 1700922517050)
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="VcsDirectoryMappings">
-    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+    <mapping directory="" vcs="Git" />
   </component>
 </project>
\ No newline at end of file
diff --git a/src/重温设计模式/结构型设计模式/装饰器模式/示例/test.txt b/src/重温设计模式/结构型设计模式/装饰器模式/示例/test.txt
deleted file mode 100644
